<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="leetcode练习七：线性动态规划"><meta name="keywords" content="leetcode,Dynamic Programming"><meta name="author" content="zhxnlp"><meta name="copyright" content="zhxnlp"><title>leetcode练习七：线性动态规划 | zhxnlpのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"JU6VFRRZVF","apiKey":"ca17f8e20c4dc91dfe1214d03173a8be","indexName":"github-io","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="zhxnlpのBlog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">一、 动态规划基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%80%E4%BB%8B"><span class="toc-text">1.1 动态规划简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">1.2 动态规划的特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8"><span class="toc-text">1.2.1 最优子结构性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98%E6%80%A7%E8%B4%A8"><span class="toc-text">1.2.2 重叠子问题性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7"><span class="toc-text">1.2.3 无后效性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-text">1.3 动态规划的基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8"><span class="toc-text">1.4  动态规划基础应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-text">1.4.1 斐波那契数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">1.4.2 爬楼梯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-text">1.4.3 不同路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93"><span class="toc-text">1.5 个人总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-text">二、记忆化搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E7%AE%80%E4%BB%8B"><span class="toc-text">2.1 记忆化搜索简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E4%B8%8E%E9%80%92%E6%8E%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.2 记忆化搜索与递推的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">2.3 记忆化搜索的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-text">2.3.1 目标和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E7%AC%AC-N-%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-text">2.3.2 第 N 个泰波那契数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%80%E4%BB%8B"><span class="toc-text">三、线性动态规划简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8D%95%E4%B8%B2%E7%BA%BF%E6%80%A7-DP-%E9%97%AE%E9%A2%98"><span class="toc-text">3.1 单串线性 DP 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">3.1.1 最长递增子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-text">3.1.2 最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">3.1.2.1 动态规划</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="toc-text">3.1.2.2 动态规划+滚动数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-text">3.1.3 最长的斐波那契子序列的长度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-3-1-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE%EF%BC%88%E8%B6%85%E6%97%B6%EF%BC%89"><span class="toc-text">3.1.3.1 暴力枚举（超时）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-3-2-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">3.1.3.2 哈希表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-3-3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">3.1.3.3 动态规划 + 哈希表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8F%8C%E4%B8%B2%E7%BA%BF%E6%80%A7-DP-%E9%97%AE%E9%A2%98"><span class="toc-text">3.2 双串线性 DP 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">3.2.1 最长公共子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">3.2.2 最长重复子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-text">3.3.3 编辑距离</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%9F%A9%E9%98%B5%E7%BA%BF%E6%80%A7-DP%E9%97%AE%E9%A2%98"><span class="toc-text">3.3 矩阵线性 DP问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">3.3.1 最小路径和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="toc-text">3.3.2最大正方形</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E6%97%A0%E4%B8%B2%E7%BA%BF%E6%80%A7-DP-%E9%97%AE%E9%A2%98"><span class="toc-text">3.4无串线性 DP 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-text">3.4.1 整数拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98"><span class="toc-text">3.4.2 只有两个键的键盘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E7%BA%BF%E6%80%A7-DP-%E9%A2%98%E7%9B%AE%E5%A4%A7%E5%85%A8"><span class="toc-text">3.5 线性 DP 题目大全</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img-blog.csdnimg.cn/92202ef591744a55a05a1fc7e108f4d6.png"></div><div class="author-info__name text-center">zhxnlp</div><div class="author-info__description text-center">nlp</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/zhxnlp">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">58</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">50</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://relph1119.github.io/my-team-learning">relph</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://ifwind.github.io/">ifwind</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://chuxiaoyu.cn/nlp-transformer-summary/">chuxiaoyu</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://img-blog.csdnimg.cn/ffe1f736be4548dc9101388503288e4d.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">zhxnlpのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">leetcode练习七：线性动态规划</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-04-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Data-Structure-and-Algorithms/">Data Structure and Algorithms</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">16.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 62 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>@[toc]</p>
<blockquote>
<p>参考<a target="_blank" rel="noopener" href="https://oi-wiki.org/dp/">《OI Wiki动态规划》</a>、<a target="_blank" rel="noopener" href="https://algo.itcharge.cn/10.Dynamic-Programming/01.Dynamic-Programming-Basic/01.Dynamic-Programming-Basic/">《算法通关手册》动态规划篇</a></p>
<h2 id="一、-动态规划基础知识"><a href="#一、-动态规划基础知识" class="headerlink" title="一、 动态规划基础知识"></a>一、 动态规划基础知识</h2><h3 id="1-1-动态规划简介"><a href="#1-1-动态规划简介" class="headerlink" title="1.1 动态规划简介"></a>1.1 动态规划简介</h3></blockquote>
<p>&#8195;&#8195; <strong>动态规划（Dynamic Programming）</strong>：简称 <strong>DP</strong>，是一种通过把原问题分解为相对简单的子问题的方式而求解复杂问题的方法。</p>
<p>动态规划方法与分治算法类似，却又不同于分治算法。</p>
<p>「动态规划的核心思想」是：</p>
<ol>
<li>把「原问题」分解为「若干个重叠的子问题」，每个子问题的求解过程都构成一个 <strong>「阶段」</strong>。在完成一个阶段的计算之后，动态规划方法才会执行下一个阶段的计算。</li>
<li>在求解子问题的过程中，按照自底向上的顺序求解出「子问题的解」，把结果存储在表格中，当需要再次求解此子问题时，直接从表格中查询该子问题的解，从而避免了大量的重复计算。<span id="more"></span>
&#8195;&#8195;「动态规划方法与分治算法的不同点」在于：</li>
</ol>
<ul>
<li>适用于动态规划求解的问题，在分解之后得到的子问题往往是相互联系的，会出现若干个重叠子问题。</li>
<li><font color='deeppink'>使用动态规划方法会将这些重叠子问题的解保存到表格里，供随后的计算查询使用，从而避免大量的重复计算。&lt;/font &gt;</li>
</ul>
<h3 id="1-2-动态规划的特征"><a href="#1-2-动态规划的特征" class="headerlink" title="1.2 动态规划的特征"></a>1.2 动态规划的特征</h3><p>&#8195;&#8195;能够使用动态规划方法解决的问题必须满足下面三个特征：「最优子结构性质」、「重叠子问题性质」和「无后效性」。</p>
<h4 id="1-2-1-最优子结构性质"><a href="#1-2-1-最优子结构性质" class="headerlink" title="1.2.1 最优子结构性质"></a>1.2.1 最优子结构性质</h4><p>「最优子结构」：指的是一个问题的最优解包含其子问题的最优解。</p>
<p>&#8195;&#8195;举个例子，如下图所示，原问题 $S = \lbrace a<em>1, a_2, a_3, a_4 \rbrace$，在 $a_1$ 步我们选出一个当前最优解之后，问题就转换为求解子问题 $S</em>{子问题} = \lbrace a<em>2, a_3, a_4 \rbrace$。如果原问题 $S$ 的最优解可以由「第 $a_1$ 步得到的局部最优解」和「 $S</em>{子问题}$ 的最优解」构成，则说明该问题满足最优子结构性质。</p>
<p>也就是说，如果原问题的最优解包含子问题的最优解，则说明该问题满足最优子结构性质。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/472489157c997fe8ea270d37c3ce2b66.png" alt=""></p>
<h4 id="1-2-2-重叠子问题性质"><a href="#1-2-2-重叠子问题性质" class="headerlink" title="1.2.2 重叠子问题性质"></a>1.2.2 重叠子问题性质</h4><p>&#8195;&#8195;「重叠子问题性质」：指的是在求解子问题的过程中，有大量的子问题是重复的，一个子问题会在下一阶段的决策中可能会被多次用到。如果有大量重复的子问题，那么只需要对求解一次，然后用表格将结果存储下来，以后使用时可以直接查询，不需要再次求解。</p>
<p>&#8195;&#8195;举个例子，比如斐波那契数列的定义是：<code>f(1) = 1, f(2) = 2, f(n) = f(n - 1) + f(n - 2)</code>。对应的递推过程如下图所示，其中 <code>f(1)</code>、<code>f(2)</code>、<code>f(3)</code>、<code>f(4)</code> 都进行了多次重复计算。而如果我们在第一次计算 <code>f(1)</code>、<code>f(2)</code>、<code>f(3)</code>、<code>f(4)</code> 时就将其结果存入表格，则再次使用时可以直接查询，从而避免重复求解相同的子问题，提升效率。</p>
<p><img src="https://img-blog.csdnimg.cn/51d7a80bfc4e481da9de03f77a7bee44.png" alt="在这里插入图片描述"></p>
<h4 id="1-2-3-无后效性"><a href="#1-2-3-无后效性" class="headerlink" title="1.2.3 无后效性"></a>1.2.3 无后效性</h4><p>&#8195;&#8195;「无后效性」：指的是子问题的解（状态值）只与之前阶段有关，而与后面阶段无关。当前阶段的若干状态值一旦确定，就不再改变，不会再受到后续阶段决策的影响。换句话说，<strong>一旦某一个子问题的求解结果确定以后，就不会再被修改</strong>。</p>
<p>&#8195;&#8195;其实我们也可以把动态规划方法的求解过程，看做是有向无环图的最长（最短）路的求解过程。每个状态对应有向无环图上的一个节点，决策对应图中的一条有向边。</p>
<p>&#8195;&#8195;如果一个问题具有「后效性」，则可能需要将其转化或者逆向求解来消除后效性，然后才可以使用动态规划方法。</p>
<h3 id="1-3-动态规划的基本思路"><a href="#1-3-动态规划的基本思路" class="headerlink" title="1.3 动态规划的基本思路"></a>1.3 动态规划的基本思路</h3><p>&#8195;&#8195;如下图所示，我们在使用动态规划方法解决某些最优化问题时，可以将解决问题的过程按照一定顺序（时间顺序、空间顺序或其他顺序）分解为若干个相互联系的「阶段」。然后按照顺序对每一个阶段做出「决策」，这个决策既决定了本阶段的效益，也决定了下一阶段的初始状态。依次做完每个阶段的决策之后，就得到了一个整个问题的决策序列。</p>
<p>&#8195;&#8195;这样就将一个原问题分解为了一系列的子问题，然后通过逐步求解从而获得最终结果。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/572208acccabdd7fa6afa9d5a7cbcf83.png" alt=""></p>
<p>&#8195;&#8195;这种前后关联、具有链状结构的多阶段进行决策的问题也叫做「多阶段决策问题」。通常我们使用动态规划方法来解决多阶段决策问题，其基本思路如下：</p>
<ol>
<li><strong>划分阶段</strong>：将原问题按顺序（时间顺序、空间顺序或其他顺序）分解为若干个相互联系的「阶段」。划分后的阶段⼀定是有序或可排序的，否则问题⽆法求解。<ul>
<li>这里的「阶段」指的是⼦问题的求解过程。每个⼦问题的求解过程都构成⼀个「阶段」，在完成前⼀阶段的求解后才会进⾏后⼀阶段的求解。</li>
</ul>
</li>
<li><strong>定义状态</strong>：将和子问题相关的某些变量（位置、数量、体积、空间等等）作为一个「状态」表示出来。状态的选择要满⾜⽆后效性。<ul>
<li>一个「状态」对应一个或多个子问题，所谓某个「状态」下的值，指的就是这个「状态」所对应的子问题的解。</li>
</ul>
</li>
<li><strong>状态转移</strong>：根据「上一阶段的状态」和「该状态下所能做出的决策」，推导出「下一阶段的状态」。或者说根据相邻两个阶段各个状态之间的关系，确定决策，然后推导出状态间的相互转移方式（即「状态转移方程」）。</li>
<li><strong>初始条件和边界条件</strong>：根据问题描述、状态定义和状态转移方程，确定初始条件和边界条件。</li>
<li><strong>最终结果</strong>：确定问题的求解目标，然后按照一定顺序求解每一个阶段的问题。最后根据状态转移方程的递推结果，确定最终结果。</li>
</ol>
<h3 id="1-4-动态规划基础应用"><a href="#1-4-动态规划基础应用" class="headerlink" title="1.4  动态规划基础应用"></a>1.4  动态规划基础应用</h3><p>&#8195;&#8195;动态规划相关的问题往往灵活多变，思维难度大，没有特别明显的套路，并且经常会在各类算法竞赛和面试中出现。</p>
<p>&#8195;&#8195;动态规划问题的关键点在于「如何状态设计」和「推导状态转移条件」，还有各种各样的「优化方法」。这类问题一定要多练习、多总结，只有接触的题型多了，才能熟练掌握动态规划思想。</p>
<p>&#8195;&#8195;下面来介绍几道关于动态规划的基础题目。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">题号</th>
<th style="text-align:left">标题</th>
<th style="text-align:left">题解</th>
<th style="text-align:left">标签</th>
<th style="text-align:left">难度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0509</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">斐波那契数</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0509.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.md">Python</a></td>
<td style="text-align:left">数组</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0070</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0070.%20%E7%88%AC%E6%A5%BC%E6%A2%AF.md">Python</a></td>
<td style="text-align:left">动态规划</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0062</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">不同路径</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0062.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.md">Python</a></td>
<td style="text-align:left">数组、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
</tbody>
</table>
</div>
<h4 id="1-4-1-斐波那契数"><a href="#1-4-1-斐波那契数" class="headerlink" title="1.4.1 斐波那契数"></a>1.4.1 斐波那契数</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数 - 力扣</a></p>
</blockquote>
<p>给定一个整数 <code>n</code>。：计算第 <code>n</code> 个斐波那契数。其中，斐波那契数列的定义如下：</p>
<ul>
<li><code>f(0) = 0, f(1) = 1</code>。</li>
<li><code>f(n) = f(n - 1) + f(n - 2)</code>，其中 <code>n &gt; 1</code>。</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>划分阶段：按照整数顺序进行阶段划分，将其划分为整数 <code>0</code> ~ <code>n</code>。</li>
</ol>
<ol>
<li><p>定义状态：定义状态 <code>dp[i]</code> 为：第 <code>i</code> 个斐波那契数。</p>
<ol>
<li>状态转移方程<br>根据题目中所给的斐波那契数列的定义 <code>f(n) = f(n - 1) + f(n - 2)</code>，则直接得出状态转移方程为 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>。</li>
</ol>
</li>
<li><p>初始条件<br>根据题目中所给的初始条件 <code>f(0) = 0, f(1) = 1</code> 确定动态规划的初始条件，即 <code>dp[0] = 0, dp[1] = 1</code>。</p>
</li>
<li><p>最终结果<br>根据状态定义，最终结果为 <code>dp[n]</code>，即第 <code>n</code> 个斐波那契数为 <code>dp[n]</code>。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$。一重循环遍历的时间复杂度为 $O(n)$。</li>
<li><strong>空间复杂度</strong>：$O(n)$。<ul>
<li>用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。</li>
<li>因为 <code>dp[i]</code> 的状态只依赖于 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code>，所以可以使用 <code>3</code> 个变量来分别表示 <code>dp[i]</code>、<code>dp[i - 1]</code>、<code>dp[i - 2]</code>，从而将空间复杂度优化到 $O(1)$。</li>
</ul>
</li>
</ul>
<h4 id="1-4-2-爬楼梯"><a href="#1-4-2-爬楼梯" class="headerlink" title="1.4.2 爬楼梯"></a>1.4.2 爬楼梯</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯 - 力扣</a></p>
</blockquote>
<p>&#8195;&#8195;假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。现在给定一个整数 <code>n</code>。请计算出有多少种不同的方法可以爬到楼顶。</p>
<ul>
<li>$1 \le n \le 45$。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入    n = <span class="number">3</span></span><br><span class="line">输出    <span class="number">3</span></span><br><span class="line">解释    有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span> <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span> <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span> <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<ol>
<li>划分阶段<br>我们按照台阶的阶层划分阶段，将其划分为 <code>0</code> ~ <code>n</code> 阶。</li>
</ol>
<ol>
<li><p>定义状态<br>定义状态 <code>dp[i]</code> 为：爬到第 <code>i</code> 阶台阶的方案数。</p>
</li>
<li><p>状态转移方程<br>根据题目大意，每次只能爬 <code>1</code> 或 <code>2</code> 个台阶。则第 <code>i</code> 阶楼梯只能从第 <code>i - 1</code> 阶向上爬 <code>1</code>阶上来，或者从第 <code>i - 2</code> 阶向上爬 <code>2</code> 阶上来。所以可以推出状态转移方程为 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>。</p>
</li>
<li><p>初始条件</p>
<ul>
<li>第 <code>0</code> 层台阶方案数：可以看做 <code>1</code> 种方法（从 <code>0</code> 阶向上爬 <code>0</code> 阶），即 <code>dp[1] = 1</code>。</li>
<li>第 <code>1</code> 层台阶方案数：<code>1</code> 种方法（从 <code>0</code> 阶向上爬 <code>1</code> 阶），即 <code>dp[1] = 1</code>。</li>
<li>第 <code>2</code> 层台阶方案数：<code>2</code> 中方法（从 <code>0</code> 阶向上爬 <code>2</code> 阶，或者从 <code>1</code> 阶向上爬 <code>1</code> 阶）。</li>
</ul>
</li>
<li><p>最终结果<br>根据状态定义，最终结果为 <code>dp[n]</code>，即爬到第 <code>n</code> 阶台阶（即楼顶）的方案数为 <code>dp[n]</code>。</p>
</li>
</ol>
<p>&#8195;&#8195;虽然这道题跟上一道题的状态转移方程都是 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>，但是两道题的考察方式并不相同，一定程度上也可以看出来动态规划相关题目的灵活多变。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$。一重循环遍历的时间复杂度为 $O(n)$。</li>
<li><strong>空间复杂度</strong>：$O(n)$。<ul>
<li>用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。</li>
<li>因为 <code>dp[i]</code> 的状态只依赖于 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code>，所以可以使用 <code>3</code> 个变量来分别表示 <code>dp[i]</code>、<code>dp[i - 1]</code>、<code>dp[i - 2]</code>，从而将空间复杂度优化到 $O(1)$。</li>
</ul>
</li>
</ul>
<h4 id="1-4-3-不同路径"><a href="#1-4-3-不同路径" class="headerlink" title="1.4.3 不同路径"></a>1.4.3 不同路径</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">62. 不同路径 - 力扣</a></p>
</blockquote>
<p>&#8195;&#8195;给定两个整数 <code>m</code> 和 <code>n</code>，代表大小为 <code>m * n</code> 的棋盘， 一个机器人位于棋盘左上角的位置，机器人每次只能向右、或者向下移动一步。要求计算出机器人从棋盘左上角到达棋盘右下角一共有多少条不同的路径。</p>
<ul>
<li>$1 \le m, n \le 100$。</li>
<li>题目数据保证答案小于等于 $2 * 10^9$。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入    m = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出    <span class="number">28</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ea0a3a2e06694b832f29e06ccf42e655.png" alt=""></p>
<p><strong>解题思路</strong></p>
<ol>
<li>划分阶段<br>按照路径的结尾位置（行位置、列位置组成的二维坐标）进行阶段划分。</li>
</ol>
<ol>
<li><p>定义状态<br>定义状态 <code>dp[i][j]</code> 为：从左上角到达 <code>(i, j)</code> 位置的路径数量。</p>
</li>
<li><p>状态转移方程<br>因为我们每次只能向右、或者向下移动一步，因此想要走到 <code>(i, j)</code>，只能从 <code>(i - 1, j)</code> 向下走一步走过来；或者从 <code>(i, j - 1)</code> 向右走一步走过来。所以可以写出状态转移方程为：<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，此时 <code>i &gt; 0，j &gt; 0</code>。</p>
</li>
<li><p>初始条件</p>
<ul>
<li>从左上角走到 <code>(0, 0)</code> 只有一种方法，即 <code>dp[0][0] = 1</code>。</li>
<li>第一行元素只有一条路径（即只能通过前一个元素向右走得到），所以 <code>dp[0][j] = 1</code>。</li>
<li>同理，第一列元素只有一条路径（即只能通过前一个元素向下走得到），所以 <code>dp[i][0] = 1</code>。</li>
</ul>
<ol>
<li>最终结果<br>根据状态定义，最终结果为 <code>dp[m - 1][n - 1]</code>，即从左上角到达右下角 <code>(m - 1, n - 1)</code> 位置的路径数量为 <code>dp[m - 1][n - 1]</code>。</li>
</ol>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用一个二维列表进行存储，dp[i][j]表示i行j列有多少种路径</span></span><br><span class="line">        dp=[[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>           <span class="comment"># 第一列路径为1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                dp[<span class="number">0</span>][j]=<span class="number">1</span>       <span class="comment"># 第一行路径为1</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> j&gt;<span class="number">0</span>:  <span class="comment"># 第一行第一列之外的位置，路径数为上方位置和左边位置的路径数之和</span></span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度</strong>：$O(m <em> n)$。初始条件赋值的时间复杂度为 $O(m + n)$，两重循环遍历的时间复杂度为 $O(m </em> n)$，所以总体时间复杂度为 $O(m * n)$。</li>
<li><strong>空间复杂度</strong>：<ul>
<li>$O(m <em> n)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(m </em> n)$。</li>
<li>因为 <code>dp[i][j]</code> 的状态只依赖于上方值 <code>dp[i - 1][j]</code> 和左侧值 <code>dp[i][j - 1]</code>，而我们在进行遍历时的顺序刚好是从上至下、从左到右。所以我们可以使用长度为 <code>m</code> 的一维数组来保存状态，从而将空间复杂度优化到 $O(m)$。</li>
</ul>
</li>
</ul>
<h3 id="1-5-个人总结"><a href="#1-5-个人总结" class="headerlink" title="1.5 个人总结"></a>1.5 个人总结</h3><ul>
<li><strong>枚举算法（Enumeration Algorithm）</strong>：即穷举法，指的是按照问题本身的性质，一一列举出该问题所有可能的解，并在逐一列举的过程中，将它们逐一与目标状态进行比较以得出满足问题要求的解。在列举的过程中，既不能遗漏也不能重复。</li>
<li><strong>分治算法（Divide and Conquer）</strong>：「分而治之」，把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</li>
<li><strong>递归（Recursion）</strong>：通过重复将原问题分解为同类的子问题而解决的方法。在绝大数编程语言中，可以通过在函数中再次调用函数自身的方式来实现递归。</li>
</ul>
<ul>
<li><strong>动态规划（Dynamic Programming）</strong>：<ul>
<li>类似分治，将复杂问题，分解为更简单的子问题进行求解（划分阶段）；</li>
<li>类似枚举，会计算出每个阶段的结果（子问题最优解），但是下一阶段的结果是根据上一阶段的结果算出，而不是直接从头计算，所以存在状态转移，提高效率</li>
<li>重复调用：根据上一阶段的结果来计算下一阶段的结果，所以使用动态规划方法会将各阶段的解保存到表格里，供随后的计算查询使用，从而避免大量的重复计算。</li>
</ul>
</li>
</ul>
<h2 id="二、记忆化搜索"><a href="#二、记忆化搜索" class="headerlink" title="二、记忆化搜索"></a>二、记忆化搜索</h2><h3 id="2-1-记忆化搜索简介"><a href="#2-1-记忆化搜索简介" class="headerlink" title="2.1 记忆化搜索简介"></a>2.1 记忆化搜索简介</h3><p>&#8195;&#8195;<strong>记忆化搜索（Memoization Search）</strong>：是一种通过存储已经遍历过的状态信息，从而避免对同一状态重复遍历的搜索算法。</p>
<p>&#8195;&#8195;记忆化搜索是动态规划的一种实现方式。在记忆化搜索中，当算法需要计算某个子问题的结果时，它首先检查是否已经计算过该问题。如果已经计算过，则直接返回已经存储的结果；否则，计算该问题，并将结果存储下来以备将来使用。</p>
<p>&#8195;&#8195;举个例子，比如「斐波那契数列」的定义是：$f(0) = 0, f(1) = 1, f(n) = f(n - 1) + f(n - 2)$。如果我们使用递归算法求解第 $n$ 个斐波那契数，则对应的递推过程如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d9fbadc2e667e5be0a6885c508283f43.png" alt=""></p>
<p>&#8195;&#8195;从图中可以看出：如果使用普通递归算法，想要计算 $f(5)$，需要先计算 $f(3)$ 和 $f(4)$，而在计算 $f(4)$ 时还需要计算 $f(3)$。这样 $f(3)$ 就进行了多次计算，同理 $f(0)$、$f(1)$、$f(2)$ 都进行了多次计算，从而导致了重复计算问题。</p>
<p>&#8195;&#8195;为了避免重复计算，在递归的同时，我们可以使用一个缓存（数组或哈希表）来保存已经求解过的 $f(k)$ 的结果。如上图所示，当递归调用用到 $f(k)$ 时，先查看一下之前是否已经计算过结果，如果已经计算过，则直接从缓存中取值返回，而不用再递推下去，这样就避免了重复计算问题。</p>
<p>我们在使用记忆化搜索解决问题的时候，其<strong>基本步骤</strong>如下：</p>
<ol>
<li>写出问题的动态规划「状态」和「状态转移方程」。</li>
<li>定义一个缓存（数组或哈希表），用于保存子问题的解。</li>
<li>定义一个递归函数，用于解决问题。在递归函数中，首先检查缓存中是否已经存在需要计算的结果，如果存在则直接返回结果，否则进行计算，并将结果存储到缓存中，再返回结果。</li>
<li>在主函数中，调用递归函数并返回结果。</li>
</ol>
<p>使用「记忆化搜索」方法解决斐波那契数列的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 使用数组保存已经求解过的 f(k) 的结果</span></span><br><span class="line">        memo = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> self.my_fib(n, memo)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_fib</span>(<span class="params">self, n: <span class="built_in">int</span>, memo: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 已经计算过结果</span></span><br><span class="line">        <span class="keyword">if</span> memo[n] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> memo[n]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 没有计算过结果</span></span><br><span class="line">        memo[n] = self.my_fib(n - <span class="number">1</span>, memo) + self.my_fib(n - <span class="number">2</span>, memo)</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure>
<h3 id="2-2-记忆化搜索与递推的区别"><a href="#2-2-记忆化搜索与递推的区别" class="headerlink" title="2.2 记忆化搜索与递推的区别"></a>2.2 记忆化搜索与递推的区别</h3><p>「记忆化搜索」与「递推」都是动态规划的实现方式，但是两者之间有一些区别。</p>
<ol>
<li><p><strong>记忆化搜索</strong>：「自顶向下」的解决问题，采用自然的递归方式编写过程，在过程中会保存每个子问题的解（通常保存在一个数组或哈希表中）来避免重复计算。</p>
<ul>
<li>优点：代码清晰易懂，可以有效的处理一些复杂的状态转移方程。有些状态转移方程是非常复杂的，使用记忆化搜索可以将复杂的状态转移方程拆分成多个子问题，通过递归调用来解决。</li>
<li>缺点：可能会因为递归深度过大而导致栈溢出问题。</li>
<li>适用场景：题的状态转移方程比较复杂，递推关系不是很明确；问题适合转换为递归形式，并且递归深度不会太深。</li>
</ul>
</li>
<li><p><strong>递推</strong>：「自底向上」的解决问题，采用循环的方式编写过程，在过程中通过保存每个子问题的解（通常保存在一个数组或哈希表中）来避免重复计算。</p>
<ul>
<li>优点：避免了深度过大问题，不存在栈溢出问题。计算顺序比较明确，易于实现。</li>
<li>缺点：无法处理一些复杂的状态转移方程。有些状态转移方程非常复杂，如果使用递推方法来计算，就会导致代码实现变得非常困难。</li>
<li>适用场景：问题的状态转移方程比较简单，递归关系比较明确；问题不太适合转换为递归形式，或者递归深度过大容易导致栈溢出。</li>
</ul>
</li>
</ol>
<h3 id="2-3-记忆化搜索的应用"><a href="#2-3-记忆化搜索的应用" class="headerlink" title="2.3 记忆化搜索的应用"></a>2.3 记忆化搜索的应用</h3><h4 id="2-3-1-目标和"><a href="#2-3-1-目标和" class="headerlink" title="2.3.1 目标和"></a>2.3.1 目标和</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">494. 目标和 - 力扣</a></p>
</blockquote>
<p>&#8195;&#8195;给定一个整数数组 $nums$ 和一个整数 $target$。数组长度不超过 $20$。向数组中每个整数前加 <code>+</code> 或 <code>-</code>。然后串联起来构造成一个表达式。返回通过上述方法构造的、运算结果等于 $target$ 的不同表达式数目。</p>
<p><strong>说明</strong>：</p>
<ul>
<li>$1 \le nums.length \le 20$。</li>
<li>$0 \le nums[i] \le 1000$。</li>
<li>$0 \le sum(nums[i]) \le 1000$。</li>
<li>$-1000 \le target \le 1000$。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一共有 <span class="number">5</span> 种方法让最终目标和为 <span class="number">3</span>。</span><br><span class="line">-<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>思路 1：深度优先搜索（超时）</strong></p>
<p>使用深度优先搜索对每位数字进行 <code>+</code> 或者 <code>-</code>，具体步骤如下：</p>
<ol>
<li>定义从位置 $0$、和为 $0$ 开始，到达数组尾部位置为止，和为 $target$ 的方案数为 <code>dfs(0, 0)</code>。</li>
<li>下面从位置 $0$、和为 $0$ 开始，以深度优先搜索遍历每个位置。</li>
<li>如果当前位置 $i$ 到达最后一个位置 $size$：<ol>
<li>如果和 <code>cur_sum</code> 等于目标和 $target$，则返回方案数 $1$。</li>
<li>如果和 <code>cur_sum</code> 不等于目标和 $target$，则返回方案数 $0$。</li>
</ol>
</li>
<li>递归搜索 $i + 1$ 位置，和为 <code>cur_sum  -  nums[i]</code> 的方案数。</li>
<li>递归搜索 $i + 1$ 位置，和为 <code>cur_sum  +  nums[i]</code> 的方案数。</li>
<li>将 4 ~ 5 两个方案数加起来就是当前位置 $i$、和为 <code>cur_sum</code> 的方案数，返回该方案数。</li>
<li>最终方案数为 <code>dfs(0, 0)</code>，将其作为答案返回即可。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, cur_sum</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i == size:</span><br><span class="line">                <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            ans = dfs(i + <span class="number">1</span>, cur_sum - nums[i]) + dfs(i + <span class="number">1</span>, cur_sum + nums[i])</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(2^n)$。其中 $n$ 为数组 $nums$ 的长度。</li>
<li><strong>空间复杂度</strong>：$O(n)$。递归调用的栈空间深度不超过 $n$。</li>
</ul>
<p><strong>思路 2：记忆化搜索</strong></p>
<p>&#8195;&#8195;在思路 1 中我们单独使用深度优先搜索对每位数字进行 <code>+</code> 或者 <code>-</code> 的方法超时了。所以我们考虑使用记忆化搜索的方式，避免进行重复搜索。</p>
<p>&#8195;&#8195;这里我们使用哈希表 $table$ 记录遍历过的位置 $i$ 及所得到的的当前和<code>cur_sum</code> 下的方案数，来避免重复搜索。具体步骤如下：</p>
<ol>
<li>定义从位置 $0$、和为 $0$ 开始，到达数组尾部位置为止，和为 $target$ 的方案数为 <code>dfs(0, 0)</code>。</li>
<li>下面从位置 $0$、和为 $0$ 开始，以深度优先搜索遍历每个位置。</li>
<li>如果当前位置 $i$ 遍历完所有位置：<ol>
<li>如果和 <code>cur_sum</code> 等于目标和 $target$，则返回方案数 $1$。</li>
<li>如果和 <code>cur_sum</code> 不等于目标和 $target$，则返回方案数 $0$。</li>
</ol>
</li>
<li>如果当前位置 $i$、和为 <code>cur_sum</code>  之前记录过（即使用 $table$ 记录过对应方案数），则返回该方案数。</li>
<li>如果当前位置 $i$、和为 <code>cur_sum</code>  之前没有记录过，则：<ol>
<li>递归搜索 $i + 1$ 位置，和为 <code>cur_sum  -  nums[i]</code> 的方案数。</li>
<li>递归搜索 $i + 1$ 位置，和为 <code>cur_sum  +  nums[i]</code> 的方案数。</li>
<li>将上述两个方案数加起来就是当前位置 $i$、和为 <code>cur_sum</code> 的方案数，将其记录到哈希表 $table$ 中，并返回该方案数。</li>
</ol>
</li>
<li>最终方案数为 <code>dfs(0, 0)</code>，将其作为答案返回</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        table = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, cur_sum</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i == size:</span><br><span class="line">                <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> (i, cur_sum) <span class="keyword">in</span> table:</span><br><span class="line">                <span class="keyword">return</span> table[(i, cur_sum)]</span><br><span class="line">            </span><br><span class="line">            cnt = dfs(i + <span class="number">1</span>, cur_sum - nums[i]) + dfs(i + <span class="number">1</span>, cur_sum + nums[i])</span><br><span class="line">            table[(i, cur_sum)] = cnt</span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(2^n)$。其中 $n$ 为数组 $nums$ 的长度。</li>
<li><strong>空间复杂度</strong>：$O(n)$。递归调用的栈空间深度不超过 $n$。</li>
</ul>
<p><strong>思路3：动态规划</strong></p>
<p>此题也可使用动态规划求解，参考<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/solution/by-flix-rkb5/">《『 一文搞懂 0-1背包问题 』记忆化搜索、动态规划 + 空间优化》</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; pos + neg = total  &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; pos - neg = target &#x27;&#x27;&#x27;</span></span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(target) &gt; total:         <span class="comment"># target可能为负</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (total + target) % <span class="number">2</span> == <span class="number">1</span>:   <span class="comment"># 不能被2整除【对应于pos不是整数】</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;【0/1背包】：从nums中选出数字组成pos或neg&#x27;&#x27;&#x27;</span></span><br><span class="line">        pos = (total + target) // <span class="number">2</span></span><br><span class="line">        neg = (total - target) // <span class="number">2</span></span><br><span class="line">        capcity = <span class="built_in">min</span>(pos, neg)         <span class="comment"># 取pos和neg中的较小者，以使得dp空间最小</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (capcity+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># dp[i][j]: 从前i个元素中选出若干个其和为j的方案数</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>        <span class="comment"># 其他 dp[0][j]均为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 状态更新</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(capcity+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; nums[i-<span class="number">1</span>]:       <span class="comment"># 容量有限，无法选择第i个数字nums[i-1]</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:                   <span class="comment"># 可选择第i个数字nums[i-1]，也可不选【两种方式之和】</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][capcity]</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-第-N-个泰波那契数"><a href="#2-3-2-第-N-个泰波那契数" class="headerlink" title="2.3.2 第 N 个泰波那契数"></a>2.3.2 第 N 个泰波那契数</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数 - 力扣</a></p>
</blockquote>
<p>给定一个整数 $n$，返回第 $n$ 个泰波那契数。</p>
<ul>
<li><strong>泰波那契数</strong>：$T<em>0 = 0, T_1 = 1, T_2 = 1$，且在 $n &gt;= 0$ 的条件下，$T</em>{n + 3} = T<em>{n} + T</em>{n+1} + T_{n+2}$。</li>
<li>$0 \le n \le 37$。</li>
<li>答案保证是一个 32 位整数，即 $answer \le 2^{31} - 1$。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">T_3 = <span class="number">0</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">T_4 = <span class="number">1</span> + <span class="number">1</span> + <span class="number">2</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>思路 1：记忆化搜索</strong></p>
<ol>
<li>问题的状态定义为：第 $n$ 个泰波那契数。其状态转移方程为：$T<em>0 = 0, T_1 = 1, T_2 = 1$，且在 $n &gt;= 0$ 的条件下，$T</em>{n + 3} = T<em>{n} + T</em>{n+1} + T_{n+2}$。</li>
<li>定义一个长度为 $n + 1$ 数组 $memo$ 用于保存一斤个计算过的泰波那契数。</li>
<li>定义递归函数 <code>my_tribonacci(n, memo)</code>。<ol>
<li>当 $n = 0$ 或者 $n = 1$，或者 $n = 2$ 时直接返回结果。</li>
<li>当 $n &gt; 2$ 时，首先检查是否计算过 $T(n)$，即判断 $memo[n]$ 是否等于 $0$。<ol>
<li>如果 $memo[n] \ne 0$，说明已经计算过 $T(n)$，直接返回 $memo[n]$。</li>
<li>如果 $memo[n] = 0$，说明没有计算过 $T(n)$，则递归调用 <code>my_tribonacci(n - 3, memo)</code>、<code>my_tribonacci(n - 2, memo)</code>、<code>my_tribonacci(n - 1, memo)</code>，并将计算结果存入 $memo[n]$ 中，并返回 $memo[n]$。</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tribonacci</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 使用数组保存已经求解过的 T(k) 的结果</span></span><br><span class="line">        memo = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> self.my_tribonacci(n, memo)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_tribonacci</span>(<span class="params">self, n: <span class="built_in">int</span>, memo: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> memo[n] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> memo[n]</span><br><span class="line">        memo[n] = self.my_tribonacci(n - <span class="number">3</span>, memo) + self.my_tribonacci(n - <span class="number">2</span>, memo) + self.my_tribonacci(n - <span class="number">1</span>, memo)</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$。</li>
<li><strong>空间复杂度</strong>：$O(n)$。</li>
</ul>
<p><strong>思路二：动态规划</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tribonacci</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        dp=[<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>]+dp[i-<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h2 id="三、线性动态规划简介"><a href="#三、线性动态规划简介" class="headerlink" title="三、线性动态规划简介"></a>三、线性动态规划简介</h2><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://chengzhaoxi.xyz/1a4a2483.html">动态规划概念和基础线性DP | 潮汐朝夕</a></p>
</blockquote>
<p>&#8195;&#8195; <strong>线性动态规划</strong>：具有「线性」阶段划分的动态规划方法统称为线性动态规划（简称为「线性 DP」），如下图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dddf1f28e09a5bcb71d5bd6444c13a80.png" alt=""></p>
<p>&#8195;&#8195;如果状态包含多个维度，但是每个维度上都是线性划分的阶段，也属于线性 DP。比如背包问题、区间 DP、数位 DP 等都属于线性 DP。</p>
<p>线性 DP 问题的划分方法有多种方式。</p>
<ul>
<li>如果按照「状态的维度数」进行分类，我们可以将线性 DP 问题分为：一维线性 DP 问题、二维线性 DP 问题，以及多维线性 DP 问题。</li>
<li>如果按照「问题的输入格式」进行分类，我们可以将线性 DP 问题分为：单串线性 DP 问题、双串线性 DP 问题、矩阵线性 DP 问题，以及无串线性 DP 问题。</li>
</ul>
<p>本文中，我们将按照问题的输入格式进行分类，对线性 DP 问题中各种类型问题进行一一讲解。</p>
<h3 id="3-1-单串线性-DP-问题"><a href="#3-1-单串线性-DP-问题" class="headerlink" title="3.1 单串线性 DP 问题"></a>3.1 单串线性 DP 问题</h3><h4 id="3-1-1-最长递增子序列"><a href="#3-1-1-最长递增子序列" class="headerlink" title="3.1.1 最长递增子序列"></a>3.1.1 最长递增子序列</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列 - 力扣</a></p>
</blockquote>
<p>单串线性 DP 问题中最经典的问题就是「最长递增子序列（Longest Increasing Subsequence，简称 LIS）」。</p>
<p>给定一个整数数组 $nums$，找到其中最长严格递增子序列的长度。</p>
<ul>
<li><strong>子序列</strong>：由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，$[3,6,2,7]$ 是数组 $[0,3,1,6,2,2,7]$ 的子序列。</li>
<li>$1 \le nums.length \le 2500$。</li>
<li>$-10^4 \le nums[i] \le 10^4$。</li>
</ul>
<p><strong>示例</strong>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长递增子序列是 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>]，因此长度为 <span class="number">4</span>。</span><br></pre></td></tr></table></figure></p>
<p><strong>思路 1：动态规划</strong></p>
<ol>
<li>划分阶段<br>按照子序列的结尾位置进行阶段划分。</li>
</ol>
<ol>
<li><p>定义状态<br>定义状态 $dp[i]$ 表示为：以 $nums[i]$ 结尾的最长递增子序列长度。</p>
</li>
<li><p>状态转移方程<br>一个较小的数后边如果出现一个较大的数，则会形成一个更长的递增子序列。对于满足 $0 \le j &lt; i$ 的数组元素 $nums[j]$ 和 $nums[i]$ 来说：</p>
<ul>
<li>如果 $nums[j] &lt; nums[i]$，则 $nums[i]$ 可以接在 $nums[j]$ 后面，此时以 $nums[i]$ 结尾的最长递增子序列长度会在「以 $nums[j]$ 结尾的最长递增子序列长度」的基础上加 $1$，即：$dp[i] = dp[j] + 1$。</li>
<li>如果 $nums[j] \le nums[i]$，则 $nums[i]$ 不可以接在 $nums[j]$ 后面，可以直接跳过。</li>
</ul>
</li>
</ol>
<p>综上，我们的状态转移方程为：$dp[i] = max(dp[i], dp[j] + 1)，0 \le j &lt; i，nums[j] &lt; nums[i]$。</p>
<ol>
<li><p>初始条件<br>默认状态下，把数组中的每个元素都作为长度为 $1$ 的递增子序列。即 $dp[i] = 1$。</p>
</li>
<li><p>最终结果<br>根据我们之前定义的状态，$dp[i]$ 表示为：以 $nums[i]$ 结尾的最长递增子序列长度。那为了计算出最大的最长递增子序列长度，则需要再遍历一遍 $dp$ 数组，求出最大值即为最终结果。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp) <span class="comment"># 不是dp[n-1]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n^2)$。两重循环遍历的时间复杂度是 $O(n^2)$，最后求最大值的时间复杂度是 $O(n)$，所以总体时间复杂度为 $O(n^2)$。</li>
<li><strong>空间复杂度</strong>：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。</li>
</ul>
<h4 id="3-1-2-最大子数组和"><a href="#3-1-2-最大子数组和" class="headerlink" title="3.1.2 最大子数组和"></a>3.1.2 最大子数组和</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和 - 力扣</a></p>
<p>单串线性 DP 问题中除了子序列相关的线性 DP 问题，还有子数组相关的线性 DP 问题。</p>
<p><strong>注意</strong>：</p>
<ul>
<li><strong>子序列</strong>：由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。</li>
<li><strong>子数组</strong>：指的是数组中的一个连续子序列。</li>
</ul>
<p>「子序列」与「子数组」都可以看做是原数组的一部分，而且都不会改变原来数组中元素的相对顺序。其区别在于数组元素是否要求连续。</p>
</blockquote>
<p>&#8195;&#8195;给定一个整数数组 $nums$,找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<ul>
<li><strong>子数组</strong>：指的是数组中的一个连续部分。</li>
<li>$1 \le nums.length \le 10^5$。</li>
<li>$-10^4 \le nums[i] \le 10^4$。</li>
</ul>
<p><strong>示例</strong>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span>。</span><br></pre></td></tr></table></figure></p>
<h5 id="3-1-2-1-动态规划"><a href="#3-1-2-1-动态规划" class="headerlink" title="3.1.2.1 动态规划"></a>3.1.2.1 动态规划</h5><ol>
<li><p>划分阶段<br>按照连续子数组的结束位置进行阶段划分。</p>
</li>
<li><p>定义状态<br>定义状态 $dp[i]$ 为：以第 $i$ 个数结尾的连续子数组的最大和。</p>
</li>
<li><p>状态转移方程<br>状态 $dp[i]$ 为：以第 $i$ 个数结尾的连续子数组的最大和。则我们可以从<code>dp[i-1]</code>来讨论 <code>dp[i]</code>。</p>
<ul>
<li>如果 <code>dp[i - 1] &lt; 0</code>，则<code>dp[i - 1] + nums[i] &lt; nums[i]</code>。所以，此时 <code>dp[i]</code> 应取第 $i$ 个数的值，即 <code>dp[i] = nums[i]</code>。</li>
<li>如果 <code>dp[i - 1] ≥0</code>，则 <code>dp[i] = dp[i - 1] + nums[i]</code>。</li>
</ul>
</li>
</ol>
<p>&#8195;&#8195;归纳一下，状态转移方程为：</p>
<script type="math/tex; mode=display">dp[i] = \begin{cases} nums[i], &  dp[i - 1] < 0 \cr dp[i - 1] + nums[i] & dp[i - 1] \ge 0 \end{cases}</script><ol>
<li><p>初始条件<br>第 $0$ 个数结尾的连续子数组的最大和为 $nums[0]$，即 $dp[0] = nums[0]$。</p>
</li>
<li><p>最终结果<br>根据状态定义，$dp[i]$ 为：以第 $i$ 个数结尾的连续子数组的最大和。则最终结果应为所有 $dp[i]$ 的最大值，即 $max(dp)$。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> dp[i - <span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$，其中 $n$ 为数组 $nums$ 的元素个数。</li>
<li><strong>空间复杂度</strong>：$O(n)$。</li>
</ul>
<h5 id="3-1-2-2-动态规划-滚动数组"><a href="#3-1-2-2-动态规划-滚动数组" class="headerlink" title="3.1.2.2 动态规划+滚动数组"></a>3.1.2.2 动态规划+滚动数组</h5><p>&#8195;&#8195;因为 $dp[i]$ 只和 $dp[i - 1]$ 和当前元素 $nums[i]$ 相关，我们也可以使用一个变量 $subMax$ 来表示以第 $i$ 个数结尾的连续子数组的最大和。然后使用 $ansMax$ 来保存全局中最大值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        subMax = nums[<span class="number">0</span>]</span><br><span class="line">        ansMax = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> subMax &lt; <span class="number">0</span>:</span><br><span class="line">                subMax = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                subMax += nums[i]</span><br><span class="line">            ansMax = <span class="built_in">max</span>(ansMax, subMax)</span><br><span class="line">        <span class="keyword">return</span> ansMax</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$，其中 $n$ 为数组 $nums$ 的元素个数。</li>
<li><strong>空间复杂度</strong>：$O(1)$。</li>
</ul>
<h4 id="3-1-3-最长的斐波那契子序列的长度"><a href="#3-1-3-最长的斐波那契子序列的长度" class="headerlink" title="3.1.3 最长的斐波那契子序列的长度"></a>3.1.3 最长的斐波那契子序列的长度</h4><p>&#8195;&#8195;有一些单串线性 DP 问题在定义状态时需要考虑两个结束位置，只考虑一个结束位置的无法清楚描述问题。这时候我们就需要需要增加一个结束位置维度来定义状态。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/">873. 最长的斐波那契子序列的长度 - 力扣</a></p>
</blockquote>
<p>&#8195;&#8195;给定一个严格递增的正整数数组 $arr$，要求从数组 $arr$ 中找出最长的斐波那契式的子序列的长度。如果不存斐波那契式的子序列，则返回 0。</p>
<ul>
<li><strong>斐波那契式序列</strong>：如果序列 $X_1, X_2, …, X_n$ 满足<ul>
<li>$n \ge 3$；</li>
<li>对于所有 $i + 2 \le n$，都有 $X<em>i + X</em>{i+1} = X_{i+2}$，则称该序列为斐波那契式序列。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>斐波那契式子序列</strong>：从序列 $A$ 中挑选若干元素组成子序列，并且子序列满足斐波那契式序列，则称该序列为斐波那契式子序列。例如：$A = [3, 4, 5, 6, 7, 8]$。则 $[3, 5, 8]$ 是 $A$ 的一个斐波那契式子序列。</p>
</li>
<li><p>$3 \le arr.length \le 1000$。</p>
</li>
<li><p>$1 \le arr[i] &lt; arr[i + 1] \le 10^9$。</p>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">18</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 最长的斐波那契式子序列有 [<span class="number">1</span>,<span class="number">11</span>,<span class="number">12</span>]、[<span class="number">3</span>,<span class="number">11</span>,<span class="number">14</span>] 以及 [<span class="number">7</span>,<span class="number">11</span>,<span class="number">18</span>]。</span><br></pre></td></tr></table></figure>
<h5 id="3-1-3-1-暴力枚举（超时）"><a href="#3-1-3-1-暴力枚举（超时）" class="headerlink" title="3.1.3.1 暴力枚举（超时）"></a>3.1.3.1 暴力枚举（超时）</h5><p>&#8195;&#8195;假设 $arr[i]$、$arr[j]$、$arr[k]$ 是序列 $arr$ 中的 $3$ 个元素，且满足关系：$arr[i] + arr[j] == arr[k]$，则 $arr[i]$、$arr[j]$、$arr[k]$ 就构成了 $arr$ 的一个斐波那契式子序列。</p>
<p>&#8195;&#8195;通过  $arr[i]$、$arr[j]$，我们可以确定下一个斐波那契式子序列元素的值为 $arr[i] + arr[j]$。</p>
<p>&#8195;&#8195;因为给定的数组是严格递增的，所以对于一个斐波那契式子序列，如果确定了 $arr[i]$、$arr[j]$，则可以顺着 $arr$ 序列，从第 $j + 1$ 的元素开始，查找值为 $arr[i] + arr[j]$ 的元素 。找到 $arr[i] + arr[j]$ 之后，然后再顺着查找子序列的下一个元素。</p>
<p>&#8195;&#8195;简单来说，就是确定了 $arr[i]$、$arr[j]$，就能尽可能的得到一个长的斐波那契式子序列，此时我们记录下子序列长度。然后对于不同的  $arr[i]$、$arr[j]$，统计不同的斐波那契式子序列的长度。</p>
<p>&#8195;&#8195;最后将这些长度进行比较，其中最长的长度就是答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(arr)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">                temp_ans = <span class="number">0</span></span><br><span class="line">                temp_i = i</span><br><span class="line">                temp_j = j</span><br><span class="line">                k = j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> k &lt; size:</span><br><span class="line">                    <span class="keyword">if</span> arr[temp_i] + arr[temp_j] == arr[k]:</span><br><span class="line">                        temp_ans += <span class="number">1</span></span><br><span class="line">                        temp_i = temp_j</span><br><span class="line">                        temp_j = k</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> temp_ans &gt; ans:</span><br><span class="line">                    ans = temp_ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ans &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ans + <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n^3)$，其中 $n$ 为数组 $arr$ 的元素个数。</li>
<li><strong>空间复杂度</strong>：$O(1)$。</li>
</ul>
<h5 id="3-1-3-2-哈希表"><a href="#3-1-3-2-哈希表" class="headerlink" title="3.1.3.2 哈希表"></a>3.1.3.2 哈希表</h5><p>&#8195;&#8195;对于 $arr[i]$、$arr[j]$，要查找的元素 $arr[i] + arr[j]$ 是否在 $arr$ 中，我们可以预先建立一个反向的哈希表。键值对关系为 $value : idx$，这样就能在 $O(1)$ 的时间复杂度通过 $arr[i] + arr[j]$ 的值查找到对应的 $arr[k]$，而不用像原先一样线性查找 $arr[k]$ 了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(arr)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        idx_map = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> idx, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr):</span><br><span class="line">            idx_map[value] = idx</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">                temp_ans = <span class="number">0</span></span><br><span class="line">                temp_i = i</span><br><span class="line">                temp_j = j</span><br><span class="line">                <span class="keyword">while</span> arr[temp_i] + arr[temp_j] <span class="keyword">in</span> idx_map:</span><br><span class="line">                    temp_ans += <span class="number">1</span></span><br><span class="line">                    k = idx_map[arr[temp_i] + arr[temp_j]]</span><br><span class="line">                    temp_i = temp_j</span><br><span class="line">                    temp_j = k</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> temp_ans &gt; ans:</span><br><span class="line">                    ans = temp_ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ans &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ans + <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n^2)$，其中 $n$ 为数组 $arr$ 的元素个数。</li>
<li><strong>空间复杂度</strong>：$O(n)$。</li>
</ul>
<h5 id="3-1-3-3-动态规划-哈希表"><a href="#3-1-3-3-动态规划-哈希表" class="headerlink" title="3.1.3.3 动态规划 + 哈希表"></a>3.1.3.3 动态规划 + 哈希表</h5><ol>
<li><p>划分阶段<br>按照斐波那契式子序列相邻两项的结尾位置进行阶段划分。</p>
<ol>
<li>定义状态<br>定义状态 $dp[i][j]$ 表示为：以 $arr[i]$、$arr[j]$ 为结尾的斐波那契式子序列的最大长度。</li>
</ol>
</li>
<li><p>状态转移方程<br>如果$arr[i] + arr[j] = arr[k]$ ，则以 $arr[i]$、$arr[k]$ 结尾的斐波那契式子序列的最大长度，等于以 $arr[i]$、$arr[j]$ 为结尾的斐波那契式子序列的最大长度加 $1$。即状态转移方程为：$dp[j][k] = max_{(A[i] + A[j] = A[k]，i &lt; j &lt; k)}(dp[i][j] + 1)$。</p>
</li>
<li><p>初始条件<br>默认状态下，数组中任意相邻两项元素都可以作为长度为 $2$ 的斐波那契式子序列，即 $dp[i][j] = 2$。</p>
</li>
<li><p>最终结果<br>根据我们之前定义的状态，$dp[i][j]$ 表示为：以 $arr[i]$、$arr[j]$ 为结尾的斐波那契式子序列的最大长度。那为了计算出最大的最长递增子序列长度，则需要在进行状态转移时，求出最大值 $ans$ 即为最终结果。</p>
</li>
</ol>
<p>因为题目定义中，斐波那契式中 $n \ge 3$，所以只有当 $ans \ge 3$ 时，返回 $ans$。如果 $ans &lt; 3$，则返回 $0$。</p>
<blockquote>
<p><strong>注意</strong>：在进行状态转移的同时，我们应和「思路 2：哈希表」一样采用哈希表优化的方式来提高效率，降低算法的时间复杂度。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">if</span> size&lt;<span class="number">3</span>:</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        	</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化 dp</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">                dp[i][j] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="comment"># 将 value : idx 映射为哈希表，这样可以快速通过 value 获取到 idx</span></span><br><span class="line">        <span class="keyword">for</span> idx, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr):</span><br><span class="line">            d[value] = idx</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">                <span class="keyword">if</span> arr[i] + arr[j] <span class="keyword">in</span> idx_map:    </span><br><span class="line">                    <span class="comment"># 获取 arr[i] + arr[j] 的 idx，即斐波那契式子序列下一项元素</span></span><br><span class="line">                    k = d[arr[i] + arr[j]]</span><br><span class="line">                    </span><br><span class="line">                    dp[j][k] = <span class="built_in">max</span>(dp[j][k], dp[i][j] + <span class="number">1</span>)</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, dp[j][k])</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> ans        </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n^2)$，其中 $n$ 为数组 $arr$ 的元素个数。</li>
<li><strong>空间复杂度</strong>：$O(n)$。</li>
</ul>
<h3 id="3-2-双串线性-DP-问题"><a href="#3-2-双串线性-DP-问题" class="headerlink" title="3.2 双串线性 DP 问题"></a>3.2 双串线性 DP 问题</h3><p> <strong>双串线性 DP 问题</strong>：问题的输入为两个数组或两个字符串的线性 DP 问题。状态一般可定义为 $dp[i][j]$，表示为：</p>
<ol>
<li>「以第一个数组中第 $i$ 个位置元素 $nums1[i]$ 为结尾的子数组（$nums1[0]…nums1[i]$）」与「以第二个数组中第 $j$ 个位置元素 $nums2[j]$ 为结尾的子数组（$nums2[0]…nums2[j]$）」的相关解。<ol>
<li>「以第一个数组中第 $i - 1$ 个位置元素 $nums1[i - 1]$ 为结尾的子数组（$nums1[0]…nums1[i - 1]$）」与「以第二个数组中第 $j - 1$ 个位置元素 $nums2[j - 1]$ 为结尾的子数组（$nums2[0]…nums2[j - 1]$）」的相关解。</li>
<li>「以第一个数组中前 $i$ 个元素为子数组（$nums1[0]…nums1[i - 1]$）」与「以第二个数组中前 $j$ 个元素为子数组（$nums2[0]…nums2[j - 1]$）」的相关解。</li>
</ol>
</li>
</ol>
<p>这 $3$ 种状态的定义区别在于相差一个元素 $nums1[i]$ 或 $nums2[j]$。</p>
<ol>
<li>第 $1$ 种状态：子数组的长度为 $i + 1$ 或 $j + 1$，子数组长度可为空</li>
<li>第 $2$ 种状态、第 $3$ 种状态：子数组的长度为 $i$ 或 $j$，子数组长度不可为空。</li>
</ol>
<p>双串线性 DP 问题中最经典的问题就是「最长公共子序列（Longest Common Subsequence，简称 LCS）」。</p>
<h4 id="3-2-1-最长公共子序列"><a href="#3-2-1-最长公共子序列" class="headerlink" title="3.2.1 最长公共子序列"></a>3.2.1 最长公共子序列</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列 - 力扣</a></p>
</blockquote>
<p>&#8195;&#8195;给定两个字符串 $text1$ 和 $text2$，要求返回两个字符串的最长公共子序列的长度。如果不存在公共子序列，则返回 $0$。</p>
<ul>
<li><strong>子序列</strong>：原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</li>
<li><strong>公共子序列</strong>：两个字符串所共同拥有的子序列。</li>
<li>$1 \le text1.length, text2.length \le 1000$。</li>
<li>$text1$ 和 $text2$ 仅由小写英文字符组成。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">&quot;abcde&quot;</span>, text2 = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">输出：<span class="number">3</span>  </span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;ace&quot;</span>，它的长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>
<p><strong>思路 1：动态规划</strong></p>
<ol>
<li>划分阶段<br>按照两个字符串的结尾位置进行阶段划分。</li>
</ol>
<ol>
<li><p>定义状态<br>定义状态 $dp[i][j]$ 表示为：「以 $text1$ 中前 $i$ 个元素组成的子字符串 $str1$ 」与「以 $text2$ 中前 $j$ 个元素组成的子字符串 $str2$」的最长公共子序列长度为 $dp[i][j]$。</p>
</li>
<li><p>状态转移方程<br>双重循环遍历字符串 $text1$ 和 $text2$，则状态转移方程为：</p>
<ol>
<li>如果 $text1[i - 1] = text2[j - 1]$，说明两个子字符串的最后一位是相同的，所以最长公共子序列长度加 $1$。即：$dp[i][j] = dp[i - 1][j - 1] + 1$。</li>
<li>如果 $text1[i - 1] \ne text2[j - 1]$，说明两个子字符串的最后一位是不同的，则 $dp[i][j]$ 需要考虑以下两种情况，取两种情况中最大的那种：$dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])$。<ol>
<li>$str1[0:i-1]$与$str2[j]$的最长公共子序列长度，即 $dp[i - 1][j]$。</li>
<li>$str1[0:i]$与$str2[j-1]$的最长公共子序列长度，即 $dp[i][j - 1]$。</li>
</ol>
</li>
</ol>
</li>
<li><p>初始条件</p>
<ol>
<li>当 $i = 0$ 时，$str1$ 表示的是空串，空串与 $str2$ 的最长公共子序列长度为 $0$，即 $dp[0][j] = 0$。</li>
<li>当 $j = 0$ 时，$str2$ 表示的是空串，$str1$ 与 空串的最长公共子序列长度为 $0$，即 $dp[i][0] = 0$。</li>
</ol>
</li>
<li><p>最终结果<br>根据状态定义，最后输出 $dp[sise1][size2]$（即 $text1$ 与 $text2$ 的最长公共子序列长度）即可，其中 $size1$、$size2$ 分别为 $text1$、$text2$ 的字符串长度。</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/74617861bb8445a7a2403acbff1dcffc.png" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size1 = <span class="built_in">len</span>(text1)</span><br><span class="line">        size2 = <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size2 + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size1 + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[size1][size2]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n \times m)$，其中 $n$、$m$ 分别是字符串 $text1$、$text2$ 的长度。两重循环遍历的时间复杂度是 $O(n \times m)$，所以总的时间复杂度为 $O(n \times m)$。</li>
<li><strong>空间复杂度</strong>：$O(n \times m)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(n \times m)$。</li>
</ul>
<h4 id="3-2-2-最长重复子数组"><a href="#3-2-2-最长重复子数组" class="headerlink" title="3.2.2 最长重复子数组"></a>3.2.2 最长重复子数组</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组 - 力扣</a></p>
</blockquote>
<p>&#8195;&#8195;给定两个整数数组 $nums1$、$nums2$，计算两个数组中公共的、长度最长的子数组长度。</p>
<ul>
<li>$1 \le nums1.length, nums2.length \le 1000$。</li>
<li>$0 \le nums1[i], nums2[i] \le 100$。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], nums2 = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：长度最长的公共子数组是 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure>
<p><strong>思路 1：动态规划</strong></p>
<ol>
<li><p>划分阶段<br>按照子数组结尾位置进行阶段划分。</p>
</li>
<li><p>定义状态<br>定义状态 $dp[i][j]$ 为：「以 $nums1$ 中前 $i$ 个元素为子数组（$nums1[0]…nums2[i - 1]$）」和「以 $nums2$ 中前 $j$ 个元素为子数组（$nums2[0]…nums2[j - 1]$）」的最长公共子数组长度。</p>
</li>
<li><p>状态转移方程</p>
<ol>
<li>如果 $nums1[i - 1] = nums2[j - 1]$，则当前元素可以构成公共子数组，此时 $dp[i][j] = dp[i - 1][j - 1] + 1$。</li>
<li>如果 $nums1[i - 1] \ne nums2[j - 1]$，则当前元素不能构成公共子数组，此时 $dp[i][j] = 0$。</li>
</ol>
</li>
<li><p>初始条件</p>
<ul>
<li>当 $i = 0$ 时，$nums1[0]…nums1[i - 1]$ 表示的是空数组，空数组与 $nums2[0]…nums2[j - 1]$ 的最长公共子序列长度为 $0$，即 $dp[0][j] = 0$。</li>
<li>当 $j = 0$ 时，$nums2[0]…nums2[j - 1]$ 表示的是空数组，空数组与 $nums1[0]…nums1[i - 1]$ 的最长公共子序列长度为 $0$，即 $dp[i][0] = 0$。</li>
</ul>
</li>
<li><p>最终结果<br>根据状态定义， $dp[i][j]$ 为：「以 $nums1$ 中前 $i$ 个元素为子数组（$nums1[0]…nums2[i - 1]$）」和「以 $nums2$ 中前 $j$ 个元素为子数组（$nums2[0]…nums2[j - 1]$）」的最长公共子数组长度。在遍历过程中，我们可以使用 $res$ 记录下所有 $dp[i][j]$ 中最大值即为答案。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        size2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size2 + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size1 + <span class="number">1</span>)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j] &gt; res:</span><br><span class="line">                    res = dp[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n \times m)$。其中 $n$ 是数组 $nums1$ 的长度，$m$ 是数组 $nums2$ 的长度。</li>
<li><strong>空间复杂度</strong>：$O(n \times m)$。</li>
</ul>
<h4 id="3-3-3-编辑距离"><a href="#3-3-3-编辑距离" class="headerlink" title="3.3.3 编辑距离"></a>3.3.3 编辑距离</h4><p>双串线性 DP 问题中除了经典的最长公共子序列问题之外，还包括字符串的模糊匹配问题。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离 - 力扣</a></p>
</blockquote>
<p>给定两个单词 $word1$、$word2$。对一个单词可以进行以下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p>请计算出将 $word1$ 转换为 $word2$ 所使用的最少操作数。</p>
<ul>
<li>$0 \le word1.length, word2.length \le 500$。</li>
<li>$word1$ 和 $word2$ 由小写英文字母组成。</li>
</ul>
<p><strong>示例</strong>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：word1 = <span class="string">&quot;intention&quot;</span>, word2 = <span class="string">&quot;execution&quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">inention -&gt; enention (将 <span class="string">&#x27;i&#x27;</span> 替换为 <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">enention -&gt; exention (将 <span class="string">&#x27;n&#x27;</span> 替换为 <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">exention -&gt; exection (将 <span class="string">&#x27;n&#x27;</span> 替换为 <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">exection -&gt; execution (插入 <span class="string">&#x27;u&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>思路 1：动态规划</strong></p>
<ol>
<li><p>划分阶段<br>按照两个字符串的结尾位置进行阶段划分。</p>
</li>
<li><p>定义状态<br>定义状态 $dp[i][j]$ 表示为：「以 $word1$ 中前 $i$ 个字符组成的子字符串 $str1$」变为「以  $word2$ 中前 $j$ 个字符组成的子字符串 $str2$」，所需要的最少操作次数。</p>
</li>
<li><p>状态转移方程</p>
<ol>
<li>如果当前字符相同（$word1[i - 1] = word2[j - 1]$），无需插入、删除、替换。$dp[i][j] = dp[i - 1][j - 1]$。</li>
<li>如果当前字符不同（$word1[i - 1] \ne word2[j - 1]$），$dp[i][j]$ 取源于以下三种情况中的最小情况：<ol>
<li>替换（$word1[i - 1]$ 替换为 $word2[j - 1]$）：最少操作次数依赖于「以 $word1$ 中前 $i - 1$ 个字符组成的子字符串 $str1$」变为「以  $word2$ 中前 $j - 1$ 个字符组成的子字符串 $str2$」，再加上替换的操作数 $1$，即：$dp[i][j] = dp[i - 1][j - 1] + 1$。</li>
<li>插入（$word1$ 在第 $i - 1$ 位置上插入元素）：最少操作次数依赖于「以 $word1$ 中前 $i - 1$ 个字符组成的子字符串 $str1$」 变为「以  $word2$ 中前 $j$ 个字符组成的子字符串 $str2$」，再加上插入需要的操作数 $1$，即：$dp[i][j] = dp[i - 1][j] + 1$。</li>
<li>删除（$word1$ 删除第 $i - 1$ 位置元素）：最少操作次数依赖于「以 $word1$ 中前 $i$ 个字符组成的子字符串 $str1$」变为「以  $word2$ 中前 $j - 1$ 个字符组成的子字符串 $str2$」，再加上删除需要的操作数 $1$，即：$dp[i][j] = dp[i][j - 1] + 1$。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>&#8195;&#8195;综合上述情况，状态转移方程为：</p>
<script type="math/tex; mode=display">dp[i][j] = \begin{cases} dp[i - 1][j - 1] & word1[i - 1] = word2[j - 1] \cr min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1 & word1[i - 1] \ne word2[j - 1] \end{cases}</script><ol>
<li><p>初始条件</p>
<ul>
<li>当 $i = 0$， $str1$为空字符串，$str1$变为$str2$时，至少需要插入 $j$ 次，即：$dp[0][j] = j$。</li>
<li>当 $j = 0$，$str2$为空字符串， $str1$变为$str2$时，至少需要删除 $i$ 次，即：$dp[i][0] = i$。</li>
</ul>
</li>
<li><p>最终结果<br>根据状态定义，最后输出 $dp[sise1][size2]$（即 $word1$ 变为 $word2$ 所使用的最少操作数）即可。其中 $size1$、$size2$ 分别为 $word1$、$word2$ 的字符串长度。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size1 = <span class="built_in">len</span>(word1)</span><br><span class="line">        size2 = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size2 + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size1 + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size1 + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size2 + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[size1][size2]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n \times m)$，其中 $n$、$m$ 分别是字符串 $word1$、$word2$ 的长度。两重循环遍历的时间复杂度是 $O(n \times m)$，所以总的时间复杂度为 $O(n \times m)$。</li>
<li><strong>空间复杂度</strong>：$O(n \times m)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(n \times m)$。</li>
</ul>
<h3 id="3-3-矩阵线性-DP问题"><a href="#3-3-矩阵线性-DP问题" class="headerlink" title="3.3 矩阵线性 DP问题"></a>3.3 矩阵线性 DP问题</h3><p>&#8195;&#8195; <strong>矩阵线性 DP 问题</strong>：问题的输入为二维矩阵的线性 DP 问题。状态一般可定义为 $dp[i][j]$，表示为：从「位置 $(0, 0)$」到达「位置 $(i, j)$」的相关解。</p>
<h4 id="3-3-1-最小路径和"><a href="#3-3-1-最小路径和" class="headerlink" title="3.3.1 最小路径和"></a>3.3.1 最小路径和</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和 - 力扣</a></p>
</blockquote>
<p>&#8195;&#8195;给定一个包含非负整数的 $m \times n$  大小的网格 $grid$,找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<ul>
<li>每次只能向下或者向右移动一步。</li>
<li>$m == grid.length$。</li>
<li>$n == grid[i].length$。</li>
<li>$1 \le m, n \le 200$。</li>
<li>$0 \le grid[i][j] \le 100$。</li>
</ul>
<p><strong>示例</strong>：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9e6ba00606fa07e0b9c0287799c9cd9c.jpeg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></table></figure>
<p><strong>思路 1：动态规划</strong></p>
<ol>
<li><p>划分阶段<br>按照路径的结尾位置（行位置、列位置组成的二维坐标）进行阶段划分。</p>
<ol>
<li>定义状态<br>定义状态 $dp[i][j]$ 为：从位置 $(0, 0)$ 到达位置 $(i, j)$ 的最小路径和。</li>
</ol>
</li>
<li><p>状态转移方程<br>当前位置 $(i, j)$ 只能从左侧位置 $(i, j - 1)$ 或者上方位置 $(i - 1, j)$ 到达。为了使得从左上角到达 $(i, j)$ 位置的最小路径和最小，应从 $(i, j - 1)$ 位置和 $(i - 1, j)$ 位置选择路径和最小的位置达到 $(i, j)$。即状态转移方程为：<script type="math/tex">dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]</script></p>
</li>
<li><p>初始条件</p>
<ul>
<li>当左侧和上方是矩阵边界时（即 $i = 0, j = 0$），$dp[i][j] = grid[i][j]$。</li>
<li>当只有左侧是矩阵边界时（即 $i \ne 0, j = 0$），只能从上方到达，$dp[i][j] = dp[i - 1][j] + grid[i][j]$。</li>
<li>当只有上方是矩阵边界时（即 $i = 0, j \ne 0$），只能从左侧到达，$dp[i][j] = dp[i][j - 1] + grid[i][j]$。</li>
</ul>
</li>
<li><p>最终结果<br>根据状态定义，最后输出 $dp[rows - 1][cols - 1]$（即从左上角到达 $(rows - 1, cols - 1)$ 位置的最小路径和）即可。其中 $rows$、$cols$ 分别为 $grid$ 的行数、列数。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cols)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols):</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + grid[i][j]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[rows - <span class="number">1</span>][cols - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(m * n)$，其中 $m$、$n$ 分别为 $grid$ 的行数和列数。</li>
<li><strong>空间复杂度</strong>：$O(m * n)$。</li>
</ul>
<h4 id="3-3-2最大正方形"><a href="#3-3-2最大正方形" class="headerlink" title="3.3.2最大正方形"></a>3.3.2最大正方形</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形 - 力扣</a></p>
</blockquote>
<p>给定一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵 $matrix$，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p>
<ul>
<li>$m == matrix.length$。</li>
<li>$n == matrix[i].length$。</li>
<li>$1 \le m, n \le 300$。</li>
<li>$matrix[i][j]$ 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code>。</li>
</ul>
<p><strong>示例</strong>：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1687084f2a15394343d9005211b338df.jpeg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>思路 1：动态规划</strong></p>
<ol>
<li><p>划分阶段<br>按照正方形的右下角坐标进行阶段划分。</p>
</li>
<li><p>定义状态<br>定义状态 $dp[i][j]$ 表示为：以矩阵位置 $(i, j)$ 为右下角，且值包含 $1$ 的正方形的最大边长。</p>
</li>
<li><p>状态转移方程<br>只有当矩阵位置 $(i, j)$ 值为 $1$ 时，才有可能存在正方形。</p>
<ul>
<li>如果矩阵位置 $(i, j)$ 上值为 $0$，则 $dp[i][j] = 0$。</li>
<li>如果矩阵位置 $(i, j)$ 上值为 $1$，则 $dp[i][j]$ 的值由该位置上方、左侧、左上方三者共同约束的，为三者中最小值加 $1$。即：$dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1$。</li>
</ul>
</li>
<li><p>初始条件<br>默认所有以矩阵位置 $(i, j)$ 为右下角，且值包含 $1$ 的正方形的最大边长都为 $0$，即 $dp[i][j] = 0$。</p>
</li>
<li><p>最终结果<br>根据我们之前定义的状态， $dp[i][j]$ 表示为：以矩阵位置 $(i, j)$ 为右下角，且值包含 $1$ 的正方形的最大边长。则最终结果为所有 $dp[i][j]$ 中的最大值。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        max_size = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cols)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                	 <span class="comment"># 第一行或第一列某个位置为“1”，则其dp值为1，因为是最小正方形</span></span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 其它位置为“1”时，只有左侧、上方和左上方三个位置都是“1”，这个位置值才+1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                    max_size = <span class="built_in">max</span>(max_size, dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> max_size * max_size</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(m \times n)$，其中 $m$、$n$ 分别为二维矩阵 $matrix$ 的行数和列数。</li>
<li><strong>空间复杂度</strong>：$O(m \times n)$。</li>
</ul>
<h3 id="3-4无串线性-DP-问题"><a href="#3-4无串线性-DP-问题" class="headerlink" title="3.4无串线性 DP 问题"></a>3.4无串线性 DP 问题</h3><p><strong>无串线性 DP 问题</strong>：问题的输入不是显式的数组或字符串，但依然可分解为若干子问题的线性 DP 问题。</p>
<h4 id="3-4-1-整数拆分"><a href="#3-4-1-整数拆分" class="headerlink" title="3.4.1 整数拆分"></a>3.4.1 整数拆分</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">343. 整数拆分 - 力扣</a></p>
</blockquote>
<p>&#8195;&#8195;给定一个正整数 $n$，将其拆分为 $k (k \ge 2)$ 个正整数的和，并使这些整数的乘积最大化，返回可以获得的最大乘积。</p>
<ul>
<li>$2 \le n \le 58$。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: n = <span class="number">10</span></span><br><span class="line">输出: <span class="number">36</span></span><br><span class="line">解释: <span class="number">10</span> = <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span>, <span class="number">3</span> × <span class="number">3</span> × <span class="number">4</span> = <span class="number">36</span>。</span><br></pre></td></tr></table></figure>
<p><strong>思路 1：动态规划</strong></p>
<ol>
<li><p>划分阶段<br>按照正整数进行划分。</p>
</li>
<li><p>定义状态<br>定义状态 $dp[i]$ 表示为：将正整数 $i$ 拆分为至少 $2$ 个正整数的和之后，这些正整数的最大乘积。</p>
</li>
<li><p>状态转移方程<br><font color='red'> 始终要记得自己定义的dp数组的含义&lt;/font &gt;<br>当 $i \ge 2$ 时，假设正整数 $i$ 拆分出的第 $1$ 个正整数是 $j(1 \le j &lt; i)$，则有两种方法：</p>
<ol>
<li>将 $i$ 拆分为 $j$ 和 $i - j$ 的和，且 $i - j$ 不再拆分为多个正整数，此时乘积为：$j \times (i - j)$。</li>
<li>将 $i$ 拆分为 $j$ 和 $i - j$ 的和，且 $i - j$ 继续拆分为多个正整数，此时乘积为：$j \times dp[i - j]$。</li>
</ol>
</li>
</ol>
<p>则 $dp[i]$ 取两者中的最大值。即：$dp[i] = max(j \times (i - j), j \times dp[i - j])$。</p>
<p>由于 $1 \le j &lt; i$，需要遍历 $j$ 得到 $dp[i]$ 的最大值，则状态转移方程如下：</p>
<script type="math/tex; mode=display">dp[i] = max_{1 \le j < i}\lbrace max(j \times (i - j), j \times dp[i - j]) \rbrace</script><ol>
<li><p>初始条件<br>$0$ 和 $1$ 都不能被拆分，所以 $dp[0] = 0, dp[1] = 0$。</p>
</li>
<li><p>最终结果<br>根据我们之前定义的状态，$dp[i]$ 表示为：将正整数 $i$ 拆分为至少 $2$ 个正整数的和之后，这些正整数的最大乘积。则最终结果为 $dp[n]$。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], (i - j) * j, dp[i - j] * j)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n^2)$。</li>
<li><strong>空间复杂度</strong>：$O(n)$。</li>
</ul>
<p><strong>思路 2：动态规划优化</strong><br>&#8195;&#8195;思路1中计算dp[i] 时，j 的值遍历了从 1 到 i−1 的所有值，因此总时间复杂度是$O(n^2)$。继续分析可知，要想得到最大乘积，j只能取2或者3（详见<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/">《官方题解》</a>），则状态转移方程为：</p>
<script type="math/tex; mode=display">dp[i]=max(2×(i−2),2×dp[i−2],3×(i−3),3×dp[i−3])</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(<span class="number">2</span> * (i - <span class="number">2</span>), <span class="number">2</span> * dp[i - <span class="number">2</span>], <span class="number">3</span> * (i - <span class="number">3</span>), <span class="number">3</span> * dp[i - <span class="number">3</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h4 id="3-4-2-只有两个键的键盘"><a href="#3-4-2-只有两个键的键盘" class="headerlink" title="3.4.2 只有两个键的键盘"></a>3.4.2 只有两个键的键盘</h4><p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/2-keys-keyboard/">650. 只有两个键的键盘</a></p>
<p>最初记事本上只有一个字符 <code>&#39;A&#39;</code>。你每次可以对这个记事本进行两种操作：</p>
<ul>
<li><strong>Copy All（复制全部）</strong>：复制这个记事本中的所有字符（不允许仅复制部分字符）。</li>
<li><strong>Paste（粘贴）</strong>：粘贴上一次复制的字符。</li>
</ul>
<p>现在，给定一个数字 $n$，需要使用最少的操作次数，在记事本上输出恰好 $n$ 个 <code>&#39;A&#39;</code> ，请返回能够打印出 $n$ 个 <code>&#39;A&#39;</code> 的最少操作次数。</p>
<ul>
<li><p>$1 \le n \le 1000$。</p>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释</span><br><span class="line">最初, 只有一个字符 <span class="string">&#x27;A&#x27;</span>。</span><br><span class="line">第 <span class="number">1</span> 步, 使用 Copy All 操作。</span><br><span class="line">第 <span class="number">2</span> 步, 使用 Paste 操作来获得 <span class="string">&#x27;AA&#x27;</span>。</span><br><span class="line">第 <span class="number">3</span> 步, 使用 Paste 操作来获得 <span class="string">&#x27;AAA&#x27;</span>。</span><br></pre></td></tr></table></figure>
<p><strong>思路 1：动态规划</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSteps</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        dp=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="comment"># 每次复制一个，n至多操作n次</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i):</span><br><span class="line">                <span class="keyword">if</span> i%j==<span class="number">0</span>:</span><br><span class="line">                    dp[i]=<span class="built_in">min</span>(dp[i],dp[j]+i//j)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<p>  其实<code>j</code>是<code>i</code>的因子，所以<code>j</code>应该不超过$\sqrt{i}$ 。    将其优化：</p>
<ol>
<li>划分阶段</li>
</ol>
<p>按照字符 <code>&#39;A&#39;</code>  的个数进行阶段划分。</p>
<ol>
<li>定义状态</li>
</ol>
<p>定义状态 $dp[i]$ 表示为：通过「复制」和「粘贴」操作，得到 $i$ 个字符 <code>&#39;A&#39;</code>，最少需要的操作数。</p>
<ol>
<li><p>状态转移方程</p>
<ol>
<li>对于 $i$ 个字符 <code>&#39;A&#39;</code>，如果 $i$ 可以被一个小于 $i$ 的整数 $j$ 除尽（$j$ 是 $i$ 的因子），则说明 $j$ 个字符 <code>&#39;A&#39;</code> 可以通过「复制」+「粘贴」总共 $\frac{i}{j}$ 次得到 $i$ 个字符 <code>&#39;A&#39;</code>。</li>
<li>而得到 $j$ 个字符 <code>&#39;A&#39;</code>，最少需要的操作数可以通过 $dp[j]$ 获取。</li>
</ol>
</li>
</ol>
<p>则我们可以枚举 $i$ 的因子，从中找到在满足 $j$ 能够整除 $i$ 的条件下，最小的 $dp[j] + \frac{i}{j}$，即为 $dp[i]$，即 $dp[i] = min_{j | i}(dp[i], dp[j] + \frac{i}{j})$。</p>
<p>由于 $j$ 能够整除 $i$，则 $j$ 与 $\frac{i}{j}$ 都是 $i$ 的因子，两者中必有一个因子是小于等于 $\sqrt{i}$ 的，所以在枚举 $i$ 的因子时，我们只需要枚举区间 $[1, \sqrt{i}]$ 即可。</p>
<p>综上所述，状态转移方程为：<script type="math/tex">dp[i] = min_{j | i}(dp[i], dp[j] + \frac{i}{j}, dp[\frac{i}{j}] + j)</script></p>
<ol>
<li><p>初始条件<br>当 $i = 1$ 时，最少需要的操作数为 $0$。所以 $dp[1] = 0$。</p>
</li>
<li><p>最终结果<br>根据我们之前定义的状态，$dp[i]$ 表示为：通过「复制」和「粘贴」操作，得到 $i$ 个字符 <code>&#39;A&#39;</code>，最少需要的操作数。 所以最终结果为 $dp[n]$。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSteps</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(math.sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + i // j, dp[i // j] + j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n \sqrt{n})$。外层循环遍历的时间复杂度是 $O(n)$，内层循环遍历的时间复杂度是 $O(\sqrt{n})$，所以总体时间复杂度为 $O(n \sqrt{n})$。</li>
<li><strong>空间复杂度</strong>：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。</li>
</ul>
<h3 id="3-5-线性-DP-题目大全"><a href="#3-5-线性-DP-题目大全" class="headerlink" title="3.5 线性 DP 题目大全"></a>3.5 线性 DP 题目大全</h3><p>单串线性 DP 问题</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">题号</th>
<th style="text-align:left">标题</th>
<th style="text-align:left">题解</th>
<th style="text-align:left">标签</th>
<th style="text-align:left">难度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0300</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.md">Python</a></td>
<td style="text-align:left">二分查找、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0673</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/">最长递增子序列的个数</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0673.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0.md">Python</a></td>
<td style="text-align:left">动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0354</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/russian-doll-envelopes/">俄罗斯套娃信封问题</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0354.%20%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98.md">Python</a></td>
<td style="text-align:left">动态规划、二分查找</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">0053</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0053.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C.md">Python</a></td>
<td style="text-align:left">数组、分治算法、动态规划</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0152</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/">乘积最大子数组</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84.md">Python</a></td>
<td style="text-align:left">数组、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0918</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">环形子数组的最大和</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0918.%20%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.md">Python</a></td>
<td style="text-align:left">数组、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0198</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.md">Python</a></td>
<td style="text-align:left">动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0213</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍 II</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II.md">Python</a></td>
<td style="text-align:left">动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0740</td>
<td style="text-align:left">删除并获得点数</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1388</td>
<td style="text-align:left">3n 块披萨</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0873</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/">最长的斐波那契子序列的长度</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0873.%20%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6.md">Python</a></td>
<td style="text-align:left">数组、哈希表、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">1027</td>
<td style="text-align:left">最长等差数列</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1055</td>
<td style="text-align:left">形成字符串的最短路径</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0368</td>
<td style="text-align:left">最大整除子集</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0032</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-valid-parentheses/">最长有效括号</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0032.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.md">Python</a></td>
<td style="text-align:left">栈、字符串、动态规划</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">0413</td>
<td style="text-align:left">等差数列划分</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0091</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-ways/">解码方法</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0091.%20%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95.md">Python</a></td>
<td style="text-align:left">字符串、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0639</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-ways-ii/">解码方法 II</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0639.%20%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%20II.md">Python</a></td>
<td style="text-align:left">字符串、动态规划</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">0132</td>
<td style="text-align:left">分割回文串 II</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1220</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-vowels-permutation/">统计元音字母序列的数目</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/1220.%20%E7%BB%9F%E8%AE%A1%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE.md">Python</a></td>
<td style="text-align:left">动态规划</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">0338</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/counting-bits/">比特位计数</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0.md">Python</a></td>
<td style="text-align:left">位运算、动态规划</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0801</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/">使序列递增的最小交换次数</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0801.%20%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0.md">Python</a></td>
<td style="text-align:left">动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0871</td>
<td style="text-align:left">最低加油次数</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0045</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">跳跃游戏 II</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0045.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%20II.md">Python</a></td>
<td style="text-align:left">贪心、数组、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0813</td>
<td style="text-align:left">最大平均值和的分组</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0887</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/super-egg-drop/">鸡蛋掉落</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0887.%20%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD.md">Python</a></td>
<td style="text-align:left">数学、二分查找、动态规划</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">0256</td>
<td style="text-align:left">粉刷房子</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0265</td>
<td style="text-align:left">粉刷房子 II</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1473</td>
<td style="text-align:left">粉刷房子 III</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0975</td>
<td style="text-align:left">奇偶跳</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0403</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/frog-jump/">青蛙过河</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0403.%20%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3.md">Python</a></td>
<td style="text-align:left">数组、动态规划</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">1478</td>
<td style="text-align:left">安排邮筒</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1230</td>
<td style="text-align:left">抛掷硬币</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0410</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/split-array-largest-sum/">分割数组的最大值</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0410.%20%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.md">Python</a></td>
<td style="text-align:left">二分查找、动态规划</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">1751</td>
<td style="text-align:left">最多可以参加的会议数目 II</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1787</td>
<td style="text-align:left">使所有区间的异或结果为零</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0121</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.md">Python</a></td>
<td style="text-align:left">数组、动态规划</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0122</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II.md">Python</a></td>
<td style="text-align:left">数组、贪心算法</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0123</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0123.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20III.md">Python</a></td>
<td style="text-align:left">数组、动态规划</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">0188</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机 IV</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0188.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20IV.md">Python</a></td>
<td style="text-align:left">数组、动态规划</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">0309</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0309.%20%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.md">Python</a></td>
<td style="text-align:left">数组、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0714</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0714.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.md">Python</a></td>
<td style="text-align:left">贪心、数组、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
</tbody>
</table>
</div>
<p>双串线性 DP 问题</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">题号</th>
<th style="text-align:left">标题</th>
<th style="text-align:left">题解</th>
<th style="text-align:left">标签</th>
<th style="text-align:left">难度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1143</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/1143.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.md">Python</a></td>
<td style="text-align:left">字符串、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0712</td>
<td style="text-align:left">两个字符串的最小ASCII删除和</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0718</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">最长重复子数组</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0718.%20%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.md">Python</a></td>
<td style="text-align:left">数组、二分查找、动态规划、滑动窗口、哈希函数、滚动哈希</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0583</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">两个字符串的删除操作</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0583.%20%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.md">Python</a></td>
<td style="text-align:left">字符串、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0072</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0072.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.md">Python</a></td>
<td style="text-align:left">字符串、动态规划</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">0044</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wildcard-matching/">通配符匹配</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0044.%20%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D.md">Python</a></td>
<td style="text-align:left">贪心、递归、字符串、动态规划</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">0010</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/regular-expression-matching/">正则表达式匹配</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0010.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.md">Python</a></td>
<td style="text-align:left">递归、字符串、动态规划</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">0097</td>
<td style="text-align:left">交错字符串</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0115</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">不同的子序列</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0115.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.md">Python</a></td>
<td style="text-align:left">字符串、动态规划</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">0087</td>
<td style="text-align:left">扰乱字符串</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<p>矩阵线性 DP 问题</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">题号</th>
<th style="text-align:left">标题</th>
<th style="text-align:left">题解</th>
<th style="text-align:left">标签</th>
<th style="text-align:left">难度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0118</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pascals-triangle/">杨辉三角</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92.md">Python</a></td>
<td style="text-align:left">数组</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0119</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pascals-triangle-ii/">杨辉三角 II</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II.md">Python</a></td>
<td style="text-align:left">数组</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0120</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/triangle/">三角形最小路径和</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0120.%20%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.md">Python</a></td>
<td style="text-align:left">数组、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0064</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0064.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.md">Python</a></td>
<td style="text-align:left">数组、动态规划、矩阵</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0174</td>
<td style="text-align:left">地下城游戏</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0221</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-square/">最大正方形</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0221.%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2.md">Python</a></td>
<td style="text-align:left">数组、动态规划、矩阵</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0931</td>
<td style="text-align:left">下降路径最小和</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0576</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/out-of-boundary-paths/">出界的路径数</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0576.%20%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0.md">Python</a></td>
<td style="text-align:left">动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0085</td>
<td style="text-align:left">最大矩形</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">0363</td>
<td style="text-align:left">矩形区域不超过 K 的最大数值和</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">面试题 17.24</td>
<td style="text-align:left">最大子矩阵</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1444</td>
<td style="text-align:left">切披萨的方案数</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<p>无串线性 DP 问题</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">题号</th>
<th style="text-align:left">标题</th>
<th style="text-align:left">题解</th>
<th style="text-align:left">标签</th>
<th style="text-align:left">难度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1137</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-th-tribonacci-number">第 N 个泰波那契数</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/1137.%20%E7%AC%AC%20N%20%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.md">Python</a></td>
<td style="text-align:left">记忆化搜索、数学、动态规划</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0650</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/2-keys-keyboard/">只有两个键的键盘</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0650.%20%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98.md">Python</a></td>
<td style="text-align:left">数学、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0264</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ugly-number-ii/">丑数 II</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0264.%20%E4%B8%91%E6%95%B0%20II.md">Python</a></td>
<td style="text-align:left">哈希表、数学、动态规划、堆（优先队列）</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0279</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.md">Python</a></td>
<td style="text-align:left">广度优先搜索、数学、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0343</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break">整数拆分</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0343.%20%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.md">Python</a></td>
<td style="text-align:left">数学、动态规划</td>
<td style="text-align:left">中等</td>
</tr>
</tbody>
</table>
</div>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhxnlp</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhxnlp.github.io/2023/04/01/数据结构与算法/LeetCode练习七：动态规划上：线性动态规划/">https://zhxnlp.github.io/2023/04/01/数据结构与算法/LeetCode练习七：动态规划上：线性动态规划/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhxnlp.github.io">zhxnlpのBlog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a><a class="post-meta__tags" href="/tags/Dynamic-Programming/">Dynamic Programming</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E4%B9%9D%EF%BC%9A%E6%A0%91%EF%BC%88%E4%B8%8A%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E9%81%8D%E5%8E%86%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"><i class="fa fa-chevron-left">  </i><span>leetcode练习九：树（上）——树的定义及遍历、二叉搜素树</span></a></div><div class="next-post pull-right"><a href="/2023/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E5%85%AB%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8B%EF%BC%9A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"><span>leetcode练习八：背包问题</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://img-blog.csdnimg.cn/ffe1f736be4548dc9101388503288e4d.png)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2023 By zhxnlp</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>