<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="leetcode练习二：排序"><meta name="keywords" content="leetcode,Sort"><meta name="author" content="zhxnlp"><meta name="copyright" content="zhxnlp"><title>leetcode练习二：排序 | zhxnlpのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"JU6VFRRZVF","apiKey":"ca17f8e20c4dc91dfe1214d03173a8be","indexName":"github-io","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="zhxnlpのBlog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">一、排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">1.1  冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.1.1 算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">1.1.2 算法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">1.1.3 代码实现：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-text">1.1.4 冒泡排序优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">1.2  选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.2.1 算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">1.2.2 算法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.2.3 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">1.3 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.3.1 算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">1.3.2 算法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.3.3 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">1.4 希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.4.1 算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">1.4.2 算法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">1.4.3 代码实现：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">1.5 归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.5.1 算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">1.5.2 算法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">1.5.3 代码实现：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">1.6 快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.6.1 算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">1.6.2 算法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">1.6.3 代码实现：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">1.7 桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-1-%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.7.1  算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">1.7.2 算法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.7.3 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">1.8 堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">1.8.1 算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-2-%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.8.2 算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-3-%E8%B0%83%E6%95%B4%E5%A0%86"><span class="toc-text">1.8.3 调整堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-4-%E5%BB%BA%E7%AB%8B%E5%88%9D%E5%A7%8B%E5%A0%86"><span class="toc-text">1.8.4 建立初始堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-5-%E5%A0%86%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E5%AE%8C%E6%95%B4%E6%BC%94%E7%A4%BA"><span class="toc-text">1.8.5 堆排序方法完整演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-6-%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">1.8.6 堆排序算法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-7-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.8.7 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">1.9 计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-1-%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.9.1 算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">1.9.2 算法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.9.3. 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">1.10 基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-1-%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.10.1 算法步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">1.10.2 算法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.10.3 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">1.11 排序算法总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-text">二、 练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%A7%BB%E5%8A%A8%E9%9B%B6%EF%BC%88%E9%A2%98283%EF%BC%89"><span class="toc-text">2.1 移动零（题283）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB%EF%BC%88%E9%A2%9875%EF%BC%89"><span class="toc-text">2.2 颜色分类（题75）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%EF%BC%88%E9%A2%98215%EF%BC%89"><span class="toc-text">2.3    数组中的第K个最大元素（题215）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">2.3.1 快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">2.3.2 堆排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-text">2.3.3 优先队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E9%A2%98912%EF%BC%89"><span class="toc-text">2.4 排序数组（题912）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%EF%BC%88%E5%89%91%E6%8C%87-Offer-51%EF%BC%89"><span class="toc-text">2.5 数组中的逆序对（剑指 Offer 51）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%88%E9%A2%98315%EF%BC%89"><span class="toc-text">2.6 计算右侧小于当前元素的个数（题315）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">2.6.1 归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-%EF%BC%88Sorted-List%EF%BC%89-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-text">2.6.2 有序数组 （Sorted List）+ 二分搜索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D-%EF%BC%88%E9%A2%98164%EF%BC%89"><span class="toc-text">2.7 最大间距  （题164）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">2.7.1 基数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">2.7.2 桶排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-3-%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E7%9C%9F%E6%98%AF%E6%97%A0%E6%95%8C%E4%BA%86"><span class="toc-text">2.7.3 你的代码真是无敌了</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E9%A1%BA%E5%BA%8F%EF%BC%88%E9%A2%981122%EF%BC%89"><span class="toc-text">2.8 数组的相对顺序（题1122）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-III%EF%BC%88%E9%A2%98220%EF%BC%89"><span class="toc-text">2.9 存在重复元素 III（题220）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-1-%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">2.9.1 桶排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%EF%BC%89"><span class="toc-text">2.9.2滑动窗口（固定长度）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%EF%BC%88%E9%A2%9856%EF%BC%89"><span class="toc-text">2.10 合并区间（题56）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-%E6%9C%80%E5%A4%A7%E6%95%B0%EF%BC%88%E9%A2%98179%EF%BC%89"><span class="toc-text">2.11 最大数（题179）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%EF%BC%88%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">2.11.1 自定义排序（内置函数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-text">2.11.2 自定义排序（快速排序）</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img-blog.csdnimg.cn/92202ef591744a55a05a1fc7e108f4d6.png"></div><div class="author-info__name text-center">zhxnlp</div><div class="author-info__description text-center">nlp</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/zhxnlp">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">58</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">50</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://relph1119.github.io/my-team-learning">relph</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://ifwind.github.io/">ifwind</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://chuxiaoyu.cn/nlp-transformer-summary/">chuxiaoyu</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://img-blog.csdnimg.cn/ffe1f736be4548dc9101388503288e4d.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">zhxnlpのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">leetcode练习二：排序</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-02-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Data-Structure-and-Algorithms/">Data Structure and Algorithms</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">20.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 77 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>@[toc]</p>
<blockquote>
<p>资源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problemset/all/">力扣题库</a>、<a target="_blank" rel="noopener" href="https://algo.itcharge.cn/00.Introduction/05.Categories-List/">LeetCode 刷题列表</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录</a></p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>参考<a target="_blank" rel="noopener" href="https://algo.itcharge.cn/01.Array/02.Array-Sort/01.Array-Bubble-Sort/">《数组排序》</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/Dby_freedom/article/details/82154869">《排序算法总结（Python版）》</a></p>
</blockquote>
<h2 id="一、排序算法"><a href="#一、排序算法" class="headerlink" title="一、排序算法"></a>一、排序算法</h2><h3 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1  冒泡排序"></a>1.1  冒泡排序</h3><h4 id="1-1-1-算法步骤"><a href="#1-1-1-算法步骤" class="headerlink" title="1.1.1 算法步骤"></a>1.1.1 算法步骤</h4><p>&#8195;&#8195;<strong>冒泡排序（<code>Bubble Sort</code>）基本思想</strong>：通过相邻元素之间的比较与交换，使值较小的元素逐步从后面移到前面，值较大的元素从前面移到后面。这个过程就像水底的气泡一样向上冒，这也是冒泡排序法名字的由来。</p>
<p><strong>动画演示：</strong><br><img src="https://img-blog.csdnimg.cn/bf8b6bcf68ef4e23ade1157ba48fabd3.gif#pic_center" alt="在这里插入图片描述"></p>
<span id="more"></span>
<h4 id="1-1-2-算法分析"><a href="#1-1-2-算法分析" class="headerlink" title="1.1.2 算法分析"></a>1.1.2 算法分析</h4><ul>
<li>时间复杂度：$O(n)$到$O(n^2)$</li>
<li>冒泡排序适用情况：冒泡排序方法在排序过程中需要移动较多次数的元素，并且排序时间效率比较低。因此，冒泡排序方法比较适合于参加排序序列的数据量较小的情况，尤其是当序列的初始状态为基本有序的情况。</li>
<li>排序稳定性：由于元素交换是在相邻元素之间进行的，不会改变值相同元素的相对位置，因此，冒泡排序法是一种 稳定排序算法。</li>
</ul>
<h4 id="1-1-3-代码实现："><a href="#1-1-3-代码实现：" class="headerlink" title="1.1.3 代码实现："></a>1.1.3 代码实现：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 第 i 趟排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 大数排后，所以每次是从序列中前 n-i+1 个元素的第1个元素开始，相邻两个元素进行比较</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - i - <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 相邻两个元素进行比较，如果前者大于后者，则交换位置</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">                    nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortnumsay</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.bubbleSort(nums)</span><br></pre></td></tr></table></figure>
<h4 id="1-1-4-冒泡排序优化"><a href="#1-1-4-冒泡排序优化" class="headerlink" title="1.1.4 冒泡排序优化"></a>1.1.4 冒泡排序优化</h4><p>&#8195;&#8195;<strong>优化1：</strong> 某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort2</span>(<span class="params">nums</span>):</span></span><br><span class="line">	n = <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">		flag = <span class="literal">True</span>    <span class="comment"># 标记</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - i):</span><br><span class="line">			<span class="keyword">if</span> nums[j] &lt; nums[j-<span class="number">1</span>]:</span><br><span class="line">				nums[j], nums[j-<span class="number">1</span>] = nums[j-<span class="number">1</span>], nums[j]</span><br><span class="line">				flag = <span class="literal">False</span></span><br><span class="line">		<span class="comment"># 某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了</span></span><br><span class="line">		<span class="keyword">if</span> flag:    </span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;<strong>优化2：</strong> 记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。            </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort3</span>(<span class="params">nums</span>):</span></span><br><span class="line">	n = <span class="built_in">len</span>(nums)</span><br><span class="line">	k = n    <span class="comment">#k为循环的范围，初始值n</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">		flag = <span class="literal">True</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k):    <span class="comment">#只遍历到最后交换的位置即可</span></span><br><span class="line">			<span class="keyword">if</span> nums[j-<span class="number">1</span>] &gt; nums[j]:</span><br><span class="line">				nums[j-<span class="number">1</span>], nums[j] = nums[j], nums[j-<span class="number">1</span>]</span><br><span class="line">				k = j     <span class="comment">#记录最后交换的位置</span></span><br><span class="line">				flag = <span class="literal">False</span></span><br><span class="line">		<span class="keyword">if</span> flag:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
<h3 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2  选择排序"></a>1.2  选择排序</h3><p>&#8195;&#8195;<strong>选择排序（<code>Selection Sort</code>）基本思想</strong>：每一趟排序中，从未排序部分中选出一个值最小的元素，与未排序部分第 1 个元素交换位置，从而将该元素划分到已排序部分。</p>
<h4 id="1-2-1-算法步骤"><a href="#1-2-1-算法步骤" class="headerlink" title="1.2.1 算法步骤"></a>1.2.1 算法步骤</h4><ol>
<li>第 <code>1</code> 趟排序：<ol>
<li>无已排序部分，把第 <code>1</code> ~ <code>n</code>个元素（总共 <code>n</code> 个元素）作为未排序部分。</li>
<li>遍历 <code>n</code> 个元素，使用变量 <code>min_i</code> 记录 <code>n</code> 个元素中值最小的元素位置。</li>
<li>将 <code>min_i</code> 与未排序部分第 <code>1</code> 个元素（也就是序列的第 <code>1</code> 个元素）交换位置。如果未排序部分第 <code>1</code> 个元素就是值最小的元素位置，则不用交换。</li>
<li>此时第 <code>1</code> 个元素为已排序部分，剩余第 <code>2</code> ~ <code>n</code> 个元素（总共 <code>n - 1</code> 个元素）为未排序部分。</li>
</ol>
</li>
<li>第 <code>2</code> 趟排序：<ol>
<li>遍历剩余 <code>n - 1</code> 个元素，使用变量 <code>min_i</code> 记录 <code>n - 1</code> 个元素中值最小的元素位置。</li>
<li>将 <code>min_i</code> 与未排序部分第 <code>1</code> 个元素（也就是序列的第 <code>2</code> 个元素）交换位置。如果未排序部分第 <code>1</code> 个元素就是值最小的元素位置，则不用交换。</li>
<li>此时第 <code>1</code> ~ <code>2</code> 个元素为已排序部分，剩余第 <code>3</code> ~ <code>n</code> 个元素（总共 <code>n - 2</code> 个元素）为未排序部分。</li>
</ol>
</li>
<li>依次类推，对剩余 <code>n - 2</code> 个元素重复上述排序过程，直到所有元素都变为已排序部分，则排序结束。</li>
</ol>
<p><strong>动画演示</strong><br><img src="https://img-blog.csdnimg.cn/d757b3aac927414fa515eb853c6f7a48.gif#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-2-2-算法分析"><a href="#1-2-2-算法分析" class="headerlink" title="1.2.2 算法分析"></a>1.2.2 算法分析</h4><ul>
<li><strong>时间复杂度</strong>：$O(n^2)$。<br>排序法所进行的元素之间的比较次数与序列的原始状态无关，时间复杂度总是 $O(n^2)$。这是因为无论序列中元素的初始排列状态如何，第 i 趟排序要找出值最小元素都需要进行 n − i 次元素之间的比较。因此，整个排序过程需要进行的元素之间的比较次数都相同，为 $\sum_{i=2}^{n}(i-1)=\frac{n(n-1)}{2}$ 次。</li>
<li><strong>适用情况</strong>：选择排序方法在排序过程中需要移动较多次数的元素，并且排序时间效率比较低。因此，选择排序方法比较适合于参加排序序列的数据量较小的情况。选择排序的主要优点是仅需要原地操作无需占用其他空间就可以完成排序，因此在空间复杂度要求较高时，可以考虑选择排序。</li>
<li><strong>排序稳定性</strong>：由于值最小元素与未排序部分第 1 个元素的交换动作是在不相邻的元素之间进行的，因此很有可能会改变值相同元素的前后位置，因此，选择排序法是一种 不稳定排序算法。</li>
<li><strong>对比冒泡排序</strong>：<ul>
<li>选择排序对冒泡排序进行了改进，保留了其基本的多趟比对思路，每趟都使当前最大项就位。</li>
<li>但选择排序对交换进行了削减，相比起冒泡排序进行多次交换，每趟仅进行1次交换，即记录最大项的所在位置，最后再跟本趟最后一项交换。</li>
<li>选择排序的时间复杂度比冒泡排序潲优。比对次数不变，还是$O(n^2)$，交换次数则减少为$O(n)$。<h4 id="1-2-3-代码实现"><a href="#1-2-3-代码实现" class="headerlink" title="1.2.3 代码实现"></a>1.2.3 代码实现</h4></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 记录未排序部分中最小值的位置</span></span><br><span class="line">            min_i = i</span><br><span class="line">            <span class="comment"># 序列分成两部分，前i个是已排序部分，i+1到le是未排序部分</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[min_i]:</span><br><span class="line">                    min_i = j</span><br><span class="line">            <span class="comment"># 如果找到最小值的位置，将 i 位置上元素与最小值位置上的元素进行交换</span></span><br><span class="line">            <span class="keyword">if</span> i != min_i:</span><br><span class="line">                nums[i], nums[min_i] = nums[min_i], nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortnumsay</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.selectionSort(nums)</span><br></pre></td></tr></table></figure>
<h3 id="1-3-插入排序"><a href="#1-3-插入排序" class="headerlink" title="1.3 插入排序"></a>1.3 插入排序</h3><p>&#8195;&#8195;<strong>插入排序（<code>Insertion Sort</code>）基本思想</strong>：将整个序列分为两部分：前面 <code>i</code> 个元素为有序序列，后面 <code>n - i</code> 个元素为无序序列。每一次排序，将无序序列的第 <code>1</code> 个元素，在有序序列中找到相应的位置并插入。</p>
<p><img src="https://img-blog.csdnimg.cn/1c5fea9a1fde4735b66e5173a9cf71c2.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-3-1-算法步骤"><a href="#1-3-1-算法步骤" class="headerlink" title="1.3.1 算法步骤"></a>1.3.1 算法步骤</h4><ol>
<li>第 <code>1</code> 趟排序：<ol>
<li>第 <code>1</code> 个元素为有序序列，后面第 <code>2</code> ~ <code>n</code>个元素（总共 <code>n - 1</code> 个元素）为无序序列。</li>
<li>从右至左遍历有序序列中的元素，如果遇到「有序序列的元素 &gt; 无序序列的第 <code>1</code> 个元素」的情况时，则将向有序序列的元素后移动一位。</li>
<li>如果遇到「有序序列的元素 &lt;= 无序序列的第 <code>1</code> 个元素」的情况或者「到达数组开始位置」时，则说明找到了插入位置。将「无序序列的第 <code>1</code> 个元素」插入该位置。</li>
</ol>
</li>
<li><p>第 <code>2</code> 趟排序：</p>
<ol>
<li>第 <code>1</code> ~ <code>2</code> 个元素为有序序列，后面第 <code>3</code> ~ <code>n</code> 个元素（总共 <code>n - 2</code> 个元素）为无序序列。</li>
<li>从右至左遍历有序序列中的元素，如果遇到「有序序列的元素 &gt; 无序序列的第 <code>1</code> 个元素」的情况时，则将向有序序列的元素后移动一位。</li>
<li>如果遇到「有序序列的元素 &lt;= 无序序列的第 <code>1</code> 个元素」的情况或者「到达数组开始位置」时，则说明找到了插入位置。将「无序序列的第 <code>1</code> 个元素」插入该位置。</li>
</ol>
</li>
<li><p>依次类推，对剩余 <code>n - 3</code> 个元素重复上述排序过程，直到所有元素都变为有序序列，则排序结束。</p>
</li>
</ol>
<p>简单来说，插入排序的算法步骤为：</p>
<ol>
<li>先将第 <code>1</code> 个元素作为一个有序序列，将第 <code>2</code> ~ <code>n</code> 个元素作为无序序列。</li>
<li>从左到右遍历一遍无序序列，对于无序序列中的每一个元素：<ol>
<li>遍历有序序列，找到适当的插入位置。</li>
<li>将有序序列中插入位置右侧的元素依次右移一位。</li>
<li>将该元素插入到适当位置</li>
</ol>
</li>
</ol>
<p><strong>动画演示：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/9f57aa9917124290b62e30bbc5c08df6.gif#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-3-2-算法分析"><a href="#1-3-2-算法分析" class="headerlink" title="1.3.2 算法分析"></a>1.3.2 算法分析</h4><p>&#8195;&#8195;插入排序比对操作主要是用来寻找新元素的待插入位置，而插入位置是靠倒序遍历前面有序数组来找到的。</p>
<ul>
<li><strong>最佳时间复杂度</strong>：$O(n)$。<br>最好的情况下，初始序列已经是升序排列，这样每个新元素只需要进行一次元素之间的比较， 总共只需要比对n − 1次，也完全并不需要移动有序数组的元素，此时时间复杂度是$O(n)$</li>
<li><strong>最差时间复杂度</strong>：$O(n^2)$。<br>最差的情况下，初始序列已经是降序排列，对应的每个 <code>i</code> 值都要进行 <code>i - 1</code> 次元素之间的比较，总的元素之间的比较次数达到最大值，为 $∑^n_{i=2}(i − 1) = \frac{n(n−1)}{2}$。</li>
<li><strong>平均时间复杂度</strong>：$O(n^2)$。如果序列的初始情况是随机的，即参加排序的序列中元素可能出现的各种排列的概率相同，则可取上述最小值和最大值的平均值作为插入排序时所进行的元素之间的比较次数，约为 $\frac{n^2}{4}$。由此得知，插入排序算法的时间复杂度 $O(n^2)$。</li>
<li><strong>排序稳定性</strong>：插入排序方法是一种 <strong>稳定排序算法</strong>。<h4 id="1-3-3-代码实现"><a href="#1-3-3-代码实现" class="headerlink" title="1.3.3 代码实现"></a>1.3.3 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 遍历无序序列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            temp = nums[i] <span class="comment"># 保存无序序列第一个元素的值，因为后面会有有序序列右移，覆盖此值</span></span><br><span class="line">            j = i <span class="comment"># 初始化插入位置</span></span><br><span class="line">            <span class="comment"># 从右至左遍历有序序列</span></span><br><span class="line">            <span class="comment"># 如果有序序列中的元素大于无序序列第一个元素，就将其右移一位</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> nums[j - <span class="number">1</span>] &gt; temp:</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 将该元素值插入到适当位置</span></span><br><span class="line">            nums[j] = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortnumsay</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.insertionSort(nums)</span><br></pre></td></tr></table></figure>
也可以都改成for语句：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 遍历无序序列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            temp = nums[i] <span class="comment"># 保存当前元素值</span></span><br><span class="line">            <span class="comment"># 从右至左遍历有序序列</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">				<span class="keyword">if</span> nums[j - <span class="number">1</span>] &gt; temp:</span><br><span class="line">                	<span class="comment"># 将有序序列中插入位置右侧的元素依次右移一位</span></span><br><span class="line">                	nums[j] = nums[j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                	<span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 将该元素插入到适当位置</span></span><br><span class="line">            nums[j] = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortnumsay</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.insertionSort(nums)</span><br></pre></td></tr></table></figure>
<h3 id="1-4-希尔排序"><a href="#1-4-希尔排序" class="headerlink" title="1.4 希尔排序"></a>1.4 希尔排序</h3>&#8195;&#8195;从上面分析可以知道，插入排序在初始序列升序排列时，时间复杂度最低。实际上，<font color='deeppink'>序列越是有序（升序），插入排序的比对次数就越少。</font></li>
</ul>
<p>&#8195;&#8195;希尔排序从此入手，对无序列表进行间隔划分，然后对每个子列表进行插入排序。随着子列表数越来越少，整个无序表也越来越有序，从而减少整体排序的比对次数。</p>
<p>&#8195;&#8195;<strong>希尔排序（<code>Shell Sort</code>）基本思想</strong>：将整个序列切按照一定的间隔值（<code>gap</code>）划分为若干个子序列，每个子序列分别排序。然后逐渐缩小<code>gap</code>值，进行下一次排序，直至<code>gap=1</code>。</p>
<h4 id="1-4-1-算法步骤"><a href="#1-4-1-算法步骤" class="headerlink" title="1.4.1 算法步骤"></a>1.4.1 算法步骤</h4><ol>
<li>确定一个元素间隔数 <code>gap</code>。</li>
<li>将参加排序的序列按此间隔数从第 <code>1</code> 个元素开始一次分成若干个子序列，即分别将所有位置相隔为 <code>gap</code> 的元素视为一个子序列。</li>
<li>在各个子序列中采用某种排序算法（例如插入排序算法）进行排序。</li>
<li>减少间隔数，并重新将整个序列按新的间隔数分成若干个子序列，再分别对各个子序列进行排序。依次类推，直到间隔数 <code>gap = 1</code>，排序结束。</li>
</ol>
<p><strong>图解演示：</strong><br><img src="https://img-blog.csdnimg.cn/3a831b253bf04786abe3879c0c473f07.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-4-2-算法分析"><a href="#1-4-2-算法分析" class="headerlink" title="1.4.2 算法分析"></a>1.4.2 算法分析</h4><ul>
<li><p><strong>时间复杂度</strong>：介于 $O(n \times \log_2 n)$ 与 $O(n^2)$ 之间。</p>
<ul>
<li>希尔排序方法的速度是一系列间隔数 $gap_i$ 的函数，而比较次数与 $gap_i$ 之间的依赖关系比较复杂，不太容易给出完整的数学分析。</li>
<li>由于采用 $gap<em>i = \lfloor gap</em>{i-1}/2 \rfloor$ 的方法缩小间隔数，对于具有 $n$ 个元素的序列，若 $gap_1 = \lfloor n/2 \rfloor$，则经过 $p = \lfloor \log_2 n \rfloor$ 趟排序后就有 $gap_p = 1$，因此，希尔排序方法的排序总躺数为 $\lfloor \log_2 n \rfloor$。</li>
<li>从算法中也可以看到，最外层的 <code>while</code> 循环为 $\log_2 n$ 数量级，中间层 <code>do-while</code> 循环为 <code>n</code> 数量级。当子序列分得越多时，子序列内的元素就越少，最内层的 <code>for</code> 循环的次数也就越少；反之，当所分的子序列个数减少时，子序列内的元素也随之增多，但整个序列也逐步接近有序，而循环次数却不会随之增加。因此，希尔排序算法的时间复杂度在 $O(n \times \log_2 n)$ 与 $O(n^2)$ 之间。</li>
</ul>
</li>
<li><p><strong>排序稳定性</strong>：希尔排序方法是一种 <strong>不稳定排序算法</strong>。</p>
</li>
</ul>
<h4 id="1-4-3-代码实现："><a href="#1-4-3-代码实现：" class="headerlink" title="1.4.3 代码实现："></a>1.4.3 代码实现：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shellSort</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        gap = size // <span class="number">2</span></span><br><span class="line">		<span class="comment"># 按照 gap 分组</span></span><br><span class="line">        <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 对每组元素进行插入排序</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, size):</span><br><span class="line">                <span class="comment"># temp 为每组中无序序列第 1 个元素</span></span><br><span class="line">                temp = nums[i]</span><br><span class="line">                j = i</span><br><span class="line">                <span class="comment"># 从右至左遍历每组中的有序序列元素</span></span><br><span class="line">                <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> nums[j - gap] &gt; temp:</span><br><span class="line">                    <span class="comment"># 将每组有序序列中插入位置右侧的元素依次在组中右移一位</span></span><br><span class="line">                    nums[j] = nums[j - gap]</span><br><span class="line">                    j -= gap</span><br><span class="line">                <span class="comment"># 将该元素插入到适当位置</span></span><br><span class="line">                nums[j] = temp</span><br><span class="line">            <span class="comment"># 缩小 gap 间隔</span></span><br><span class="line">            gap = gap // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortnumsay</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.shellSort(nums)</span><br></pre></td></tr></table></figure>
<h3 id="1-5-归并排序"><a href="#1-5-归并排序" class="headerlink" title="1.5 归并排序"></a>1.5 归并排序</h3><p>&#8195;&#8195;<strong>归并排序（<code>Merge Sort</code>）基本思想</strong>：采用经典的分治策略，先递归地将当前序列平均分成两半。然后将有序序列两两合并，最终合并成一个有序序列。</p>
<h4 id="1-5-1-算法步骤"><a href="#1-5-1-算法步骤" class="headerlink" title="1.5.1 算法步骤"></a>1.5.1 算法步骤</h4><ul>
<li>分割过程：先递归地将当前序列平均分成两半，直到子序列长度为 1。<ul>
<li>找到序列中心位置 <code>mid</code>，从中心位置将序列分成左右两个子序列 <code>left_arr</code>、<code>right_arr</code>。</li>
<li>对左右两个子序列 <code>left_arr</code>、<code>right_arr</code> 分别进行递归分割。</li>
<li>最终将数组分割为 n 个长度均为 1 的有序子序列。</li>
</ul>
</li>
<li>归并过程：从长度为 1 的有序子序列开始，依次进行两两归并，直到合并成一个长度为 n 的有序序列。<ul>
<li>使用数组变量 <code>arr</code> 存放归并后的有序数组。</li>
<li>使用两个指针 <code>left</code>、<code>right</code>分别指向两个有序子序列 left_arr、right_arr 的开始位置。</li>
<li>比较两个指针指向的元素，将两个有序子序列中较小元素依次存入到结果数组 <code>arr</code> 中，并将指针移动到下一位置。</li>
<li>重复步骤 3，直到某一指针到达子序列末尾。</li>
<li>将另一个子序列中的剩余元素存入到结果数组 <code>arr</code> 中。</li>
<li>返回归并后的有序数组 <code>arr</code>。</li>
</ul>
</li>
</ul>
<p><strong>动画演示：</strong><br><img src="https://img-blog.csdnimg.cn/188fd7e2ca0047f1900c0265434f1574.gif#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>将序列分为为 [6]，[2]，[1]，[3]，[7]，[5]，[4]，[8]。</li>
<li>第 1 趟排序：将子序列中的有序子序列两两归并，归并后的子序列为：[2, 6]，[1, 3]，[5, 7]，[4, 8]。</li>
<li>第 2 趟排序：将子序列中的有序子序列两两归并，归并后的子序列为：[1, 2, 3, 6]，[4, 5, 7, 8]。</li>
<li>第 3 趟排序：将子序列中的有序子序列两两归并，归并后的子序列为：[1, 2, 3, 4, 5, 6, 7, 8]。得到长度为 n 的有序序列，排序结束。<h4 id="1-5-2-算法分析"><a href="#1-5-2-算法分析" class="headerlink" title="1.5.2 算法分析"></a>1.5.2 算法分析</h4></li>
<li><strong>时间复杂度</strong>：$O(n \times \log_2n)$。归并排序算法的时间复杂度等于归并趟数与每一趟归并的时间复杂度乘积。子算法 <code>merge(left_arr, right_arr):</code> 的时间复杂度是 $O(n)$，因此，归并排序算法总的时间复杂度为 $O(n \times \log_2 n)$。</li>
<li><strong>空间复杂度</strong>：$O(n)$。归并排序方法需要用到与参加排序的序列同样大小的辅助空间。因此算法的空间复杂度为 $O(n)$。</li>
<li><strong>排序稳定性</strong>：归并排序算法是一种 <strong>稳定排序算法</strong>。<ul>
<li>因为在两个有序子序列的归并过程中，如果两个有序序列中出现相同元素，<code>merge(left_arr, right_arr):</code> 算法能够使前一个序列中那个相同元素先被复制，从而确保这两个元素的相对次序不发生改变。<h4 id="1-5-3-代码实现："><a href="#1-5-3-代码实现：" class="headerlink" title="1.5.3 代码实现："></a>1.5.3 代码实现：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.merge(nums)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,arr</span>):</span>						<span class="comment"># 分割过程</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(arr)&lt;=<span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> arr    						<span class="comment"># 数组元素个数小于等于 1 时，直接返回原数组</span></span><br><span class="line">        mid=<span class="built_in">len</span>(arr)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># 注意，这里是递归的写法</span></span><br><span class="line">        left_arr=self.merge(arr[:mid])</span><br><span class="line">        right_arr=self.merge(arr[mid:])</span><br><span class="line">        <span class="keyword">return</span> self.mergesort(left_arr,right_arr) </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergesort</span>(<span class="params">self,left_arr,right_arr</span>):</span> 	<span class="comment"># 归并过程</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        arr=[]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将两个有序子序列中较小元素依次插入到结果数组中</span></span><br><span class="line">        <span class="comment"># 注意，这里都是&lt;，不能取=,因为left_arr[len(left_arr)]是超出索引的        </span></span><br><span class="line">        <span class="keyword">while</span> left&lt;<span class="built_in">len</span>(left_arr) <span class="keyword">and</span> right&lt;<span class="built_in">len</span>(right_arr):</span><br><span class="line">            <span class="keyword">if</span> left_arr[left]&lt;right_arr[right]:</span><br><span class="line">                arr.append(left_arr[left])</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr.append(right_arr[right])</span><br><span class="line">                right+=<span class="number">1</span>  </span><br><span class="line">                </span><br><span class="line">		<span class="comment"># 如果子序列有剩余元素，则将其插入到结果数组中</span></span><br><span class="line">        arr=arr+left_arr[left:]+right_arr[right:]             </span><br><span class="line">               </span><br><span class="line">        <span class="keyword">return</span> arr                            </span><br></pre></td></tr></table></figure>
<h3 id="1-6-快速排序"><a href="#1-6-快速排序" class="headerlink" title="1.6 快速排序"></a>1.6 快速排序</h3>&#8195;&#8195;<strong>快速排序（Quick Sort）基本思想：</strong> 根据序列的中值将序列分为两半，前一半都小于中值，后一半都大于中值，然后每部分再进行递归的快速排序。<h4 id="1-6-1-算法步骤"><a href="#1-6-1-算法步骤" class="headerlink" title="1.6.1 算法步骤"></a>1.6.1 算法步骤</h4>&#8195;&#8195;<strong>递归结束条件</strong>：序列只有一个元素，不需要再排序<br>&#8195;&#8195;<strong>中值选取</strong>：每次根据中值将序列分为规模相等的两半是最好的情况，此时中值就是序列的中位数，但是寻找中位数也需要开销，所以可以所以找一个数作为中值，比如序列的第一个数。</li>
</ul>
</li>
</ul>
<p><strong>分裂过程：</strong> 目标是找到“中值”的位置。</p>
<ul>
<li>设置左右标(left/right)</li>
<li>左标向右移动，右标向左移动</li>
<li>左标一直向右移动，碰到比中值大的就停止；右标一直向左移动，碰到比中值小的就停止。然后把左右标所指的数据项交换，</li>
<li>继续移动，直到左标移到右标的右侧，停止移动。这时右标所指位置就是“中值”应处的位置，将中值和这个位置交换，并记录此时中值的位置。这样就分裂完成，左半部分比中值小，右半部分比中值大。</li>
<li><strong>图解演示：</strong><br><img src="https://img-blog.csdnimg.cn/0e5c48609cdf4b7e8388170ad95df062.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e809a598098147e4ad76c11a68ea21c2.png" alt="在这里插入图片描述"><br>动画演示：<br><img src="https://img-blog.csdnimg.cn/d1b11ad705a04991809615b1f70e6b09.gif#pic_center" alt="在这里插入图片描述"><h4 id="1-6-2-算法分析"><a href="#1-6-2-算法分析" class="headerlink" title="1.6.2 算法分析"></a>1.6.2 算法分析</h4>&#8195;&#8195;快速排序算法的时间复杂度主要跟基准数的选择有关。本文中是将当前序列中第 <code>1</code> 个元素作为基准值。在这种选择下，如果参加排序的元素初始时已经有序的情况下，快速排序方法花费的时间最长。也就是会得到最坏时间复杂度。</li>
</ul>
<p>&#8195;&#8195;在这种情况下，第 <code>1</code> 趟排序经过 <code>n - 1</code> 次比较以后，将第 <code>1</code> 个元素仍然确定在原来的位置上，并得到 <code>1</code> 个长度为 <code>n - 1</code> 的子序列。第 <code>2</code> 趟排序进过 <code>n - 2</code> 次比较以后，将第 <code>2</code> 个元素确定在它原来的位置上，又得到 <code>1</code> 个长度为 <code>n - 2</code> 的子序列。</p>
<p>&#8195;&#8195;最终总的比较次数为 $(n − 1) + (n − 2) + … + 1 = \frac{n(n − 1)}{2}$。因此这种情况下的时间复杂度为 $O(n^2)$，也是最坏时间复杂度，这种情况一般不会发生。</p>
<p>&#8195;&#8195;而在平均情况下，我们可以从当前序列中随机选择一个元素作为基准数。这样，每一次选择的基准数可以看做是等概率随机的。其期望时间复杂度为 $O(n \times \log_2n)$，也就是平均时间复杂度。</p>
<p>下面来总结一下：</p>
<ul>
<li><strong>最佳时间复杂度</strong>：$O(n \times \log_2n)$。每一次选择的基准数都是当前序列的中位数，此时算法时间复杂度满足的递推式为 $T(n) = 2 \times T(\frac{n}{2}) + \Theta(n)$，由主定理可得 $T(n) = O(n \times \log_2n)$。</li>
<li><strong>最坏时间复杂度</strong>：$O(n^2)$。每一次选择的基准数都是序列的最终位置上的值，此时算法时间复杂度满足的递推式为 $T(n) = T(n - 1) + \Theta(n)$，累加可得 $T(n) = O(n^2)$。</li>
<li><strong>平均时间复杂度</strong>：$O(n \times \log_2n)$。在平均情况下，每一次选择的基准数可以看做是等概率随机的。其期望时间复杂度为 $O(n \times \log_2n)$。</li>
<li><strong>空间复杂度</strong>：$O(n)$。无论快速排序算法递归与否，排序过程中都需要用到堆栈或其他结构的辅助空间来存放当前待排序序列的首、尾位置。最坏的情况下，空间复杂度为 $O(n)$。如果对算法进行一些改写，在一趟排序之后比较被划分所得到的两个子序列的长度，并且首先对长度较短的子序列进行快速排序，这时候需要的空间复杂度可以达到 $O(log_2 n)$。</li>
<li><strong>排序稳定性</strong>：快速排序是一种 <strong>不稳定排序算法</strong>。<h4 id="1-6-3-代码实现："><a href="#1-6-3-代码实现：" class="headerlink" title="1.6.3 代码实现："></a>1.6.3 代码实现：</h4>&#8195;&#8195;从待排序列中找到一个基准数 <code>pivot</code>（这里取序列第一个元素），将比 <code>pivot</code>小的元素都移到序列左侧，比 <code>pivot</code>大的都移到序列右侧。这样就将待排序列分成了<code>[start,pivot-1]</code>、<code>pivot</code>和<code>[pivot+1,end]</code>三部分。再分别对前后两部分递归调用快速排序。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">nums</span>):</span>           </span><br><span class="line">    <span class="keyword">return</span> qSort(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qSort</span>(<span class="params">nums,start,end</span>):</span></span><br><span class="line">    <span class="keyword">if</span> start&lt;end:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        当分裂后的子序列有两个以上元素时，就进行排序。</span></span><br><span class="line"><span class="string">        使用左右指针分别指向子序列的开头和结尾</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pivot=nums[start]</span><br><span class="line">        left,right=start+<span class="number">1</span>,end</span><br><span class="line">        done=<span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        左指针一直右移，直到指向的元素大于中值；右指针一直左移，直到指向的元素小于中值。交换左右指针的元素值</span></span><br><span class="line"><span class="string">        继续下一次移动交换，直到左指针越过右指针。此时右指针位置就是中值应该在的位置，进行交换，排序完毕。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">		<span class="keyword">while</span> done:</span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[left]&lt;=pivot:</span><br><span class="line">                left=left+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[right]&gt;=pivot:</span><br><span class="line">                right=right-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                done=<span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[left],nums[right] = nums[right],nums[left]</span><br><span class="line"></span><br><span class="line">        nums[start],nums[right]=nums[right],nums[start]</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        排完序后，中值前的部分[start,pivot-1]都是小于中值，中值后的部分[pivot+1,end]都是大于中值</span></span><br><span class="line"><span class="string">        对这两部分再次进行递归的快速排序</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        qSort(nums,start,right-<span class="number">1</span>)</span><br><span class="line">        qSort(nums,right+<span class="number">1</span>,end)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
也可以写成另一种方式：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>    </span><br><span class="line">        <span class="keyword">return</span> self.qsort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qsort</span>(<span class="params">self,ary, start, end</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start &lt; end:</span><br><span class="line">            left = start</span><br><span class="line">            right = end</span><br><span class="line">            pivot = ary[start]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ary</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> ary[right] &gt;= pivot:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:  <span class="comment"># 说明打破while循环的原因是ary[right] &lt;= key</span></span><br><span class="line">                ary[left] = ary[right]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> ary[left] &lt; pivot:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:  <span class="comment"># 说明打破while循环的原因是ary[left] &gt;= key</span></span><br><span class="line">                ary[right] = ary[left]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        ary[left] = pivot  <span class="comment"># 此时，left=right，用key来填坑</span></span><br><span class="line"></span><br><span class="line">        self.qsort(ary, start, left - <span class="number">1</span>)</span><br><span class="line">        self.qsort(ary, left + <span class="number">1</span>, end)</span><br><span class="line">        <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure>
<h3 id="1-7-桶排序"><a href="#1-7-桶排序" class="headerlink" title="1.7 桶排序"></a>1.7 桶排序</h3><p><strong>桶排序（Bucket Sort）基本思想</strong>：将未排序数组分到若干个「桶」中，每个桶的元素再进行单独排序。</p>
<h4 id="1-7-1-算法步骤"><a href="#1-7-1-算法步骤" class="headerlink" title="1.7.1  算法步骤"></a>1.7.1  算法步骤</h4><ol>
<li>根据原始数组的值域范围，将数组划分为 <code>k</code> 个相同大小的子区间，每个区间称为一个桶。</li>
<li>遍历原始数组元素，将每个元素装入对应区间的桶中。</li>
<li>对每个桶内的元素单独排序（使用插入排序、归并排序、快排排序等算法）。</li>
<li>最后按照区间顺序将桶内的元素合并起来，完成排序。</li>
</ol>
<p><strong>图解演示</strong></p>
<ol>
<li>划分子区间</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/268ad231558d117ac1915e2cdbe194c4.png" alt=""></p>
<ol>
<li>将数组元素装入桶中，并对桶内元素单独排序</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0c05f4ed5dd7cdf918a784a27f8556a9.png" alt=""></p>
<ol>
<li>将桶内元素合并起来，完成排序</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/da068073da16aaf09ce1c8d63867a78a.png" alt=""></p>
<h4 id="1-7-2-算法分析"><a href="#1-7-2-算法分析" class="headerlink" title="1.7.2 算法分析"></a>1.7.2 算法分析</h4><ul>
<li><strong>时间复杂度</strong>：$O(n)$。当输入元素个数为 $n$，桶的个数是 $m$ 时，每个桶里的数据就是 $k = n / m$ 个。每个桶内排序的时间复杂度为 $O(k \times \log_2 k)$。$m$ 个桶就是 $m <em> O(k </em> log_2k) = m \times O((n / m) \times \log_2(n/m)) = O(n*log_2(n/m))$。当桶的个数 $m$ 接近于数据个数 $n$ 时，$log_2(n/m)$ 就是一个较小的常数，所以排序桶排序时间复杂度接近于 $O(n)$。</li>
<li><strong>空间复杂度</strong>：$O(n + m)$。由于桶排序使用了辅助空间，所以桶排序的空间复杂度是 $O(n + m)$。</li>
<li><strong>排序稳定性</strong>：如果桶内使用插入排序算法等稳定排序算法，则桶排序也是一种 <strong>稳定排序算法</strong>。</li>
</ul>
<h4 id="1-7-3-代码实现"><a href="#1-7-3-代码实现" class="headerlink" title="1.7.3 代码实现"></a>1.7.3 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">self, arr</span>):</span></span><br><span class="line">        <span class="comment"># 遍历无序序列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">            temp = arr[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 从右至左遍历有序序列</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> arr[j - <span class="number">1</span>] &gt; temp:</span><br><span class="line">                <span class="comment"># 将有序序列中插入位置右侧的元素依次右移一位</span></span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 将该元素插入到适当位置</span></span><br><span class="line">            arr[j] = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bucketSort</span>(<span class="params">self, arr, bucket_size=<span class="number">5</span></span>):</span></span><br><span class="line">        <span class="comment"># 计算待排序序列中最大值元素 arr_max 和最小值元素 arr_min</span></span><br><span class="line">        arr_min, arr_max = <span class="built_in">min</span>(arr), <span class="built_in">max</span>(arr)</span><br><span class="line">        <span class="comment"># 定义桶的个数为 (最大值元素 - 最小值元素) // 每个桶的大小 + 1</span></span><br><span class="line">        bucket_count = (arr_max - arr_min) // bucket_size + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 定义桶数组 buckets</span></span><br><span class="line">        buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(bucket_count)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历原始数组元素，将每个元素装入对应区间的桶中</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            buckets[(num - arr_min) // bucket_size].append(num)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对每个桶内的元素单独排序，并合并到 res 数组中</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">            self.insertionSort(bucket)</span><br><span class="line">            res.extend(bucket)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.bucketSort(nums)</span><br></pre></td></tr></table></figure>
<h3 id="1-8-堆排序"><a href="#1-8-堆排序" class="headerlink" title="1.8 堆排序"></a>1.8 堆排序</h3><h4 id="1-8-1-算法思想"><a href="#1-8-1-算法思想" class="headerlink" title="1.8.1 算法思想"></a>1.8.1 算法思想</h4><blockquote>
<p><strong>堆排序（Heap sort）基本思想</strong>：</p>
<p>借用「堆结构」所设计的排序算法。将数组转化为大顶堆，重复从大顶堆中取出数值最大的节点，并让剩余的堆结构继续维持大顶堆性质。</p>
</blockquote>
<p><strong>堆（Heap）</strong>：符合以下两个条件之一的完全二叉树：</p>
<ul>
<li><strong>大顶堆</strong>：根节点值 ≥ 子节点值。</li>
<li><strong>小顶堆</strong>：根节点值 ≤ 子节点值。</li>
</ul>
<h4 id="1-8-2-算法步骤"><a href="#1-8-2-算法步骤" class="headerlink" title="1.8.2 算法步骤"></a>1.8.2 算法步骤</h4><ol>
<li><strong>建立初始堆</strong>：将无序序列构造成第 <code>1</code> 个大顶堆（初始堆），使得 <code>n</code> 个元素的最大值处于序列的第 <code>1</code> 个位置。</li>
<li><strong>调整堆</strong>：交换序列的第 <code>1</code> 个元素（最大值元素）与第 <code>n</code> 个元素的位置。将序列前 <code>n - 1</code> 个元素组成的子序列调整成一个新的大顶堆，使得 <code>n - 1</code> 个元素的最大值处于序列第 <code>1</code> 个位置，从而得到第 <code>2</code> 个最大值元素。</li>
<li><strong>调整堆</strong>：交换子序列的第 <code>1</code> 个元素（最大值元素）与第 <code>n - 1</code> 个元素的位置。将序列前 <code>n - 2</code> 个元素组成的子序列调整成一个新的大顶堆，使得 <code>n - 2</code> 个元素的最大值处于序列第 <code>1</code> 个位置，从而得到第 <code>3</code> 个最大值元素。</li>
<li>依次类推，不断交换子序列的第 <code>1</code> 个元素（最大值元素）与当前子序列最后一个元素位置，并将其调整成新的大顶堆。直到子序列剩下一个元素时，排序结束。此时整个序列就变成了一个有序序列。</li>
</ol>
<p>从堆排序算法步骤中可以看出：堆排序算法主要涉及「调整堆」和「建立初始堆」两个步骤。</p>
<h4 id="1-8-3-调整堆"><a href="#1-8-3-调整堆" class="headerlink" title="1.8.3 调整堆"></a>1.8.3 调整堆</h4><p><strong>调整堆方法</strong>：把移走了最大值元素以后的剩余元素组成的序列再构造为一个新的堆积。具体步骤如下：</p>
<ol>
<li>从根节点开始，自上而下地调整节点的位置，使其成为堆积。<ol>
<li>判断序号为 <code>i</code> 的节点与其左子树节点（序号为 <code>2 * i</code>）、右子树节点（序号为 <code>2 * i + 1</code>）中值关系。</li>
<li>如果序号为 <code>i</code> 节点大于等于左右子节点值，则排序结束。</li>
<li>如果序号为 <code>i</code> 节点小于左右子节点值，则将序号为 <code>i</code> 节点与左右子节点中值最大的节点交换位置。</li>
</ol>
</li>
<li>因为交换了位置，使得当前节点的左右子树原有的堆积特性被破坏。于是，从当前节点的左右子树节点开始，自上而下继续进行类似的调整。</li>
<li>依次类推，直到整棵完全二叉树成为一个大顶堆。</li>
</ol>
<p><strong>调整堆方法演示</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1289a25a64578c2780ec5cf6548e8bbb.gif" alt=""></p>
<ol>
<li>交换序列的第 <code>1</code> 个元素 <code>90</code> 与最后 <code>1</code> 个元素 <code>19</code> 的位置，此时当前节点为根节点 <code>19</code>。</li>
<li>判断根节点 <code>19</code>与其左右子节点值，因为 <code>17 &lt; 19 &lt; 36</code>，所以将根节点 <code>19</code> 与左子节点 <code>36</code> 互换位置，此时当前节点为根节点 <code>19</code>。</li>
<li>判断当前节点 <code>36</code> 与其左右子节点值，因为 <code>19 &lt; 25 &lt; 26</code>，所以将当前节点 <code>19</code> 与右节点 <code>26</code> 互换位置。调整堆结束。</li>
</ol>
<h4 id="1-8-4-建立初始堆"><a href="#1-8-4-建立初始堆" class="headerlink" title="1.8.4 建立初始堆"></a>1.8.4 建立初始堆</h4><ol>
<li>如果原始序列对应的完全二叉树（不一定是堆）的深度为 <code>d</code>，则从 <code>d - 1</code> 层最右侧分支节点（序号为 $\lfloor \frac{n}{2} \rfloor$）开始，初始时令 $i = \lfloor \frac{n}{2} \rfloor$，调用调整堆算法。</li>
<li>每调用一次调整堆算法，执行一次 <code>i = i - 1</code>，直到 <code>i == 1</code> 时，再调用一次，就把原始序列调整为了一个初始堆。</li>
</ol>
<p><strong>方法演示</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/143f7e1be004a10794cb28e08e1643e1.gif" alt=""></p>
<ol>
<li>原始序列为 <code>[2, 7, 26, 25, 19, 17, 1, 90, 3, 36]</code>，对应完全二叉树的深度为 <code>3</code>。</li>
<li>从第 <code>2</code> 层最右侧的分支节点，也就序号为 <code>5</code> 的节点开始，调用堆调整算法，使其与子树形成大顶堆。</li>
<li>节点序号减 <code>1</code>，对序号为 <code>4</code> 的节点，调用堆调整算法，使其与子树形成大顶堆。</li>
<li>节点序号减 <code>1</code>，对序号为 <code>3</code> 的节点，调用堆调整算法，使其与子树形成大顶堆。</li>
<li>节点序号减 <code>1</code>，对序号为 <code>2</code> 的节点，调用堆调整算法，使其与子树形成大顶堆。</li>
<li>节点序号减 <code>1</code>，对序号为 <code>1</code> 的节点，调用堆调整算法，使其与子树形成大顶堆。</li>
<li>此时整个原始序列对应的完全二叉树就成了一个大顶堆，建立初始堆完毕。</li>
</ol>
<h4 id="1-8-5-堆排序方法完整演示"><a href="#1-8-5-堆排序方法完整演示" class="headerlink" title="1.8.5 堆排序方法完整演示"></a>1.8.5 堆排序方法完整演示</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/4c9941c0790d2f6339bd9f97e5d97d46.gif" alt=""></p>
<ol>
<li>原始序列为 <code>[2, 7, 26, 25, 19, 17, 1, 90, 3, 36]</code>，先根据原始序列建立一个初始堆。</li>
<li>交换序列中第 <code>1</code> 个元素（<code>90</code>）与第 <code>10</code> 个元素（<code>2</code>）的位置。将序列前 <code>9</code> 个元素组成的子序列调整成一个大顶堆，此时堆顶变为 <code>36</code>。</li>
<li>交换序列中第 <code>1</code> 个元素（<code>36</code>）与第 <code>9</code> 个元素（<code>3</code>）的位置。将序列前 <code>8</code> 个元素组成的子序列调整成一个大顶堆，此时堆顶变为 <code>26</code>。</li>
<li>交换序列中第 <code>1</code> 个元素（<code>26</code>）与第 <code>8</code> 个元素（<code>2</code>）的位置。将序列前 <code>7</code> 个元素组成的子序列调整成一个大顶堆，此时堆顶变为 <code>25</code>。</li>
<li>以此类推，不断交换子序列的第 <code>1</code> 个元素（最大值元素）与当前子序列最后一个元素位置，并将其调整成新的大顶堆。直到子序列只剩下最后一个元素 <code>1</code> 时，排序结束。此时整个序列变成了一个有序序列，即 <code>[1, 2, 3, 7, 17, 19, 25, 26, 36, 90]</code>。</li>
</ol>
<h4 id="1-8-6-堆排序算法分析"><a href="#1-8-6-堆排序算法分析" class="headerlink" title="1.8.6 堆排序算法分析"></a>1.8.6 堆排序算法分析</h4><ul>
<li><strong>时间复杂度</strong>：$O(n \times \log_2 n)$。<ul>
<li>堆积排序的时间主要花费在两个方面：「建立初始堆」和「调整堆」。</li>
<li>设原始序列所对应的完全二叉树深度为 $d$，算法由两个独立的循环组成：<ol>
<li>在第 $1$ 个循环构造初始堆积时，从 $i = d - 1$ 层开始，到 $i = 1$ 层为止，对每个分支节点都要调用一次调整堆算法，而一次调整堆算法，对于第 $i$ 层一个节点到第 $d$ 层上建立的子堆积，所有节点可能移动的最大距离为该子堆积根节点移动到最后一层（第 $d$ 层） 的距离，即 $d - i$。而第 $i$ 层上节点最多有 $2^{i-1}$ 个，所以每一次调用调整堆算法的最大移动距离为 $2^{i-1} * (d-i)$。因此，堆积排序算法的第 $1$ 个循环所需时间应该是各层上的节点数与该层上节点可移动的最大距离之积的总和，即：$\sum<em>{i = d - 1}^1 2^{i-1} (d-i) = \sum</em>{j = 1}^{d-1} 2^{d-j-1} \times j = \sum<em>{j = 1}^{d-1} 2^{d-1} \times {j \over 2^j} \le n \sum</em>{j = 1}^{d-1} {j \over 2^j} &lt; 2n$。这一部分的时间花费为 $O(n)$。                                                                                                                                                                                                                                                                 </li>
<li>在第 $2$ 个循环中，每次调用调整堆算法一次，节点移动的最大距离为这棵完全二叉树的深度 $d = \lfloor \log_2(n) \rfloor + 1$，一共调用了 $n - 1$ 次调整堆算法，所以，第 $2$ 个循环的时间花费为 $(n-1)(\lfloor \log_2 (n)\rfloor + 1) = O(n \times \log_2 n)$。</li>
</ol>
</li>
<li>因此，堆积排序的时间复杂度为 $O(n \times \log_2 n)$。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：$O(1)$。由于在堆积排序中只需要一个记录大小的辅助空间，因此，堆积排序的空间复杂度为：$O(1)$。</li>
<li><strong>排序稳定性</strong>：堆排序是一种 <strong>不稳定排序算法</strong>。</li>
</ul>
<h4 id="1-8-7-代码实现"><a href="#1-8-7-代码实现" class="headerlink" title="1.8.7 代码实现"></a>1.8.7 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 调整为大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">self, arr: [<span class="built_in">int</span>], index: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="comment"># 根节点为 index，左节点为 2 * index + 1， 右节点为 2 * index + 2</span></span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        right = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= end:</span><br><span class="line">            <span class="comment"># 当前节点为非叶子结点</span></span><br><span class="line">            max_index = index</span><br><span class="line">            <span class="keyword">if</span> arr[left] &gt; arr[max_index]:</span><br><span class="line">                max_index = left</span><br><span class="line">            <span class="keyword">if</span> right &lt;= end <span class="keyword">and</span> arr[right] &gt; arr[max_index]:</span><br><span class="line">                max_index = right</span><br><span class="line">            <span class="keyword">if</span> index == max_index:</span><br><span class="line">                <span class="comment"># 如果不用交换，则说明已经交换结束</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            arr[index], arr[max_index] = arr[max_index], arr[index]</span><br><span class="line">            <span class="comment"># 继续调整子树</span></span><br><span class="line">            index = max_index</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            right = left + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildMaxHeap</span>(<span class="params">self, arr: [<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="comment"># (size - 2) // 2 是最后一个非叶节点，叶节点不用调整</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((size - <span class="number">2</span>) // <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            self.heapify(arr, i, size - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 升序堆排序，思路如下：</span></span><br><span class="line">    <span class="comment"># 1. 先建立大顶堆</span></span><br><span class="line">    <span class="comment"># 2. 让堆顶最大元素与最后一个交换，然后调整第一个元素到倒数第二个元素，这一步获取最大值</span></span><br><span class="line">    <span class="comment"># 3. 再交换堆顶元素与倒数第二个元素，然后调整第一个元素到倒数第三个元素，这一步获取第二大值</span></span><br><span class="line">    <span class="comment"># 4. 以此类推，直到最后一个元素交换之后完毕。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxHeapSort</span>(<span class="params">self, arr: [<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.buildMaxHeap(arr)</span><br><span class="line">        size = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            arr[<span class="number">0</span>], arr[size - i - <span class="number">1</span>] = arr[size - i - <span class="number">1</span>], arr[<span class="number">0</span>]</span><br><span class="line">            self.heapify(arr, <span class="number">0</span>, size - i - <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.maxHeapSort(nums)</span><br></pre></td></tr></table></figure>
<h3 id="1-9-计数排序"><a href="#1-9-计数排序" class="headerlink" title="1.9 计数排序"></a>1.9 计数排序</h3><p>&#8195;&#8195; <strong>计数排序（Counting Sort）基本思想</strong>：使用一个额外的数组 <code>counts</code>，其中 <code>counts[i]</code> 表示原数组 <code>arr</code> 中值等于 <code>i</code> 的元素个数。然后根据数组 <code>counts</code> 来将 <code>arr</code> 中的元素排到正确的位置。</p>
<h4 id="1-9-1-算法步骤"><a href="#1-9-1-算法步骤" class="headerlink" title="1.9.1 算法步骤"></a>1.9.1 算法步骤</h4><ol>
<li>找出待排序序列中最大值元素 <code>arr_max</code> 和最小值元素 <code>arr_min</code>。</li>
<li>定义大小为 <code>arr_max - arr_min + 1</code> 的数组 <code>counts</code>，初始时，<code>counts</code> 中元素值全为 <code>0</code>。</li>
<li>遍历数组 <code>arr</code>，统计值为 <code>num</code> 的元素出现的次数。将其次数存入 <code>counts</code> 数组的第 <code>num - arr_min</code> 项（<code>counts[num - arr_min]</code> 表示元素值 <code>num</code> 出现的次数）。</li>
<li>对所有的计数累加，从 <code>counts</code> 中的第一个元素开始，每一项和前一项相加。此时 <code>counts[i]</code> 表示值为 <code>i</code> 的元素排名。</li>
<li>反向填充目标数组：<ol>
<li>逆序遍历数组 <code>arr</code>。对于每个元素值 <code>arr[i]</code>，其对应排名为 <code>counts[arr[i] - arr_min]</code>。</li>
<li>根据排名，将 <code>arr[i]</code> 放在数组对应位置（因为数组下标是从 <code>0</code> 开始的，所以对应位置为排名减 <code>1</code>）。即 <code>res[counts[arr[i] - arr_min] - 1] = arr[i]</code>。</li>
<li>放入之后， 将 <code>arr[i]</code> 的对应排名减 <code>1</code>，即 <code>counts[arr[i] - arr_min] -= 1</code>。</li>
</ol>
</li>
</ol>
<p><strong>动画演示</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/eb1bcdad169668a0a80eaa7ff39df0ff.gif" alt="计数排序"></p>
<h4 id="1-9-2-算法分析"><a href="#1-9-2-算法分析" class="headerlink" title="1.9.2 算法分析"></a>1.9.2 算法分析</h4><ul>
<li><strong>时间复杂度</strong>：$O(n + k)$。其中 $k$ 代表待排序序列的值域。</li>
<li><strong>空间复杂度</strong>：$O(k)$。其中 $k$ 代表待排序序列的值域。由于用于计数的数组 <code>counts</code> 的长度取决于待排序数组中数据的范围（大小等于待排序数组最大值减去最小值再加 <code>1</code>）。所以计数排序算法对于数据范围很大的数组，需要大量的内存。</li>
<li><strong>计数排序适用情况</strong>：计数排序一般用于整数排序，不适用于按字母顺序、人名顺序排序。</li>
<li><strong>排序稳定性</strong>：计数排序是一种 <strong>稳定排序算法</strong>。</li>
</ul>
<h4 id="1-9-3-代码实现"><a href="#1-9-3-代码实现" class="headerlink" title="1.9.3. 代码实现"></a>1.9.3. 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countingSort</span>(<span class="params">self, arr</span>):</span></span><br><span class="line">        <span class="comment"># 计算待排序序列中最大值元素 arr_max 和最小值元素 arr_min</span></span><br><span class="line">        arr_min, arr_max = <span class="built_in">min</span>(arr), <span class="built_in">max</span>(arr)</span><br><span class="line">        <span class="comment"># 定义计数数组 counts，大小为 最大值元素 - 最小值元素 + 1</span></span><br><span class="line">        size = arr_max - arr_min + <span class="number">1</span></span><br><span class="line">        counts = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 统计值为 num 的元素出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            counts[num - arr_min] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算元素排名</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            counts[j] += counts[j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反向填充目标数组</span></span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 根据排名，将 arr[i] 放在数组对应位置</span></span><br><span class="line">            res[counts[arr[i] - arr_min] - <span class="number">1</span>] = arr[i]</span><br><span class="line">            <span class="comment"># 将 arr[i] 的对应排名减 1</span></span><br><span class="line">            counts[arr[i] - arr_min] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.countingSort(nums)</span><br></pre></td></tr></table></figure>
<h3 id="1-10-基数排序"><a href="#1-10-基数排序" class="headerlink" title="1.10 基数排序"></a>1.10 基数排序</h3><p>&#8195;&#8195;假设要对 10 万个手机号码进行排序，显然桶排序和计数排序都不太适合，那怎样才能做到时间复杂度为 O(n) 呢?  此时可以考虑基数排序。<br>&#8195;&#8195;手机号码有这样的规律，<font color='deeppink'>假设要比较两个手机号码 a, b 的大小，如果在前面几位中，a 手机号码已经比 b大了，那后面几位就不用看了</font>。所以借助 稳定排序算法，我们可以这么实现：从手机号码的最后一位开始，分别按照每一位的数字对手机号码进行排序，依次往前进行，经过 11 次排序之后，手机号码就都有序了。</p>
<p>&#8195;&#8195; <strong>基数排序（Radix Sort）基本思想</strong>：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后后，从最低位开始，依次进行排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p>
<h4 id="1-10-1-算法步骤"><a href="#1-10-1-算法步骤" class="headerlink" title="1.10.1 算法步骤"></a>1.10.1 算法步骤</h4><p>&#8195;&#8195;基数排序算法可以采用「最低位优先法（Least Significant Digit First）」或者「最高位优先法（Most Significant Digit first）」。最常用的是「最低位优先法」。</p>
<p>下面我们以最低位优先法为例，讲解一下算法步骤。</p>
<ol>
<li>遍历数组元素，获取数组最大值元素，并取得位数。</li>
<li>定义一个长度为 <code>10</code> 的桶 <code>buckets</code>，分别代表 <code>0 ~ 9</code> 这 <code>10</code> 位数字。</li>
<li>以个位元素为索引，根据数组元素个位上的值，将数组元素存入对应数字的桶中。</li>
<li>清空原始数组，并从桶中依次取出对应元素，重新加入到原始数组中。</li>
<li>之后分别以十位，百位，…，最大值元素的最高位为索引，根据元素对应位上的数字，存入对应数字的桶中。并合并数组，完成排序。</li>
</ol>
<p><strong>动画演示</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4a37ada8ea48d1f9c9a023bc8c8d6f6d.gif" alt=""></p>
<ol>
<li>初始序列为 <code>[32, 1, 10, 96, 57, 7, 62, 47, 82, 25, 79, 5]</code>，序列所有元素的最大位数为 <code>2</code>。</li>
<li>以个位为索引，根据元素个位上的数字，将其分别存入到 <code>0</code> ~ <code>9</code> 这 <code>10</code> 个桶中。</li>
<li>清空原始数组，并从桶中依次取出对应元素，重新加入到原始数组中。此时序列变为 <code>[10, 1, 32, 62, 82, 25, 5, 96, 57, 7, 47, 79]</code>。</li>
<li>以十位为索引，根据元素十位上的数字，将其分别存入到 <code>0</code> ~ <code>9</code> 这 <code>10</code> 个桶中。</li>
<li>清空原始数组，并从桶中依次取出对应元素，重新加入到原始数组中。此时序列变为 <code>[1, 5, 7, 10, 25, 32, 47, 57, 62, 79, 82, 96]</code>，完成排序。</li>
</ol>
<h4 id="1-10-2-算法分析"><a href="#1-10-2-算法分析" class="headerlink" title="1.10.2 算法分析"></a>1.10.2 算法分析</h4><p>&#8195;&#8195;基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<ul>
<li><strong>时间复杂度</strong>：$O(n \times k)$。<ul>
<li>根据每一位的排序，可以用桶排序或者计数排序来实现，它们的时间复杂度可以做到 O(n)。如果排序的数据有 K位，则总的时间复杂度为 O(K * n)，当 K 不大时，基数排序的时间复杂度就近似为 O(n)</li>
<li>$k$ 的大小取决于数字位的选择（十进制位、二进制位）和待排序元素所属数据类型全集的大小。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：$O(n + k)$。</li>
<li><strong>排序稳定性</strong>：基数排序是一种 <strong>稳定排序算法</strong>。</li>
<li>有时候，要排序的数据并不都是等长的，比如我们要对英文单词进行排序。这时候，我们可以把所有单词都补足到相同长度，位数不够的在后面补 ’0‘，所有字母的 ASCII 码都大于 ‘0’，因此不会影响原有的大小顺序。</li>
</ul>
<h4 id="1-10-3-代码实现"><a href="#1-10-3-代码实现" class="headerlink" title="1.10.3 代码实现"></a>1.10.3 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">radixSort</span>(<span class="params">self, arr</span>):</span></span><br><span class="line">        <span class="comment"># 桶的大小为所有元素的最大位数</span></span><br><span class="line">        size = <span class="built_in">len</span>(<span class="built_in">str</span>(<span class="built_in">max</span>(arr)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从低位到高位依次遍历每一位，以各个数位值为索引，对数组进行按数位排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="comment"># 使用一个长度为 10 的桶来存放各个位上的元素</span></span><br><span class="line">            buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">            <span class="comment"># 遍历数组元素，根据元素对应位上的值，将其存入对应位的桶中</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">                buckets[num // (<span class="number">10</span> ** i) % <span class="number">10</span>].append(num)</span><br><span class="line">            <span class="comment"># 清空原始数组</span></span><br><span class="line">            arr.clear()</span><br><span class="line">            <span class="comment"># 从桶中依次取出对应元素，并重新加入到原始数组</span></span><br><span class="line">            <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">                <span class="keyword">for</span> num <span class="keyword">in</span> bucket:</span><br><span class="line">                    arr.append(num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.radixSort(nums)</span><br></pre></td></tr></table></figure>
<h3 id="1-11-排序算法总结"><a href="#1-11-排序算法总结" class="headerlink" title="1.11 排序算法总结"></a>1.11 排序算法总结</h3><p>下面为七种经典排序算法指标对比情况：<br><img src="https://img-blog.csdnimg.cn/13128565aa0043ada3fa108e6ecf8115.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>冒泡排序,简单选择排序,堆排序,直接插入排序,希尔排序的空间复杂度为O(1),因为需要一个临时变量来交换元素位置,(另外遍历序列时自然少不了用一个变量来做索引)</p>
</li>
<li><p>快速排序空间复杂度为logn(因为递归调用了) </p>
</li>
<li>归并排序空间复杂是O(n),需要一个大小为n的临时数组.。基数排序的空间复杂是O(n),桶排序的空间复杂度不确定。</li>
<li>所有排序算法中最快的应该是<strong>桶排序</strong>(很多人误以为是快速排序,实际上不是.不过实际应用中快速排序用的多)。但桶排序一般用的不多,因为有几个比较大的缺陷.<ul>
<li>待排序的元素不能是负数,小数.</li>
<li>空间复杂度不确定,要看待排序元素中最大值是多少.。所需要的辅助数组大小即为最大元素的值.</li>
</ul>
</li>
</ul>
<h2 id="二、-练习题"><a href="#二、-练习题" class="headerlink" title="二、 练习题"></a>二、 练习题</h2><h3 id="2-1-移动零（题283）"><a href="#2-1-移动零（题283）" class="headerlink" title="2.1 移动零（题283）"></a>2.1 移动零（题283）</h3><p>&#8195;&#8195;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>
<ul>
<li>示例 1:<ul>
<li>输入: nums = [0,1,0,3,12]</li>
<li>输出: [1,3,12,0,0]</li>
</ul>
</li>
<li>示例 2:<ul>
<li>输入: nums = [0]</li>
<li>输出: [0]</li>
</ul>
</li>
</ul>
<p>思路 1：冒泡排序（超时）<br>&#8195;&#8195;冒泡排序的思想，就是通过相邻元素的比较与交换，使得较大元素从前面移到后面。我们可以借用冒泡排序的思想，将值为 0 的元素移动到数组末尾。因为冒泡排序的时间复杂度为$O(n^2)$ 。所以这种做法会导致超时。</p>
<p>思路 2：双指针</p>
<ol>
<li>使用两个指针 slow，fast。slow 指向处理好的非 0 数字数组的尾部，fast 指针指向当前待处理元素。</li>
<li>不断向右移动 fast 指针，每次移动到非零数，则将左右指针对应的数交换，交换同时将 slow 右移。</li>
<li>此时，slow 指针左侧均为处理好的非零数，而从 slow 指针指向的位置开始， fast 指针左边为止都为 0。</li>
<li>遍历结束之后，则所有 0 都移动到了右侧，且保持了非零数的相对位置。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):            </span><br><span class="line">            <span class="keyword">if</span> nums[i]!=<span class="number">0</span>:</span><br><span class="line">                nums[i],nums[slow]=nums[slow],nums[i]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
<h3 id="2-2-颜色分类（题75）"><a href="#2-2-颜色分类（题75）" class="headerlink" title="2.2 颜色分类（题75）"></a>2.2 颜色分类（题75）</h3><p><strong>方法一：单指针</strong><br>&#8195;&#8195;这道题和上一题很类似，最简单的方法是遍历两次，先将0排到最前面，再接着将1排到前面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 两次遍历，先排0再排1</span></span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">0</span>:</span><br><span class="line">                nums[left],nums[i]=nums[i],nums[left]</span><br><span class="line">                left+=<span class="number">1</span>  </span><br><span class="line">                              </span><br><span class="line">        right=left  <span class="comment"># 前面left个位置已经排好了0     </span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j]==<span class="number">1</span>:</span><br><span class="line">                nums[right],nums[j]=nums[j],nums[right]</span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
<p><strong>方法二：双指针（官方题解）</strong><br>&#8195;&#8195;我们可以额外使用一个指针，即使用两个指针分别用来交换 0 和1。具体地，我们用指针 $p_0$来交换 0，$p_1$来交换 1，初始值都为 0。当我们从左向右遍历整个数组时：</p>
<ul>
<li>如果找到了 1，那么将其与 $nums[p_1]$ 进行交换，并将 $p_1$向后移动一个位置，这与方法一是相同的；</li>
<li>如果找到了 0，那么将其与 $nums[p_0]$ 进行交换，并将 $p_0$向后移动一个位置。这样做是正确的吗？<br>&#8195;&#8195;我们可以注意到，因为连续的 0 之后是连续的 1，因此如果我们将 0 与$nums[p_0]$ 进行交换，那么我们可能会把一个 1 交换出去。当 $p_0 &lt; p_1$时，我们已经将一些 1 连续地放在头部，此时一定会把一个 1 交换出去，导致答案错误。因此，如果$p_0 &lt; p_1$，那么我们需要再将 $nums[i]$ 与$nums[p_1]$进行交换，其中 i 是当前遍历到的位置。<br>&#8195;&#8195;在进行了第一次交换后，$nums[i]$的值为 1，我们需要将这个 1 放到「头部」的末端。在最后，无论是否有 $p_0 &lt; p_1$，我们需要将 $p_0$ 和 $p_1$均向后移动一个位置，而不是仅将 $p_0$向后移动一个位置。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 两个指针分别用于交换0和1</span></span><br><span class="line">        p0=p1=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">1</span>:</span><br><span class="line">                nums[i],nums[p1]=nums[p1],nums[i]</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i]==<span class="number">0</span>:</span><br><span class="line">                nums[i],nums[p0]=nums[p0],nums[i]</span><br><span class="line">                <span class="keyword">if</span> p0&lt;p1:</span><br><span class="line">                    nums[i],nums[p1]=nums[p1],nums[i]</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">                p0+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
<p><strong>方法三：快速排序</strong><br>我们也可以借鉴快速排序算法中的 <code>partition</code> 过程，将 1 作为基准数 <code>pivot</code>，然后将序列分为三部分：0（即比 1 小的部分）、等于 1 的部分、2（即比 1 大的部分）。具体步骤如下：</p>
<ol>
<li>使用两个指针 left、right，分别指向数组的头尾。left 表示当前处理好红色元素的尾部，right 表示当前处理好蓝色的头部。</li>
<li>再使用一个下标 index 遍历数组，如果遇到 <code>nums[index] == 0</code>，就交换 nums[index] 和 nums[left]，同时将 left 右移。如果遇到 <code>nums[index] == 2</code>，就交换 nums[index] 和 nums[right]，同时将 right 左移。</li>
<li>直到 index 移动到 right 位置之后，停止遍历。遍历结束之后，此时 left 左侧都是红色，right 右侧都是蓝色。</li>
<li>注意：移动的时候需要判断 index 和 left 的位置，因为 left 左侧是已经处理好的数组，所以需要判断 index 的位置是否小于 left，小于的话，需要更新 index 位置。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> index &lt; left:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[index] == <span class="number">0</span>:</span><br><span class="line">                nums[index], nums[left] = nums[left], nums[index]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[index] == <span class="number">2</span>:</span><br><span class="line">                nums[index], nums[right] = nums[right], nums[index]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-数组中的第K个最大元素（题215）"><a href="#2-3-数组中的第K个最大元素（题215）" class="headerlink" title="2.3    数组中的第K个最大元素（题215）"></a>2.3    数组中的第K个最大元素（题215）</h3><p>&#8195;&#8195;给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。示例：</p>
<ul>
<li>输入: [3,2,1,5,6,4], k = 2</li>
<li>输出: 5          </li>
</ul>
<p>&#8195;&#8195;这道题使用改进的冒泡排序、选择排序、插入排序都会超时。希尔排序（1440ms）、归并排序（1016ms）、堆排序（640ms），这些都是可以通过的。也可以考虑使用快速排序。</p>
<h4 id="2-3-1-快速排序"><a href="#2-3-1-快速排序" class="headerlink" title="2.3.1 快速排序"></a>2.3.1 快速排序</h4><p><strong>快速排序思路：</strong><br>&#8195;&#8195;使用快速排序在每次调整时，都会确定一个元素的最终位置，且以该元素为界限，将数组分成了左右两个子数组，左子数组中的元素都比该元素小，右子树组中的元素都比该元素大。</p>
<p>&#8195;&#8195;这样，只要某次划分的元素位置q恰好是第 k 个下标就找到了答案。至于<code>nums[left,q-1]</code>和<code>nums[q+1,right]</code>是否有序，我们并不关心。具体来说，在分解的过程当中，我们会对子数组进行划分，如果划分得到的 <code>q</code> 正好就是我们需要的下标，就直接返回 <code>nums[q]</code>；否则，如果 <code>q</code> 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>       </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> self.qSort(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>,k)  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qSort</span>(<span class="params">self,nums,start,end,k</span>):</span></span><br><span class="line">        <span class="comment"># if start&lt;end:这个是完全排序的结束条件，如果是topk排序，结束条件是pivot_idx=len(nums)-k</span></span><br><span class="line">        pivot_idx=self.partition(nums,start,end)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        如果pivot_idx==len(nums)-k,说明中值正好就是第k大的值，直接返回nums[pivot_idx]；</span></span><br><span class="line"><span class="string">        否则，如果pivot_idx&gt;len(nums)-k，就递归左子区间，否则递归右子区间。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pivot_idx==<span class="built_in">len</span>(nums)-k:</span><br><span class="line">            <span class="keyword">return</span> nums[pivot_idx]</span><br><span class="line">        <span class="keyword">elif</span> pivot_idx&gt;<span class="built_in">len</span>(nums)-k:</span><br><span class="line">            <span class="keyword">return</span> self.qSort(nums,start,pivot_idx-<span class="number">1</span>,k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.qSort(nums,pivot_idx+<span class="number">1</span>,end,k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self,nums,start,end</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        左指针一直右移，直到指向的元素大于中值；右指针一直左移，直到指向的元素小于中值。交换左右指针的元素值</span></span><br><span class="line"><span class="string">        继续下一次移动交换，直到左指针越过右指针。此时右指针位置就是中值应该在的位置，进行交换，排序完毕。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 改进中值，选取序列中随机一个位置的元素，将其和序列开头元素交换位置，作为中值</span></span><br><span class="line">        idx=random.randint(start,end)</span><br><span class="line">        nums[start],nums[idx]=nums[idx],nums[start]</span><br><span class="line">        pivot=nums[start]</span><br><span class="line"></span><br><span class="line">        left=start+<span class="number">1</span></span><br><span class="line">        right=end</span><br><span class="line">        done=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[left]&lt;=pivot:</span><br><span class="line">                left=left+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[right]&gt;=pivot:</span><br><span class="line">                right=right-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                done=<span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[left],nums[right] = nums[right],nums[left]                        </span><br><span class="line"></span><br><span class="line">        nums[start],nums[right]=nums[right],nums[start]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;使用完整的快速排序再取第k大的元素，是2672ms。只排到第k大的元素是640ms。加上随机选取中值之后，是80ms到90ms。<br>堆排序、优先队列等方法可参考<a target="_blank" rel="noopener" href="https://algo.itcharge.cn/Solutions/0200-0299/kth-largest-element-in-an-array/#%E6%80%9D%E8%B7%AF-4%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97">算法通关手册</a>或<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/">官方题解</a>。</p>
<p>&#8195;&#8195;与这道题类似的还有<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数（剑指 Offer 40）</a>，使用随机快速排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span>(<span class="params">self, arr, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>     </span><br><span class="line">        <span class="keyword">if</span> k&gt;<span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> self.qSort(arr,<span class="number">0</span>,<span class="built_in">len</span>(arr)-<span class="number">1</span>,k)  </span><br><span class="line">        <span class="keyword">elif</span> k==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qSort</span>(<span class="params">self,nums,start,end,k</span>):</span></span><br><span class="line">        <span class="comment"># if start&lt;end:这个是完全排序的结束条件，如果是topk排序，结束条件是pivot_idx=k-1</span></span><br><span class="line">        pivot_idx=self.partition(nums,start,end)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        注意，第k大的数其下标是k-1</span></span><br><span class="line"><span class="string">        如果pivot_idx==k-1,说明中值正好就是第k大的值，直接返回nums[pivot_idx]；</span></span><br><span class="line"><span class="string">        否则，如果pivot_idx&gt;k-1，就递归左子区间，否则递归右子区间。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 第k小的数位于序列的第k-1个位置（快排默认是升序）</span></span><br><span class="line">        <span class="keyword">if</span> pivot_idx==k-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[:pivot_idx+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> pivot_idx&gt;k-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.qSort(nums,start,pivot_idx-<span class="number">1</span>,k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.qSort(nums,pivot_idx+<span class="number">1</span>,end,k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self,nums,start,end</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        左指针一直右移，直到指向的元素大于中值；右指针一直左移，直到指向的元素小于中值。交换左右指针的元素值</span></span><br><span class="line"><span class="string">        继续下一次移动交换，直到左指针越过右指针。此时右指针位置就是中值应该在的位置，进行交换，排序完毕。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 改进中值，选取序列中随机一个位置的元素，将其和序列开头元素交换位置，作为中值</span></span><br><span class="line">        idx=random.randint(start,end)</span><br><span class="line">        nums[start],nums[idx]=nums[idx],nums[start]</span><br><span class="line">        pivot=nums[start]</span><br><span class="line"></span><br><span class="line">        left=start+<span class="number">1</span></span><br><span class="line">        right=end</span><br><span class="line">        done=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[left]&lt;=pivot:</span><br><span class="line">                left=left+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[right]&gt;=pivot:</span><br><span class="line">                right=right-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                done=<span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[left],nums[right] = nums[right],nums[left]                        </span><br><span class="line"></span><br><span class="line">        nums[start],nums[right]=nums[right],nums[start]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$。证明过程可参考「算法导论 9.2：期望为线性的选择算法」。</li>
<li><strong>空间复杂度</strong>：$O(\log_2 n)$。递归使用栈空间的空间代价期望为 $O(\log_2n)$。<h4 id="2-3-2-堆排序"><a href="#2-3-2-堆排序" class="headerlink" title="2.3.2 堆排序"></a>2.3.2 堆排序</h4>升序堆排序的思路如下：</li>
</ul>
<ol>
<li><p>将无序序列构造成第 <code>1</code> 个大顶堆（初始堆），使得 <code>n</code> 个元素的最大值处于序列的第 <code>1</code> 个位置。</p>
</li>
<li><p><strong>调整堆</strong>：交换序列的第 <code>1</code> 个元素（最大值元素）与第 <code>n</code> 个元素的位置。将序列前 <code>n - 1</code> 个元素组成的子序列调整成一个新的大顶堆，使得 <code>n - 1</code> 个元素的最大值处于序列第 <code>1</code> 个位置，从而得到第 <code>2</code> 个最大值元素。</p>
</li>
<li><p><strong>调整堆</strong>：交换子序列的第 <code>1</code> 个元素（最大值元素）与第 <code>n - 1</code> 个元素的位置。将序列前 <code>n - 2</code> 个元素组成的子序列调整成一个新的大顶堆，使得 <code>n - 2</code> 个元素的最大值处于序列第 <code>1</code> 个位置，从而得到第 <code>3</code> 个最大值元素。</p>
</li>
<li><p>依次类推，不断交换子序列的第 <code>1</code> 个元素（最大值元素）与当前子序列最后一个元素位置，并将其调整成新的大顶堆。直到获取第 <code>k</code> 个最大值元素为止。</p>
</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 调整为大顶堆</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">nums, index, end</span>):</span></span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            right = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= end:</span><br><span class="line">                <span class="comment"># 当前节点为非叶子节点</span></span><br><span class="line">                max_index = index</span><br><span class="line">                <span class="keyword">if</span> nums[left] &gt; nums[max_index]:</span><br><span class="line">                    max_index = left</span><br><span class="line">                <span class="keyword">if</span> right &lt;= end <span class="keyword">and</span> nums[right] &gt; nums[max_index]:</span><br><span class="line">                    max_index = right</span><br><span class="line">                <span class="keyword">if</span> index == max_index:</span><br><span class="line">                    <span class="comment"># 如果不用交换，则说明已经交换结束</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                nums[index], nums[max_index] = nums[max_index], nums[index]</span><br><span class="line">                <span class="comment"># 继续调整子树</span></span><br><span class="line">                index = max_index</span><br><span class="line">                left = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                right = left + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 初始化大顶堆</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buildMaxHeap</span>(<span class="params">nums</span>):</span></span><br><span class="line">            size = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="comment"># (size-2) // 2 是最后一个非叶节点，叶节点不用调整</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((size - <span class="number">2</span>) // <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                heapify(nums, i, size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">        buildMaxHeap(nums)</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            nums[<span class="number">0</span>], nums[size-i-<span class="number">1</span>] = nums[size-i-<span class="number">1</span>], nums[<span class="number">0</span>]</span><br><span class="line">            heapify(nums, <span class="number">0</span>, size-i-<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度</strong>：$O(n \times \log_2n)$。</li>
<li><strong>空间复杂度</strong>：$O(1)$。</li>
</ul>
<h4 id="2-3-3-优先队列"><a href="#2-3-3-优先队列" class="headerlink" title="2.3.3 优先队列"></a>2.3.3 优先队列</h4><ol>
<li>遍历数组元素，对于挡圈元素 <code>num</code>：<ol>
<li>如果优先队列中的元素个数小于 <code>k</code> 个，则将当前元素 <code>num</code> 放入优先队列中。</li>
<li>如果优先队列中的元素个数大于等于 <code>k</code> 个，并且当前元素 <code>num</code> 大于优先队列的队头元素，则弹出队头元素，并将当前元素 <code>num</code> 插入到优先队列中。</li>
</ol>
</li>
<li>遍历完，此时优先队列的队头元素就是第K个最大元素，将其弹出并返回即可。</li>
</ol>
<p>&#8195;&#8195;这里我们借助了 Python 中的 <code>heapq</code> 模块实现优先队列算法，这一步也可以通过手写堆的方式实现优先队列。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; k:</span><br><span class="line">                heapq.heappush(res, num)</span><br><span class="line">            <span class="keyword">elif</span> num &gt; res[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(res)</span><br><span class="line">                heapq.heappush(res, num)</span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(res)</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度</strong>：$O(n \times \log_2k)$。</li>
<li><strong>空间复杂度</strong>：$O(k)$。</li>
</ul>
<h3 id="2-4-排序数组（题912）"><a href="#2-4-排序数组（题912）" class="headerlink" title="2.4 排序数组（题912）"></a>2.4 排序数组（题912）</h3><p>给你一个整数数组 nums，请你将该数组升序排列。</p>
<p>&#8195;&#8195;本题冒泡排序（改进）是过不了的，估计选择排序、插入排序也不行。可行的有希尔排序（1172ms）、归并排序（1036ms）、快速排序（816ms）。其中，验证的nums列表中有一个是nums全部为2的极端情况，直接快速排序是超时的。所以可以设置归并+快排，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(nums))&lt;<span class="number">5</span>: <span class="comment"># 随便选的一个值，排除一些极端情况下快排会超时</span></span><br><span class="line">            <span class="keyword">return</span> self.merge(nums) <span class="comment"># 归并排序</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.qSort(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>) <span class="comment"># 快速排序</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,arr</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(arr)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        mid=<span class="built_in">len</span>(arr)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># 注意，这里是递归的写法</span></span><br><span class="line">        left_arr=self.merge(arr[:mid])</span><br><span class="line">        right_arr=self.merge(arr[mid:])</span><br><span class="line">        <span class="keyword">return</span> self.mergesort(left_arr,right_arr)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergesort</span>(<span class="params">self,left_arr,right_arr</span>):</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        arr=[]</span><br><span class="line">        <span class="comment"># 注意，这里都是&lt;，不能取=,因为left_arr[len(left_arr)]是超出索引的</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;<span class="built_in">len</span>(left_arr) <span class="keyword">and</span> right&lt;<span class="built_in">len</span>(right_arr):</span><br><span class="line">            <span class="keyword">if</span> left_arr[left]&lt;right_arr[right]:</span><br><span class="line">                arr.append(left_arr[left])</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr.append(right_arr[right])</span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">while</span> left&lt;<span class="built_in">len</span>(left_arr):</span><br><span class="line">            arr.append(left_arr[left])</span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right&lt;<span class="built_in">len</span>(right_arr):</span><br><span class="line">            arr.append(right_arr[right])</span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">        <span class="comment">#print(left_arr,right_arr,arr)</span></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qSort</span>(<span class="params">self,nums,start,end</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start&lt;end:</span><br><span class="line">            pivot_idx=self.partition(nums,start,end)</span><br><span class="line">            self.qSort(nums,start,pivot_idx-<span class="number">1</span>)</span><br><span class="line">            self.qSort(nums,pivot_idx+<span class="number">1</span>,end)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self,nums,start,end</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        左指针一直右移，直到指向的元素大于中值；右指针一直左移，直到指向的元素小于中值。交换左右指针的元素值</span></span><br><span class="line"><span class="string">        继续下一次移动交换，直到左指针越过右指针。此时右指针位置就是中值应该在的位置，进行交换，排序完毕。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 改进中值，选取序列中随机一个位置的元素，将其和序列开头元素交换位置，作为中值</span></span><br><span class="line">        idx=random.randint(start,end)</span><br><span class="line">        nums[start],nums[idx]=nums[idx],nums[start]</span><br><span class="line">        pivot=nums[start]</span><br><span class="line"></span><br><span class="line">        left=start+<span class="number">1</span></span><br><span class="line">        right=end</span><br><span class="line">        done=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[left]&lt;=pivot:</span><br><span class="line">                left=left+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[right]&gt;=pivot:</span><br><span class="line">                right=right-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                done=<span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[left],nums[right] = nums[right],nums[left]                        </span><br><span class="line"></span><br><span class="line">        nums[start],nums[right]=nums[right],nums[start]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right        </span><br></pre></td></tr></table></figure>
<p>其它排序方法详见<a target="_blank" rel="noopener" href="https://algo.itcharge.cn/Solutions/0900-0999/sort-an-array/">算法通关手册</a>。</p>
<h3 id="2-5-数组中的逆序对（剑指-Offer-51）"><a href="#2-5-数组中的逆序对（剑指-Offer-51）" class="headerlink" title="2.5 数组中的逆序对（剑指 Offer 51）"></a>2.5 数组中的逆序对（剑指 Offer 51）</h3><p>&#8195;&#8195;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。示例：</p>
<ul>
<li>输入: [7,5,6,4]</li>
<li>输出: 5                </li>
</ul>
<p><strong>思路 1：归并排序</strong><br>&#8195;&#8195;归并排序主要分为：「分解过程」和「合并过程」。其中「合并过程」实质上是两个有序数组的合并过程。<br><img src="https://img-blog.csdnimg.cn/9676155cdd1f4c94adf1f0763753d21e.png" alt="在这里插入图片描述"><br>&#8195;&#8195;每当遇到<font color='deeppink'> 左子数组当前元素 &gt; 右子树组当前元素时</font>，意味着<font color='deeppink'>「左子数组从当前元素开始，一直到左子数组末尾元素」与「右子树组当前元素」构成了若干个逆序对</font>。</p>
<p>&#8195;&#8195;比如上图中的左子数组 <code>[0, 3, 5, 7]</code> 与右子树组 <code>[1, 4, 6, 8]</code>，遇到左子数组中元素 3 大于右子树组中元素 1。则左子数组从 3 开始，经过 5 一直到 7，与右子数组当前元素 1 都构成了逆序对。即 <code>[3, 1]、[5, 1]、[7, 1]</code> 都构成了逆序对。</p>
<p>&#8195;&#8195;因此，我们可以在合并两个有序数组的时候计算逆序对。具体做法如下：</p>
<ol>
<li>使用全局变量 <code>count</code> 来存储逆序对的个数。然后进行归并排序。</li>
<li>归并过程中：<ul>
<li>使用数组变量 arr 存放归并后的有序数组</li>
<li>使用两个指针 left、right 分别指向两个有序子序列 left_arr、right_arr 的开始位置。</li>
<li>如果 <code>left_arr[left] &lt;= right_arr[right]</code>，则将 <code>left_arr[left]</code> 存入到结果数组 <code>arr</code> 中，并将指针移动到下一位置。</li>
<li>如果 <code>left_arr[left] &gt; right_arr[right]</code>，则 记录当前左子序列中元素与当前右子序列元素所形成的逆序对的个数，并累加到 <code>count</code> 中，即 <code>self.count += len(left_arr) - left</code>，然后将 <code>right_arr[right]</code> 存入到结果数组 <code>arr</code> 中，并将指针移动到下一位置。</li>
<li>重复以上，直到某一指针到达子序列末尾，将另一个子序列中的剩余元素存入到结果数组 arr 中。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums=self.mergeSort(nums)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">self, arr</span>):</span>                       <span class="comment"># 分割过程</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:                           <span class="comment"># 数组元素个数小于等于 1 时，直接返回原数组</span></span><br><span class="line">                <span class="keyword">return</span> arr</span><br><span class="line">            </span><br><span class="line">            mid = <span class="built_in">len</span>(arr) // <span class="number">2</span>                         <span class="comment"># 将数组从中间位置分为左右两个数组。</span></span><br><span class="line">            <span class="comment"># 注意这里是递归的写法</span></span><br><span class="line">            left_arr = self.mergeSort(arr[<span class="number">0</span>: mid])      <span class="comment"># 递归将左子序列进行分割和排序</span></span><br><span class="line">            right_arr =  self.mergeSort(arr[mid:])      <span class="comment"># 递归将右子序列进行分割和排序</span></span><br><span class="line">            <span class="keyword">return</span> self.merge(left_arr, right_arr)      <span class="comment"># 把当前序列组中有序子序列逐层向上，进行两两合并。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, left_arr, right_arr</span>):</span>           <span class="comment"># 归并过程</span></span><br><span class="line">        arr = []</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 这里不能取等于，否则超出索引，下同</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(left_arr) <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(right_arr):</span><br><span class="line">            <span class="comment"># 将两个有序子序列中较小元素依次插入到结果数组中</span></span><br><span class="line">            <span class="keyword">if</span> left_arr[left] &lt;= right_arr[right]:</span><br><span class="line">                arr.append(left_arr[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.count+=<span class="built_in">len</span>(left_arr)-left</span><br><span class="line">                arr.append(right_arr[right])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        arr=arr+left_arr[left:]+right_arr[right:]            </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> arr                                  <span class="comment"># 返回排好序的结果数组</span></span><br></pre></td></tr></table></figure>
<p><strong>思路 2 树状数组：</strong> 见<a target="_blank" rel="noopener" href="https://algo.itcharge.cn/Solutions/Offer/shu-zu-zhong-de-ni-xu-dui-lcof/">算法通关手册</a></p>
<h3 id="2-6-计算右侧小于当前元素的个数（题315）"><a href="#2-6-计算右侧小于当前元素的个数（题315）" class="headerlink" title="2.6 计算右侧小于当前元素的个数（题315）"></a>2.6 计算右侧小于当前元素的个数（题315）</h3><blockquote>
<p>参考<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/4chong-jie-fa-yi-wang-da-jin-pai-xu-shu-5vvds/">《『 4种解法一网打尽 』 有序数组、归并排序、树状数组和线段树的实现及注释》</a></p>
</blockquote>
<p>&#8195;&#8195;给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<ul>
<li>示例 1：<ul>
<li>输入：nums = [5,2,6,1]</li>
<li>输出：[2,1,1,0] </li>
<li>解释：<ul>
<li>5 的右侧有 2 个更小的元素 (2 和 1)</li>
<li>2 的右侧仅有 1 个更小的元素 (1)</li>
<li>6 的右侧有 1 个更小的元素 (1)</li>
<li>1 的右侧有 0 个更小的元素</li>
</ul>
</li>
</ul>
</li>
<li>示例 2：<ul>
<li>输入：nums = [-1]</li>
<li>输出：[0]<h4 id="2-6-1-归并排序"><a href="#2-6-1-归并排序" class="headerlink" title="2.6.1 归并排序"></a>2.6.1 归并排序</h4>&#8195;&#8195;这题类似上一题求逆序对。但是本题我们要求解的是 <code>nums[i]</code>右侧小于 <code>nums[i]</code> 的元素的数量，即以 <code>nums[i]</code>为左端点的「逆序对」的数目。注意到，在常规的归并排序过程中，数组中的元素其位置会发生变化，所以在本题中我们则需要记录下每个元素的初始位置，以便将每个元素贡献的逆序对数目归功到对应的位置上。<br>&#8195;&#8195;由于数组中的元素会重复，不能使用哈希表，所以考虑为每个数值添加其对应的下标，即对于第 <code>i</code> 个元素 <code>nums[i]</code>，可将其扩充为<code>(nums[i], i)</code>。这样在nums排序过程中，即便 nums 中元素的位置发生了变化，也可将每个元素贡献的逆序对数目准确定位到对应的位置上，原理如下图所示：<br><img src="https://img-blog.csdnimg.cn/11625172912b49e58456e7dedc4f9537.png" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据nums[*][0]进行排序，对应的index随之移动&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">nums, low, high</span>):</span></span><br><span class="line">            <span class="keyword">if</span> low &gt;= high:     <span class="comment"># 递归终止</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;递归排序&#x27;&#x27;&#x27;</span></span><br><span class="line">            mid = low + (high-low)//<span class="number">2</span>     </span><br><span class="line">            mergeSort(nums, low, mid)           <span class="comment"># 左半部分逆序对数目</span></span><br><span class="line">            mergeSort(nums, mid+<span class="number">1</span>, high)        <span class="comment"># 右半部分逆序对数目</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;nums[low, mid] 和 nums[mid+1, high] 已排序好&#x27;&#x27;&#x27;</span></span><br><span class="line">            tmp = []                            <span class="comment"># 记录nums[low, high]排序结果</span></span><br><span class="line">            left, right = low, mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;=mid <span class="keyword">and</span> right&lt;=high:</span><br><span class="line">                <span class="keyword">if</span> nums[left][<span class="number">0</span>] &lt;= nums[right][<span class="number">0</span>]:         <span class="comment"># 根据nums[*][0]进行排序</span></span><br><span class="line">                    tmp.append(nums[left])</span><br><span class="line">                    res[nums[left][<span class="number">1</span>]] += right-(mid+<span class="number">1</span>)     <span class="comment"># 记录逆序对数目【对应坐标nums[*][1]处】</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp.append(nums[right])</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;左或右数组需遍历完（最多只有一个未遍历完）&#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;=mid:</span><br><span class="line">                tmp.append(nums[left])</span><br><span class="line">                res[nums[left][<span class="number">1</span>]] += right -(mid+<span class="number">1</span>)    <span class="comment"># 记录逆序对数目【对应坐标nums[*][1]处】</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> right&lt;=high:</span><br><span class="line">                tmp.append(nums[right])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            nums[low:high+<span class="number">1</span>] = tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;主程序&#x27;&#x27;&#x27;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">0</span>] * n               <span class="comment"># 存储结果</span></span><br><span class="line">        nums = [(num, idx) <span class="keyword">for</span> idx, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums)] </span><br><span class="line">        <span class="comment"># 每个数值附上其对应的索引：</span></span><br><span class="line">        <span class="comment"># 此时，nums[i][0]表示原来的数值，而nums[i][1]则表示原数值对应的索引（方便定位）</span></span><br><span class="line"></span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, n-<span class="number">1</span>)     <span class="comment"># 归并排序</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="2-6-2-有序数组-（Sorted-List）-二分搜索"><a href="#2-6-2-有序数组-（Sorted-List）-二分搜索" class="headerlink" title="2.6.2 有序数组 （Sorted List）+ 二分搜索"></a>2.6.2 有序数组 （Sorted List）+ 二分搜索</h4><p>&#8195;&#8195;<strong>基本思路</strong>： 维护一个有序数组 sl，从右往左依次往里添加 nums 中的元素，每次添加 nums[i] 前基于「二分搜索」判断出当前 sl 中比 nums[i] 小的元素个数（即 nums[i] 右侧比 nums[i] 还要小的元素个数），并计入答案即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">0</span>] * n</span><br><span class="line">        sl = []         <span class="comment"># 有序数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bisect_left</span>(<span class="params">arr, x, low, high</span>):</span></span><br><span class="line">            left, right = low, high</span><br><span class="line">            <span class="keyword">while</span> left&lt;right:</span><br><span class="line">                mid = (left+right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> arr[mid] &lt; x:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="comment"># arr.insert(left, x)</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):        			 <span class="comment"># 反向遍历</span></span><br><span class="line">            <span class="comment"># pos = bisect.bisect_left(sl, nums[i])      # 找到右边比当前值小的元素个数</span></span><br><span class="line">            pos = bisect_left(sl, nums[i], <span class="number">0</span>, <span class="built_in">len</span>(sl))   <span class="comment"># 找到右边比当前值小的元素个数</span></span><br><span class="line">            res[i] = pos                    			 <span class="comment"># 记入答案</span></span><br><span class="line">            sl.insert(pos, nums[i])         			 <span class="comment"># 将当前值加入有序数组中</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>可简写为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedList</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">0</span>] * n</span><br><span class="line">        sl = SortedList()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):        <span class="comment"># 反向遍历</span></span><br><span class="line">            cnt = sl.bisect_left(nums[i])   <span class="comment"># 找到右边比当前值小的元素个数</span></span><br><span class="line">            res[i] = cnt                    <span class="comment"># 记入答案</span></span><br><span class="line">            sl.add(nums[i])                 <span class="comment"># 将当前值加入有序数组中</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;树状数组、线段树方法，请参考<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/4chong-jie-fa-yi-wang-da-jin-pai-xu-shu-5vvds/">《『 4种解法一网打尽 』 有序数组、归并排序、树状数组和线段树的实现及注释》</a>。</p>
<h3 id="2-7-最大间距-（题164）"><a href="#2-7-最大间距-（题164）" class="headerlink" title="2.7 最大间距  （题164）"></a>2.7 最大间距  （题164）</h3><p>&#8195;&#8195;给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。</p>
<blockquote>
<p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。</p>
</blockquote>
<p>示例 :</p>
<ul>
<li>输入: nums = [3,6,9,1]</li>
<li>输出: 3</li>
<li>解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</li>
<li>提示：$1 &lt;= nums.length &lt;= 10^5$，$0 &lt;= nums[i] &lt;= 10^9$<h4 id="2-7-1-基数排序"><a href="#2-7-1-基数排序" class="headerlink" title="2.7.1 基数排序"></a>2.7.1 基数排序</h4>根据题意可知所有元素都是非负整数，且数值在 32 位有符号整数范围内。所以我们可以选择基数排序。基数排序的步骤如下：</li>
</ul>
<ol>
<li>遍历数组元素，获取数组最大值元素，并取得位数。</li>
<li>以个位元素为索引，对数组元素排序。</li>
<li>合并数组。</li>
<li>之后依次以十位，百位，…，直到最大值元素的最高位处值为索引，进行排序，并合并数组，最终完成排序。</li>
<li>最后，还要注意数组元素个数小于 2 的情况需要特别判断一下。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">radixSort</span>(<span class="params">self, arr</span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(<span class="built_in">str</span>(<span class="built_in">max</span>(arr)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">                buckets[num // (<span class="number">10</span> ** i) % <span class="number">10</span>].append(num)</span><br><span class="line">            arr.clear()</span><br><span class="line">            <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">                <span class="keyword">for</span> num <span class="keyword">in</span> bucket:</span><br><span class="line">                    arr.append(num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        arr = self.radixSort(nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(arr[i] - arr[i - <span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)))</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)。</li>
</ul>
<h4 id="2-7-2-桶排序"><a href="#2-7-2-桶排序" class="headerlink" title="2.7.2 桶排序"></a>2.7.2 桶排序</h4><p><img src="https://img-blog.csdnimg.cn/e060550fd85f49bb89d4ded2b014e57b.png" alt="在这里插入图片描述"><br>例如：nums = [1,3,4,5,6,10,11,12,17]<br>则：每个桶的长度 = （17 - 1） / (9-1) = 2。桶的个数 = （17-1）/ 2 + 1 = 9<br>所以我们的桶为（左闭右开）：<br><img src="https://img-blog.csdnimg.cn/5e98342b3bf14c149589a5f23467448d.png" alt="在这里插入图片描述"><br>答案 = max（差值） = 5。</p>
<blockquote>
<p>&#8195;&#8195;注意：在桶长度这里我们进行了和1取max的操作，这是为了一些边界条件的情况，比如数组是<code>[1,1,1,1]</code>。当然我们也可以不取max，把向下取整改为向上取整。<br>&#8195;&#8195;在所有排序算法里，我们一般认为快速排序是速度相对较快的，然而桶排序在大多数情况下比快速排序还要快，但是它付出的代价就是牺牲<code>O(n)</code>空间的复杂度，且比归并排序的空间占用要多一点点，多出来的一点点就是可能出现的空桶。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 一些初始化</span></span><br><span class="line">        max_ = <span class="built_in">max</span>(nums)</span><br><span class="line">        min_ = <span class="built_in">min</span>(nums)</span><br><span class="line">        max_gap = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        each_bucket_len = <span class="built_in">max</span>(<span class="number">1</span>,(max_-min_) // (<span class="built_in">len</span>(nums)-<span class="number">1</span>))</span><br><span class="line">        buckets =[[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>((max_-min_) // each_bucket_len + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 把数字放入桶中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            loc = (nums[i] - min_) // each_bucket_len</span><br><span class="line">            buckets[loc].append(nums[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历桶更新答案</span></span><br><span class="line">        prev_max = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(buckets)):</span><br><span class="line">            <span class="keyword">if</span> buckets[i] <span class="keyword">and</span> prev_max != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">                max_gap = <span class="built_in">max</span>(max_gap, <span class="built_in">min</span>(buckets[i])-prev_max)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> buckets[i]:</span><br><span class="line">                prev_max = <span class="built_in">max</span>(buckets[i])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> max_gap</span><br></pre></td></tr></table></figure>
<h4 id="2-7-3-你的代码真是无敌了"><a href="#2-7-3-你的代码真是无敌了" class="headerlink" title="2.7.3 你的代码真是无敌了"></a>2.7.3 你的代码真是无敌了</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums=<span class="built_in">sorted</span>(nums)</span><br><span class="line">            res=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i+<span class="number">1</span>]-nums[i]&gt;res:</span><br><span class="line">                    res= nums[i+<span class="number">1</span>]-nums[i]</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/a2fa801f1214400d9194fc0595bc8eb7.png" alt="在这里插入图片描述"><br>之前最快的是224ms。</p>
<h3 id="2-8-数组的相对顺序（题1122）"><a href="#2-8-数组的相对顺序（题1122）" class="headerlink" title="2.8 数组的相对顺序（题1122）"></a>2.8 数组的相对顺序（题1122）</h3><p>&#8195;&#8195;给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。<br>&#8195;&#8195;对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p>
<ul>
<li>示例 1：<ul>
<li>输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]</li>
<li>输出：[2,2,2,1,4,3,3,9,6,7,19]</li>
</ul>
</li>
<li>示例  2:<ul>
<li>输入：arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]</li>
<li>输出：[22,28,8,6,17,44]</li>
</ul>
</li>
</ul>
<p>提示：1 &lt;= arr1.length, arr2.length &lt;= 1000；0 &lt;= arr1[i], arr2[i] &lt;= 1000</p>
<p>因为元素值范围在 [0, 1000]，所以可以使用计数排序的思路来解题。</p>
<ol>
<li>使用数组 count 统计 arr1 各个元素个数。</li>
<li>遍历 arr2 数组，将对应元素num2 按照个数 count[num2] 添加到答案数组 ans 中，同时在 count 数组中减去对应个数。</li>
<li>然后在处理 count 中剩余元素，将 count 中大于 0 的元素下标依次添加到答案数组 ans 中。最后返回答案数组 ans</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">relativeSortArray</span>(<span class="params">self, arr1: <span class="type">List</span>[<span class="built_in">int</span>], arr2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># 计算待排序序列中最大值元素 arr_max 和最小值元素 arr_min</span></span><br><span class="line">        arr1_min, arr1_max = <span class="built_in">min</span>(arr1), <span class="built_in">max</span>(arr1)</span><br><span class="line">        <span class="comment"># 定义计数数组 counts，大小为 最大值元素 - 最小值元素 + 1</span></span><br><span class="line">        size = arr1_max - arr1_min + <span class="number">1</span></span><br><span class="line">        counts = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 统计值为 num 的元素出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr1:</span><br><span class="line">            counts[num - arr1_min] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr2:</span><br><span class="line">            <span class="keyword">while</span> counts[num - arr1_min] &gt; <span class="number">0</span>:</span><br><span class="line">                res.append(num)</span><br><span class="line">                counts[num - arr1_min] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">while</span> counts[i] &gt; <span class="number">0</span>:</span><br><span class="line">                num = i + arr1_min</span><br><span class="line">                res.append(num)</span><br><span class="line">                counts[i] -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="2-9-存在重复元素-III（题220）"><a href="#2-9-存在重复元素-III（题220）" class="headerlink" title="2.9 存在重复元素 III（题220）"></a>2.9 存在重复元素 III（题220）</h3><p>&#8195;&#8195;给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>t</code> 。请你判断是否存在 两个不同下标 i 和 j，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code> 。如果存在则返回 true，不存在返回 false。 </p>
<ul>
<li>示例 1：<ul>
<li>输入：nums = [1,2,3,1], k = 3, t = 0</li>
<li>输出：true</li>
</ul>
</li>
<li>示例2：<ul>
<li>输入：nums = [1,5,9,1,5,9], k = 2, t = 3</li>
<li>输出：false</li>
</ul>
</li>
</ul>
<p>&#8195;&#8195;题目中需要满足两个要求，一个是元素值的要求（abs(nums[i] - nums[j]) &lt;= t） ，一个是下标范围的要求（abs(i - j) &lt;= k）。所以对于任意一个位置 i 来说，合适的 j 应该在区间 <code>[i - k, i + k]</code> 内，同时 nums[j] 值应该在区间 <code>[nums[i] - t, nums[i] + t]</code> 内。<br>&#8195;&#8195;检测相邻 2 * k 个元素是否满足 <code>abs(nums[i] - nums[j]) &lt;= t</code> 的方法。有两种思路：「桶排序」和「滑动窗口（固定长度）」。</p>
<h4 id="2-9-1-桶排序"><a href="#2-9-1-桶排序" class="headerlink" title="2.9.1 桶排序"></a>2.9.1 桶排序</h4><blockquote>
<p>参考【题解】<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/contains-duplicate-iii/solution/li-yong-tong-de-yuan-li-onpython3-by-zhou-pen-chen/">利用桶的原理O(n)，Python3 - 存在重复元素 III - 力扣</a></p>
</blockquote>
<ol>
<li>利用桶排序的思想，将桶的大小设置为 <code>t + 1</code>。只需要使用一重循环遍历位置 <code>i</code>，然后根据 <code>nums[i] // (t + 1)</code>，从而决定将 <code>nums[i]</code> 放入哪个桶中。</li>
<li>这样在同一个桶内各个元素之间的差值绝对值都小于等于 <code>t</code>。而相邻桶之间的元素，只需要校验一下两个桶之间的差值是否不超过 <code>t</code>。这样就可以以 $O(1)$ 的时间复杂度检测相邻 <code>2 * k</code> 个元素是否满足 <code>abs(nums[i] - nums[j]) &lt;= t</code>。</li>
<li>而 <code>abs(i - j) &lt;= k</code> 条件则可以通过在一重循环遍历时，将超出范围的 <code>nums[i - k]</code> 从对应桶中删除，从而保证桶中元素一定满足 <code>abs(i - j) &lt;= k</code>。</li>
</ol>
<p>具体步骤如下：</p>
<ol>
<li>将每个桶的大小设置为 <code>t + 1</code>。我们将元素按照大小依次放入不同的桶中。</li>
<li>遍历数组 <code>nums</code> 中的元素，对于元素<code>nums[i]</code> ：<ol>
<li>如果 <code>nums[i]</code> 放入桶之前桶里已经有元素了，那么这两个元素必然满足 <code>abs(nums[i] - nums[j]) &lt;= t</code>，</li>
<li>如果之前桶里没有元素，那么就将 <code>nums[i]</code> 放入对应桶中。</li>
<li>再判断左右桶的左右两侧桶中是否有元素满足 <code>abs(nums[i] - nums[j]) &lt;= t</code>。</li>
<li>然后将 <code>nums[i - k]</code> 之前的桶清空，因为这些桶中的元素与 <code>nums[i]</code> 已经不满足 <code>abs(i - j) &lt;= k</code> 了。</li>
</ol>
</li>
<li>最后上述满足条件的情况就返回 <code>True</code>，最终遍历完仍不满足条件就返回 <code>False</code>。</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        bucket_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 将 nums[i] 划分到大小为 t + 1 的不同桶中</span></span><br><span class="line">            num = nums[i] // (t + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 桶中已经有元素了</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> bucket_dict:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 把 nums[i] 放入桶中</span></span><br><span class="line">            bucket_dict[num] = nums[i]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断左侧桶是否满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (num - <span class="number">1</span>) <span class="keyword">in</span> bucket_dict <span class="keyword">and</span> <span class="built_in">abs</span>(bucket_dict[num - <span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 判断右侧桶是否满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (num + <span class="number">1</span>) <span class="keyword">in</span> bucket_dict <span class="keyword">and</span> <span class="built_in">abs</span>(bucket_dict[num + <span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 将 i - k 之前的旧桶清除，因为之前的桶已经不满足条件了</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">                bucket_dict.pop(nums[i - k] // (t + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$。$n$ 是给定数组长度。</li>
<li><strong>空间复杂度</strong>：$O(min(n, k))$。桶中最多包含 $min(n, k + 1)$ 个元素。</li>
</ul>
<h4 id="2-9-2滑动窗口（固定长度）"><a href="#2-9-2滑动窗口（固定长度）" class="headerlink" title="2.9.2滑动窗口（固定长度）"></a>2.9.2滑动窗口（固定长度）</h4><ol>
<li>使用一个长度为 <code>k</code> 的滑动窗口，每次遍历到 <code>nums[right]</code> 时，滑动窗口内最多包含 <code>nums[right]</code> 之前最多 <code>k</code> 个元素。只需要检查前 <code>k</code> 个元素是否在 <code>[nums[right] - t, nums[right] + t]</code> 区间内即可。</li>
<li>检查 <code>k</code> 个元素是否在 <code>[nums[right] - t, nums[right] + t]</code> 区间，可以借助保证有序的数据结构（比如 <code>SortedList</code>）+ 二分查找来解决，从而减少时间复杂度。</li>
</ol>
<p>具体步骤如下：</p>
<ol>
<li>使用有序数组类 <code>window</code> 维护一个长度为 <code>k</code> 的窗口，满足数组内元素有序，且支持增加和删除操作。</li>
<li><code>left</code>、<code>right</code> 都指向序列的第一个元素。即：<code>left = 0</code>，<code>right = 0</code>。</li>
<li>将当前元素填入窗口中，即 <code>window.add(nums[right])</code>。</li>
<li>当窗口元素大于 <code>k</code> 个时，即 <code>right - left &gt; k</code>，移除窗口最左侧元素，并向右移动 <code>left</code>。</li>
<li>当窗口元素小于等于 <code>k</code> 个时：<ol>
<li>使用二分查找算法，查找 <code>nums[right]</code> 在 <code>window</code> 中的位置 <code>idx</code>。</li>
<li>判断 <code>window[idx]</code> 与相邻位置上元素差值绝对值，若果满足 <code>abs(window[idx] - window[idx - 1]) &lt;= t</code> 或者 <code>abs(window[idx + 1] - window[idx]) &lt;= t</code> 时返回 <code>True</code>。</li>
</ol>
</li>
<li>向右移动 <code>right</code>。</li>
<li>重复 <code>3</code> ~ <code>6</code> 步，直到 <code>right</code> 到达数组末尾，如果还没找到满足条件的情况，则返回 <code>False</code>。</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedList</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        window = SortedList()</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; size:</span><br><span class="line">            window.add(nums[right])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> right - left &gt; k:</span><br><span class="line">                window.remove(nums[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            idx = bisect.bisect_left(window, nums[right])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> idx &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">abs</span>(window[idx] - window[idx - <span class="number">1</span>]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> idx &lt; <span class="built_in">len</span>(window) - <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">abs</span>(window[idx + <span class="number">1</span>] - window[idx]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度</strong>：$O(n \times \log_2(min(n, k)))$。</li>
<li><strong>空间复杂度</strong>：$O(min(n, k))$。</li>
</ul>
<h3 id="2-10-合并区间（题56）"><a href="#2-10-合并区间（题56）" class="headerlink" title="2.10 合并区间（题56）"></a>2.10 合并区间（题56）</h3><p>&#8195;&#8195;给定数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>
<ul>
<li><p>示例 1：</p>
<ul>
<li>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</li>
<li>输出：[[1,6],[8,10],[15,18]]</li>
<li>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li>
</ul>
</li>
<li><p>示例 2：</p>
<ul>
<li>输入：intervals = [[1,4],[4,5]]</li>
<li>输出：[[1,5]]</li>
<li>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</li>
</ul>
</li>
<li><p>说明：</p>
<ul>
<li>$1 \le intervals.length \le 10^4$。</li>
<li>$intervals[i].length == 2$。</li>
<li>$0 \le starti \le endi \le 10^4$。</li>
</ul>
</li>
</ul>
<p>此题可以考虑对区间进行排序：</p>
<ol>
<li>设定一个数组 <code>ans</code> 用于表示最终不重叠的区间数组</li>
<li>对原始区间先按照区间左端点大小从小到大进行排序。</li>
<li>遍历所有区间，先将第一个区间加入 <code>ans</code> 数组中。然后依次考虑后边的区间：<ol>
<li>如果第 <code>i</code> 个区间左端点在前一个区间右端点右侧，则这两个区间不会重合，直接将该区间加入 <code>ans</code> 数组中。</li>
<li>否则的话，这两个区间重合，判断一下两个区间的右区间值，更新前一个区间的右区间值为较大值，然后继续考虑下一个区间，以此类推。</li>
</ol>
</li>
<li>最后返回数组 <code>ans</code>。</li>
</ol>
<p><strong>代码</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    </span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">        	<span class="comment"># not ans表示初始ans为空。ans[-1][1]是最后一个加入的区间的右端点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ans <span class="keyword">or</span> ans[-<span class="number">1</span>][<span class="number">1</span>] &lt; interval[<span class="number">0</span>]:</span><br><span class="line">                ans.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(ans[-<span class="number">1</span>][<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>时间复杂度</strong>：$O(n \times \log_2 n)$。其中 $n$ 为区间数量。</li>
<li><strong>空间复杂度</strong>：$O(n)$。</li>
</ul>
<h3 id="2-11-最大数（题179）"><a href="#2-11-最大数（题179）" class="headerlink" title="2.11 最大数（题179）"></a>2.11 最大数（题179）</h3><h4 id="2-11-1-自定义排序（内置函数）"><a href="#2-11-1-自定义排序（内置函数）" class="headerlink" title="2.11.1 自定义排序（内置函数）"></a>2.11.1 自定义排序（内置函数）</h4><p>&#8195;&#8195;本质上是给数组进行排序。假设 x、y 是数组 nums 中的两个元素，规定 排序判断规则 为：如果拼接字符串 x + y &lt; y + x，则 y &gt; x 。y 应该排在 x 前面。反之，则 y &lt; x。<br>&#8195;&#8195;按照上述规则，对原数组套用任何方法进行排序即可。这里我们使用了 functools.cmp_to_key 自定义排序函数。<br><img src="https://img-blog.csdnimg.cn/e93c592b588f4c2896d1a54db9cad4de.png" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cmp</span>(<span class="params">a, b</span>):</span></span><br><span class="line">            <span class="keyword">if</span> a + b == b + a:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> a + b &gt; b + a:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        nums_s = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, nums))</span><br><span class="line">        nums_s.sort(key=functools.cmp_to_key(cmp), reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(nums_s)))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n^2)$。其中 $n$ 为区间数量。</li>
<li><strong>空间复杂度</strong>：$O(n)$。</li>
</ul>
<p>类似的还有<a target="_blank" rel="noopener" href="https://algo.itcharge.cn/Solutions/Offer/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cmp</span>(<span class="params">a, b</span>):</span></span><br><span class="line">            <span class="keyword">if</span> a + b == b + a:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> a + b &gt; b + a:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        nums_s = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, nums))</span><br><span class="line">        nums_s.sort(key=functools.cmp_to_key(cmp))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(nums_s)</span><br></pre></td></tr></table></figure>
<h4 id="2-11-2-自定义排序（快速排序）"><a href="#2-11-2-自定义排序（快速排序）" class="headerlink" title="2.11.2 自定义排序（快速排序）"></a>2.11.2 自定义排序（快速排序）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">l , r</span>):</span></span><br><span class="line">            <span class="keyword">if</span> l &gt;= r: <span class="keyword">return</span></span><br><span class="line">            i, j = l, r</span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                <span class="keyword">while</span> strs[j] + strs[l] &gt;= strs[l] + strs[j] <span class="keyword">and</span> i &lt; j: j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> strs[i] + strs[l] &lt;= strs[l] + strs[i] <span class="keyword">and</span> i &lt; j: i += <span class="number">1</span></span><br><span class="line">                strs[i], strs[j] = strs[j], strs[i]</span><br><span class="line">            strs[i], strs[l] = strs[l], strs[i]</span><br><span class="line">            quick_sort(l, i - <span class="number">1</span>)</span><br><span class="line">            quick_sort(i + <span class="number">1</span>, r)</span><br><span class="line">        </span><br><span class="line">        strs = [<span class="built_in">str</span>(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">        quick_sort(<span class="number">0</span>, <span class="built_in">len</span>(strs) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(strs)</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhxnlp</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhxnlp.github.io/2023/02/13/数据结构与算法/leetcode练习二：排序/">https://zhxnlp.github.io/2023/02/13/数据结构与算法/leetcode练习二：排序/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhxnlp.github.io">zhxnlpのBlog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a><a class="post-meta__tags" href="/tags/Sort/">Sort</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E4%B8%89%EF%BC%9A%E9%93%BE%E8%A1%A8/"><i class="fa fa-chevron-left">  </i><span>leetcode练习三：链表</span></a></div><div class="next-post pull-right"><a href="/2023/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode%E7%BB%83%E4%B9%A0%E4%B8%80%EF%BC%9A%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/"><span>leetcode练习一：数组（二分查找、双指针、滑动窗口）</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://img-blog.csdnimg.cn/ffe1f736be4548dc9101388503288e4d.png)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2023 By zhxnlp</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>