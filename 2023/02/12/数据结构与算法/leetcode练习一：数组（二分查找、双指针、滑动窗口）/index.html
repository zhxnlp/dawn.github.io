<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="leetcode练习一：数组（二分查找、双指针、滑动窗口）"><meta name="keywords" content="leetcode,Array,Binary Search,Two Pointers,Sliding Window"><meta name="author" content="zhxnlp"><meta name="copyright" content="zhxnlp"><title>leetcode练习一：数组（二分查找、双指针、滑动窗口） | zhxnlpのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"JU6VFRRZVF","apiKey":"ca17f8e20c4dc91dfe1214d03173a8be","indexName":"github-io","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="zhxnlpのBlog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-text">一、 数组理论基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二、 二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">2.1 解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-text">2.2 练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E9%A2%98704"><span class="toc-text">2.2.1  二分查找(题704)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88%E9%A2%9835%EF%BC%89"><span class="toc-text">2.2.2  搜索插入位置（题35）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E6%9F%A5%E6%89%BE%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%B5%B7%E6%AD%A2%E4%BD%8D%E7%BD%AE%EF%BC%88%E9%A2%9834%EF%BC%89"><span class="toc-text">2.2.3  查找排序数组元素起止位置（题34）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%EF%BC%88%E9%A2%98367%EF%BC%89"><span class="toc-text">2.2.4 有效的完全平方数（题367）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%EF%BC%88%E9%A2%9869%EF%BC%89"><span class="toc-text">2.2.5 x 的平方根（题69）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC%EF%BC%88%E9%A2%98162%EF%BC%89"><span class="toc-text">2.2.6 寻找峰值（题162）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-7-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%88%E9%A2%98153%EF%BC%89"><span class="toc-text">2.2.7 寻找旋转排序数组中的最小值（题153）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-8-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-%EF%BC%88%E9%A2%9833%EF%BC%89"><span class="toc-text">2.2.8 搜索旋转排序数组  （题33）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text">三 双指针法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">3.1 解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-text">3.2 练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%EF%BC%88%E9%A2%9826%EF%BC%89"><span class="toc-text">3.2.1 删除排序数组中的重复项（题26）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E7%A7%BB%E5%8A%A8%E9%9B%B6%EF%BC%88%E9%A2%98283%EF%BC%89"><span class="toc-text">3.2.2 移动零（题283）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E9%A2%98844%EF%BC%89"><span class="toc-text">3.2.3 比较含退格的字符串（题844）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%EF%BC%88%E9%A2%98977%EF%BC%89"><span class="toc-text">3.2.4 有序数组的平方（题977）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E9%A2%9888%EF%BC%89"><span class="toc-text">3.2.5 合并两个有序数组（题88）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-6-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E9%A2%98167%EF%BC%89"><span class="toc-text">3.2.6 两数之和 II - 输入有序数组（题167）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-7-%E7%A7%BB%E5%8A%A8%E9%9B%B6%EF%BC%88%E9%A2%98283%EF%BC%89"><span class="toc-text">3.2.7 移动零（题283）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-8-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB%EF%BC%88%E9%A2%9875%EF%BC%89"><span class="toc-text">3.2.8 颜色分类（题75）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">四、滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">4.1 解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-text">4.2 练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88%E9%A2%983%EF%BC%89"><span class="toc-text">4.2.1 无重复字符的最长子串（题3）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%88%E9%A2%98567%EF%BC%89"><span class="toc-text">4.2.2 字符串的排列（题567）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%EF%BC%88%E9%A2%9876%EF%BC%89"><span class="toc-text">4.2.3 最小覆盖子串（题76）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E6%9C%80%E7%9F%AD%E8%B6%85%E4%B8%B2"><span class="toc-text">4.2.4 最短超串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%EF%BC%88%E9%A2%98438%EF%BC%89"><span class="toc-text">4.2.5 找到字符串中所有字母异位词（题438）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-6-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2%EF%BC%88%E9%A2%9830%EF%BC%89"><span class="toc-text">4.2.6 串联所有单词的子串（题30）</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img-blog.csdnimg.cn/92202ef591744a55a05a1fc7e108f4d6.png"></div><div class="author-info__name text-center">zhxnlp</div><div class="author-info__description text-center">nlp</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/zhxnlp">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">58</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">50</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://relph1119.github.io/my-team-learning">relph</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://ifwind.github.io/">ifwind</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://chuxiaoyu.cn/nlp-transformer-summary/">chuxiaoyu</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://img-blog.csdnimg.cn/ffe1f736be4548dc9101388503288e4d.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">zhxnlpのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">leetcode练习一：数组（二分查找、双指针、滑动窗口）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-02-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Data-Structure-and-Algorithms/">Data Structure and Algorithms</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">13k</span><span class="post-meta__separator">|</span><span>阅读时长: 50 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>@[toc]</p>
<blockquote>
<p>资源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problemset/all/">力扣题库</a>、<a target="_blank" rel="noopener" href="https://algo.itcharge.cn/00.Introduction/05.Categories-List/">LeetCode 刷题列表</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录</a></p>
</blockquote>
<h2 id="一、-数组理论基础"><a href="#一、-数组理论基础" class="headerlink" title="一、 数组理论基础"></a>一、 数组理论基础</h2><blockquote>
<p>参考代码随想录<a target="_blank" rel="noopener" href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">《数组理论基础》</a></p>
<p>数组是存放在连续内存空间上的相同类型数据的集合，数组可以方便的通过下标索引的方式获取到下标下对应的数据，例如：<br><img src="https://img-blog.csdnimg.cn/ba939ff642cb4170a7052f4ac65d3563.png" alt="在这里插入图片描述"><br>有两点需要注意：</p>
<ul>
<li>数组下标都是从0开始的。</li>
<li>数组内存空间的地址是连续的<span id="more"></span>
正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：<br><img src="https://img-blog.csdnimg.cn/7b5a3e0d29074bdc9a88e17d60576e9f.png" alt="在这里插入图片描述"><br>那么二维数组在内存的空间地址是连续的么？不同编程语言的内存管理是不一样的。在C++中二维数组是连续分布的，Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。</li>
</ul>
</blockquote>
<h2 id="二、-二分查找"><a href="#二、-二分查找" class="headerlink" title="二、 二分查找"></a>二、 二分查找</h2><h3 id="2-1-解题思路"><a href="#2-1-解题思路" class="headerlink" title="2.1 解题思路"></a>2.1 解题思路</h3><p>&#8195;&#8195;<strong>二分法的前提条件</strong>：数组为有序数组<br>&#8195;&#8195;<strong>循环不变量规则</strong>：在二分查找的过程中，区间的定义是不变量，所以在while寻找中每一次边界的处理都要坚持根据区间的定义来操作。<br>&#8195;&#8195;区间的定义决定了二分法的代码应该如何写。区间的定义一般为两种，左闭右闭即<code>[left, right]</code>，或者左闭右开即<code>[left, right)</code>。</p>
<p>具体思路：</p>
<p><img src="https://img-blog.csdnimg.cn/e59ac11b1c504d989811dd0aad8e01b0.png" alt="在这里插入图片描述"></p>
<p><strong>1. 左闭右闭写法</strong><br>因为定义target在<code>[left, right]</code>区间，所以有如下两点：</p>
<ul>
<li><code>while (left &lt;= right)</code> 要使用 <code>&lt;=</code> ，因为<code>left == right</code>是有意义的，所以使用 &lt;=</li>
<li><code>if (nums[middle] &gt; target)</code> ，right 要赋值为 <code>middle - 1</code>，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<p><strong>2. 左闭右开写法</strong><br>因为定义target在<code>[left, right)</code>区间，所以有如下两点：</p>
<ul>
<li><code>while (left &lt; right)</code>，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li>
<li><code>if (nums[middle] &gt; target)</code> right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>
</ul>
<h3 id="2-2-练习题"><a href="#2-2-练习题" class="headerlink" title="2.2 练习题"></a>2.2 练习题</h3><h4 id="2-2-1-二分查找-题704"><a href="#2-2-1-二分查找-题704" class="headerlink" title="2.2.1  二分查找(题704)"></a>2.2.1  二分查找(题704)</h4><p>解法一：左闭右闭:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = left + (right - left) // <span class="number">2</span> <span class="comment"># 防止溢出 等同于(left + right)/2            </span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &gt; target:</span><br><span class="line">                right = middle - <span class="number">1</span>  <span class="comment"># target在左区间，所以[left, middle - 1]</span></span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &lt; target:</span><br><span class="line">                left = middle + <span class="number">1</span>  <span class="comment"># target在右区间，所以[middle + 1, right]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle  <span class="comment"># 数组中找到目标值，直接返回下标</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 未找到目标值</span></span><br></pre></td></tr></table></figure><br>解法二：左闭右开<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)  <span class="comment"># 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:  <span class="comment"># 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            middle = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &gt; target:</span><br><span class="line">                right = middle  <span class="comment"># target 在左区间，在[left, middle)中</span></span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &lt; target:</span><br><span class="line">                left = middle + <span class="number">1</span>  <span class="comment"># target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle  <span class="comment"># 数组中找到目标值，直接返回下标</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 未找到目标值</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2-2-2-搜索插入位置（题35）"><a href="#2-2-2-搜索插入位置（题35）" class="headerlink" title="2.2.2  搜索插入位置（题35）"></a>2.2.2  搜索插入位置（题35）</h4><p>要在数组中插入目标值，无非是这四种情况：</p>
<ul>
<li>目标值在数组所有元素之前</li>
<li>目标值等于数组中某一个元素（就是上一题）</li>
<li>目标值插入数组中的位置<code>nums[pos−1]&lt;target≤nums[pos]</code></li>
<li>目标值在数组所有元素之后</li>
</ul>
<p>对于数组中没有目标值的情况，其实就是寻找升序数组中第一个大于等于$\textit{target}$ 的下标。经过测试可知，这个下标是<code>right+1（left）</code>，所以本题答案为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span> </span><br><span class="line">        ans=<span class="built_in">len</span>(nums)     </span><br><span class="line">        <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">            mid=(left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;target:</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid]&gt;target:</span><br><span class="line">                right=mid-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> right+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-查找排序数组元素起止位置（题34）"><a href="#2-2-3-查找排序数组元素起止位置（题34）" class="headerlink" title="2.2.3  查找排序数组元素起止位置（题34）"></a>2.2.3  查找排序数组元素起止位置（题34）</h4><p>&#8195;&#8195;直观的思路肯定是从前往后遍历一遍。用两个变量记录第一次和最后一次遇见 $\textit{target}$ 的下标，但这个方法的时间复杂度为 $O(n)$，没有利用到数组升序排列的条件。由于数组已经排序，因此整个数组是单调递增的，我们可以利用二分法来加速查找的过程。</p>
<p>&#8195;&#8195;考虑<code>target</code>开始和结束位置，其实就是查找数组中<strong>第一个等于target 的位置</strong>（记为<code>start</code>）和<strong>第一个大于target 的位置减1</strong>（记为 <code>end</code>）。为了代码的复用，我们定义 <code>lower_bound(nums,target)</code>函数，表示在 $nums$ 数组中二分查找 $target$的位置。</p>
<p>&#8195;&#8195;最后，因为 $target$可能不存在数组中，因此我们需要重新校验我们得到的两个下标，看是否符合条件，如果符合条件就返回<code>[start,end]</code>，不符合就返回<code>[−1,−1]</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">nums,target</span>):</span></span><br><span class="line">            <span class="comment"># lower_bound返回最小的满足nums[i]&gt;=targrt的i</span></span><br><span class="line">            left,right=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>   </span><br><span class="line">            <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">                mid=(left+right)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid]&lt;target:</span><br><span class="line">                    left=mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right=mid-<span class="number">1</span>           </span><br><span class="line">            <span class="keyword">return</span> right+<span class="number">1</span> <span class="comment"># 或left</span></span><br><span class="line">        start=lower_bound(nums,target) <span class="comment"># 第一个大于等于target的下标</span></span><br><span class="line">        <span class="keyword">if</span> start==<span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start]!=target:</span><br><span class="line">        <span class="comment"># 分别对应target大于整个数组和target不在数组中</span></span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end=lower_bound(nums,target+<span class="number">1</span>)-<span class="number">1</span> <span class="comment"># 第一个大于target 的下标</span></span><br><span class="line">        <span class="keyword">return</span> [start,end]</span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-有效的完全平方数（题367）"><a href="#2-2-4-有效的完全平方数（题367）" class="headerlink" title="2.2.4 有效的完全平方数（题367）"></a>2.2.4 有效的完全平方数（题367）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPerfectSquare</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        left,right=<span class="number">1</span>,num</span><br><span class="line">        <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">            mid=(left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid*mid&gt;num:</span><br><span class="line">                right=mid-<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mid*mid&lt;num:</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-5-x-的平方根（题69）"><a href="#2-2-5-x-的平方根（题69）" class="headerlink" title="2.2.5 x 的平方根（题69）"></a>2.2.5 x 的平方根（题69）</h4><p>&#8195;&#8195;由于 x 平方根的整数部分ans 是满足 $k^2 \leq x$的最大 k 值，因此我们可以对 k进行二分查找，从而得到答案。<br>&#8195;&#8195;二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 <code>mid</code> 的平方与 <code>x</code> 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 <code>ans</code> 后，也就不需要再去尝试 <code>ans+1</code> 了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left,right=<span class="number">0</span>,x</span><br><span class="line">        <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">            mid=(left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid*mid&lt;=x: <span class="comment"># 根据牛顿迭代法，可以写mid**2&lt;=x</span></span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
<h4 id="2-2-6-寻找峰值（题162）"><a href="#2-2-6-寻找峰值（题162）" class="headerlink" title="2.2.6 寻找峰值（题162）"></a>2.2.6 寻找峰值（题162）</h4><p>&#8195;&#8195;使用两个指针 left、right 。left 指向数组第一个元素，right 指向数组最后一个元素。取区间中间节点 mid，并比较 nums[mid] 和 nums[mid + 1] 的值大小。</p>
<ul>
<li>如果 nums[mid] 小于 nums[mid + 1]，则右侧存在峰值，令 left = mid + 1。</li>
<li>如果 nums[mid] 大于等于 nums[mid + 1]，则左侧存在峰值，令 right = mid。</li>
</ul>
<p>&#8195;&#8195;最后，当 left == right 时，跳出循环，返回 left。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        left,right=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left </span><br></pre></td></tr></table></figure>
<h4 id="2-2-7-寻找旋转排序数组中的最小值（题153）"><a href="#2-2-7-寻找旋转排序数组中的最小值（题153）" class="headerlink" title="2.2.7 寻找旋转排序数组中的最小值（题153）"></a>2.2.7 寻找旋转排序数组中的最小值（题153）</h4><p>&#8195;&#8195;二分查找的前提条件是数组有序，本题数组经过旋转之后，前半部分和后半部分也都是有序的，所以也可以使用二分查找。<br>&#8195;&#8195;数组经过「旋转」之后，会有两种情况，第一种就是原先的升序序列，另一种是两段升序的序列。第一种的最小值在最左边。第二种最小值在第二段升序序列的第一个元素。</p>
<blockquote>
<p>解说视频见<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solution/jian-dan-yi-dong-javac-pythonjspei-yang-zvoif/">官方题解</a><br><img src="https://img-blog.csdnimg.cn/680d06470b2b446f8d106166d16ea391.png" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>如果 <code>nums[mid] &gt; nums[right]</code>，则最小值一定在 mid 右侧，则令<code>left= mid + 1</code> ，继续查找右侧区间。</li>
<li>如果 <code>nums[mid] ≤ nums[right]</code>，则最小值一定在 mid 左侧，或者 mid 位置，令 <code>right = mid</code> ，继续查找左侧区间。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:         <span class="comment"># 不能取等号，保证查找区间至少有一个元素</span></span><br><span class="line">            mid=(left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;nums[right]:</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;类似题目还有<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a> ，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:			<span class="comment"># 无法判断在 mid 的哪一侧，可以采用 right = right - 1 逐步缩小区域</span></span><br><span class="line">                right = right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure>
<h4 id="2-2-8-搜索旋转排序数组-（题33）"><a href="#2-2-8-搜索旋转排序数组-（题33）" class="headerlink" title="2.2.8 搜索旋转排序数组  （题33）"></a>2.2.8 搜索旋转排序数组  （题33）</h4><p>&#8195;&#8195;原本为升序排列的数组 nums 经过「旋转」之后，会有两种情况，第一种就是原先的升序序列，另一种是两段升序的序列。其实我们可以把第一种情况中的整个数组看做是左半部分，然后右半部分为空数组。所以将旋转后的数组看成左右两个升序部分：左半部分和右半部分。<br>&#8195;&#8195;创建两个指针 left、right，分别指向数组首尾。让后计算出两个指针中间值 mid。将 mid 与两个指针做比较，并考虑与 target 的关系。</p>
<ul>
<li>如果 <code>mid[mid] == target</code>，说明找到了 <code>target</code>，直接返回下标。</li>
<li><p>如果 <code>nums[mid] ≥ nums[left]</code>，则 <code>mid</code> 在左半部分（因为右半部分值都比 <code>nums[left]</code> 小）。</p>
<ul>
<li>如果 <code>nums[mid] ≥ target</code>，并且 <code>target ≥ nums[left]</code>，则 <code>target</code> 在左半部分，并且在 <code>mid</code> 左侧，此时应将 <code>right</code> 左移到 <code>mid - 1</code> 位置。</li>
<li>如果 <code>nums[mid] ≤ target</code>，则 <code>target</code> 在左半部分，并且在 <code>mid</code> 右侧，此时应将 <code>left</code> 右移到 <code>mid + 1</code> 位置。</li>
<li>如果 <code>nums[left] &gt; target</code>，则 <code>target</code> 在右半部分，应将 <code>left</code> 移动到 <code>mid + 1</code> 位置。</li>
</ul>
</li>
<li><p>如果 <code>nums[mid] &lt; nums[left]</code>，则 <code>mid</code> 在右半部分（因为右半部分值都比 <code>nums[left]</code> 小）。</p>
<ul>
<li>如果 <code>nums[mid] &lt; target</code>，并且 <code>target ≤ nums[right]</code>，则 <code>target</code> 在右半部分，并且在 <code>mid</code> 右侧，此时应将 <code>left</code> 右移到 <code>mid + 1</code> 位置。</li>
<li>如果 <code>nums[mid] ≥ target</code>，则 <code>target</code> 在右半部分，并且在 <code>mid</code> 左侧，此时应将 <code>right</code> 左移到 <code>mid - 1</code> 位置。</li>
<li>如果 <code>nums[right] &lt; target</code>，则 <code>target</code> 在左半部分，应将 <code>right</code> 左移到 <code>mid - 1</code> 位置</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= nums[left]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; target <span class="keyword">and</span> target &gt;= nums[left]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>与之类似的还有搜索旋转排序数组 II，区别是数组元素会重复。</p>
<ul>
<li><p>如果 nums[mid] &gt; nums[left]，则 mid 在左半部分（因为右半部分值都比 nums[left] 小）。</p>
<ul>
<li>如果 nums[mid] ≥ target，并且 target ≥ nums[left]，则 target 在左半部分，并且在 mid 左侧，此时应将 right 左移到 mid - 1 位置。</li>
<li>否则如果 nums[mid] &lt; target，则 target 在左半部分，并且在 mid 右侧，此时应将 left 右移到 mid + 1。</li>
<li>否则如果 nums[left] &gt; target，则 target 在右半部分，应将 left 移动到 mid + 1 位置。</li>
</ul>
</li>
<li><p>如果 nums[mid] &lt; nums[left]，则 mid 在右半部分（因为右半部分值都比 nums[left] 小）。</p>
<ul>
<li>如果 nums[mid] &lt; target，并且 target ≤ nums[right]，则 target 在右半部分，并且在 mid 右侧，此时应将 left 右移到 mid + 1 位置。</li>
<li>否则如果 nums[mid] ≥ target，则 target 在右半部分，并且在 mid 左侧，此时应将 right 左移到 mid - 1 位置。</li>
<li>否则如果 nums[right] &lt; target，则 target 在左半部分，应将 right 左移到 mid - 1 位置。</li>
</ul>
</li>
<li>最终判断 <code>nums[left]</code> 是否等于 <code>target</code>，如果等于，则返回 <code>True</code>，否则返回 <code>False</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[left]:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt;= nums[mid]:</span><br><span class="line">                    right = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[left]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = left + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left] == target</span><br></pre></td></tr></table></figure>
<h2 id="三-双指针法"><a href="#三-双指针法" class="headerlink" title="三 双指针法"></a>三 双指针法</h2><h3 id="3-1-解题思路"><a href="#3-1-解题思路" class="headerlink" title="3.1 解题思路"></a>3.1 解题思路</h3><p>以 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">移除元素（27）</a>举例，介绍双指针法。</p>
<ul>
<li>暴力解法：这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。删除过程如下：<br><img src="https://img-blog.csdnimg.cn/0b48363fc58d4b4e9ce57f829a9e4d26.gif#pic_center" alt="在这里插入图片描述"></li>
</ul>
<p>很明显暴力解法的时间复杂度是$O(n^2)$，空间复杂度：$O(1)$。</p>
<ul>
<li>双指针法（快慢指针法）： 右指针 <code>right</code> 指向当前将要处理的元素，左指针<code>left</code> 指向下一个将要赋值的位置。通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。<ul>
<li>如果右指针指向的元素不等于 <code>val</code>，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</li>
<li>如果右指针指向的元素等于 <code>val</code>，它不能在输出数组里，此时左指针不动，右指针右移一位。<br><img src="https://img-blog.csdnimg.cn/8fa2b816816c4b008382a2fc76c19abb.gif#pic_center" alt="在这里插入图片描述"><br>&#8195;&#8195;整个过程保持不变的性质是：区间<code>[0,left)</code> 中的元素都不等于 <code>val</code>。当左右指针遍历完输入数组以后，<code>left</code> 的值就是输出数组的长度。这样的算法在最坏情况下（输入数组中没有元素等于<code>val</code>），左右指针各遍历了数组一次。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        fast = <span class="number">0</span>  <span class="comment"># 快指针</span></span><br><span class="line">        slow = <span class="number">0</span>  <span class="comment"># 慢指针</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> fast &lt; size:  <span class="comment"># a = size 时，nums[a] 会越界</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            slow 用来收集不等于 val 的值，如果 fast 对应值不等于 val，</span></span><br><span class="line"><span class="string">            则把它与 slow 替换，同时slow+1。fast不管是否等于val，始终都有fast+1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<ul>
<li>双指针优化：<ul>
<li>思路：如果要移除的元素恰好在数组的开头，例如序列 <strong>[1,2,3,4,5]</strong>，当 <code>val</code> 为 1时，我们需要把每一个元素都左移一位。注意到题目中说：<strong>「元素的顺序可以改变」</strong>。实际上我们可以直接将最后一个元素 5 移动到序列开头，取代元素 1，得到序列 [5,2,3,4]，同样满足题目要求。这个优化在序列中<code>val</code> 元素的数量较少时非常有效。</li>
<li>算法：实现方面，我们依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。<br>&#8195;&#8195;如果左指针 <code>left</code> 指向的元素等于 <code>val</code>，此时将右指针<code>right</code> 指向的元素复制到左指针 <code>left</code> 的位置，然后右指针 <code>right</code> 左移一位。如果赋值过来的元素恰好也等于<code>val</code>，可以继续把右指针 <code>right</code> 指向的元素的值赋值过来（左指针<code>left</code> 指向的等于<code>val</code> 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 <code>val</code> 为止。<br>&#8195;&#8195;当左指针<code>left</code> 和右指针<code>right</code> 重合的时候，左右指针遍历完数组中所有的元素。<br>&#8195;&#8195;<font color='deeppink'>这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作</font>。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow,fast=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> slow &lt;=fast:</span><br><span class="line">            <span class="keyword">if</span> nums[slow] ==val:</span><br><span class="line">                nums[slow]=nums[fast]</span><br><span class="line">                fast-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                slow+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-练习题"><a href="#3-2-练习题" class="headerlink" title="3.2 练习题"></a>3.2 练习题</h3><h4 id="3-2-1-删除排序数组中的重复项（题26）"><a href="#3-2-1-删除排序数组中的重复项（题26）" class="headerlink" title="3.2.1 删除排序数组中的重复项（题26）"></a>3.2.1 删除排序数组中的重复项（题26）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast = <span class="number">1</span> <span class="comment"># 快指针,因为后面会用到fast-1，所以fast赋值从1开始</span></span><br><span class="line">        slow = <span class="number">1</span> <span class="comment"># 慢指针</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> fast &lt; size:  <span class="comment"># a = size 时，nums[a] 会越界</span></span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[fast-<span class="number">1</span>]: <span class="comment"># 判断很前一个数是否重复</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-移动零（题283）"><a href="#3-2-2-移动零（题283）" class="headerlink" title="3.2.2 移动零（题283）"></a>3.2.2 移动零（题283）</h4><p><strong>思路：使非0元素左移，等同于使0往右移。</strong><br>算法：使用双指针，右指针不断向右移动。每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移，否则只有右指针右移，左指针不动。<br>&#8195;&#8195;每次交换，都是将左指针的零与右指针的非零数交换，结果就是左右指针之间都是0。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left,right = <span class="number">0</span>,<span class="number">0</span>  </span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):  <span class="comment"># a = size 时，nums[a] 会越界</span></span><br><span class="line">            <span class="keyword">if</span> nums[right] != <span class="number">0</span>: </span><br><span class="line">                nums[left],nums[right] = nums[right], nums[left]       </span><br><span class="line">                left+= <span class="number">1</span></span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">               </span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></p>
<p>&#8195;&#8195;也可以看做是参考了快速排序的思想，用0当做这个中间点，把不等于0(注意题目没说不能有负数)的放到中间点的左边，等于0的放到其右边。使用两个指针left和right，只要nums[right]!=0，我们就交换nums[left]和nums[right]：<br><img src="https://img-blog.csdnimg.cn/2a42cabfcf6d48c78589c4082f62cdeb.gif#pic_center =500x" alt="在这里插入图片描述"><br>用for循环写出来就是：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">		<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">		:type nums: List[int]</span></span><br><span class="line"><span class="string">		:rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">		&quot;&quot;&quot;</span>		</span><br><span class="line">		left = <span class="number">0</span> </span><br><span class="line">		<span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">			<span class="comment"># 当前元素!=0，就把其交换到左边，等于0的交换到右边</span></span><br><span class="line">			<span class="keyword">if</span> nums[right]:</span><br><span class="line">				nums[left],nums[right] = nums[right],nums[left]</span><br><span class="line">				left += <span class="number">1</span></span><br></pre></td></tr></table></figure><br>如果right指针指向末尾来进行交换，会改变非0元素顺序。</p>
<h4 id="3-2-3-比较含退格的字符串（题844）"><a href="#3-2-3-比较含退格的字符串（题844）" class="headerlink" title="3.2.3 比较含退格的字符串（题844）"></a>3.2.3 比较含退格的字符串（题844）</h4><p>&#8195;&#8195;栈有后进先出的特性，比如网页的后退、文本编辑中的撤销操作等，这些操作的特性都契合这个特性，本题也是一样，所以可以考虑用栈来处理。<br><strong>方法一：重构字符串</strong>：用栈处理遍历过程，每次我们遍历到一个字符：</p>
<ul>
<li>如果它是退格符，那么我们将栈顶弹出；</li>
<li>如果它是普通字符，那么我们将其压入栈中。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       :type s: str</span></span><br><span class="line"><span class="string">       :type t: str</span></span><br><span class="line"><span class="string">       :rtype: bool</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">s</span>):</span></span><br><span class="line">           ls = <span class="built_in">list</span>()</span><br><span class="line">           <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">               <span class="keyword">if</span> ch != <span class="string">&quot;#&quot;</span>:</span><br><span class="line">                   ls.append(ch)</span><br><span class="line">               <span class="keyword">elif</span> ls:</span><br><span class="line">                   ls.pop()</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ls)</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> build(s) == build(t)</span><br></pre></td></tr></table></figure>
复杂度分析</li>
<li>时间复杂度：$O(N+M)$，其中 N 和 M分别为字符串 S 和 T 的长度。我们需要遍历两字符串各一次。</li>
<li>空间复杂度：$O(N+M)$，其中 N 和 M 分别为字符串 S 和 T 的长度。主要为还原出的字符串的开销。</li>
</ul>
<p><strong>方法二：双指针</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back</span>(<span class="params">s</span>):</span></span><br><span class="line">            s=<span class="built_in">list</span>(s)</span><br><span class="line">            slow,fast=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> fast&lt;<span class="built_in">len</span>(s):</span><br><span class="line">            	<span class="comment"># 只要快指针不是指向&#x27;#&#x27;就将其赋值给慢指针，同时慢指针右移</span></span><br><span class="line">                <span class="keyword">if</span> s[fast]!=<span class="string">&quot;#&quot;</span>: </span><br><span class="line">                    s[slow]=s[fast]</span><br><span class="line">                    slow+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 当快指针指向&#x27;#&#x27;时慢指针后退一格</span></span><br><span class="line">                    <span class="keyword">if</span> slow&gt;<span class="number">0</span>: <span class="comment"># 慢指针指向空不再退格</span></span><br><span class="line">                        slow-=<span class="number">1</span></span><br><span class="line">                fast+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s[:slow]</span><br><span class="line">        <span class="keyword">return</span> back(s)==back(t)</span><br></pre></td></tr></table></figure>
<p><strong>方法三：双指针（官方）</strong></p>
<p>&#8195;&#8195;一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。<br>&#8195;&#8195;具体地，我们定义<code>skip</code> 表示当前待删除的字符的数量。每次我们遍历到一个字符：</p>
<ul>
<li>若该字符为退格符，则我们需要多删除一个普通字符，我们让<code>skip + 1</code>；</li>
<li>若该字符为普通字符：<ul>
<li>若<code>skip</code> 为 0，则说明当前字符不需要删去；</li>
<li>若 <code>skip</code> 不为 0，则说明当前字符需要删去，我们让<code>skip - 1</code>。</li>
</ul>
</li>
</ul>
<p>&#8195;&#8195;所以可以定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。<br><img src="https://img-blog.csdnimg.cn/img_convert/3a7cbd6ec5903c4662a4fd993983dbc1.gif#pic_center =500x" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        up,down=<span class="built_in">len</span>(s)-<span class="number">1</span>,<span class="built_in">len</span>(t)-<span class="number">1</span></span><br><span class="line">        skip_s,skip_t=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> up&gt;=<span class="number">0</span> <span class="keyword">or</span> down&gt;=<span class="number">0</span>: <span class="comment">#同时遍历两个字符串</span></span><br><span class="line">            <span class="keyword">while</span> up&gt;=<span class="number">0</span>:     <span class="comment"># 先逆序遍历s中字符串，找到不需要删除的普通字符</span></span><br><span class="line">                <span class="keyword">if</span> s[up]==<span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    skip_s+=<span class="number">1</span></span><br><span class="line">                    up-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> skip_s&gt;<span class="number">0</span>:</span><br><span class="line">                        up-=<span class="number">1</span></span><br><span class="line">                        skip_s-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">while</span> down&gt;=<span class="number">0</span>:           <span class="comment"># 先逆序遍历s中字符串，找到不需要删除的普通字符</span></span><br><span class="line">                <span class="keyword">if</span> t[down]==<span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    skip_t+=<span class="number">1</span></span><br><span class="line">                    down-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> skip_t&gt;<span class="number">0</span>:</span><br><span class="line">                        down-=<span class="number">1</span></span><br><span class="line">                        skip_t-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 开始进行字符对比</span></span><br><span class="line">            <span class="keyword">if</span> up&gt;=<span class="number">0</span> <span class="keyword">and</span> down&gt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> s[up]!=t[down]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 存在一个字符串遍历完而另一个还没遍历完的情况，此时也是返回False</span></span><br><span class="line">            <span class="keyword">elif</span> up&gt;=<span class="number">0</span> <span class="keyword">or</span> down&gt;=<span class="number">0</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 无论何种情况都要开始遍历到下一个位置</span></span><br><span class="line">            up-=<span class="number">1</span></span><br><span class="line">            down-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-4-有序数组的平方（题977）"><a href="#3-2-4-有序数组的平方（题977）" class="headerlink" title="3.2.4 有序数组的平方（题977）"></a>3.2.4 有序数组的平方（题977）</h4><p>&#8195;&#8195;本题主要思路是原数组nuns本身是有序的，只不过负数的平方反过来成了降序。比如[-3,-2,-1]是升序的，其平方[9,4,1]成了降序。这样造成数组每个元素平方之后，是一个两边大中间小的结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [-<span class="number">4</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line">平方：nums =[<span class="number">16</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;此时可以考虑使用一个额外的列表ls，初始化为与nums等长。然后使用指针<code>idx</code>从后往前遍历ls，则每次最大的元素一定是从nums的两端往中间取，至于具体是左端还是右端，比较这两个元素就行。故考虑使用左右指针<code>left</code>和<code>right</code>，分别从0和-1的位置开始遍历。具体的：</p>
<ul>
<li>若 <code>nums[left]**2&lt;=nums[right]**2</code>，则<code>ls[idx]=nums[right]**2</code>，同时左指针往右一格遍历nums左侧的下一个元素</li>
<li>若 <code>nums[left]**2&gt;nums[right]**2</code>，则<code>ls[idx]=nums[left]**2</code>，同时右指针往左一格遍历nums右侧的下一个元素</li>
<li>每次ls赋值完，指针<code>idx</code>都左移一格，即<code>idx-=1</code>。</li>
</ul>
<p>参考别人图解则是：</p>
<p><img src="https://img-blog.csdnimg.cn/59899153594b461c9d428284918610bf.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始化额外数组ls，初始赋值nums左右指针和数组ls的末端指针idx       </span></span><br><span class="line">        ls=[-<span class="number">1</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        left,right,idx=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 开始从末端遍历ls，最大值只会来自nums的两端，故遍历左右指针，更大的数赋值给ls[idx]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;=right:</span><br><span class="line">            <span class="keyword">if</span> nums[left]**<span class="number">2</span>&lt;=nums[right]**<span class="number">2</span>:</span><br><span class="line">                ls[idx]=nums[right]**<span class="number">2</span></span><br><span class="line">                <span class="comment"># 右侧更大则赋值给ls[idx]，同时right和idx都右移一位</span></span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">                idx-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ls[idx]=nums[left]**<span class="number">2</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                idx-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ls</span><br></pre></td></tr></table></figure>
<h4 id="3-2-5-合并两个有序数组（题88）"><a href="#3-2-5-合并两个有序数组（题88）" class="headerlink" title="3.2.5 合并两个有序数组（题88）"></a>3.2.5 合并两个有序数组（题88）</h4><p>&#8195;&#8195;给你两个按 非递减顺序 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，其元素个数分别是 <code>m</code> 和 <code>n</code> 。请你 合并 <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>&#8195;&#8195;注意：最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p>示例 ：</p>
<ul>
<li>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</li>
<li>输出：[1,2,2,3,5,6]</li>
<li>解释：需要合并 [1,2,3] 和 [2,5,6] 。</li>
<li>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</li>
<li>nums1.length == m + n，0 &lt;= m, n &lt;= 200</li>
</ul>
<p>&#8195;&#8195;这道题和上一题很相似，两个数组都是有序的，为了利用这一性质，我们可以使用双指针方法，每次将两个数组中更大的元素放在<code>nums1</code>末尾。这样做是为了不使用额外的存储空间，所以需要倒序遍历。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># p1和p2分别指向两个数组的末尾，倒序遍历</span></span><br><span class="line">        p1,p2=m-<span class="number">1</span>,n-<span class="number">1</span></span><br><span class="line">        idx=m+n-<span class="number">1</span></span><br><span class="line">        <span class="comment"># p1、p2如果不限制可以为负值，也能表示下标，所以不能单纯设置idx》0</span></span><br><span class="line">        <span class="keyword">while</span> p1&gt;=<span class="number">0</span> <span class="keyword">and</span> p2&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># print(p1,p2,idx)</span></span><br><span class="line">            <span class="keyword">if</span> nums1[p1]&gt;nums2[p2]:</span><br><span class="line">            	<span class="comment"># 这里写nums1[idx]=nums1[p1]结果也正确，下同</span></span><br><span class="line">                nums1[idx],nums1[p1]=nums1[p1],nums1[idx]</span><br><span class="line">                p1-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[idx],nums2[p2]=nums2[p2],nums1[idx]</span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">            idx-=<span class="number">1</span> </span><br><span class="line">        <span class="comment"># 当nums1序列中大数排完后，p1=0,循环终止，此时p2可能还有剩下的数，这些数都是最小的一部分，直接接到nums1前面</span></span><br><span class="line">        <span class="comment"># print(nums2[:p2+1] )</span></span><br><span class="line">        nums1[:p2+<span class="number">1</span>]=nums2[:p2+<span class="number">1</span>]         </span><br><span class="line">        <span class="keyword">return</span> nums1</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-6-两数之和-II-输入有序数组（题167）"><a href="#3-2-6-两数之和-II-输入有序数组（题167）" class="headerlink" title="3.2.6 两数之和 II - 输入有序数组（题167）"></a>3.2.6 两数之和 II - 输入有序数组（题167）</h4><p>&#8195;&#8195;这道题和两数之和（题3）的区别是，数组是有序的。所以可以考虑使用两个指针分别遍历数组，如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。重复上述操作，直到找到答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            total = numbers[low] + numbers[high]</span><br><span class="line">            <span class="keyword">if</span> total == target:</span><br><span class="line">                <span class="keyword">return</span> [low + <span class="number">1</span>, high + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="3-2-7-移动零（题283）"><a href="#3-2-7-移动零（题283）" class="headerlink" title="3.2.7 移动零（题283）"></a>3.2.7 移动零（题283）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">		<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">		:type nums: List[int]</span></span><br><span class="line"><span class="string">		:rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">		&quot;&quot;&quot;</span>		</span><br><span class="line">		left = <span class="number">0</span> <span class="comment"># 两个指针l和r</span></span><br><span class="line">		<span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">			<span class="comment"># 当前元素!=0，就把其交换到左边，等于0的交换到右边</span></span><br><span class="line">			<span class="keyword">if</span> nums[right]:</span><br><span class="line">				nums[left],nums[right] = nums[right],nums[left]</span><br><span class="line">				left += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-8-颜色分类（题75）"><a href="#3-2-8-颜色分类（题75）" class="headerlink" title="3.2.8 颜色分类（题75）"></a>3.2.8 颜色分类（题75）</h4><p><strong>方法一：单指针</strong><br>&#8195;&#8195;这道题和上一题很类似，最简单的方法是遍历两次，先将0排到最前面，再接着将1排到前面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 两次遍历，先排0再排1</span></span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">0</span>:</span><br><span class="line">                nums[left],nums[i]=nums[i],nums[left]</span><br><span class="line">                left+=<span class="number">1</span>  </span><br><span class="line">                              </span><br><span class="line">        right=left  <span class="comment"># 前面left个位置已经排好了0     </span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j]==<span class="number">1</span>:</span><br><span class="line">                nums[right],nums[j]=nums[j],nums[right]</span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
<p><strong>方法二：双指针（官方题解）</strong><br>&#8195;&#8195;我们可以额外使用一个指针，即使用两个指针分别用来交换 0 和1。具体地，我们用指针 $p_0$来交换 0，$p_1$来交换 1，初始值都为 0。当我们从左向右遍历整个数组时：</p>
<ul>
<li>如果找到了 1，那么将其与 $nums[p_1]$ 进行交换，并将 $p_1$向后移动一个位置，这与方法一是相同的；</li>
<li>如果找到了 0，那么将其与 $nums[p_0]$ 进行交换，并将 $p_0$向后移动一个位置。这样做是正确的吗？<br>&#8195;&#8195;我们可以注意到，因为连续的 0 之后是连续的 1，因此如果我们将 0 与$nums[p_0]$ 进行交换，那么我们可能会把一个 1 交换出去。当 $p_0 &lt; p_1$时，我们已经将一些 1 连续地放在头部，此时一定会把一个 1 交换出去，导致答案错误。因此，如果$p_0 &lt; p_1$，那么我们需要再将 $nums[i]$ 与$nums[p_1]$进行交换，其中 i 是当前遍历到的位置。<br>&#8195;&#8195;在进行了第一次交换后，$nums[i]$的值为 1，我们需要将这个 1 放到「头部」的末端。在最后，无论是否有 $p_0 &lt; p_1$，我们需要将 $p_0$ 和 $p_1$均向后移动一个位置，而不是仅将 $p_0$向后移动一个位置。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 两个指针分别用于交换0和1</span></span><br><span class="line">        p0=p1=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">1</span>:</span><br><span class="line">                nums[i],nums[p1]=nums[p1],nums[i]</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i]==<span class="number">0</span>:</span><br><span class="line">                nums[i],nums[p0]=nums[p0],nums[i]</span><br><span class="line">                <span class="keyword">if</span> p0&lt;p1:</span><br><span class="line">                    nums[i],nums[p1]=nums[p1],nums[i]</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">                p0+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
<p><strong>方法三：快速排序</strong><br>&#8195;&#8195;我们也可以借鉴快速排序算法中的 <code>partition</code> 过程，将 1 作为基准数 <code>pivot</code>，然后将序列分为三部分：0（即比 1 小的部分）、等于 1 的部分、2（即比 1 大的部分）。具体步骤如下：</p>
<ol>
<li>使用两个指针 left、right，分别指向数组的头尾。left 表示当前处理好红色元素的尾部，right 表示当前处理好蓝色的头部。</li>
<li>再使用一个下标 index 遍历数组，如果遇到 <code>nums[index] == 0</code>，就交换 nums[index] 和 nums[left]，同时将 left 右移。如果遇到 <code>nums[index] == 2</code>，就交换 nums[index] 和 nums[right]，同时将 right 左移。</li>
<li>直到 index 移动到 right 位置之后，停止遍历。遍历结束之后，此时 left 左侧都是红色，right 右侧都是蓝色。</li>
<li>注意：移动的时候需要判断 index 和 left 的位置，因为 left 左侧是已经处理好的数组，所以需要判断 index 的位置是否小于 left，小于的话，需要更新 index 位置。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> index &lt; left:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[index] == <span class="number">0</span>:</span><br><span class="line">                nums[index], nums[left] = nums[left], nums[index]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[index] == <span class="number">2</span>:</span><br><span class="line">                nums[index], nums[right] = nums[right], nums[index]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="四、滑动窗口"><a href="#四、滑动窗口" class="headerlink" title="四、滑动窗口"></a>四、滑动窗口</h2><h3 id="4-1-解题思路"><a href="#4-1-解题思路" class="headerlink" title="4.1 解题思路"></a>4.1 解题思路</h3><p>下面以<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组（题209）</a>这一题讲解滑动窗口的思路。</p>
<p>&#8195;&#8195;给定一个含有 n 个正整数的数组<code>nums</code>和一个正整数 <code>target</code> 。找出该数组中满足其和 <code>≥ target</code> 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<ul>
<li>示例1：<ul>
<li>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li>
<li>输出：2</li>
<li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li>
</ul>
</li>
<li>示例2：<ul>
<li>输入：target = 11, nums = [1,1,1,1,1,1,1,1]</li>
<li>输出：0</li>
</ul>
</li>
</ul>
<hr>
<p><strong>解法一：暴力解法</strong><br>&#8195;&#8195;使用两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是$O(n^2)$。<br>&#8195;&#8195;具体的，先初始化子数组的最小长度为无穷大，枚举数组<code>nums</code> 中的每个下标作为子数组的开始下标，对于每个开始下标 <code>i</code>，需要找到大于或等于 <code>i</code> 的最小下标 <code>j</code>，使得从 <code>[nums[i] , nums[j] ]</code>的元素和大于或等于 <code>s</code>，并更新子数组的最小长度（此时子数组的长度是 <code>j−i+1</code>）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, s: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = n + <span class="number">1</span> <span class="comment"># 存储最小数组长度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n): <span class="comment"># 计算位置i到位置j的元素和</span></span><br><span class="line">                total += nums[j]</span><br><span class="line">                <span class="keyword">if</span> total &gt;= s:</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, j - i + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>
<p><strong>解法二：滑动窗口</strong><br><img src="https://img-blog.csdnimg.cn/59a05f1ae642403094f95e0a98bbc03e.png" alt="在这里插入图片描述"><br>&#8195;&#8195;思路：使用一个动态区间，维护整个区间的和都是大于等于target，从左往右遍历并不断更新动态区间的长度。以题目中的示例来举例，target = 7, nums = [2,3,1,2,4,3]来看一下查找的过程：</p>
<p><img src="https://img-blog.csdnimg.cn/385cf314302446e8819771dd3d143bd8.gif#pic_center" alt="在这里插入图片描述"><br>&#8195;&#8195;其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做<strong>滑动窗口</strong>更适合一些。<br>&#8195;&#8195;在本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？：满足其和 ≥ s 的长度最小的 连续 子数组。</li>
<li>如何移动窗口的起始位置？：如果当前窗口的值大于s了，窗口就要向前移动了</li>
<li>如何移动窗口的结束位置？：窗口的结束位置就是遍历数组的指针</li>
</ul>
<p>&#8195;&#8195;具体的，将右指针<code>right</code>遍历到数组的最右端，遍历过程中，求出当前子数组的和（使用一个变量<code>total</code>来维护）。在<code>total &gt;= target</code>时，我们就缩小区间，即左指针移右移，此时需要<code>total-nums[left]</code>更新区间和，并更新区间长度<code>ans</code>。然后 右指针继续右移，这样我们总是保证了<code>total &gt;= target</code>。 最终右指针右移到数组末尾依旧没找到<code>total &gt;= target</code>，或者找到最短子数组长度<code>ans</code>。</p>
<blockquote>
<p>&#8195;&#8195;注意，只有<code>total &gt;= target</code>时，左指针才会移动。因此，当右指针移动到下一个位置时，总是有前缀和<code>total &gt;= s</code>。可以看作是，每次左指针移动都是在找到一个新的更短的符合条件的连续子数组，因此维护的总和total一定是<code>&gt;=s</code>的，而答案一定是更新的。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, target, nums</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="comment">#  初始化左右指针、区间和以及区间长度</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            ans = n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#  移动右指针，计算当前子数组的和</span></span><br><span class="line">            <span class="keyword">while</span> right &lt; n:</span><br><span class="line">                total += nums[right]</span><br><span class="line">                <span class="comment"># 只要和大于目标值，左指针就一直右移</span></span><br><span class="line">                <span class="keyword">while</span> total &gt;= target:       </span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, right - left + <span class="number">1</span>) <span class="comment"># 先更新区间长度再移动指针        </span></span><br><span class="line">                    total -= nums[left]  <span class="comment"># 区间和减去刚刚舍去的左指针的值</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将$O(n^2)$暴力解法降为$O(n)$。</p>
<h3 id="4-2-练习题"><a href="#4-2-练习题" class="headerlink" title="4.2 练习题"></a>4.2 练习题</h3><h4 id="4-2-1-无重复字符的最长子串（题3）"><a href="#4-2-1-无重复字符的最长子串（题3）" class="headerlink" title="4.2.1 无重复字符的最长子串（题3）"></a>4.2.1 无重复字符的最长子串（题3）</h4><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<ul>
<li>输入: s = “abcabcbb”</li>
<li>输出: 3 </li>
<li>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</li>
</ul>
<hr>
<p><strong>方法一：官方解法</strong></p>
<p>&#8195;&#8195;使用两个指针表示最长子串的左右边界，依次递增地枚举子串的起始位置<code>left</code>。假设<code>left=k</code>，我们得到了不含重复字符的最长子串的结束位置为<code>right</code>。那么下一次遍历到<code>left=k+1</code>时，k+1到right这个区间字符串仍是不重复的。由于left左移，区间缩小，故right应该右移遍历，直到右侧出现了重复字符为止。<br>&#8195;&#8195;在上面的流程中，我们还需要使用一种数据结构来判断是否有重复的字符，可以直接使用集合。在左指针右移动的时候，我们从集合中移除一个字符；在右指针向右移动的时候，我们往集合中添加一个字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        se = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        right, ans = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>: <span class="comment"># 从第二个字符开始删除</span></span><br><span class="line">                <span class="comment"># 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                se.remove(s[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> right + <span class="number">1</span> &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> s[right + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> se:</span><br><span class="line">                <span class="comment"># 不断地移动右指针</span></span><br><span class="line">                se.add(s[right + <span class="number">1</span>])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p><strong>方法二：滑动窗口</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">        left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="comment"># 因为重复的元素会出现在任何位置，比如&#x27;abccd&#x27;，不能简单的用列表pop(0)</span></span><br><span class="line">        <span class="comment"># 和位置无关的位置结构，可以选用集合</span></span><br><span class="line">        se=<span class="built_in">set</span>() </span><br><span class="line">        ans=<span class="number">0</span> <span class="comment"># 子串长度初始化为0，当s为空时，不会进入for循环，此时长度依旧为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 指针右移，首先添加第一个元素 </span></span><br><span class="line">            <span class="keyword">while</span> s[right] <span class="keyword">in</span> se:</span><br><span class="line">            <span class="comment"># 当右指针遇到重复元素时，左指针右移，当前长度减一</span></span><br><span class="line">            <span class="comment"># 直到右指针不再和集合中元素重复                                        </span></span><br><span class="line">                se.remove(s[left])</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                      </span><br><span class="line">            ans=<span class="built_in">max</span>(ans,right-left+<span class="number">1</span>)     </span><br><span class="line">            se.add(s[right])            </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：应该将<code>se.add(s[right])</code> 放在 <code>while</code> 循环之后，否则每次集合先添加，就肯定可以进while循环了。</p>
</blockquote>
<p>方法三：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">	    <span class="comment"># 定义当前最长不重复子串的长度</span></span><br><span class="line">	    le = <span class="number">0</span></span><br><span class="line">	    <span class="comment"># 定义字典，用于记录每个字符最后一次出现的位置</span></span><br><span class="line">	    d = &#123;&#125;</span><br><span class="line">	    <span class="comment"># 定义left指针，用于维护当前子串</span></span><br><span class="line">	    left = -<span class="number">1</span></span><br><span class="line">	    	    </span><br><span class="line">	    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)): 		          </span><br><span class="line">	        <span class="keyword">if</span> s[r] <span class="keyword">in</span> d:       		     <span class="comment"># 如果当前字符已经在字典中出现过	           </span></span><br><span class="line">	            left = <span class="built_in">max</span>(left, d[s[r]])    <span class="comment"># 更新left指针位置</span></span><br><span class="line">	        d[s[r]] = r					     <span class="comment"># 更新当前字符最后一次出现的位置</span></span><br><span class="line">	        <span class="comment"># 更新最长不重复子串的长度</span></span><br><span class="line">	        le = <span class="built_in">max</span>(le, r - left)</span><br><span class="line">	    <span class="keyword">return</span> le</span><br></pre></td></tr></table></figure></p>
<p>&#8195;&#8195;上面代码中，首先定义了当前最长不重复子串的长度 <code>le</code>，用于记录结果；字典 <code>d</code>，用于记录每个字符最后一次出现的位置；<code>left</code>指针，用于维护当前子串。</p>
<p>&#8195;&#8195;接下来使用for循环遍历字符串<code>s</code>，对于每个字符，如果当前字符已经在字典中出现过，那么<code>left</code>指针应该跳到该字符上一次出现的位置的后面一个位置，这样才能保证当前子串中没有重复字符。然后更新当前字符最后一次出现的位置，遍历right指针并更新答案即可。<br>&#8195;&#8195;需要注意的是，重复字符上一次出现的位置可能会更小（比如’abbac’），故需要设置为<code>max(left, d[s[r]])</code>。</p>
<h4 id="4-2-2-字符串的排列（题567）"><a href="#4-2-2-字符串的排列（题567）" class="headerlink" title="4.2.2 字符串的排列（题567）"></a>4.2.2 字符串的排列（题567）</h4><p>&#8195;&#8195;给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。换句话说，s1 的排列之一是 s2 的 子串 。</p>
<ul>
<li>输入：s1 = “ab” s2 = “eidbaooo”</li>
<li>输出：true</li>
<li>解释：s2 包含 s1 的排列之一 (“ba”).</li>
</ul>
<hr>
<p>这道题是 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a> 的简单版本。解题思路：<strong>滑动窗口 + 字典</strong></p>
<ul>
<li><p>分析一： 题目要求 s1 的排列之一是 s2 的一个子串。而子串必须是连续的，所以要求的 s2 子串的长度跟 s1 长度必须相等。</p>
</li>
<li><p>分析二： 那么我们有必要把 s1 的每个排列都求出来吗？当然不用。如果字符串 a 是 b 的一个排列，那么当且仅当它们两者中的每个字符的个数都必须完全相等。</p>
</li>
</ul>
<p>&#8195;&#8195;所以，根据上面两点分析，我们已经能确定这个题目可以使用 滑动窗口 + 字典 来解决。</p>
<p>&#8195;&#8195;我们使用一个长度和 s1 长度相等的固定窗口大小的滑动窗口，在 s2 上面从左向右滑动，判断 s2 在滑动窗口内的每个字符出现的个数是否跟 s1 每个字符出现次数完全相等。</p>
<p>&#8195;&#8195;我们定义 <code>counter1</code> 是对 s1 内字符出现的个数的统计，定义 <code>counter2</code> 是对 s2 内字符出现的个数的统计。在窗口每次右移的时候，需要把右边新加入窗口的字符个数在 counter2 中加 1，把左边移出窗口的字符的个数减 1。 <code>if counter1 == counter2</code> ，那么说明窗口内的子串是 s1  的一个排列，返回 <code>True</code>；如果窗口已经把 s2 遍历完了仍然没有找到满足条件的排列，返回 <code>False</code>。</p>
<p>&#8195;&#8195;对于题目给的示例一：s1 = “ab” s2 = “eidbaooo”，我制作了滑动窗口过程的动画帮助理解：</p>
<p><img src="https://img-blog.csdnimg.cn/5f7643a7e62149a3874d15f309fbdb6b.gif#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.gif.cn/tools/compress">gif动图裁剪压缩网站</a></p>
</blockquote>
<p><strong>躲坑指南：</strong></p>
<ul>
<li>本题中的 <code>counter</code> 可以用字典，也可以用数组来实现。用字典的时候，需要注意：如果移除 <code>left</code> 元素后，若 <code>counter2[s2[left]] == 0</code> 那么需要从字典中删除 <code>s2[left]</code> 这个key。因为 <code>&#123;&quot;a&quot;:0, &quot;b&quot;:1&#125;</code> 和 <code>&#123;&quot;b&quot;:1&#125;</code> 是不等的。</li>
<li>窗口的定义一定要搞清楚是否包含两边的端点，比如我定义的窗口是 <code>[left, right]</code> 两个端点都包含，那么就需要把两个端点的元素也放入 <code>counter2</code> 中。</li>
<li><code>counter2</code> 初始化的时候只放了 <code>[0, right - 1]</code> 个元素，因为在 while 循环中的第一行就是把 <code>right</code> 元素放到 <code>counter2</code> 中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span>(<span class="params">self, s1, s2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s1: str</span></span><br><span class="line"><span class="string">        :type s2: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 统计 s1 中每个字符出现的次数</span></span><br><span class="line">        counter1 = collections.Counter(s1)</span><br><span class="line">        N = <span class="built_in">len</span>(s2)</span><br><span class="line">        <span class="comment"># 定义滑动窗口的范围是 [left, right]，闭区间，长度与s1相等</span></span><br><span class="line">        left ,right = <span class="number">0</span>,<span class="built_in">len</span>(s1) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 统计窗口s2[left, right - 1]内的元素出现的次数</span></span><br><span class="line">        counter2 = collections.Counter(s2[<span class="number">0</span>:right])</span><br><span class="line">        <span class="keyword">while</span> right &lt; N:</span><br><span class="line">            <span class="comment"># 把 right 位置的元素放到 counter2 中</span></span><br><span class="line">            counter2[s2[right]] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果滑动窗口内各个元素出现的次数跟 s1 的元素出现次数完全一致，返回 True</span></span><br><span class="line">            <span class="keyword">if</span> counter1 == counter2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 窗口向右移动前，把当前 left 位置的元素出现次数 - 1</span></span><br><span class="line">            counter2[s2[left]] -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果当前 left 位置的元素出现次数为 0， 需要从字典中删除，否则这个出现次数为 0 的元素会影响两 counter 之间的比较</span></span><br><span class="line">            <span class="keyword">if</span> counter2[s2[left]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> counter2[s2[left]]</span><br><span class="line">            <span class="comment"># 窗口向右移动</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>写法二：（<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutation-in-string/solution/by-flix-ix7f/">『 一招吃遍七道 』滑动窗口的应用</a>）<br>&#8195;&#8195;在窗口滑动的过程中，我们维持一个长度为 len(s1) 的滑动窗口，当窗口中待匹配的字符数目为 0，我们就找到了一个满足要求的子串。此题更进一步的思路可以看下一题最小覆盖子串（题76）的解答。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s1)&gt;<span class="built_in">len</span>(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">            count1=<span class="built_in">dict</span>(Counter(s1))</span><br><span class="line">            need=<span class="built_in">len</span>(s1) <span class="comment">#所需字符的总次数</span></span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s2)):</span><br><span class="line">                ch=s2[right]</span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                如果ch是所需的字符，就将ch需要的次数减一，</span></span><br><span class="line"><span class="string">                但是ch次数&gt;0时，才表示这个字符还需要，此时才有need+1</span></span><br><span class="line"><span class="string">                而且要先计算need次数，因为ch次数先操作会导致need统计错误，类似于计算窗口的值再移动窗口</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> count1:</span><br><span class="line">                    <span class="keyword">if</span> count1[ch]&gt;<span class="number">0</span>:                     </span><br><span class="line">                        need-=<span class="number">1</span></span><br><span class="line">                    count1[ch]-=<span class="number">1</span></span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                窗口是固定大小，左指针跟随右指针移动，同时维护需求字典               </span></span><br><span class="line"><span class="string">                一开始窗口还不到s1长度，此时left会小于0。left=0是窗口第一次右移</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">                left=right-<span class="built_in">len</span>(s1)</span><br><span class="line">                <span class="keyword">if</span> left&gt;=<span class="number">0</span>:</span><br><span class="line">                    ch=s2[left]</span><br><span class="line">                    <span class="keyword">if</span> ch <span class="keyword">in</span> count1:</span><br><span class="line">                        <span class="keyword">if</span> count1[ch]&gt;=<span class="number">0</span>:</span><br><span class="line">                            </span><br><span class="line">                            need+=<span class="number">1</span></span><br><span class="line">                        count1[ch]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> need==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-最小覆盖子串（题76）"><a href="#4-2-3-最小覆盖子串（题76）" class="headerlink" title="4.2.3 最小覆盖子串（题76）"></a>4.2.3 最小覆盖子串（题76）</h4><p>&#8195;&#8195;这道题和<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/M1oyTv/">剑指 Offer II 017. 含有所有字符的最短字符串</a>几乎是一样的，区别仅仅在于本题的最短子串只有唯一一个，而后者可能出现多个，只要求取其中任意一个就行。所以二者的代码可以是完全一样的。</p>
<p>&#8195;&#8195;我们以<strong>哈希表<code>cnt</code>记录目标字符串 <code>t</code> 中待匹配的各字符的数目</strong>，并在 <code>s</code> 中维护一个变长的滑动窗口，期望使得窗口中的字符能够覆盖 <code>t</code>。具体地，设定一个非负变量 <code>need</code> 表示当前窗口还需要匹配到的字符总数：</p>
<ul>
<li>当窗口新增一位字符 <code>ch</code> 时：<ul>
<li>若<code>cnt[ch]&gt;0</code>，说明 待加入的字符<code>ch</code> 是当前窗口还需要的，此时新加入的 <code>ch</code> 能够使得 <code>need-1</code></li>
<li>若<code>cnt[ch]≤0</code>，说明 当前窗口不需要这个字符，need不变</li>
<li>无论<code>cnt[ch]</code>是否大于0，由于窗口一直右移，<code>cnt[ch]</code>本身的次数是要减一的。所以<code>cnt[ch]</code> 可以为负值，这表示表示当前窗口中字符 <code>ch</code> 过多。</li>
</ul>
</li>
<li><p>当窗口滑出一位字符 <code>ch</code> 时：</p>
<ul>
<li>若<code>cnt[ch]≥0</code>，说明 待加入的字符<code>ch</code> 是当前窗口还需要的（滑出去需求更大了），此时滑出的 <code>ch</code> 能够使得 <code>need+1</code></li>
<li>若<code>cnt[ch]＜0</code>，说明 当前窗口不需要这个字符，need不变</li>
<li>无论<code>cnt[ch]</code>是否大于0，由于窗口一直右移，<code>cnt[ch]</code>本身的次数是要加一的。</li>
</ul>
</li>
<li><p>当 <code>need=0</code> 时，说明找到了覆盖子串 ，在记录下答案的同时，我们还需要尝试收缩窗口左边界（参照上一步）。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(t)&gt;<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> s==t:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">            cnt=<span class="built_in">dict</span>(Counter(t)) <span class="comment"># 哈希表：记录需要匹配到的各个字符的数目</span></span><br><span class="line">            left=<span class="number">0</span>				 </span><br><span class="line">            need=<span class="built_in">len</span>(t) <span class="comment"># 需匹配的字符总数。每次右指针匹配到所需字符，need-=1，所以need=0表示匹配到了完整的覆盖子串	</span></span><br><span class="line">            le=<span class="built_in">len</span>(s)+<span class="number">1</span> <span class="comment"># 最短长度</span></span><br><span class="line">            result=<span class="string">&quot;&quot;</span>   <span class="comment"># 覆盖子串，即返回的结果</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                ch=s[right]          </span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> cnt:		<span class="comment"># 窗口右端新加入的字符ch若位于s1中，就将其次数-1。可以是负数，表示ch有多余的</span></span><br><span class="line">                    <span class="keyword">if</span> cnt[ch]&gt;<span class="number">0</span>:	<span class="comment"># 但是只有字符ch大于0，才表示这个字符还需要，need-=1</span></span><br><span class="line">                        need-=<span class="number">1</span></span><br><span class="line">                    cnt[ch]-=<span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">while</span> need==<span class="number">0</span>:     <span class="comment"># 只要所需字符为0，就一直移动左指针</span></span><br><span class="line">                    ch=s[left]</span><br><span class="line">                    <span class="keyword">if</span> ch <span class="keyword">in</span> cnt:  <span class="comment"># 刚滑出的字符位于s1中，操作同上</span></span><br><span class="line">                        <span class="keyword">if</span> cnt[ch]&gt;=<span class="number">0</span>:</span><br><span class="line">                            need+=<span class="number">1</span></span><br><span class="line">                        cnt[ch]+=<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 下面这一段写在while语句之前也可以，只要left+=1在最后一行</span></span><br><span class="line">                    <span class="keyword">if</span> right-left&lt;le:</span><br><span class="line">                        le=right-left</span><br><span class="line">                        result=s[left:right+<span class="number">1</span>]</span><br><span class="line">                        </span><br><span class="line">                    left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> <span class="keyword">if</span> le==<span class="built_in">len</span>(s)+<span class="number">1</span> <span class="keyword">else</span> result</span><br></pre></td></tr></table></figure>
<h4 id="4-2-4-最短超串"><a href="#4-2-4-最短超串" class="headerlink" title="4.2.4 最短超串"></a>4.2.4 最短超串</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-supersequence-lcci/">题目链接</a></p>
</blockquote>
<p>这题和上一题差不多，改一下输出结果的格式就行。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestSeq</span>(<span class="params">self, big, small</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type big: List[int]</span></span><br><span class="line"><span class="string">        :type small: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        cnt=<span class="built_in">dict</span>(Counter(small)) <span class="comment"># 哈希表：记录需要匹配到的各个字符的数目</span></span><br><span class="line">        left=<span class="number">0</span>				 </span><br><span class="line">        need=<span class="built_in">len</span>(small) <span class="comment"># 需匹配的字符总数。每次右指针匹配到所需字符，need-=1，所以need=0表示匹配到了完整的覆盖子串	</span></span><br><span class="line">        le=<span class="built_in">len</span>(big)+<span class="number">1</span>   <span class="comment"># 记录最短子串长度          </span></span><br><span class="line">        result=[]       <span class="comment"># 返回的结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(big)):</span><br><span class="line">            ch=big[right]          </span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> cnt:		<span class="comment"># 窗口右端新加入的字符ch若位于s1中，就将其次数-1。可以是负数，表示ch有多余的</span></span><br><span class="line">                <span class="keyword">if</span> cnt[ch]&gt;<span class="number">0</span>:	<span class="comment"># 但是只有字符ch大于0，才表示这个字符还需要，need-=1</span></span><br><span class="line">                    need-=<span class="number">1</span></span><br><span class="line">                cnt[ch]-=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">while</span> need==<span class="number">0</span>:     <span class="comment"># 只要所需字符为0，就一直移动左指针</span></span><br><span class="line">                ch=big[left]</span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> cnt:  <span class="comment"># 刚滑出的字符位于s1中，操作同上</span></span><br><span class="line">                    <span class="keyword">if</span> cnt[ch]&gt;=<span class="number">0</span>:</span><br><span class="line">                        need+=<span class="number">1</span></span><br><span class="line">                    cnt[ch]+=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 下面这一段写在while语句之前也可以，只要left+=1在最后一行</span></span><br><span class="line">                <span class="comment"># 只要子串更短就覆盖结果，所以即使最短子串有多个，也只会返回第一个</span></span><br><span class="line">                <span class="keyword">if</span> right-left&lt;le: <span class="comment">#</span></span><br><span class="line">                    le=right-left</span><br><span class="line">                    result=[left,right]</span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [] <span class="keyword">if</span> le==<span class="built_in">len</span>(big)+<span class="number">1</span> <span class="keyword">else</span> result</span><br></pre></td></tr></table></figure></p>
<h4 id="4-2-5-找到字符串中所有字母异位词（题438）"><a href="#4-2-5-找到字符串中所有字母异位词（题438）" class="headerlink" title="4.2.5 找到字符串中所有字母异位词（题438）"></a>4.2.5 找到字符串中所有字母异位词（题438）</h4><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<br>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<ul>
<li>输入: s = “cbaebabacd”, p = “abc”</li>
<li>输出: [0,6]</li>
<li>解释:<ul>
<li>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。</li>
<li>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</li>
</ul>
</li>
</ul>
<p>&#8195;&#8195;这道题和题567几乎一样，只是需要返回每个子串的起始位置，答案就不写了，同样的题还有<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/VabMRr/">《剑指 Offer II 015. 字符串中的所有变位词》</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span>(<span class="params">self, s, p</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(p)&gt;<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">            count1=<span class="built_in">dict</span>(Counter(p))</span><br><span class="line">            need=<span class="built_in">len</span>(p) <span class="comment">#所需字符的总次数</span></span><br><span class="line">            result=[]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                ch=s[right]</span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                如果ch是所需的字符，就将ch需要的次数减一，</span></span><br><span class="line"><span class="string">                但是ch次数&gt;0时，才表示这个字符还需要，此时才有need+1</span></span><br><span class="line"><span class="string">                而且要先计算need次数，因为ch次数先操作会导致need统计错误，类似于计算窗口的值再移动窗口</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> count1:</span><br><span class="line">                    <span class="keyword">if</span> count1[ch]&gt;<span class="number">0</span>:                     </span><br><span class="line">                        need-=<span class="number">1</span></span><br><span class="line">                    count1[ch]-=<span class="number">1</span></span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                窗口是固定大小，左指针跟随右指针移动，同时维护需求字典               </span></span><br><span class="line"><span class="string">                一开始窗口还不到s1长度，此时left会小于0。left=0是窗口第一次右移</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">                left=right-<span class="built_in">len</span>(p)</span><br><span class="line">                <span class="keyword">if</span> left&gt;=<span class="number">0</span>:</span><br><span class="line">                    ch=s[left]</span><br><span class="line">                    <span class="keyword">if</span> ch <span class="keyword">in</span> count1:</span><br><span class="line">                        <span class="keyword">if</span> count1[ch]&gt;=<span class="number">0</span>:</span><br><span class="line">                            </span><br><span class="line">                            need+=<span class="number">1</span></span><br><span class="line">                        count1[ch]+=<span class="number">1</span></span><br><span class="line">  </span><br><span class="line">                <span class="keyword">if</span> need==<span class="number">0</span>:</span><br><span class="line">                    result.append(left+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h4 id="4-2-6-串联所有单词的子串（题30）"><a href="#4-2-6-串联所有单词的子串（题30）" class="headerlink" title="4.2.6 串联所有单词的子串（题30）"></a>4.2.6 串联所有单词的子串（题30）</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">题目链接</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span>          </span><br><span class="line">    </span><br><span class="line">    	<span class="comment"># word的所有排列组合和元素顺序无关，可以考虑使用字典，不看具体单词只看元素</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        <span class="comment"># 将words中每个元素统计其次数存入字典</span></span><br><span class="line">        cnw=<span class="built_in">dict</span>(Counter(words))</span><br><span class="line">        le1=<span class="built_in">len</span>(<span class="string">&quot;&quot;</span>.join(words)) <span class="comment"># 匹配子串总长度，也等于滑动窗口长度</span></span><br><span class="line">        le2=<span class="built_in">len</span>(words[<span class="number">0</span>]) <span class="comment"># 每个word等长</span></span><br><span class="line">        need=<span class="built_in">len</span>(words)   <span class="comment"># need表示总共需要的元素数,不等于cnw长度，因为有键是多个，坑死我了</span></span><br><span class="line">        </span><br><span class="line">        res=[] <span class="comment"># 记录匹配子串的起始位置</span></span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,le2): <span class="comment"># s的分词方式有多种，都需要遍历到</span></span><br><span class="line">            <span class="comment">#print(&quot;start:&quot;,start)</span></span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(start+le2,<span class="built_in">len</span>(s)+<span class="number">1</span>,le2):<span class="comment">#还是要分割成若干个单词，间隔le2</span></span><br><span class="line">            <span class="comment"># 遍历右指针，如果碰到需要的单词，就将其需要次数减1，如果次数大于0，就将总次数减1</span></span><br><span class="line">            <span class="comment"># 假如word长为3，即le2=3，右指针就从3开始遍历，每次加入的字符长度都是3</span></span><br><span class="line">           </span><br><span class="line">                ch=s[right-le2:right]</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> cnw:</span><br><span class="line">                    <span class="keyword">if</span> cnw[ch]&gt;<span class="number">0</span>:</span><br><span class="line">                        need-=<span class="number">1</span></span><br><span class="line">                    cnw[ch]-=<span class="number">1</span></span><br><span class="line">                <span class="comment">#print(&quot;r:&quot;,ch,cnw,need)</span></span><br><span class="line">                left=right-le1 <span class="comment"># 窗口是固定大小，长为le。left=0时刚好是要第一次滑动窗口</span></span><br><span class="line">                <span class="keyword">if</span> left&gt;=le2:</span><br><span class="line">                    ch=s[left-le2:left]</span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">if</span> ch <span class="keyword">in</span> cnw:</span><br><span class="line">                        <span class="keyword">if</span> cnw[ch]&gt;=<span class="number">0</span>:</span><br><span class="line">                            need+=<span class="number">1</span></span><br><span class="line">                        cnw[ch]+=<span class="number">1</span></span><br><span class="line">                    <span class="comment">#print(ch,cnw,need)</span></span><br><span class="line">                                    </span><br><span class="line">                <span class="keyword">if</span> need==<span class="number">0</span>:</span><br><span class="line">                    res.append(left)</span><br><span class="line">                <span class="comment"># 每次起点位置遍历完，need 和cnw上一次被改了，需要重置</span></span><br><span class="line">            need=<span class="built_in">len</span>(words)</span><br><span class="line">            cnw=<span class="built_in">dict</span>(Counter(words))</span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><br>后续有空再补。</p>
<hr>
<p>904-水果成篮(opens new window)<br>159-至多包含两个不同字符的最长子串<br>340-至多包含 K 个不同字符的最长子串<br>30-串联所有单词的子串<br>239- 滑动窗口最大值<br>632-最小区间<br>727.-最小窗口子序列</p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhxnlp</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhxnlp.github.io/2023/02/12/数据结构与算法/leetcode练习一：数组（二分查找、双指针、滑动窗口）/">https://zhxnlp.github.io/2023/02/12/数据结构与算法/leetcode练习一：数组（二分查找、双指针、滑动窗口）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhxnlp.github.io">zhxnlpのBlog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a><a class="post-meta__tags" href="/tags/Array/">Array</a><a class="post-meta__tags" href="/tags/Binary-Search/">Binary Search</a><a class="post-meta__tags" href="/tags/Two-Pointers/">Two Pointers</a><a class="post-meta__tags" href="/tags/Sliding-Window/">Sliding Window</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode%E7%BB%83%E4%B9%A0%E4%BA%8C%EF%BC%9A%E6%8E%92%E5%BA%8F/"><i class="fa fa-chevron-left">  </i><span>leetcode练习二：排序</span></a></div><div class="next-post pull-right"><a href="/2022/01/15/datawhale%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/lightGBM/"><span>集成学习5： LightGBM实战</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://img-blog.csdnimg.cn/ffe1f736be4548dc9101388503288e4d.png)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2023 By zhxnlp</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>