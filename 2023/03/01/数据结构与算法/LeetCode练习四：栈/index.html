<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="leetcode练习四：栈"><meta name="keywords" content="leetcode,Stack"><meta name="author" content="zhxnlp"><meta name="copyright" content="zhxnlp"><title>leetcode练习四：栈 | zhxnlpのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"JU6VFRRZVF","apiKey":"ca17f8e20c4dc91dfe1214d03173a8be","indexName":"github-io","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="zhxnlpのBlog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E5%A0%86%E6%A0%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">一、 堆栈基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%A0%86%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-text">1.2 堆栈的顺序存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E5%A0%86%E6%A0%88%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%9F%BA%E6%9C%AC%E6%8F%8F%E8%BF%B0"><span class="toc-text">1.2.1 堆栈顺序存储基本描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E5%A0%86%E6%A0%88%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-text">1.2.2 堆栈顺序存储实现代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%A0%86%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-text">1.3 堆栈的链式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E5%A0%86%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%9F%BA%E6%9C%AC%E6%8F%8F%E8%BF%B0"><span class="toc-text">1.3.1 堆栈的链式存储基本描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E5%A0%86%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-text">1.3.2 堆栈的链式存储实现代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E5%A0%86%E6%A0%88%E7%9A%84%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8"><span class="toc-text">二、 堆栈的基础应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%A0%86%E6%A0%88%E5%9F%BA%E7%A1%80%E9%A2%98%E5%88%97%E8%A1%A8"><span class="toc-text">2.1 堆栈基础题列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-text">2.2 括号匹配问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-text">2.2.1 有效的括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-text">2.2.2 最长有效括号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%89%8D%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2.3 前缀、中缀、后缀表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="toc-text">2.3.1 表达式简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86"><span class="toc-text">2.3.2 表达式转换原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E7%AE%97%E6%B3%95"><span class="toc-text">2.3.3 中缀转后缀算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">2.3.4 后缀表达式求值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-text">2.4 表达式求值问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8II"><span class="toc-text">2.4.1 基本计算器II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">2.4.2  逆波兰表达式求值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8I"><span class="toc-text">2.4.3 基本计算器I</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97"><span class="toc-text">2.5 验证栈序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-text">三、单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E6%A0%88"><span class="toc-text">3.1 单调递增栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8D%95%E8%B0%83%E9%80%92%E5%87%8F%E6%A0%88"><span class="toc-text">3.2 单调递减栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%8D%95%E8%B0%83%E6%A0%88%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3.3 单调栈适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%AF%BB%E6%89%BE%E5%B7%A6%E4%BE%A7%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">3.3.1 寻找左侧第一个比当前元素大的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E5%AF%BB%E6%89%BE%E5%B7%A6%E4%BE%A7%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">3.3.2 寻找左侧第一个比当前元素小的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E5%AF%BB%E6%89%BE%E5%8F%B3%E4%BE%A7%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">3.3.3 寻找右侧第一个比当前元素大的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-%E5%AF%BB%E6%89%BE%E5%8F%B3%E4%BE%A7%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">3.3.4 寻找右侧第一个比当前元素小的元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">四、 单调栈的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8D%95%E8%B0%83%E6%A0%88%E9%A2%98%E7%9B%AE%E5%88%97%E8%A1%A8"><span class="toc-text">4.1 单调栈题目列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I-amp-II"><span class="toc-text">4.2 下一个更大元素 I &amp; II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-text">4.3 每日温度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6"><span class="toc-text">4.4 股票价格跨度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D"><span class="toc-text">4.5 去除重复字母</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="toc-text">4.6 柱状图中最大的矩形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-text">4.7 接雨水</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2"><span class="toc-text">4.8 最大矩形</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img-blog.csdnimg.cn/92202ef591744a55a05a1fc7e108f4d6.png"></div><div class="author-info__name text-center">zhxnlp</div><div class="author-info__description text-center">nlp</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/zhxnlp">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">58</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">50</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://relph1119.github.io/my-team-learning">relph</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://ifwind.github.io/">ifwind</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://chuxiaoyu.cn/nlp-transformer-summary/">chuxiaoyu</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://img-blog.csdnimg.cn/ffe1f736be4548dc9101388503288e4d.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">zhxnlpのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">leetcode练习四：栈</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Data-Structure-and-Algorithms/">Data Structure and Algorithms</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">14k</span><span class="post-meta__separator">|</span><span>阅读时长: 50 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>@[toc]</p>
<blockquote>
<p>本文主要参考<a target="_blank" rel="noopener" href="https://algo.itcharge.cn/03.Stack/01.Stack-Basic/01.Stack-Basic/">《算法通关手册》堆栈篇</a></p>
<h2 id="一、-堆栈基础知识"><a href="#一、-堆栈基础知识" class="headerlink" title="一、 堆栈基础知识"></a>一、 堆栈基础知识</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3></blockquote>
<p> <strong>堆栈（Stack）</strong>：简称为栈。一种线性表数据结构，是一种只允许在表的一端进行插入和删除操作的线性表。</p>
<p>&#8195;&#8195;我们把栈中允许插入和删除的一端称为 <strong>「栈顶（top）」</strong>；另一端则称为 <strong>「栈底（bottom）」</strong>。当表中没有任何数据元素时，称之为 <strong>「空栈」</strong>。</p>
<p>堆栈有两种基本操作：<strong>「插入操作」</strong> 和 <strong>「删除操作」</strong>。</p>
<ul>
<li>栈的插入操作又称为「入栈」或者「进栈」。</li>
<li>栈的删除操作又称为「出栈」或者「退栈」。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/07774fbc4c85c01ef050267826da680e.png" alt=""><br><span id="more"></span><br>&#8195;&#8195;简单来说，栈是一种 <strong>「后进先出（Last In First Out）」</strong> 的线性表，简称为 <strong>「LIFO 结构」</strong>。我们可以从两个方面来解释一下栈的定义：</p>
<ul>
<li><p><strong>「线性表」</strong>：栈首先是一个线性表，栈中元素具有前驱后继的线性关系。栈中元素按照 $a_1, a_2, … , a_n$ 的次序依次进栈。栈顶元素为 $a_n$。</p>
</li>
<li><p><strong>「后进先出原则」</strong>：根据堆栈的定义，每次删除的总是堆栈中当前的栈顶元素，即最后进入堆栈的元素。而在进栈时，最先进入堆栈的元素一定在栈底，最后进入堆栈的元素一定在栈顶。也就是说，元素进入堆栈或者退出退栈是按照「后进先出（Last In First Out）」的原则进行的。</p>
</li>
</ul>
<p><strong>堆栈的基本操作</strong></p>
<p>&#8195;&#8195;栈作为一种线性表来说，理论上应该具备线性表所有的操作特性，但由于「后进先出」的特殊性，所以针对栈的操作进行了一些变化。尤其是插入操作和删除操作，改为了入栈（push）和出栈（pop）。</p>
<p>堆栈的基本操作如下：</p>
<ul>
<li><p><strong>初始化空栈</strong>：创建一个空栈，定义栈的大小 <code>size</code>，以及栈顶元素指针 <code>top</code>。</p>
</li>
<li><p><strong>判断栈是否为空</strong>：当堆栈为空时，返回 <code>True</code>。当堆栈不为空时，返回 <code>False</code>。一般只用于栈中删除操作和获取当前栈顶元素操作中。</p>
</li>
<li><p><strong>判断栈是否已满</strong>：当堆栈已满时，返回 <code>True</code>，当堆栈未满时，返回 <code>False</code>。一般只用于顺序栈中插入元素和获取当前栈顶元素操作中。</p>
</li>
<li><p><strong>插入元素（进栈、入栈）</strong>：相当于在线性表最后元素后面插入一个新的数据元素。并改变栈顶指针 <code>top</code> 的指向位置。</p>
</li>
<li><p><strong>删除元素（出栈、退栈）</strong>：相当于在线性表最后元素后面删除最后一个数据元素。并改变栈顶指针 <code>top</code> 的指向位置。</p>
</li>
<li><strong>获取栈顶元素</strong>：相当于获取线性表中最后一个数据元素。与插入元素、删除元素不同的是，该操作并不改变栈顶指针 <code>top</code> 的指向位置。</li>
</ul>
<p>接下来我们来看一下栈的顺序存储与链式存储两种不同的实现方式。</p>
<h3 id="1-2-堆栈的顺序存储"><a href="#1-2-堆栈的顺序存储" class="headerlink" title="1.2 堆栈的顺序存储"></a>1.2 堆栈的顺序存储</h3><p>和线性表类似，栈有两种存储表示方法：<strong>「顺序栈」</strong> 和 <strong>「链式栈」</strong>。</p>
<ul>
<li><strong>「顺序栈」</strong>：即堆栈的顺序存储结构。利用一组地址连续的存储单元依次存放自栈底到栈顶的元素，同时使用指针 <code>top</code> 指示栈顶元素在顺序栈中的位置。</li>
<li><strong>「链式栈」</strong>：即堆栈的链式存储结构。利用单链表的方式来实现堆栈。栈中元素按照插入顺序依次插入到链表的第一个节点之前，并使用栈顶指针 <code>top</code> 指示栈顶元素，<code>top</code> 永远指向链表的头节点位置。</li>
</ul>
<p>&#8195;&#8195;堆栈最简单的实现方式就是借助于一个数组来描述堆栈的顺序存储结构。在 <code>Python</code> 中我们可以借助列表 <code>list</code> 来实现。这种采用顺序存储结构的堆栈也被称为 <strong>「顺序栈」</strong>。</p>
<h4 id="1-2-1-堆栈顺序存储基本描述"><a href="#1-2-1-堆栈顺序存储基本描述" class="headerlink" title="1.2.1 堆栈顺序存储基本描述"></a>1.2.1 堆栈顺序存储基本描述</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/d0730e6b8c8fd338dcfdefafff1aa318.png" alt=""></p>
<p>我们约定 <code>self.top</code> 指向栈顶元素所在位置。</p>
<ul>
<li><strong>初始化空栈</strong>：使用列表创建一个空栈，定义栈的大小 <code>self.size</code>，并令栈顶元素指针 <code>self.top</code> 指向 <code>-1</code>，即 <code>self.top = -1</code>。</li>
<li><strong>判断栈是否为空</strong>：当 <code>self.top == -1</code> 时，说明堆栈为空，返回 <code>True</code>，否则返回 <code>False</code>。</li>
<li><strong>判断栈是否已满</strong>：当 <code>self.top == self.size - 1</code>，说明堆栈已满，返回 <code>True</code>，否则返回返回 <code>False</code>。</li>
<li><strong>插入元素（进栈、入栈）</strong>：先判断堆栈是否已满，已满直接抛出异常。如果堆栈未满，则在 <code>self.stack</code> 末尾插入新的数据元素，并令 <code>self.top</code> 向右移动 <code>1</code> 位。</li>
<li><strong>删除元素（出栈、退栈）</strong>：先判断堆栈是否为空，为空直接抛出异常。如果堆栈不为空，则删除 <code>self.stack</code> 末尾的数据元素，并令 <code>self.top</code> 向左移动 <code>1</code> 位。</li>
<li><strong>获取栈顶元素</strong>：先判断堆栈是否为空，为空直接抛出异常。不为空则返回 <code>self.top</code> 指向的栈顶元素，即 <code>self.stack[self.top]</code>。</li>
</ul>
<h4 id="1-2-2-堆栈顺序存储实现代码"><a href="#1-2-2-堆栈顺序存储实现代码" class="headerlink" title="1.2.2 堆栈顺序存储实现代码"></a>1.2.2 堆栈顺序存储实现代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="comment"># 初始化空栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size=<span class="number">100</span></span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.size = size</span><br><span class="line">        self.top = -<span class="number">1</span>    </span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.top == -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断栈是否已满</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_full</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.top + <span class="number">1</span> == self.size</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 入栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_full():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Stack is full&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.append(value)</span><br><span class="line">            self.top += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 出栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Stack is empty&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.pop()</span><br><span class="line">            self.top -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Stack is empty&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack[self.top]</span><br></pre></td></tr></table></figure>
<h3 id="1-3-堆栈的链式存储"><a href="#1-3-堆栈的链式存储" class="headerlink" title="1.3 堆栈的链式存储"></a>1.3 堆栈的链式存储</h3><p>&#8195;&#8195;堆栈的顺序存储结构保留着顺序存储分配空间的固有缺陷，即在栈满或者其他需要重新调整存储空间时需要移动大量元素。为此，堆栈可以采用链式存储方式来实现。在 <code>Python</code> 中我们通过构造链表节点 <code>Node</code> 的方式来实现。这种采用链式存储结构的堆栈也被称为 <strong>「链式栈」</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2d396094962d5c19d93ed098778d89aa.png" alt=""></p>
<h4 id="1-3-1-堆栈的链式存储基本描述"><a href="#1-3-1-堆栈的链式存储基本描述" class="headerlink" title="1.3.1 堆栈的链式存储基本描述"></a>1.3.1 堆栈的链式存储基本描述</h4><p>我们约定 <code>self.top</code> 指向栈顶元素所在位置。</p>
<ul>
<li><strong>初始化空栈</strong>：使用列表创建一个空栈，并令栈顶元素指针 <code>self.top</code> 指向 <code>None</code>，即 <code>self.top = None</code>。</li>
<li><strong>判断栈是否为空</strong>：当 <code>self.top == None</code> 时，说明堆栈为空，返回 <code>True</code>，否则返回 <code>False</code>。</li>
<li><strong>插入元素（进栈、入栈）</strong>：创建值为 <code>value</code> 的链表节点，插入到链表头节点之前，并令栈顶指针 <code>self.top</code> 指向新的头节点。</li>
<li><strong>删除元素（出栈、退栈）</strong>：先判断堆栈是否为空，为空直接抛出异常。如果堆栈不为空，则先使用变量 <code>cur</code> 存储当前栈顶指针 <code>self.top</code> 指向的头节点，然后令 <code>self.top</code> 沿着链表移动 <code>1</code> 位，然后再删除之前保存的 <code>cur</code> 节点。</li>
<li><strong>获取栈顶元素</strong>：先判断堆栈是否为空，为空直接抛出异常。不为空则返回 <code>self.top</code> 指向的栈顶节点的值，即 <code>self.top.value</code>。</li>
</ul>
<h4 id="1-3-2-堆栈的链式存储实现代码"><a href="#1-3-2-堆栈的链式存储实现代码" class="headerlink" title="1.3.2 堆栈的链式存储实现代码"></a>1.3.2 堆栈的链式存储实现代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="comment"># 初始化空栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.top == <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 入栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        cur = Node(value)</span><br><span class="line">        cur.<span class="built_in">next</span> = self.top</span><br><span class="line">        self.top = cur</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 出栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Stack is empty&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.top</span><br><span class="line">            self.top = self.top.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">del</span> cur</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Stack is empty&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.top.value</span><br></pre></td></tr></table></figure>
<h2 id="二、-堆栈的基础应用"><a href="#二、-堆栈的基础应用" class="headerlink" title="二、 堆栈的基础应用"></a>二、 堆栈的基础应用</h2><p>堆栈是算法和程序中最常用的辅助结构，其的应用十分广泛。堆栈基本应用于两个方面：</p>
<ul>
<li>使用堆栈可以很方便的保存和取用信息，因此长被用作算法和程序中的辅助存储结构，临时保存信息，供后面操作中使用。<ul>
<li>例如：操作系统中的函数调用栈，浏览器中的前进、后退功能。</li>
</ul>
</li>
<li>堆栈的后进先出规则，可以保证特定的存取顺序。<ul>
<li>例如：翻转一组元素的顺序、铁路列车车辆调度。</li>
</ul>
</li>
</ul>
<h3 id="2-1-堆栈基础题列表"><a href="#2-1-堆栈基础题列表" class="headerlink" title="2.1 堆栈基础题列表"></a>2.1 堆栈基础题列表</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">题号</th>
<th style="text-align:left">标题</th>
<th style="text-align:left">题解</th>
<th style="text-align:left">标签</th>
<th style="text-align:left">难度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1047</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">删除字符串中的所有相邻重复项</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/1047.%20%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.md">Python</a></td>
<td style="text-align:left">字符串、栈</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0155</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/">最小栈</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0155.%20%E6%9C%80%E5%B0%8F%E6%A0%88.md">Python</a></td>
<td style="text-align:left">栈、设计</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0020</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0020.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.md">Python</a></td>
<td style="text-align:left">栈、字符串</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0227</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator-ii/">基本计算器 II</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0227.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%20II.md">Python</a></td>
<td style="text-align:left">栈、字符串</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0739</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0739.%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.md">Python</a></td>
<td style="text-align:left">栈、哈希表</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0150</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">逆波兰表达式求值</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0150.%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.md">Python</a></td>
<td style="text-align:left">栈</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0232</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">用栈实现队列</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.md">Python</a></td>
<td style="text-align:left">栈、设计</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">剑指 Offer 09</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.md">Python</a></td>
<td style="text-align:left">栈、设计、队列</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0394</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">字符串解码</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0394.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81.md">Python</a></td>
<td style="text-align:left">栈、深度优先搜索</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0032</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-valid-parentheses/">最长有效括号</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0032.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.md">Python</a></td>
<td style="text-align:left">栈、字符串、动态规划</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">0946</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-stack-sequences/">验证栈序列</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0946.%20%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97.md">Python</a></td>
<td style="text-align:left">栈、数组、模拟</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">剑指 Offer 06</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.md">Python</a></td>
<td style="text-align:left">栈、递归、链表、双指针</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0739</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0739.%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.md">Python</a></td>
<td style="text-align:left">栈、哈希表</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0071</td>
<td style="text-align:left">简化路径</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<p>下面我们来讲解一下栈应用的典型例子。</p>
<h3 id="2-2-括号匹配问题"><a href="#2-2-括号匹配问题" class="headerlink" title="2.2 括号匹配问题"></a>2.2 括号匹配问题</h3><h4 id="2-2-1-有效的括号"><a href="#2-2-1-有效的括号" class="headerlink" title="2.2.1 有效的括号"></a>2.2.1 有效的括号</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode）</a></p>
</blockquote>
<p>&#8195;&#8195;给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串 <code>s</code> 是否有效（即括号是否匹配）。</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。<ul>
<li>左括号必须以正确的顺序闭合。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>输入：s = “()[]{}”</li>
<li>输出：True</li>
</ul>
<p><strong>解题思路</strong>：括号匹配是「栈」的经典应用。我们可以用栈来解决这道题。</p>
<ol>
<li>先判断一下字符串的长度是否为偶数。因为括号是成对出现的，所以字符串的长度应为偶数，可以直接判断长度为奇数的字符串不匹配。如果字符串长度为奇数，则说明字符串 <code>s</code> 中的括号不匹配，直接返回 <code>False</code>。</li>
<li>使用栈 <code>stack</code> 来保存未匹配的左括号。然后依次遍历字符串 <code>s</code> 中的每一个字符。<ol>
<li>如果遍历到左括号时，将其入栈。</li>
<li>如果遍历到右括号时，先看栈顶元素是否是与当前右括号相同类型的左括号。<ol>
<li>如果是与当前右括号相同类型的左括号，则令其出栈，继续向前遍历。</li>
<li>如果不是与当前右括号相同类型的左括号，则说明字符串 <code>s</code> 中的括号不匹配，直接返回 <code>False</code>。</li>
</ol>
</li>
</ol>
</li>
<li>遍历完，还要再判断一下栈是否为空。<ol>
<li>如果栈为空，则说明字符串 <code>s</code> 中的括号匹配，返回 <code>True</code>。</li>
<li>如果栈不为空，则说明字符串 <code>s</code> 中的括号不匹配，返回 <code>False</code>。</li>
</ol>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> ch == <span class="string">&#x27;[&#x27;</span> <span class="keyword">or</span> ch == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                stack.append(ch)</span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack) !=<span class="number">0</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack) !=<span class="number">0</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack) !=<span class="number">0</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$。</li>
<li><strong>空间复杂度</strong>：$O(1)$。</li>
</ul>
<h4 id="2-2-2-最长有效括号"><a href="#2-2-2-最长有效括号" class="headerlink" title="2.2.2 最长有效括号"></a>2.2.2 最长有效括号</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-valid-parentheses/">32  最长有效括号 - 力扣（LeetCode）</a></p>
</blockquote>
<p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。<br>示例：</p>
<ul>
<li>输入：s = “)()())”</li>
<li>输出：4</li>
<li>解释：最长有效括号子串是 “()()”</li>
</ul>
<p>参考官方题解，使用单调栈来解决。主要思路是我们始终保持<strong>栈底元素</strong>为当前已经遍历过的元素中，<strong>「最后一个没有被匹配的右括号的下标」</strong>。</p>
<ul>
<li>对于遇到的每个 ‘<code>(</code>’ ，直接入栈</li>
<li>对于遇到的每个 ‘<code>)</code>’ ，我们先弹出栈顶元素表示匹配了当前右括号：<ul>
<li>如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」</li>
</ul>
</li>
<li>如果栈不为空，当前右括号的下标减去栈顶元素即为，<strong>「以该右括号为结尾的最长有效括号的长度」</strong>。<br>我们从前往后遍历字符串并更新答案即可。</li>
</ul>
<blockquote>
<p>&#8195;&#8195;注意：如果一开始栈为空，第一个字符为左括号的时候，我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 <code>−1</code> 的元素。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        stack=[-<span class="number">1</span>] <span class="comment"># 初始赋值为-1，这样匹配到都一个右括号时，长度=1-（-1）=2，刚刚好。</span></span><br><span class="line">        ans=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i]==<span class="string">&quot;(&quot;</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack)==<span class="number">0</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans=<span class="built_in">max</span>(ans,i-stack[-<span class="number">1</span>])               </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$。</li>
<li><strong>空间复杂度</strong>：$O(n)$。        </li>
</ul>
<h3 id="2-3-前缀、中缀、后缀表达式"><a href="#2-3-前缀、中缀、后缀表达式" class="headerlink" title="2.3 前缀、中缀、后缀表达式"></a>2.3 前缀、中缀、后缀表达式</h3><h4 id="2-3-1-表达式简介"><a href="#2-3-1-表达式简介" class="headerlink" title="2.3.1 表达式简介"></a>2.3.1 表达式简介</h4><ul>
<li>中缀表达式<ul>
<li>中缀表达式：操作符介于操作数之间的表达式。</li>
<li>中缀(infix)表达式：A + B * C + D ，为了避免计算顺序混淆，引入全括号表达式；</li>
<li>全括号中缀表达式：((A + (B * C)) + D)，内层括号优先级更高。</li>
</ul>
</li>
<li>前缀和后缀表达式<ul>
<li>前缀(prefix)表达式：将操作符移到前面，形式变为：操作符、第一操作数、第二操作数。</li>
<li>后缀(postfix)表达式：将操作符移到后面，形式变为：第一操作数、第二操作数、操作符。</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/15200971498df17c98229b62960a34e0.png#pic_center =500x" alt="在这里插入图片描述"></p>
<h4 id="2-3-2-表达式转换原理"><a href="#2-3-2-表达式转换原理" class="headerlink" title="2.3.2 表达式转换原理"></a>2.3.2 表达式转换原理</h4><p>例：<code>(A + (B * C))</code></p>
<ol>
<li><strong>中缀转后缀表达式</strong>：把操作符移到相应的右括号替代之，并删掉左括号<ul>
<li>把操作符<code>*</code>移到子表达式<code>(B * C)</code>的右括号位置替代它，再删去左括号得到<code>BC*</code></li>
<li>把操作符<code>+</code>移到相应的右括号并删掉左括号，表达式就转为 <strong>后缀</strong> 形式，即：<code>ABC*+</code> 。</li>
</ul>
</li>
<li><strong>中缀转前缀表达式</strong>：同理，把操作符移到相应的左括号替代之，并删掉右括号，表达时就转换为 <strong>前缀</strong> 形式，即：<code>+A*BC</code> 。</li>
</ol>
<p>总结：</p>
<ul>
<li><strong>前后缀表达式中，操作符顺序完全决定了运算的次序，多数情况下计算机用此方法，特别是后缀法。</strong></li>
<li><strong>离操作数越近的越先做</strong></li>
<li>无论表达式多复杂，转换为前缀或后缀只需要两个步骤：  <ul>
<li>将中缀表达式转换为全括号形式；  </li>
<li><strong>将所有操作符移动到子表达式所在的左括号（前缀）或者右括号（后缀）处，替代之，再删除所有括号。</strong></li>
</ul>
</li>
</ul>
<h4 id="2-3-3-中缀转后缀算法"><a href="#2-3-3-中缀转后缀算法" class="headerlink" title="2.3.3 中缀转后缀算法"></a>2.3.3 中缀转后缀算法</h4><ul>
<li>在中缀表达式转换为后缀形式的处理过程中，操作符比操作数要晚输出，所以在扫描到对应的第二个操作数之前，需要把操作符先保存起来；</li>
<li>而这些暂存的操作符，由于优先级的规则还有可能要<strong>反转</strong>次序输出。<br>在<code>A+B*C</code>中，<code>+</code>虽然先出现，但优先级比后面这个<code>*</code>要低，所以它要等<code>*</code>处理完后，才能再处理。</li>
<li>这种<strong>反转</strong>特性，使得我们考虑用<code>栈</code>来保存暂时<strong>未处理</strong>的<strong>操作符</strong>。</li>
</ul>
<p>&#8195;&#8195;总结下，在从左到右扫描逐个字符扫描中缀表达式的过程中，采用一个<strong>栈</strong>来暂存未处理的操作符。这样，<strong>栈顶</strong>的操作符就是<strong>最近</strong>暂存进去的，当遇到一个新的操作符，就需要跟栈顶的操作符比较下优先级，再行处理。<br>&#8195;&#8195;所以遇到<strong>左括号</strong>，要标记下，其后出现的操作符<strong>优先级提升了</strong>，一旦扫描到对应的右括号，就可以马上输出这个操作符</p>
<p><strong>流程</strong>：</p>
<ul>
<li>从左到右扫描中缀表达式单词列表<ul>
<li>如果单词是操作数，则直接添加到后缀表达式列表的末尾；</li>
<li>如果单词是左括号，则压入opstack栈顶；</li>
<li>如果单词是右括号，则反复弹出opstack栈顶操作符，加入到输出列表末尾，直到碰到左括号；</li>
<li>如果单词是操作符，则压入opstack栈顶，但在压入栈顶之前，要比较其与栈顶操作符的优先级，如果栈顶的高于或等于它，就要反复弹出栈顶操作符，加入到输出列表末尾；直到栈顶的操作符优先级低于它。</li>
</ul>
</li>
<li>中缀表达式单词列表扫描结束后，把opstack栈中的所有剩余操作符  依次弹出，添加到输出列表末尾。</li>
<li>把输出列表再用join方法合并成后缀表达式字符串，算法结束。</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infixToPostfix</span>(<span class="params">infixexpr</span>):</span></span><br><span class="line">    prec = &#123;&#125;</span><br><span class="line">    prec[<span class="string">&quot;*&quot;</span>] = <span class="number">3</span></span><br><span class="line">    prec[<span class="string">&quot;/&quot;</span>] = <span class="number">3</span></span><br><span class="line">    prec[<span class="string">&quot;+&quot;</span>] = <span class="number">2</span></span><br><span class="line">    prec[<span class="string">&quot;-&quot;</span>] = <span class="number">2</span></span><br><span class="line">    prec[<span class="string">&quot;(&quot;</span>] = <span class="number">1</span></span><br><span class="line">    opStack = Stack()</span><br><span class="line">    postfixList = []</span><br><span class="line">    tokenList = infixexpr.split()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokenList:</span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span> <span class="keyword">or</span> token <span class="keyword">in</span> <span class="string">&quot;0123456789&quot;</span>:</span><br><span class="line">            postfixList.append(token)</span><br><span class="line">        <span class="keyword">elif</span> token == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            opStack.push(token)</span><br><span class="line">        <span class="keyword">elif</span> token == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            topToken = opStack.pop()</span><br><span class="line">            <span class="keyword">while</span> topToken != <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                postfixList.append(topToken)</span><br><span class="line">                topToken = opStack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">not</span> opStack.isEmpty()) <span class="keyword">and</span> \</span><br><span class="line">                (prec[opStack.peek()] &gt;= prec[token]):</span><br><span class="line">                postfixList.append(opStack.pop())</span><br><span class="line">            opStack.push(token)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> opStack.isEmpty():</span><br><span class="line">        postfixList.append(opStack.pop())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(postfixList)</span><br></pre></td></tr></table></figure>
<h4 id="2-3-4-后缀表达式求值"><a href="#2-3-4-后缀表达式求值" class="headerlink" title="2.3.4 后缀表达式求值"></a>2.3.4 后缀表达式求值</h4><ul>
<li>创建空栈operandStack用于暂存操作数。</li>
<li>将后缀表达式用split方法解析为单词（token）的列表。</li>
<li>从左到右扫描单词列表，如果单词是一个操作数，将单词转换为整数int，压入operandStack栈顶；如果单词是一个操作符，就开始求值，从栈顶弹出两个操作数，先弹出的是右操作数，后弹出的是左操作数，计算后将值重新压入栈顶。</li>
<li>单词列表扫描结束后，表达式的值就在栈顶。</li>
<li>弹出栈顶的值，返回。<br><img src="https://img-blog.csdnimg.cn/ca6f3ddb73cb4aa8a46158447f30adaa.png" alt="在这里插入图片描述"><br><strong>代码实现</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postfixEval</span>(<span class="params">postfixExpr</span>):</span></span><br><span class="line">    operandStack = Stack()</span><br><span class="line">    tokenList = postfixExpr.split()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokenList:</span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">&quot;0123456789&quot;</span>:</span><br><span class="line">            operandStack.push(<span class="built_in">int</span>(token))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            operand2 = operandStack.pop()</span><br><span class="line">            operand1 = operandStack.pop()</span><br><span class="line">            result = doMath(token,operand1,operand2)</span><br><span class="line">            operandStack.push(result)</span><br><span class="line">    <span class="keyword">return</span> operandStack.pop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doMath</span>(<span class="params">op,op1,op2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> op == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1 * op2</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1 / op2</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1 + op2</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> op1 - op2</span><br></pre></td></tr></table></figure>
<h3 id="2-4-表达式求值问题"><a href="#2-4-表达式求值问题" class="headerlink" title="2.4 表达式求值问题"></a>2.4 表达式求值问题</h3><h4 id="2-4-1-基本计算器II"><a href="#2-4-1-基本计算器II" class="headerlink" title="2.4.1 基本计算器II"></a>2.4.1 基本计算器II</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II - 力扣（LeetCode）</a></p>
</blockquote>
<p>&#8195;&#8195;给定一个字符串表达式 <code>s</code>，表达式中所有整数为非负整数，运算符只有 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>，没有括号。请实现一个基本计算器来计算并返回它的值。</p>
<ul>
<li>$1 \le s.length \le 3 * 10^5$。</li>
<li><code>s</code> 由整数和算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>）组成，中间由一些空格隔开。</li>
<li><code>s</code> 表示一个有效表达式。</li>
<li>表达式中的所有整数都是非负整数，且在范围 $[0, 2^{31} - 1]$ 内。</li>
<li>题目数据保证答案是一个 32-bit 整数。</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>输入：s = “<code>3+2*2</code>“</li>
<li>输出：7</li>
</ul>
<p><strong>解题思路</strong></p>
<p>&#8195;&#8195;计算表达式中，乘除运算优先于加减运算。我们可以先做所有的乘除运算，将其结果放回表达式的原位置，这样整个表达式的值，就成了一系列加减的结果。</p>
<ul>
<li>遍历字符串，使用op记录每个数字之前的运算符。对于第一个数字，其之前的运算符视为‘+’。每次遍历到数字末尾时，根据op决定当前数字的计算方式：</li>
<li><code>+</code>：直接入栈</li>
<li><code>-</code>：将数字的负数入栈</li>
<li><code>*/</code>：将栈顶数字弹出，计算其与当前数字的结果，再将计算结果入栈</li>
<li>处理完当前数字后，更新操作符op，进行下一次计算</li>
<li>遍历完后，计算栈中所有数字的累加结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        s=<span class="built_in">list</span>(s)</span><br><span class="line">        stack=[]</span><br><span class="line">        op=<span class="string">&#x27;+&#x27;</span>    <span class="comment"># 记录操作符，默认为+</span></span><br><span class="line">        num=<span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                      </span><br><span class="line">            <span class="keyword">if</span> s[i].isdigit():</span><br><span class="line">                num+=s[i]</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> i==<span class="built_in">len</span>(s)-<span class="number">1</span> <span class="keyword">or</span> s[i] <span class="keyword">in</span> <span class="string">&#x27;+-*/&#x27;</span>:</span><br><span class="line">                num=<span class="built_in">int</span>(num)</span><br><span class="line">                <span class="keyword">if</span> op==<span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.append(num)</span><br><span class="line">                <span class="keyword">elif</span> op==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.append(-num)</span><br><span class="line">                <span class="keyword">elif</span> op==<span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stack.append(stack.pop()*num)</span><br><span class="line">                <span class="keyword">elif</span> op==<span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    stack.append(<span class="built_in">int</span>(stack.pop()/num))</span><br><span class="line">                op=s[i]</span><br><span class="line">                num=<span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-逆波兰表达式求值"><a href="#2-4-2-逆波兰表达式求值" class="headerlink" title="2.4.2  逆波兰表达式求值"></a>2.4.2  逆波兰表达式求值</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a>          </p>
</blockquote>
<p>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。</p>
<ul>
<li>两个整数之间的除法总是 向零截断</li>
<li>表达式中不含除零运算</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式，有效的算符为 ‘+’、’-‘、’*’ 和 ‘/‘ 。</li>
<li>示例：<ul>
<li>输入：tokens = <code>[&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</code></li>
<li>输出：22</li>
<li>该算式转化为常见的中缀算术表达式为：  <code>((10 * (6 / ((9 + 3) * -11))) + 17) + 5</code></li>
</ul>
</li>
</ul>
<p>&#8195;&#8195;本题实际是后缀表达式求值问题。因为前缀或者后缀表达式中，靠近数字的操作符先运算，所以不存在中缀表达式那种需要先比较运算符优先级的情况，直接运算就行了。唯一注意的是，数字可以是负数，需要稍微处理一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        Stack = []       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">        	<span class="comment"># 数字直接入栈，负数将其乘以-1再入栈</span></span><br><span class="line">            <span class="keyword">if</span> token.isdigit():</span><br><span class="line">                Stack.append(<span class="built_in">int</span>(token))</span><br><span class="line">            <span class="keyword">elif</span> token[<span class="number">0</span>]==<span class="string">&quot;-&quot;</span> <span class="keyword">and</span> <span class="built_in">len</span>(token)&gt;<span class="number">1</span>:<span class="comment"># 此时表示的是负数</span></span><br><span class="line">                Stack.append(<span class="built_in">int</span>(token[<span class="number">1</span>:])*-<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 碰到操作符就开始运算，弹出的第一个栈顶元素是第二操作数            </span></span><br><span class="line">            <span class="keyword">else</span>:               </span><br><span class="line">                num2 = Stack.pop()</span><br><span class="line">                num1 = Stack.pop()</span><br><span class="line">                result = self.doMath(token,num1,num2)</span><br><span class="line">                Stack.append(result)</span><br><span class="line">        <span class="keyword">return</span> Stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doMath</span>(<span class="params">self,op,num1,num2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 * num2</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(num1 / num2)</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 + num2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 - num2</span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-基本计算器I"><a href="#2-4-3-基本计算器I" class="headerlink" title="2.4.3 基本计算器I"></a>2.4.3 基本计算器I</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a></p>
</blockquote>
<p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。</p>
<ul>
<li>s 由数字、加减乘除和小括号 组成</li>
<li>‘+’ 不能用作一元运算，例如， “<code>+1</code>“ 和 “<code>+(2 + 3)</code>“ 无效</li>
<li>‘-‘ 可以用作一元运算，即 “<code>-1</code>“ 和 “<code>-(2 + 3)</code>“ 是有效的</li>
<li>输入中不存在两个连续的操作符</li>
<li>示例：<ul>
<li>输入： <code>s= &quot;(1+(4+5+2)-3)+(6+8)&quot;</code></li>
<li>输出：23</li>
</ul>
</li>
</ul>
<p>解题思路一：括号展开+栈<br><img src="https://img-blog.csdnimg.cn/43defdacf53247a3ad02a608541c085a.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/76e0c83809bc4c488b042bd752eba049.png" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ops = [<span class="number">1</span>]</span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                sign = ops[-<span class="number">1</span>]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                sign = -ops[-<span class="number">1</span>]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                ops.append(sign)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                ops.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> s[i].isdigit():</span><br><span class="line">                    num = num * <span class="number">10</span> + <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                ret += num * sign</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<p>解题思路2：构造nums和ops两个栈，分别存放操作数和操作符，然后遍历表达式：</p>
<blockquote>
<p>参考<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator-ii/solution/shi-yong-shuang-zhan-jie-jue-jiu-ji-biao-c65k/">《使用「双栈」解决「究极表达式计算」问题》</a></p>
<ul>
<li>遇到空格，跳过</li>
<li>遇到数字，将连续数字直接在nums中入栈（负数乘以-1）</li>
<li>遇到右括号时，优先级最大，反复弹出ops和nums中的元素进行计算，直到遇到左括号，将结果存入nums中。</li>
<li>因为我们是从前往后做的，假设我们当前已经扫描到 2 + 1 了（此时栈内的操作为 + ）。</li>
<li>遇到操作符，在ops中入栈。在放入之前先把栈内可以算的都算掉（<strong>只有「栈内运算符」比「当前运算符」优先级高/同等，才进行运算</strong>），使用现有的 nums 和 ops 进行计算，直到没有操作或者遇到左括号，计算结果放到 nums<ul>
<li>以<code>2 + 1</code>为例，如果后面出现的 + 2 或者 - 1 的话，满足「栈内运算符」比「当前运算符」优先级高/同等，可以将 2 + 1 算掉，把结果放到 nums 中；</li>
<li>如果后面出现的是 * 2 或者 / 1 的话，不满足「栈内运算符」比「当前运算符」优先级高/同等，这时候不能计算 2 + 1。</li>
<li>由于第一个数可能是负数，为了减少边界判断。一个小技巧是先往 nums 添加一个 0</li>
<li>为防止 () 内出现的首个字符为运算符，将所有的空格去掉，并将 (- 替换为 (0-，(+ 替换为 (0+（当然也可以不进行这样的预处理，将这个处理逻辑放到循环里去做）</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="2-5-验证栈序列"><a href="#2-5-验证栈序列" class="headerlink" title="2.5 验证栈序列"></a>2.5 验证栈序列</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-stack-sequences/">946 验证栈序列</a></p>
</blockquote>
<p>&#8195;&#8195;给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。</p>
<ul>
<li>示例 1：<ul>
<li>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</li>
<li>输出：true</li>
<li>解释：我们可以按以下顺序执行：<ul>
<li>push(1), push(2), push(3), push(4), pop() -&gt; 4,</li>
<li>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</li>
</ul>
</li>
</ul>
</li>
<li>示例 2：<ul>
<li>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</li>
<li>输出：false</li>
<li>解释：1 不能在 2 之前弹出。</li>
</ul>
</li>
</ul>
<p>使用分离双指针<code>i</code>和<code>j</code>，分别遍历<code>pushed</code> 和 <code>popped</code>两个数组。再用空栈存储每次操作的元素。</p>
<ul>
<li><code>pushed[i]</code>入栈，<code>i</code>右移</li>
<li>当<code>popped[j]</code>在栈中时，开始弹出，弹出前进行比较<ul>
<li><code>popped[j]</code>等于栈顶元素时，栈顶元素出栈，<code>j</code>右移</li>
<li>否则弹出次序不对，返回<code>False</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span>(<span class="params">self, pushed: <span class="type">List</span>[<span class="built_in">int</span>], popped: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n=<span class="built_in">len</span>(popped)</span><br><span class="line">        stack=[]</span><br><span class="line">        i,j=<span class="number">0</span>,<span class="number">0</span><span class="comment"># 分离双指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i&lt;n <span class="keyword">and</span> j&lt;n:</span><br><span class="line">            stack.append(pushed[i])</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> popped[j] <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="keyword">if</span> popped[j]==stack[-<span class="number">1</span>]:</span><br><span class="line">                    j+=<span class="number">1</span></span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
也可以写成：（<code>popped[j]</code>等于栈顶元素就出栈，遍历完看栈是否为空）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span>(<span class="params">self, pushed: <span class="type">List</span>[<span class="built_in">int</span>], popped: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n=<span class="built_in">len</span>(popped)</span><br><span class="line">        stack=[]</span><br><span class="line">        i,j=<span class="number">0</span>,<span class="number">0</span><span class="comment"># 分离双指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i&lt;n <span class="keyword">and</span> j&lt;n:</span><br><span class="line">            stack.append(pushed[i])</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> popped[j]==stack[-<span class="number">1</span>]:</span><br><span class="line">                    j+=<span class="number">1</span></span><br><span class="line">                    stack.pop()                </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack)==<span class="number">0</span>             </span><br></pre></td></tr></table></figure>
<h2 id="三、单调栈"><a href="#三、单调栈" class="headerlink" title="三、单调栈"></a>三、单调栈</h2><ul>
<li><p><strong>单调栈（Monotone Stack）</strong>：一种特殊的栈。在栈的「先进后出」规则基础上，要求「从 <strong>栈顶</strong> 到 <strong>栈底</strong> 的元素是单调递增（或者单调递减）」。</p>
</li>
<li><p><strong>单调递增栈</strong>：从栈顶到栈底的元素是单调递增的栈</p>
</li>
<li><strong>单调递减栈</strong>：从栈顶到栈底的元素是单调递减的栈</li>
</ul>
<blockquote>
<p>注意：这里定义的顺序是从「栈顶」到「栈底」。有的文章里是反过来的。本文全文以「栈顶」到「栈底」的顺序为基准来描述单调栈。</p>
</blockquote>
<h3 id="3-1-单调递增栈"><a href="#3-1-单调递增栈" class="headerlink" title="3.1 单调递增栈"></a>3.1 单调递增栈</h3><p>&#8195;&#8195;只有比栈顶元素小的元素才能直接进栈，否则需要先将栈中比当前元素小的元素出栈，再将当前元素入栈。 下面我们以数组 <code>[2, 7, 5, 4, 6, 3, 4, 2]</code> 为例，从左到右遍历，模拟一下「单调递增栈」的进栈、出栈过程：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">第 i 步</th>
<th style="text-align:center">待插入元素</th>
<th>操 作</th>
<th>结 果（左侧为栈底）</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td>2 入栈</td>
<td>[2]</td>
<td>元素 2 的左侧无比 2 大的元素</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">7</td>
<td>2 出栈，7 入栈</td>
<td>[7]</td>
<td>元素 7 的左侧无比 7 大的元素</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td>5 入栈</td>
<td>[7, 5]</td>
<td>元素 5 的左侧第一个比 5 大的元素为：7</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td>4 入栈</td>
<td>[7, 5, 4]</td>
<td>元素 4 的左侧第一个比 4 大的元素为：5</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td>4 出栈，5 出栈，6 入栈</td>
<td>[7, 6]</td>
<td>元素 6 的左侧第一个比 6 大的元素为：7</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
<td>3 入栈</td>
<td>[7, 6, 3]</td>
<td>元素 3 的左侧第一个比 3 大的元素为：6</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">4</td>
<td>3 出栈，4 入栈</td>
<td>[7, 6, 4]</td>
<td>元素 4 的左侧第一个比 4 大的元素为：6</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">2</td>
<td>2 入栈</td>
<td>[7, 6, 4, 2]</td>
<td>元素 2 的左侧第一个比 2 大的元素为：4</td>
</tr>
</tbody>
</table>
</div>
<p>&#8195;&#8195;最终栈中元素为 <code>[7, 6, 4, 2]</code>。因为从栈顶（右端）到栈底（左侧）元素的顺序为 <code>2, 4, 6, 7</code>，满足递增关系，所以这是一个单调递增栈。</p>
<p>&#8195;&#8195;我们以上述过程第 5 步为例，所对应的图示过程为：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/abb6ae403797803c5b1c49bcda3235ef.png" alt=""><br>以从左到右遍历元素为例，单调递增栈伪代码为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">monotoneIncreasingStack</span>(<span class="params">nums</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> num &gt;= stack[-<span class="number">1</span>]:</span><br><span class="line">            stack.pop()</span><br><span class="line">        stack.append(num)</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2-单调递减栈"><a href="#3-2-单调递减栈" class="headerlink" title="3.2 单调递减栈"></a>3.2 单调递减栈</h3><p>&#8195;&#8195;只有比栈顶元素大的元素才能直接进栈，否则需要先将栈中比当前元素大的元素出栈，再将当前元素入栈。下面我们以数组 <code>[4, 3, 2, 5, 7, 4, 6, 8]</code> 为例，模拟一下「单调递减栈」的进栈、出栈过程：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">第 i 步</th>
<th style="text-align:center">待插入元素</th>
<th>操 作</th>
<th>结 果（左侧为栈底）</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
<td>4 入栈</td>
<td>[4]</td>
<td>元素 4 的左侧无比 4 小的元素</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td>4 出栈，3 入栈</td>
<td>[3]</td>
<td>元素 3 的左侧无比 3 小的元素</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td>3 出栈，2 入栈</td>
<td>[2]</td>
<td>元素 2 的左侧无比 2 小的元素</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td>5 入栈</td>
<td>[2, 5]</td>
<td>元素 5 的左侧第一个比 5 小的元素是：2</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">7</td>
<td>7 入栈</td>
<td>[2, 5, 7]</td>
<td>元素 7 的左侧第一个比 7 小的元素是：5</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
<td>7 出栈，5 出栈，4 入栈</td>
<td>[2, 4]</td>
<td>元素 4 的左侧第一个比 4 小的元素是：2</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">6</td>
<td>6 入栈</td>
<td>[2, 4, 6]</td>
<td>元素 6 的左侧第一个比 6 小的元素是：4</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td>8 入栈</td>
<td>[2, 4, 6, 8]</td>
<td>元素 8 的左侧第一个比 8 小的元素是：6</td>
</tr>
</tbody>
</table>
</div>
<p>&#8195;&#8195;最终栈中元素为 <code>[2, 4, 6, 8]</code>。因为从栈顶（右端）到栈底（左侧）元素的顺序为 <code>8, 6, 4, 2</code>，满足递减关系，所以这是一个单调递减栈。</p>
<p>&#8195;&#8195;我们以上述过程第 6 步为例，所对应的图示过程为： </p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a7c7cc8f491a3b62f72bfa4c9eaa228f.png" alt=""><br>以从左到右遍历元素为例，单调递减栈伪代码为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">monotoneDecreasingStack</span>(<span class="params">nums</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> num &lt;= stack[-<span class="number">1</span>]:</span><br><span class="line">            stack.pop()</span><br><span class="line">        stack.append(num)</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-单调栈适用场景"><a href="#3-3-单调栈适用场景" class="headerlink" title="3.3 单调栈适用场景"></a>3.3 单调栈适用场景</h3><p>单调栈可以在时间复杂度为 $O(n)$ 的情况下，求解出某个元素左边或者右边第一个比它大或者小的元素。</p>
<p>所以单调栈一般用于解决一下几种问题：</p>
<ul>
<li>寻找左侧第一个比当前元素大的元素。</li>
<li>寻找左侧第一个比当前元素小的元素。</li>
<li>寻找右侧第一个比当前元素大的元素。</li>
<li>寻找右侧第一个比当前元素小的元素。</li>
</ul>
<p>下面分别说一下这几种问题的求解方法。</p>
<h4 id="3-3-1-寻找左侧第一个比当前元素大的元素"><a href="#3-3-1-寻找左侧第一个比当前元素大的元素" class="headerlink" title="3.3.1 寻找左侧第一个比当前元素大的元素"></a>3.3.1 寻找左侧第一个比当前元素大的元素</h4><ul>
<li>从左到右遍历元素，构造单调递增栈（从栈顶到栈底递增）：<ul>
<li>一个元素左侧第一个比它大的元素就是将其「插入单调递增栈」时的栈顶元素。</li>
<li>如果插入时的栈为空，则说明左侧不存在比当前元素大的元素。</li>
</ul>
</li>
</ul>
<h4 id="3-3-2-寻找左侧第一个比当前元素小的元素"><a href="#3-3-2-寻找左侧第一个比当前元素小的元素" class="headerlink" title="3.3.2 寻找左侧第一个比当前元素小的元素"></a>3.3.2 寻找左侧第一个比当前元素小的元素</h4><ul>
<li>从左到右遍历元素，构造单调递减栈（从栈顶到栈底递减）：<ul>
<li>一个元素左侧第一个比它小的元素就是将其「插入单调递减栈」时的栈顶元素。</li>
<li>如果插入时的栈为空，则说明左侧不存在比当前元素小的元素。</li>
</ul>
</li>
</ul>
<h4 id="3-3-3-寻找右侧第一个比当前元素大的元素"><a href="#3-3-3-寻找右侧第一个比当前元素大的元素" class="headerlink" title="3.3.3 寻找右侧第一个比当前元素大的元素"></a>3.3.3 寻找右侧第一个比当前元素大的元素</h4><ul>
<li><p>从左到右遍历元素，构造单调递增栈（从栈顶到栈底递增）：</p>
<ul>
<li>一个元素右侧第一个比它大的元素就是将其「弹出单调递增栈」时即将插入的元素。</li>
<li>如果该元素没有被弹出栈，则说明右侧不存在比当前元素大的元素。</li>
</ul>
</li>
<li><p>从右到左遍历元素，构造单调递增栈（从栈顶到栈底递增）：</p>
<ul>
<li>一个元素右侧第一个比它大的元素就是将其「插入单调递增栈」时的栈顶元素。</li>
<li>如果插入时的栈为空，则说明右侧不存在比当前元素大的元素。</li>
</ul>
</li>
</ul>
<h4 id="3-3-4-寻找右侧第一个比当前元素小的元素"><a href="#3-3-4-寻找右侧第一个比当前元素小的元素" class="headerlink" title="3.3.4 寻找右侧第一个比当前元素小的元素"></a>3.3.4 寻找右侧第一个比当前元素小的元素</h4><ul>
<li><p>从左到右遍历元素，构造单调递减栈（从栈顶到栈底递减）：</p>
<ul>
<li>一个元素右侧第一个比它小的元素就是将其「弹出单调递减栈」时即将插入的元素。</li>
<li>如果该元素没有被弹出栈，则说明右侧不存在比当前元素小的元素。</li>
</ul>
</li>
<li><p>从右到左遍历元素，构造单调递减栈（从栈顶到栈底递减）：</p>
<ul>
<li>一个元素右侧第一个比它小的元素就是将其「插入单调递减栈」时的栈顶元素。</li>
<li>如果插入时的栈为空，则说明右侧不存在比当前元素小的元素。</li>
</ul>
</li>
</ul>
<p>上边的分类解法有点绕口，可以简单记为以下条规则：</p>
<ul>
<li><p>无论哪种题型，都建议从左到右遍历元素。</p>
</li>
<li><p>查找 <strong>「比当前元素大的元素」</strong> 就用 <strong>单调递增栈</strong>，查找 <strong>「比当前元素小的元素」</strong> 就用 <strong>单调递减栈</strong>。</p>
</li>
<li>从 <strong>「左侧」</strong> 查找就看 <strong>「插入栈」</strong> 时的栈顶元素，从 <strong>「右侧」</strong> 查找就看 <strong>「弹出栈」</strong> 时即将插入的元素。</li>
</ul>
<h2 id="四、-单调栈的应用"><a href="#四、-单调栈的应用" class="headerlink" title="四、 单调栈的应用"></a>四、 单调栈的应用</h2><h3 id="4-1-单调栈题目列表"><a href="#4-1-单调栈题目列表" class="headerlink" title="4.1 单调栈题目列表"></a>4.1 单调栈题目列表</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">题号</th>
<th style="text-align:left">标题</th>
<th style="text-align:left">题解</th>
<th style="text-align:left">标签</th>
<th style="text-align:left">难度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0739</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0739.%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.md">Python</a></td>
<td style="text-align:left">栈、哈希表</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0496</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素 I</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0496.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I.md">Python</a></td>
<td style="text-align:left">栈、数组、哈希表、单调栈</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:left">0503</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/">下一个更大元素 II</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0503.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20II.md">Python</a></td>
<td style="text-align:left">栈、数组、单调栈</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0901</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/online-stock-span/">股票价格跨度</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0901.%20%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6.md">Python</a></td>
<td style="text-align:left">栈、设计、数据流、单调栈</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0084</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0084.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.md">Python</a></td>
<td style="text-align:left">栈、数组、单调栈</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">0316</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicate-letters/">去除重复字母</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0316.%20%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D.md">Python</a></td>
<td style="text-align:left">栈、贪心、字符串、单调栈</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">1081</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/">不同字符的最小子序列</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/1081.%20%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97.md">Python</a></td>
<td style="text-align:left">栈、贪心、字符串、单调栈</td>
<td style="text-align:left">中等</td>
</tr>
<tr>
<td style="text-align:left">0042</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a></td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0042.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4.md">Python</a></td>
<td style="text-align:left">栈、数组、双指针、动态规划、单调栈</td>
<td style="text-align:left">困难</td>
</tr>
<tr>
<td style="text-align:left">0085</td>
<td style="text-align:left">最大矩形</td>
<td style="text-align:left"></td>
<td style="text-align:left">单调栈</td>
<td style="text-align:left">困难</td>
</tr>
</tbody>
</table>
</div>
<p>下面介绍一下经典题目</p>
<h3 id="4-2-下一个更大元素-I-amp-II"><a href="#4-2-下一个更大元素-I-amp-II" class="headerlink" title="4.2 下一个更大元素 I &amp; II"></a>4.2 下一个更大元素 I &amp; II</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">0496. 下一个更大元素 I</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/">0503. 下一个更大元素 II</a></li>
</ul>
</blockquote>
<p>&#8195;&#8195;给定两个没有重复元素的数组 <code>nums1</code> 和 <code>nums2</code> ，其中 <code>nums1</code> 是 <code>nums2</code> 的子集。要求找出 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值，如果不存在，对应位置输出 <code>-1</code>。<br><strong>示例</strong> ：</p>
<ul>
<li>输入：nums1 = [4,1,2], nums2 = [1,3,4,2].</li>
<li>输出：[-1,3,-1]</li>
<li>解释：nums1 中每个值的下一个更大元素如下所述：<ul>
<li>4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</li>
<li>1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。</li>
<li>2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</li>
</ul>
</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><p>暴力求解：<br>根据题意直接暴力求解。遍历 <code>nums1</code> 中的每一个元素。对于 <code>nums1</code> 的每一个元素 <code>nums1[i]</code>，再遍历一遍 <code>nums2</code>，查找 <code>nums2</code> 中对应位置右边第一个比 <code>nums1[i]</code> 大的元素。这种解法的时间复杂度是 $O(n^2)$。</p>
</li>
<li><p>使用单调递增栈。因为 <code>nums1</code> 是 <code>nums2</code> 的子集，所以我们可以先遍历一遍 <code>nums2</code>，并构造单调递增栈，求出 <code>nums2</code> 中每个元素右侧下一个更大的元素。然后将其存储到哈希表中。然后再遍历一遍 <code>nums1</code>，从哈希表中取出对应结果，存放到答案数组中。这种解法的时间复杂度是 $O(n)$。</p>
</li>
</ol>
<p><strong>解题步骤</strong></p>
<ul>
<li>使用数组 <code>ans</code> 存放答案。使用 <code>stack</code> 表示单调递增栈。使用哈希表 <code>d</code> 用于存储 <code>nums2</code> 中下一个比当前元素大的数值，映射关系为 <code>当前元素值：下一个比当前元素大的数值</code>。</li>
<li><p>遍历数组 <code>nums2</code>，对于当前元素：</p>
<ul>
<li>如果当前元素值较小，则直接让当前元素值入栈。</li>
<li>如果当前元素值较大，则一直出栈，直到当前元素值小于栈顶元素。<ul>
<li>出栈时，出栈元素是第一个大于当前元素值的元素。则将其映射到 <code>d</code> 中。</li>
</ul>
</li>
</ul>
</li>
<li><p>遍历完数组 <code>nums2</code>，建立好所有元素下一个更大元素的映射关系之后，再遍历数组 <code>nums1</code>。</p>
</li>
<li>从 <code>d</code> 中取出对应的值，将其加入到答案数组中，最终输出答案数组 <code>ans</code>。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        stack=[]</span><br><span class="line">        d=<span class="built_in">dict</span>()</span><br><span class="line">        ans=[]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> i&gt;stack[-<span class="number">1</span>]:                </span><br><span class="line">                d[stack[-<span class="number">1</span>]]=i</span><br><span class="line">                stack.pop()</span><br><span class="line">            stack.append(i)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> nums1:</span><br><span class="line">            ans.append(d.get(j,-<span class="number">1</span>))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;类似的题目还有下一个更大元素 I I，唯一不同的是数组是循环的。简单做法是将nums循环一次，即nums=nums+nums，再求解后，取结果的前m个数值作为答案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        m=<span class="built_in">len</span>(nums)</span><br><span class="line">        nums=nums+nums        </span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        stack=[]</span><br><span class="line">        ans=[-<span class="number">1</span>]*n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums[i]&gt;nums[stack[-<span class="number">1</span>]]:</span><br><span class="line">                index=stack.pop()</span><br><span class="line">                ans[index]=nums[i]</span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans[:m]</span><br></pre></td></tr></table></figure>
<p>上面代码中 <code>index=stack.pop()</code>等同于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index=stack[-<span class="number">1</span>]  </span><br><span class="line">stack.pop() </span><br></pre></td></tr></table></figure>
<h3 id="4-3-每日温度"><a href="#4-3-每日温度" class="headerlink" title="4.3 每日温度"></a>4.3 每日温度</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度 - 力扣（LeetCode）</a></p>
</blockquote>
<p>&#8195;&#8195;给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<ul>
<li>$1 \le temperatures.length \le 10^5$。</li>
<li>$30 \le temperatures[i] \le 100$。</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>输入: temperatures = [73,74,75,71,69,72,76,73]</li>
<li>输出: [1,1,4,2,1,1,0,0]</li>
</ul>
<p><strong>解题思路</strong></p>
<p>&#8195;&#8195;本题就是寻找每个元素右侧第一个更大的元素，然后返回「该元素」与「右侧第一个比当前元素更大的元素」之间的距离，将所有距离保存为数组返回结果。考虑使用「单调递增栈」，栈中保存元素的下标。</p>
<p><strong>详细步骤</strong></p>
<ol>
<li>将答案数组 <code>ans</code> 全部赋值为 0。然后遍历数组每个位置元素。</li>
<li>如果栈为空，则将当前元素的下标入栈。</li>
<li>如果栈不为空，且当前数字大于栈顶元素对应数字，则栈顶元素出栈，并计算下标差。</li>
<li>此时当前元素就是栈顶元素的下一个更高值，将其下标差存入答案数组 <code>ans</code> 中保存起来，判断栈顶元素。</li>
<li>直到当前数字小于或等于栈顶元素，则停止出栈，将当前元素下标入栈。</li>
<li>最后输出答案数组 <code>ans</code>。</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        stack=[]</span><br><span class="line">        n=<span class="built_in">len</span>(temperatures)</span><br><span class="line">        ans=[<span class="number">0</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temperatures[i]&gt;temperatures[stack[-<span class="number">1</span>]]:</span><br><span class="line">                index=stack.pop()</span><br><span class="line">                ans[index]=i-index</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="4-4-股票价格跨度"><a href="#4-4-股票价格跨度" class="headerlink" title="4.4 股票价格跨度"></a>4.4 股票价格跨度</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/online-stock-span/">0901. 股票价格跨度</a></p>
</blockquote>
<p>&#8195;&#8195;设计一个算法收集某些股票的每日报价，并返回该股票当日价格的跨度 。当日股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。<br>&#8195;&#8195;实现 StockSpanner 类：</p>
<ul>
<li><code>StockSpanner()</code> ：初始化类对象。</li>
<li><code>int next(int price)</code> ：给出今天的股价 <code>price</code> ，返回该股票当日价格的 跨度 。</li>
</ul>
<p><strong>示例</strong></p>
<ul>
<li>输入： [100,80,60,70,60,75,85]</li>
<li>输出：那么股票跨度将是 [1,1,1,2,1,4,6] 。</li>
</ul>
<p><strong>解题思路</strong></p>
<p>「求解小于或等于今天价格的最大连续日」等价于「求出左侧第一个比当前股票价格大的股票，并计算距离」。求出左侧第一个比当前股票价格大的股票我们可以使用「单调递减栈」来做。</p>
<p><strong>详细步骤</strong></p>
<ul>
<li><p>初始化方法：初始化一个空栈，即 <code>self.stack = []</code></p>
</li>
<li><p>求解今天股票价格的跨度：</p>
<ul>
<li>初始化跨度 <code>span</code> 为 <code>1</code>。</li>
<li>如果今日股票价格 <code>price</code> 大于等于栈顶元素 <code>self.stack[-1][0]</code>，则：<ul>
<li>将其弹出，即 <code>top = self.stack.pop()</code>。</li>
<li>跨度累加上弹出栈顶元素的跨度，即 <code>span += top[1]</code>。</li>
<li>继续判断，直到遇到一个今日股票价格 <code>price</code> 小于栈顶元素的元素位置，再将 <code>[price, span]</code> 压入栈中。</li>
</ul>
</li>
<li><p>如果今日股票价格 <code>price</code> 小于栈顶元素 <code>self.stack[-1][0]</code>，则直接将 <code>[price, span]</code> 压入栈中。</p>
</li>
<li><p>最后输出今天股票价格的跨度 <code>span</code>。    </p>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self, price: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        span = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> self.stack <span class="keyword">and</span> price &gt;= self.stack[-<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">            top = self.stack.pop()</span><br><span class="line">            span += top[<span class="number">1</span>]</span><br><span class="line">        self.stack.append([price, span])</span><br><span class="line">        <span class="keyword">return</span> span</span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;也可以将遍历时每个元素的下标 <code>self.cur</code>存入栈中，然后计算入栈时，当前元素下标和入栈前栈顶元素的下标差就行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment">#单调递增插入栈。左侧第一个更大的元素就是插入元素时的栈顶元素</span></span><br><span class="line">        self.stack = [(inf,-<span class="number">1</span>)]</span><br><span class="line">        self.cur=-<span class="number">1</span> <span class="comment"># 遍历时的当前元素下标，赋值为-1，第一次遍历时下标=0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self, price: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.cur+=<span class="number">1</span> <span class="comment"># 第一个元素下标为0</span></span><br><span class="line">                                </span><br><span class="line">        <span class="keyword">while</span> self.stack <span class="keyword">and</span> price&gt;=self.stack[-<span class="number">1</span>][<span class="number">0</span>]: </span><br><span class="line">            self.stack.pop()             </span><br><span class="line">        self.stack.append([price,self.cur])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当前元素已入栈，所以其插入前的栈顶元素是stack[-2]</span></span><br><span class="line">        <span class="keyword">return</span> self.cur-self.stack[-<span class="number">2</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="4-5-去除重复字母"><a href="#4-5-去除重复字母" class="headerlink" title="4.5 去除重复字母"></a>4.5 去除重复字母</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicate-letters/">0316. 去除重复字母</a>    ，这道题和<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/">1081. 不同字符的最小子序列</a>是一样的。</p>
</blockquote>
<p>&#8195;&#8195;给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p>
<p>示例：</p>
<ul>
<li>输入：s = “cbacdcbc”</li>
<li>输出：”acdb”</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><strong>去重</strong>：可以通过 <strong>「使用哈希表存储字母出现次数」</strong> 的方式，将每个字母出现的次数统计起来，再遍历一遍，去除重复的字母。</li>
<li><strong>不能打乱其他字符顺序</strong>：按顺序遍历，将非重复的字母存储到答案数组或者栈中，最后再拼接起来，就能保证不打乱其他字符顺序。</li>
<li><strong>字典序最小</strong>：意味着字典序小的字母应该尽可能放在前面。<ol>
<li>对于第 <code>i</code> 个字符 <code>s[i]</code> 而言，如果第 <code>0</code> ~ <code>i - 1</code> 之间的某个字符 <code>s[j]</code> 在 <code>s[i]</code> 之后不再出现了，那么 <code>s[j]</code> 必须放到 <code>s[i]</code> 之前。</li>
<li>而如果 <code>s[j]</code> 在之后还会出现，并且 <code>s[j]</code> 的字典序大于 <code>s[i]</code>，我们则可以先舍弃 <code>s[j]</code>，把 <code>s[i]</code> 尽可能的放到前面。后边再考虑使用 <code>s[j]</code> 所对应的字符。</li>
</ol>
</li>
</ol>
<p>要满足第 3 条需求，我们可以使用 <strong>「单调递减栈」</strong> 来解决，即使用单调栈存储 <code>s[i]</code> 之前出现的非重复、并且字典序最小的字符序列。整个算法步骤如下：</p>
<ol>
<li>先遍历一遍字符串，用哈希表 <code>d</code> 统计出每个字母出现的次数。</li>
<li>然后使用单调递减栈保存当前字符之前出现的非重复、并且字典序最小的字符序列。</li>
<li>当遍历到 <code>s[i]</code> 时，如果 <code>s[i]</code> 没有在栈中出现过：<ol>
<li>比较 <code>s[i]</code> 和栈顶元素 <code>stack[-1]</code> 的字典序。如果 <code>s[i]</code> 的字典序小于栈顶元素 <code>stack[-1]</code>，并且栈顶元素次数 <code>&gt;1</code>，则将栈顶元素弹出，并从哈希表 <code>d</code> 中减去栈顶元素出现的次数，继续遍历。</li>
<li>直到栈顶元素出现次数为 <code>1</code> 时停止弹出。此时将 <code>s[i]</code> 添加到单调栈中。</li>
</ol>
</li>
<li>如果 遍历时，<code>s[i]</code> 在栈中出现过，就将其次数-1，因为我们只在<code>s[i]</code> 首次遍历时将其入栈，后续重复时不入栈，其统计次数应该-1。</li>
<li>最后将单调栈中的字符依次拼接为答案字符串，并返回。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        d=<span class="built_in">dict</span>(Counter(s))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用单调递减栈保证字典序最小</span></span><br><span class="line">        <span class="comment"># 如果遍历的当前元素小于栈顶元素，当其次数大于1时，将栈顶弹出，对应次数-1。直至=0时不再弹出</span></span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> ch&lt;stack[-<span class="number">1</span>] <span class="keyword">and</span> d[stack[-<span class="number">1</span>]]&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 注意，这里是先统计次数，再执行pop操作，并且是ch&lt;=stack[-1]</span></span><br><span class="line">                    d[stack[-<span class="number">1</span>]]-=<span class="number">1</span></span><br><span class="line">                    stack.pop()                     </span><br><span class="line">                stack.append(ch)</span><br><span class="line">            <span class="comment"># 如果ch已经在栈中，将其次数-1，等同于之前的相同元素会出栈，当前重复元素入栈。</span></span><br><span class="line">            <span class="comment"># 否则[bbcaac]这种会出错。</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                d[ch]-=<span class="number">1</span></span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-6-柱状图中最大的矩形"><a href="#4-6-柱状图中最大的矩形" class="headerlink" title="4.6 柱状图中最大的矩形"></a>4.6 柱状图中最大的矩形</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">0084. 柱状图中最大的矩形</a></p>
</blockquote>
<p>&#8195;&#8195;给定一个非负整数数组 <code>heights</code> ，<code>heights[i]</code> 用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。要求计算出在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>示例</strong></p>
<ul>
<li>输入：heights = [2,1,5,6,2,3]</li>
<li>输出：10</li>
<li>解释：最大的矩形为图中红色区域，面积为 10<br><img src="https://img-blog.csdnimg.cn/5374cad9e594404f97e4c44f65eb09a5.png" alt="在这里插入图片描述"></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><p>暴力枚举「宽度」：<br>一重循环枚举所有柱子，第二重循环遍历柱子右侧的柱子，所得的宽度就是两根柱子形成区间的宽度，高度就是这段区间中的最小高度。然后计算出对应面积，记录并更新最大面积。这样下来，时间复杂度为 $O(n^2)$。</p>
</li>
<li><p>暴力枚举枚举「高度」。一重循环枚举所有柱子，以柱子高度为当前矩形高度，然后向两侧延伸，遇到小于当前矩形高度的情况就停止。然后计算当前矩形面积，记录并更新最大面积。这样下来，时间复杂度也是 $O(n^2)$。</p>
</li>
<li><p>单调栈遍历，求左右边界</p>
<ul>
<li>当前柱子<code>heights[i]</code>所能延伸到的最大面积<code>S[i]</code>，其实就是左右两侧高度不小于<code>heights[i]</code>的最远柱子之间的面积。也就是说，柱子<code>i</code>往左右延伸，直到碰到的柱子高度<code>&lt;heights[i]</code>时停止。所以本题关键是求数组<code>heights</code>中，每个元素左侧最近的更小值和右侧最近的更小值，考虑使用单调递减栈求解。</li>
<li>注意，面积延伸时，碰到更小的高度才停止，所以使用严格单调递减栈，遍历的元素严格大于栈顶元素才入栈，小于等于栈顶元素时，栈顶弹出。所以判断条件是<code>heights[i]&lt;=heights[stack[-1]]</code>，有等号。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        stack=[]</span><br><span class="line">        n=<span class="built_in">len</span>(heights)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 寻找左侧更小值，使用单调递减插入栈，栈中只存入栈元素的下标。</span></span><br><span class="line">        <span class="comment"># 当前元素≤栈顶元素时，栈顶弹出。</span></span><br><span class="line">        <span class="comment"># 直到当前元素入栈，此时栈顶元素就是当前元素的左侧第一个更小值。</span></span><br><span class="line">        <span class="comment"># 如果碰到空栈，说明左侧没有更小的元素，将其下标记为-1（哨兵，表示往左可以延伸到数组开头）</span></span><br><span class="line">        left=[-<span class="number">1</span>]*n        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i]&lt;=heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()               </span><br><span class="line">            left[i]=stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># print(left)</span></span><br><span class="line">        </span><br><span class="line">        right=[n]*n</span><br><span class="line">        stack=[] <span class="comment"># 没有重新设置stack初始化，坑</span></span><br><span class="line">        <span class="comment"># 寻找右侧更小值，使用单调递减弹出栈</span></span><br><span class="line">        <span class="comment"># 当前元素≤栈顶元素时，将栈顶弹出。此时，弹出前的栈顶元素的右侧第一个更小值就是当前元素</span></span><br><span class="line">        <span class="comment"># 如果为空栈，说明右侧没有更小元素，将其下标记为n（也就是往右遍历到数组结尾）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i]&lt;=heights[stack[-<span class="number">1</span>]]:               </span><br><span class="line">                right[stack[-<span class="number">1</span>]]=i <span class="keyword">if</span> stack <span class="keyword">else</span> n</span><br><span class="line">                stack.pop()               </span><br><span class="line">                </span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="comment"># print(right)                                           </span></span><br><span class="line">        </span><br><span class="line">        ans = [(right[i]-left[i]-<span class="number">1</span>) * heights[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans)</span><br></pre></td></tr></table></figure>
<p>&#8195;&#8195;上面的代码中，我们用插入栈得到左侧更小的元素，使用弹出栈得到右侧更小的元素，但都使用了单调递减栈，判断条件也相同，所以其实可以一次遍历得到左右边界，优化后代码为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        stack=[]</span><br><span class="line">        n=<span class="built_in">len</span>(heights)</span><br><span class="line">        left=[-<span class="number">1</span>]*n </span><br><span class="line">        right=[n]*n  </span><br><span class="line">             </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i]&lt;=heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                right[stack[-<span class="number">1</span>]]=i </span><br><span class="line">                stack.pop()               </span><br><span class="line">            left[i]=stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">                                                      </span><br><span class="line">        ans = [(right[i]-left[i]-<span class="number">1</span>) * heights[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans)</span><br></pre></td></tr></table></figure>
<h3 id="4-7-接雨水"><a href="#4-7-接雨水" class="headerlink" title="4.7 接雨水"></a>4.7 接雨水</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">0042. 接雨水</a></p>
</blockquote>
<p>给定n个非负整数组成的数组 height ，其表示表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<ul>
<li>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</li>
<li>输出：6</li>
<li>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/31ea57f2e59c48ccb782068675cf0c3e.png" alt="在这里插入图片描述"></p>
<ul>
<li>$n == height.length$。</li>
<li>$1 \le n \le 2 * 10^4$。</li>
<li>$0 \le height[i] \le 10^5$。</li>
</ul>
<p><strong>解题思路</strong>    </p>
<ol>
<li><p>求出蓄水边界</p>
<ul>
<li>最明显的，某个柱子左右有更高的柱子时，这个柱子上才可以接雨水 ，这样需要首先求出数组中每个元素左侧和右侧最近的更高柱子，即蓄水的左右边界。</li>
<li>所以考虑使用单调递增栈求出左右边界的下标。比如<code>height = [0,1,0,2,1,0,1,3,2,1,2,1]</code>时，左边界<code>left=[-1, -1, 1, -1, 3, 4, 3, -1, 7, 8, 7, 10]</code>，右边界<code>right=[1, 3, 3, 7, 7, 6, 7, 12, 12, 10, 12, 12]</code></li>
<li>寻找左右边界时，因为是寻找两侧严格大的柱子，判断条件不一样，没办法一次遍历出来（可以自行测试）。</li>
</ul>
</li>
<li><p>求出蓄水面积</p>
<ul>
<li>蓄水宽度=左右边界下标差，蓄水高度=min（左右边界高度）- 当前柱子高度。这样可以算出每个柱子可以接的雨水。</li>
<li>还是以上面例子为例，此时得到的结果ans（柱子下标i，接水面积area）=<code>[(2,1),(4,3),(5,1),(6,3),(9,1)]</code>。可见计算的结果都是对的，唯一错误是下标4和6的这两个柱子，蓄水面积都计算了一次。观察可以发现，这两个柱子的左右边界完全相同，其结果只需要计算一次</li>
<li>考虑使用字典<code>d</code>，存储每个柱子的边界。对于相同的边界，蓄水面积只计算一次。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment">#寻找左边界</span></span><br><span class="line"></span><br><span class="line">        n=<span class="built_in">len</span>(height)</span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="comment"># 构造单调递增栈，更小的元素才入栈。例如[8,3,3,7.7,9]，当第一个3入栈时，7才是右侧更大的元素，所以是当前元素严格大于栈顶元素才入栈</span></span><br><span class="line">        left,right=[-<span class="number">1</span>]*n,[n]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[i]&gt;height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                right[stack[-<span class="number">1</span>]]=i </span><br><span class="line">                stack.pop()         </span><br><span class="line">            <span class="comment">#left[i]=stack[-1] if stack else -1</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        </span><br><span class="line">        stack=[]    </span><br><span class="line">        <span class="comment"># 构造单调递增栈，更小的元素才入栈。例如[8,3,3]，当第二个3入栈时，8才是左侧更大的元素</span></span><br><span class="line">        <span class="comment"># 所以判断条件中有等号，相同元素也要弹出。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[i]&gt;=height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            left[i]=stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;left:&quot;</span>,left)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;right:&quot;</span>,right)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果碰到左右边界完全一样，只计算一次</span></span><br><span class="line">        ans=[]</span><br><span class="line">        d=<span class="built_in">dict</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        	<span class="comment"># 遍历每个元素的左右边界</span></span><br><span class="line">            l,r=left[i],right[i]</span><br><span class="line">            <span class="keyword">if</span> l!=-<span class="number">1</span> <span class="keyword">and</span> r!=n:                              </span><br><span class="line">                <span class="keyword">if</span> (l,r) <span class="keyword">not</span> <span class="keyword">in</span> d: <span class="comment"># 相同边界的柱子蓄水量只计算一次</span></span><br><span class="line">                    area=(<span class="built_in">min</span>(height[l],height[r])-height[i])*(right[i]-left[i]-<span class="number">1</span>)</span><br><span class="line">                    ans.append(area)</span><br><span class="line">                    <span class="comment">#print(i,area)</span></span><br><span class="line">                d[(l,r)]=i</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(ans)</span><br></pre></td></tr></table></figure>
<p><strong>优化一：一次遍历出左右边界</strong><br>&#8195;&#8195;上面代码可以优化，其实无论是<code>height[i]&gt;=height[stack[-1]]</code>还是<code>height[i]&gt;height[stack[-1]]</code>，只用一个判断条件得到的结果，有一个边界是不完全准确的，但是不影响最终结果。比如：</p>
<ul>
<li><code>height[i]&gt;height[stack[-1]]</code>时，左边界不准，为<code>left= [-1, -1, 1, -1, 3, 4, 4(3), -1, 7, 8, 8(7), 10]</code>，右边界是准的，<code>right= [1, 3, 3, 7, 7, 6, 7, 12, 12, 10, 12, 12]</code>。</li>
<li>上面第6个柱子左边界应该是3，这里判断是4。结果就是计算时，左边界4和柱子6的高度一样，area=0。所以，虽然不是严格的左边界，但是不影响最终结果。以上面数组为例，<code>area=[(2,1),(4,3),(5,1),(6,0),(9,1)]</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment">#寻找左右边界</span></span><br><span class="line">        n=<span class="built_in">len</span>(height)</span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="comment"># 构造单调递增栈，更小的元素才入栈。例如[8,3,3,7.7,9]，当第一个3入栈时，7才是右侧更大的元素，所以是当前元素严格大于栈顶元素才入栈</span></span><br><span class="line">        <span class="comment"># 例如[8,3,3]，当第二个3入栈时，8才是左侧更大的元素</span></span><br><span class="line">        left,right=[-<span class="number">1</span>]*n,[n]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[i]&gt;height[stack[-<span class="number">1</span>]]: <span class="comment"># 这里可以是≥</span></span><br><span class="line">                right[stack[-<span class="number">1</span>]]=i </span><br><span class="line">                stack.pop()         </span><br><span class="line">            left[i]=stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(&quot;left:&quot;,left)</span></span><br><span class="line">        <span class="comment"># print(&quot;right:&quot;,right)</span></span><br><span class="line"></span><br><span class="line">        ans=[]        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        	<span class="comment"># 遍历每个元素的左右边界</span></span><br><span class="line">            l,r=left[i],right[i]</span><br><span class="line">            <span class="keyword">if</span> l!=-<span class="number">1</span> <span class="keyword">and</span> r!=n:                              </span><br><span class="line">                area=(<span class="built_in">min</span>(height[l],height[r])-height[i])*(right[i]-left[i]-<span class="number">1</span>)</span><br><span class="line">                ans.append(area)</span><br><span class="line">                <span class="comment"># print(i,area)</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(ans)</span><br></pre></td></tr></table></figure>
<p><strong>优化二：在一次遍历中求左右边界，并同时求出蓄水面积</strong><br>&#8195;&#8195;这里需要将判断条件左右边界不为数组头尾（<code>if l!=-1 and r!=n:</code>  ） ，改为<code>if stack</code>，因为只有遇到空栈，才说明左右侧没有更高的柱子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        size = <span class="built_in">len</span>(height)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        	<span class="comment"># 这里写成height[i] &gt;= height[stack[-1]]也是没有问题的</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[i] &gt; height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                cur = stack.pop(-<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 当前元素被弹出时，其上一个元素是左侧更大值，将要入栈的是右侧更大值</span></span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    left = stack[-<span class="number">1</span>] </span><br><span class="line">                    right = i </span><br><span class="line">                    high = <span class="built_in">min</span>(height[i], height[stack[-<span class="number">1</span>]]) - height[cur]</span><br><span class="line">                    ans += high * (right - left - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 遇到空栈，停止弹出，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans         </span><br></pre></td></tr></table></figure>
<h3 id="4-8-最大矩形"><a href="#4-8-最大矩形" class="headerlink" title="4.8 最大矩形"></a>4.8 最大矩形</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-rectangle/">0085：最大矩阵</a> ，参考题解<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-rectangle/solution/python3-qian-zhui-he-dan-diao-zhan-ji-su-vkpp/">《Python3 前缀和+单调栈计算最大矩形》</a>        </p>
</blockquote>
<p>&#8195;&#8195;给定一个仅包含 0 和 1 ，大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。<br>示例：</p>
<ul>
<li>输入：matrix = [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]</li>
<li>输出：6</li>
<li>解释：最大矩形如下图所示。</li>
</ul>
<p>  <img src="https://img-blog.csdnimg.cn/aea8adcd2c104630b34f7b60d2ba3574.png" alt="在这里插入图片描述"></p>
<p><strong>解题思路</strong> ： </p>
<ul>
<li><p>我们可以统计每一行中，每个元素上方“1”的个数，这样就等同于得到了每一行柱子的高度<code>height</code>。</p>
<ul>
<li>对于<code>height</code>的计算，根据最大前缀和思想，当前位置j为‘0’，则<code>height[j]=0</code>，当前位置为‘1’，则需要加上上一层连续1的个数，即<code>height[j]+=1</code>。</li>
<li>例如本题中，<code>height[2]=[3, 1, 3, 2, 2]</code> </li>
</ul>
</li>
<li><p>用<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">0084. 柱状图中最大的矩形</a>中同样的做法，求得柱状图的最大面积就行。例如示例中，第二行面积为<code>[3, 5, 3, 6, 2]</code></p>
</li>
<li>遍历每一行，得到各行的最大面积，取全局最大值就行。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/71e7087118204c57897b293eea9d30c8.png" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m,n=<span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        height=[<span class="number">0</span>]*n <span class="comment"># 每行上方1的个数，可视作柱子的高度</span></span><br><span class="line">        ans=[]		 <span class="comment"># 存储每行的最大面积</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 第m行每个位置含1的高度</span></span><br><span class="line">                height[j]=height[j]+<span class="number">1</span> <span class="keyword">if</span> matrix[i][j]==<span class="string">&quot;1&quot;</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#根据柱子高度计算最大面积，等同于第84题</span></span><br><span class="line">            stack=[]</span><br><span class="line">            left,right=[-<span class="number">1</span>]*n,[n]*n</span><br><span class="line">            <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> height[h]&lt;height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                    right[stack[-<span class="number">1</span>]]=h</span><br><span class="line">                    stack.pop()</span><br><span class="line">                left[h]=stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">                stack.append(h)</span><br><span class="line">            res=[(right[h]-left[h]-<span class="number">1</span>)*height[h] <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n)] </span><br><span class="line">            </span><br><span class="line">            ans.append(<span class="built_in">max</span>(res))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans)</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhxnlp</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhxnlp.github.io/2023/03/01/数据结构与算法/LeetCode练习四：栈/">https://zhxnlp.github.io/2023/03/01/数据结构与算法/LeetCode练习四：栈/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhxnlp.github.io">zhxnlpのBlog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a><a class="post-meta__tags" href="/tags/Stack/">Stack</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E4%BA%94%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/"><i class="fa fa-chevron-left">  </i><span>leetcode练习五：哈希表</span></a></div><div class="next-post pull-right"><a href="/2023/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E4%B8%89%EF%BC%9A%E9%93%BE%E8%A1%A8/"><span>leetcode练习三：链表</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://img-blog.csdnimg.cn/ffe1f736be4548dc9101388503288e4d.png)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2023 By zhxnlp</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>