<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhxnlpのBlog</title>
  
  <subtitle>You got a dream, you gotta protect it</subtitle>
  <link href="https://zhxnlp.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhxnlp.github.io/"/>
  <updated>2023-04-08T02:36:28.242Z</updated>
  <id>https://zhxnlp.github.io/</id>
  
  <author>
    <name>zhxnlp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode练习九：树（下）——优先队列、堆排序</title>
    <link href="https://zhxnlp.github.io/2023/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E4%B9%9D%EF%BC%9A%E6%A0%91%EF%BC%88%E4%B8%8B%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://zhxnlp.github.io/2023/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E4%B9%9D%EF%BC%9A%E6%A0%91%EF%BC%88%E4%B8%8B%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2023-04-07T16:00:00.000Z</published>
    <updated>2023-04-08T02:36:28.242Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>参考<a href="https://algo.itcharge.cn/04.Queue/02.Priority-Queue/01.Priority-Queue/">《算法通关手册》</a>、<a href="https://www.bilibili.com/video/BV1gy4y1E7M5/?p=77&amp;spm_id_from=333.999.top_right_bar_window_history.content.click&amp;vd_source=21011151235423b801d3f3ae98b91e94">B站《数据结构与算法B Python版》视频</a></p></blockquote><h2 id="一、二叉堆和优先队列"><a href="#一、二叉堆和优先队列" class="headerlink" title="一、二叉堆和优先队列"></a>一、二叉堆和优先队列</h2><p>&#8195;&#8195;队列有一种变体称为<strong>优先队列<code>Priority Queue</code></strong>。优先队列的<strong>出队跟队列一样从队首出队，但在优先队列内部，数据项的次序却是由“优先级”来确定</strong>：</p><ol><li>高优先级的数据项排在队首，而低优先级的数据项排在后面。</li><li>这样，优先队列的入队操作就比较复杂，需要将数据项根据其优先级尽量挤到队列前方。<h3 id="1-1-Binary-Heap库实现优先队列"><a href="#1-1-Binary-Heap库实现优先队列" class="headerlink" title="1.1 Binary Heap库实现优先队列"></a>1.1 <code>Binary Heap</code>库实现优先队列</h3>&#8195;&#8195;实现优先队列的经典方案是采用二叉堆数据结构，二叉堆能够将优先队列的入队和出队复杂度都保持在$O(logn)$。<ul><li>二叉堆逻辑结构上像二叉树，却是用非嵌套的列表来实现的。</li><li>最小key排在队首的称为<strong>最小堆<code>min heap</code></strong>（优先级最高）；反之，最大key排在队首的是<strong>最大堆<code>max heap</code></strong>。后续主要讲最小堆。<span id="more"></span><blockquote><p>&#8195;&#8195;如果用有序表来实现，入队时根据优先级插入到相应的位置，那么入队一定是$O(n)$的。队首出队复杂度是$O(n)$，队尾出队复杂度是$O(1)$</p></blockquote></li></ul></li></ol><p>最小堆<code>ADT BinaryHeap</code>的操作定义如下：</p><ul><li><code>BinaryHeap()</code> ：创建一个空二叉堆对象；</li><li><code>insert(k)</code> ：将新key 加入到堆中（在合适的位置插入）；</li><li><code>findMin()</code> ：返回堆中的最小项，最小项仍保留在堆中；</li><li><code>delMin()</code> ：返回堆中的最小项，同时从堆中删除；</li><li><code>isEmpty()</code> ：返回堆是否为空；</li><li><code>size()</code> ：返回堆中key 的个数；</li><li><code>buildHeap(list)</code> ：从一个key 列表创建新堆。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.trees.binheap <span class="keyword">import</span> BinHeap </span><br><span class="line"></span><br><span class="line">bh = BinHeap ()</span><br><span class="line">bh.insert (<span class="number">5</span>)</span><br><span class="line">bh.insert (<span class="number">7</span>)</span><br><span class="line">bh.insert (<span class="number">3</span>)</span><br><span class="line">bh.insert (<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># delMin()每次都返回剩余数据项中最小的那个，并删除它</span></span><br><span class="line"><span class="built_in">print</span> (bh.delMin())</span><br><span class="line"><span class="built_in">print</span> (bh.delMin())</span><br><span class="line"><span class="built_in">print</span> (bh.delMin())</span><br><span class="line"><span class="built_in">print</span> (bh.delMin())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h3 id="1-2-Python-heapq库实现优先队列"><a href="#1-2-Python-heapq库实现优先队列" class="headerlink" title="1.2 Python heapq库实现优先队列"></a>1.2 Python <code>heapq</code>库实现优先队列</h3><p>Python heapq库的用法介绍:</p><ul><li><code>heapq.heapify(list)</code>：从列表创建最小堆</li><li><code>heapq._heapify_max(list)</code>：从列表创建最大堆</li><li><code>heappush(heap, item)</code>：将数据item入堆</li><li><code>heappop(heap)</code>：将堆中最小元素出堆（最小的就是堆顶），最大元素出堆是<code>_heappop_max(heap)</code>；</li><li><code>heapq.heapreplace(heap.item)</code> ：先操作heappop(heap)，再操作heappush(heap,item)。</li><li><code>heapq.heappushpop(list, item)</code>：先操作heappush(heap,item)，再操作heappop(heap)，和上一个函数相反。</li><li><code>heapq.merge(*iterables)</code>：合并多个堆，例如<code>a = [2, 4, 6]，b = [1, 3, 5]，c = heapq.merge(a, b)</code></li><li><code>heapq.nlargest(n, iterable,[ key])</code>：返回堆中的最大n个元素</li><li><code>heapq.nsmallest(n, iterable,[ key])</code>：返回堆中最小的n个元素</li><li><code>heapq[0]</code>：返回堆顶</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = [<span class="number">10</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">7</span>, <span class="number">30</span>, <span class="number">24</span>, <span class="number">27</span>, <span class="number">45</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">36</span>, <span class="number">21</span>]</span><br><span class="line">heapq.heapify(array)</span><br><span class="line"><span class="built_in">print</span>(heapq.nlargest(<span class="number">2</span>, array))</span><br><span class="line"><span class="built_in">print</span>(heapq.nsmallest(<span class="number">3</span>, array))</span><br><span class="line"></span><br><span class="line">[<span class="number">50</span>, <span class="number">45</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.queue = []</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item, priority</span>):</span></span><br><span class="line">        heapq.heappush(self.queue, (-priority, self.index, item))</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(self.queue)[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="1-3-手动实现最小堆"><a href="#1-3-手动实现最小堆" class="headerlink" title="1.3 手动实现最小堆"></a>1.3 手动实现最小堆</h3><h4 id="1-3-1-非嵌套列表实现完全二叉树"><a href="#1-3-1-非嵌套列表实现完全二叉树" class="headerlink" title="1.3.1  非嵌套列表实现完全二叉树"></a>1.3.1  非嵌套列表实现完全二叉树</h4><p>&#8195;&#8195;为了使堆操作能保持在对数水平上，就必须采用<strong>二叉树结构</strong>。同时如果要使操作始终保持在对数数量级上，就必须始终<strong>保持二叉树的平衡</strong>，树根左右子树拥有相同数量的节点，所以考虑采用<strong>完全二叉树</strong>的结构来近似实现平衡。</p><p>&#8195;&#8195;完全二叉树的叶子节点只能出现在最下面两层，每个内部节点都有两个子节点，最多只有一个内部节点例外。最下层的叶子节点连续集中在最左边的位置上，即不存在只有右子树的情况。<br><img src="https://img-blog.csdnimg.cn/ee85a512e02d4ecea2a9ff62102dce1c.png" alt="在这里插入图片描述"></p><p>&#8195;&#8195;完全二叉树由于其特殊性，可以简单的<strong>用非嵌套列表方式实现</strong>，如下图：如果节点的下标为<code>p</code>，那么其左子节点下标为<code>2p</code>，右子节点为<code>2p+1</code>，其父节点下标为<code>p//2</code>。</p><p><img src="https://img-blog.csdnimg.cn/804354f34427488b8d9bc8c4a37cc92f.png#pic_center =500x" alt="在这里插入图片描述"></p><h4 id="1-3-2-非嵌套列表实现最小堆"><a href="#1-3-2-非嵌套列表实现最小堆" class="headerlink" title="1.3.2 非嵌套列表实现最小堆"></a>1.3.2 非嵌套列表实现最小堆</h4><p>&#8195;&#8195;上面讲过二叉堆分<strong>最小堆<code>min heap</code></strong>和<strong>最大堆<code>max heap</code></strong>：</p><p><img src="https://img-blog.csdnimg.cn/6cb959de8fc5457992df481d1ee173f1.png" alt="在这里插入图片描述"></p><p>&#8195;&#8195;同样的，我们也可以用非嵌套列表实现最小堆：</p><p><img src="https://img-blog.csdnimg.cn/00bfbe59150344788853066039600ec6.png#pic_center =500x" alt="在这里插入图片描述"></p><blockquote><p>在最小堆中，任何一条路径，均是一个已排序数列，根节点的<code>key</code>最小。</p><h4 id="1-3-3-最小堆的python实现"><a href="#1-3-3-最小堆的python实现" class="headerlink" title="1.3.3  最小堆的python实现"></a>1.3.3  最小堆的python实现</h4><p>&#8195;&#8195;之前讲到的完全二叉树节点下标规律是根节点从1开始才有用，如果从0开始就得做偏移，比较复杂。为了代码的简洁，我们建堆时，将下标为0的位置空出来不用，根节点从1开始。</p></blockquote><ul><li>二叉堆初始化：采用一个列表来保存堆数据，初始化下标0的位置，用一个0占位并一直保留，并初始化此时的<code>size=0</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinHeap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.heapList = [<span class="number">0</span>]     <span class="comment"># 初始化0占位</span></span><br><span class="line">        self.currentSize = <span class="number">0</span><span class="comment"># 初始化此时的size=0</span></span><br></pre></td></tr></table></figure><ul><li><code>insert(key)</code>：将新key插入到堆中（上浮到正确位置）<ul><li>为了保持完全二叉树的性质，新key应该添加到列表末尾，但这样直接添加，显然无法保持堆次序。虽然对其它路径的次序没有影响，但可能破坏其到根的路径的次序。</li><li>将新key沿着路径“上浮”到其正确位置。新key的上浮不会影响其他路径节点的堆次序。</li><li>上浮是将新节点与其父节点比较，如果更大就将其和父节点进行交换</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/74808dc3582a446ea18ef4813e841ff3.png#pic_center =600x" alt="在这里插入图片描述"></p><p> <img src="https://img-blog.csdnimg.cn/2edc64204185495bb33b796d0c00c198.png#pic_center =600x" alt="在这里插入图片描述"></p><ul><li><code>delMin()</code>：移走整个堆中最小的key，即根节点heapList[1]<ul><li>为了保持完全二叉树的性质，只用最后一个节点来代替根节点。同样，这操作还是破坏了堆次序。</li><li>将新的根节点沿着一条路径下沉，直到比两个子节点都小。</li><li>下沉的路径选择：如果比子节点大，那么选择较小的子节点交换下沉（保证交换后的根节点最小）。</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/dd2ef13f4a114f50aa4a39a1c43163f1.png#pic_center =600x" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/02d17d43b2ea4fe3ae8b36accf7e6f99.png#pic_center" alt="在这里插入图片描述"></p><ul><li><code>buildHeap(lst)</code>方法：从无序表直接生成堆，再用下沉法，能将总代价控制在$O(n)$。<br><img src="https://img-blog.csdnimg.cn/81841c5f5247470c879fa40e86142e0c.png#pic_center =600x" alt="在这里插入图片描述"><blockquote><p>&#8195;&#8195;用<code>insert(key)</code>方法，将无序表的各个数据项insert到堆中，每一个的入堆操作都是$O(logn)$，n个元素，其复杂度就是$O(nlogn)$，用用下沉法，能将总代价控制在$O(n)$</p></blockquote></li></ul><p>代码实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二叉堆操作的实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinHeap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.heapList = [<span class="number">0</span>]</span><br><span class="line">        self.currentSize = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">percUp</span>(<span class="params">self,i</span>):</span><span class="comment"># 上浮操作</span></span><br><span class="line">        <span class="keyword">while</span> i//<span class="number">2</span> &gt; <span class="number">0</span>:<span class="comment"># 根节点为1，比较完根节点就结束了</span></span><br><span class="line">            <span class="keyword">if</span> self.heapList[i] &lt; self.heapList[i//<span class="number">2</span>]:  <span class="comment"># 如果子节点的值小于其父节点的值，就进行节点交换</span></span><br><span class="line">                temp = self.heapList[i//<span class="number">2</span>]</span><br><span class="line">                self.heapList[i//<span class="number">2</span>] = self.heapList[i]  <span class="comment"># 与父节点交换</span></span><br><span class="line">                self.heapList[i] = temp</span><br><span class="line">            i = i//<span class="number">2</span>  <span class="comment"># 交换之后，沿路径向下，可以优化为停止交换就不再上浮</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self,k</span>):</span></span><br><span class="line">        self.heapList.append(k)  <span class="comment"># 添加到末尾</span></span><br><span class="line">        self.currentSize = self.currentSize + <span class="number">1</span></span><br><span class="line">        self.percUp(self.currentSize)  <span class="comment"># 新key下标就是此时数组长度，将其上浮</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">percDown</span>(<span class="params">self,i</span>):</span><span class="comment"># 新顶下沉函数</span></span><br><span class="line">        <span class="keyword">while</span> (i * <span class="number">2</span>) &lt;= self.currentSize:<span class="comment"># i*2表示一直进行新顶下沉操作（和左子节点比较）</span></span><br><span class="line">            mc = self.minChild(i)<span class="comment"># 子节点中更小的节点的下标</span></span><br><span class="line">            <span class="keyword">if</span> self.heapList[i] &gt; self.heapList[mc]:    <span class="comment"># 如果新顶大于更小的子节点，就需要下沉</span></span><br><span class="line">                tmp = self.heapList[i]</span><br><span class="line">                self.heapList[i] = self.heapList[mc]   <span class="comment"># 交换下沉</span></span><br><span class="line">                self.heapList[mc] = tmp</span><br><span class="line">            i = mc  <span class="comment"># 沿路径向下</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minChild</span>(<span class="params">self,i</span>):</span><span class="comment"># 获取子节点中更小的节点的下标</span></span><br><span class="line">    <span class="comment"># 只有一个子节点，那就是最小的</span></span><br><span class="line">        <span class="keyword">if</span> i*<span class="number">2</span> + <span class="number">1</span> &gt; self.currentSize:<span class="comment"># 计算出的右子节点下标大于数组长度，表示新顶没有右子节点，只有左子节点</span></span><br><span class="line">            <span class="keyword">return</span> i*<span class="number">2</span>  </span><br><span class="line">        <span class="keyword">else</span>:            <span class="comment"># 否则比较两个子节点的大小，返回值更小的子节点</span></span><br><span class="line">            <span class="keyword">return</span> i*<span class="number">2</span> <span class="keyword">if</span> self.heapList[i*<span class="number">2</span>] &lt; self.heapList[i*<span class="number">2</span>+<span class="number">1</span>] <span class="keyword">else</span> i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delMin</span>(<span class="params">self</span>):</span></span><br><span class="line">        retval = self.heapList[<span class="number">1</span>]  </span><br><span class="line">        self.heapList[<span class="number">1</span>] = self.heapList[self.currentSize] <span class="comment"># 最后一个节点与根节点交换</span></span><br><span class="line">        self.currentSize = self.currentSize - <span class="number">1</span>     <span class="comment"># size-1</span></span><br><span class="line">        self.heapList.pop()<span class="comment"># 移除最后的节点</span></span><br><span class="line">        self.percDown(<span class="number">1</span>)  <span class="comment"># 新的根节点下沉</span></span><br><span class="line">        <span class="keyword">return</span> retval<span class="comment"># 返回原先的根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildHeap</span>(<span class="params">self,alist</span>):</span>        </span><br><span class="line">        self.currentSize = <span class="built_in">len</span>(alist)</span><br><span class="line">        self.heapList = [<span class="number">0</span>] + alist[:]<span class="comment"># 直接从无序表建堆</span></span><br><span class="line">        i = <span class="built_in">len</span>(alist) // <span class="number">2</span>  <span class="comment"># 从最后一个节点的父节点开始下沉，所有叶节点无需下沉</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">len</span>(self.heapList),i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(self.heapList,i)</span><br><span class="line">            self.percDown(i)</span><br><span class="line">            i = i-<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(self.heapList,i)</span><br></pre></td></tr></table></figure><h2 id="二、优先队列题目"><a href="#二、优先队列题目" class="headerlink" title="二、优先队列题目"></a>二、优先队列题目</h2><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0703</td><td style="text-align:left"><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">数据流中的第 K 大元素</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0703.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC%20K%20%E5%A4%A7%E5%85%83%E7%B4%A0.md">Python</a></td><td style="text-align:left">树、设计、二叉搜索树、二叉树、数据流、堆（优先队列）</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0347</td><td style="text-align:left"><a href="https://leetcode.cn/problems/top-k-frequent-elements/">前 K 个高频元素</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.md">Python</a></td><td style="text-align:left">堆、哈希表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0451</td><td style="text-align:left"><a href="https://leetcode.cn/problems/sort-characters-by-frequency/">根据字符出现频率排序</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0451.%20%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F.md">Python</a></td><td style="text-align:left">哈希表、字符串、桶排序、计数、排序、堆（优先队列）</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0973</td><td style="text-align:left"><a href="https://leetcode.cn/problems/k-closest-points-to-origin/">最接近原点的 K 个点</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0973.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84%20K%20%E4%B8%AA%E7%82%B9.md">Python</a></td><td style="text-align:left">几何、数组、数学、分治、快速选择、排序、堆（优先队列）</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">1296</td><td style="text-align:left"><a href="https://leetcode.cn/problems/divide-array-in-sets-of-k-consecutive-numbers/">划分数组为连续数字的集合</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/1296.%20%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E4%B8%BA%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97%E7%9A%84%E9%9B%86%E5%90%88.md">Python</a></td><td style="text-align:left">贪心、数组、哈希表、排序</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0239</td><td style="text-align:left"><a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0239.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.md">Python</a></td><td style="text-align:left">队列，数组、滑动窗口、单调队列、堆（优先队列）</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0295</td><td style="text-align:left"><a href="https://leetcode.cn/problems/find-median-from-data-stream/">数据流的中位数</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0295.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.md">Python</a></td><td style="text-align:left">设计、双指针、数据流、排序、堆（优先队列）</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0023</td><td style="text-align:left"><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并K个升序链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0023.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">链表、分治、堆（优先队列）、归并排序</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0218</td><td style="text-align:left"><a href="https://leetcode.cn/problems/the-skyline-problem/">天际线问题</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0218.%20%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98.md">Python</a></td><td style="text-align:left">树状数组、线段树、数组、分治、有序集合、扫描线、堆（优先队列）</td><td style="text-align:left">困难</td></tr></tbody></table></div><h3 id="2-1-数据流中第K大的元素"><a href="#2-1-数据流中第K大的元素" class="headerlink" title="2.1 数据流中第K大的元素"></a>2.1 数据流中第K大的元素</h3><blockquote><p><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">0703. 数据流中的第 K 大元素</a></p></blockquote><p>设计一个 <code>KthLargest</code> 类，用于找到数据流中第 <code>k</code> 大元素。</p><ul><li><code>KthLargest(int k, int[] nums)</code>：使用整数 k 和整数流 nums 初始化对象。</li><li><code>int add(int val)</code>：将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。      </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;KthLargest&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>]</span><br><span class="line">[[<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>]], [<span class="number">3</span>], [<span class="number">5</span>], [<span class="number">10</span>], [<span class="number">9</span>], [<span class="number">4</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">KthLargest kthLargest = new KthLargest(<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>]);</span><br><span class="line">kthLargest.add(<span class="number">3</span>);   // <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">kthLargest.add(<span class="number">5</span>);   // <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">kthLargest.add(<span class="number">10</span>);  // <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">kthLargest.add(<span class="number">9</span>);   // <span class="keyword">return</span> <span class="number">8</span></span><br><span class="line">kthLargest.add(<span class="number">4</span>);   // <span class="keyword">return</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p>思路：使用最小堆保存前K个最大的元素，堆顶就是第k大的元素</p><ul><li>建立大小为 <code>k</code> 的最小堆，将前K个最大元素压入堆中。</li><li>每次 <code>add</code> 操作时，将新元素压入堆中，如果堆中元素超出了 <code>k</code> 个，则将堆中最小元素（堆顶）移除，保证堆中元素保证不超过 <code>k</code> 个。</li><li>此时堆中最小元素（堆顶）就是整个数据流中的第 <code>k</code> 大元素。</li></ul><p>代码：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.k=k</span><br><span class="line">        self.queue=nums               </span><br><span class="line">        heapq.heapify(self.queue)</span><br><span class="line">        <span class="built_in">print</span>(self.queue)</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        heapq.heappush(self.queue,val)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.queue)&gt;self.k:</span><br><span class="line">            heapq.heappop(self.queue)</span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><h3 id="2-2-最接近原点的-K-个点"><a href="#2-2-最接近原点的-K-个点" class="headerlink" title="2.2 最接近原点的 K 个点"></a>2.2 最接近原点的 K 个点</h3><blockquote><p><a href="https://leetcode.cn/problems/k-closest-points-to-origin/">0973. 最接近原点的 K 个点</a></p><p>给定一个由由平面上的点组成的列表 <code>points</code>，再给定一个整数 <code>K</code>。要求找出 <code>K</code> 个距离原点<code>(0, 0)</code> 最近的点。</p><ul><li>这里的距离是平面上两点之间的距离，即欧几里德距离。</li><li>可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的（每个点的距离不一样）。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">3</span>],[-<span class="number">2</span>,<span class="number">2</span>]], k = <span class="number">1</span></span><br><span class="line">输出：[[-<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">解释： </span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>) 和原点之间的距离为 sqrt(<span class="number">10</span>)，</span><br><span class="line">(-<span class="number">2</span>, <span class="number">2</span>) 和原点之间的距离为 sqrt(<span class="number">8</span>)，</span><br><span class="line">由于 sqrt(<span class="number">8</span>) &lt; sqrt(<span class="number">10</span>)，(-<span class="number">2</span>, <span class="number">2</span>) 离原点更近。</span><br><span class="line">我们只需要距离原点最近的 K = <span class="number">1</span> 个点，所以答案就是 [[-<span class="number">2</span>,<span class="number">2</span>]]。</span><br></pre></td></tr></table></figure><p>思路：优先队列</p><ul><li>使用列表<code>distance</code>存储每个点到原点的距离</li><li>使用列表<code>ls</code>存储每个点的距离，和其对应的点，即<code>ls=list(zip(distance,points))</code></li><li>使用<code>heapq</code>建立最小堆，堆顶元素永远是最小距离的点</li><li>遍历<code>k</code>次，取出堆顶的点，存储到答案<code>ans</code>中<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">distance=[(point[<span class="number">0</span>]**<span class="number">2</span>+point[<span class="number">1</span>]**<span class="number">2</span>)**<span class="number">0.5</span> <span class="keyword">for</span> point <span class="keyword">in</span> points]</span><br><span class="line">        ls=<span class="built_in">list</span>(<span class="built_in">zip</span>(distance,points))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据距离建立最小堆</span></span><br><span class="line">        <span class="keyword">import</span> heapq        </span><br><span class="line">        heapq.heapify(ls)</span><br><span class="line">        ans=[]</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> count&lt;k:</span><br><span class="line">ans.append(heapq.heappop(ls)[<span class="number">1</span>])</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="2-3-前K个高频元素"><a href="#2-3-前K个高频元素" class="headerlink" title="2.3 前K个高频元素"></a>2.3 前K个高频元素</h3><blockquote><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">0347. 前 K 个高频元素</a></p></blockquote></li></ul><p>给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code>,返回出现频率前 <code>k</code> 高的元素。可以按任意顺序返回答案。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>解法一：将元素根据其频次进行降序排列，前k个元素就是答案<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        d=<span class="built_in">dict</span>(Counter(nums))</span><br><span class="line">        <span class="comment"># 根据元素出现顺序降序排列，排序后d是一个元组列表[(key,value)]</span></span><br><span class="line">        d=<span class="built_in">sorted</span>(d.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="literal">True</span>)  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            ans.append(d[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><br>解法二：根据元素频次建立最大堆，遍历K次，将堆顶元素出栈保存</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        d=<span class="built_in">dict</span>(Counter(nums))</span><br><span class="line">        queue=[]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> d.items():</span><br><span class="line">        <span class="comment"># heapq默认建立最小堆，将频次取负数得到最大堆效果</span></span><br><span class="line">            heapq.heappush(queue,(-value,key))</span><br><span class="line"></span><br><span class="line">        ans=[]</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> count&lt;k: <span class="comment"># 遍历k次，每次将堆顶元素（频次最高）存储到ans中</span></span><br><span class="line">            ans.append(heapq.heappop(queue)[<span class="number">1</span>])</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="2-4-滑动窗口最大值"><a href="#2-4-滑动窗口最大值" class="headerlink" title="2.4 滑动窗口最大值"></a>2.4 滑动窗口最大值</h3><blockquote><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">0239. 滑动窗口最大值</a></p></blockquote><p>&#8195;&#8195;给定一个整数数组 <code>nums</code>，再给定一个整数 <code>k</code>，表示为大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。我们只能看到滑动窗口内的 <code>k</code> 个数字，滑动窗口每次只能向右移动一位。<br>&#8195;&#8195;请返回滑动窗口中的最大值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>] -<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [-<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span> [-<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>思路 1：优先队列</strong></p><p>&#8195;&#8195;我们可以使用优先队列（大顶堆）来存储长度为k的窗口内的数组，这样堆顶元素一定是滑动窗口内的最大值。</p><ul><li>当堆顶元素还在窗口中，依旧返回堆顶元素。</li><li>当堆顶元素滑出了窗口，删除堆顶元素，直到堆顶元素还在窗口中，这时堆顶元素就是新的滑动窗口的最大值</li></ul><p>&#8195;&#8195;假设窗口右指针为<code>i</code>，那么长度为k的滑动窗口左右指针就是<code>[i-k+1,i]</code>。当<code>堆顶元素的索引&lt;i-k+1</code>时，表示堆顶元素不在滑动窗口中。以下是具体步骤：</p><ol><li>初始的时候将前 <code>k</code> 个元素加入优先队列的二叉堆中。存入优先队列的是数组值与索引构成的元组。优先队列将数组值作为优先级。</li><li>然后滑动窗口从第 <code>k</code> 个元素开始遍历，将当前数组值和索引的元组插入到二叉堆中。</li><li>当二叉堆堆顶元素的索引已经不在滑动窗口的范围中时，即 <code>q[0][1] &lt;= i - k</code> 时，不断删除堆顶元素，直到最大值元素的索引在滑动窗口的范围中。</li><li>将最大值加入到答案数组中，继续向右滑动至遍历结束，返回答案</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        queue=[]</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="comment"># 根据元素值建立大顶堆，同时存储其下标</span></span><br><span class="line">            heapq.heappush(queue,(-nums[idx],idx))</span><br><span class="line">        <span class="comment">#print(queue)</span></span><br><span class="line">        ans=[-queue[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 窗口下标为[i-k+1,i]，最大值不在窗口，即堆顶元素的下标小于窗口左指针</span></span><br><span class="line">            heapq.heappush(queue,(-nums[i],i))</span><br><span class="line">            <span class="keyword">while</span> queue[<span class="number">0</span>][<span class="number">1</span>]&lt;i-k+<span class="number">1</span>:</span><br><span class="line">                heapq.heappop(queue)</span><br><span class="line">            ans.append(-queue[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="2-5-寻找两个正序数组的中位数"><a href="#2-5-寻找两个正序数组的中位数" class="headerlink" title="2.5 寻找两个正序数组的中位数"></a>2.5 寻找两个正序数组的中位数</h3><blockquote><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">0004. 寻找两个正序数组的中位数</a></p></blockquote><p>&#8195;&#8195;给定两个正序（从小到大排序）数组 <code>nums1</code>、<code>nums2</code>，找出并返回这两个正序数组的中位数，并要求算法的时间复杂度应该为 $O(\log (m + n))$</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，中位数 (<span class="number">2</span> + <span class="number">3</span>) / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><p><strong>思路一：优先队列</strong><br>&#8195;&#8195;假设两个数组连接后长度为n，那么此题等同于找到数组中第<code>n//2+1</code>大的数（n为奇数，n为偶数就是中间两个数的均值。所以可以考虑使用优先队列：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        n=<span class="built_in">len</span>(nums1)+<span class="built_in">len</span>(nums2)</span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="comment"># 建立最小堆</span></span><br><span class="line">        queue=nums1        </span><br><span class="line">        heapq.heapify(queue)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums2:</span><br><span class="line">            heapq.heappush(queue,num)</span><br><span class="line"></span><br><span class="line">        k=n//<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue)&gt;k:         <span class="comment"># n为奇数，中位数就是第k小的数</span></span><br><span class="line">            heapq.heappop(queue)</span><br><span class="line">        ans.append(queue[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">0</span>:<span class="comment"># n为偶数，中位数就是第k小的数和第k-1小的数的均值</span></span><br><span class="line">            heapq.heappop(queue)</span><br><span class="line">            ans.append(queue[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(ans)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(ans[<span class="number">0</span>])    </span><br></pre></td></tr></table></figure><h3 id="2-6-数据流的中位数"><a href="#2-6-数据流的中位数" class="headerlink" title="2.6 数据流的中位数"></a>2.6 数据流的中位数</h3><blockquote><p><a href="https://leetcode.cn/problems/find-median-from-data-stream/">0295. 数据流的中位数</a></p></blockquote><p>设计一个支持一下两种操作的数组结构：</p><ul><li><code>void addNum(int num)</code>：从数据流中添加一个整数到数据结构中。</li><li><code>double findMedian()</code>：返回目前所有元素的中位数。</li></ul><p>首先，我们可以使用两个优先队列（堆）来维护整个数据流数据：</p><ul><li><strong>大顶堆<code>self.maxq</code></strong>：存储<strong>小于中位数的数</strong>。</li><li><strong>小顶堆<code>self.minq</code></strong>：存储<strong>大于中位数的数</strong>。</li></ul><p>算法步骤：</p><ul><li>初始化时，第一个元素先放入<code>self.maxq</code>。这样当元素为奇数个时，总有<code>self.maxq</code>比<code>self.minq</code>多一个元素。</li><li><code>findMedian</code>返回结果：<ul><li>当数据流元素数量为偶数：两个队列长度相等（<code>n1=n2</code>），此时动态中位数为两者堆顶元素的平均值；</li><li>当数据流元素数量为奇数：<code>n1=n2+1</code>，此时动态中位数为<code>self.maxq</code>堆顶元素（小于中位数的数组中最大的那个）。</li></ul></li><li><code>addNum</code>插入元素：<ul><li>当n1==0，当前元素直接插入大顶堆<code>self.maxq</code>，因为heapq默认创建小顶堆，所以插入其负数，即<code>heapq.heappush(self.maxq,-num)</code></li><li>当n1==n2，说明插入前是偶数个元素，此时大顶堆<code>self.maxq</code>应该多一个元素，但是分两种情况：<ul><li><code>num&lt;-self.maxq[0]</code>，当前元素小于<code>self.maxq</code>中的最大值，所以直接入堆<code>self.maxq</code>（小于中位数的堆）</li><li><code>num》-self.maxq[0]</code>，当前元素应该入小顶堆<code>self.minq</code>。但是为了保持<code>self.maxq</code>多一个元素，就需要再将<code>self.minq</code>中的最小值移到<code>self.maxq</code>中</li></ul></li><li>当<code>n1!=n2</code> ，说明插入前是奇数个元素，此时应该是往小顶堆<code>self.minq</code>插入元素，也分两种情况：<ul><li><code>num&gt;-self.maxq[0]</code>，当前元素小于<code>self.maxq</code>中的最大值，所以直接入堆<code>self.minq</code>（大于中位数的堆）</li><li><code>num《-self.maxq[0]</code>，当前元素应该入大顶堆<code>self.maxq</code>。但是为了保持两堆元素个数相同，就需要再将<code>self.maxq</code>中的最大值移到<code>self.minq</code>中。</li></ul></li></ul></li></ul><p>需要注意的是，heapq默认创建最小堆，为了达到创建并维护最大堆得效果：</p><ul><li>所有入堆<code>self.maxq</code>的元素应该加负号</li><li>从<code>self.maxq</code>中移入<code>self.minq</code>的元素应该恢复符号（负负得正，<code>heapq.heappush(self.minq,-temp)</code>）</li><li>比较<code>self.maxq</code>堆顶元素时也要加负号，返回结果时也是<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.maxq=[]</span><br><span class="line">        self.minq=[]</span><br><span class="line">        heapq.heapify(self.maxq) <span class="comment"># 大顶堆，存储小于中位数的元素</span></span><br><span class="line">        heapq.heapify(self.minq) <span class="comment"># 小顶堆，存储大于中位数的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        n1,n2=<span class="built_in">len</span>(self.maxq),<span class="built_in">len</span>(self.minq)</span><br><span class="line">        <span class="comment"># 当self.maxq为空，直接入大顶堆</span></span><br><span class="line">        <span class="keyword">if</span> n1==<span class="number">0</span>:</span><br><span class="line">            heapq.heappush(self.maxq,-num) <span class="comment"># 取负数就是大顶堆效果</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">elif</span> n1==n2:</span><br><span class="line">            <span class="keyword">if</span> num&lt;-self.maxq[<span class="number">0</span>]: <span class="comment"># 小于中位数直接入大顶堆</span></span><br><span class="line">                heapq.heappush(self.maxq,-num)</span><br><span class="line">            <span class="keyword">else</span>:                 <span class="comment"># 否则应该入小顶堆，但是得将小顶堆最小元素入大顶堆 </span></span><br><span class="line">                heapq.heappush(self.minq,num)               </span><br><span class="line">                temp=heapq.heappop(self.minq)</span><br><span class="line">                heapq.heappush(self.maxq,-temp)                </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 当前元素是偶数个，需要入小顶堆</span></span><br><span class="line">            <span class="keyword">if</span> num&gt;-self.maxq[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappush(self.minq,num)</span><br><span class="line">            <span class="keyword">else</span>:                </span><br><span class="line">                heapq.heappush(self.maxq,-num)</span><br><span class="line">                temp=heapq.heappop(self.maxq)</span><br><span class="line">                heapq.heappush(self.minq,-temp)</span><br><span class="line">                                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        temp=self.maxq[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> -temp <span class="keyword">if</span> <span class="built_in">len</span>(self.maxq)&gt;<span class="built_in">len</span>(self.minq) <span class="keyword">else</span> (self.minq[<span class="number">0</span>]-temp)/<span class="number">2</span>        </span><br></pre></td></tr></table></figure>也可以改写成（官方题解）：</li><li>self.maxq为空或者num &lt; -self.maxq[0]时，当前元素应该入堆self.maxq。<ul><li>如果之前两堆元素相等，那么是轮到self.maxq入堆，无需额外的操作。此时当前元素入堆后， len(self.maxq)=len(self.minq) + 1 ；</li><li>如果之前就有len(self.maxq)=len(self.minq) + 1 ，那么入堆后len(self.maxq)&gt;len(self.minq) + 1，此时应该将self.maxq堆顶元素pop到self.minq中。</li></ul></li><li>num 》-self.maxq[0]，当前元素应该入堆self.minq，同样是分两种情况：<ul><li>如果之前len(self.maxq)=len(self.minq) + 1，那么确实轮到入堆self.minq，无需额外操作。入堆后两堆元素个数相等</li><li>如果入堆后两堆元素个数不等，此时应该将self.minq堆顶元素pop到self.maxq中。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.maxq=[]</span><br><span class="line">        self.minq=[]</span><br><span class="line">        heapq.heapify(self.maxq) <span class="comment"># 大顶堆，存储小于中位数的元素</span></span><br><span class="line">        heapq.heapify(self.minq) <span class="comment"># 小顶堆，存储大于中位数的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.maxq <span class="keyword">or</span> num &lt; -self.maxq[<span class="number">0</span>]:</span><br><span class="line">            heapq.heappush(self.maxq, -num)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.minq) + <span class="number">1</span> &lt; <span class="built_in">len</span>(self.maxq):</span><br><span class="line">                heapq.heappush(self.minq, -heapq.heappop(self.maxq))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(self.minq, num)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.minq) &gt; <span class="built_in">len</span>(self.maxq):</span><br><span class="line">                heapq.heappush(self.maxq, -heapq.heappop(self.minq))</span><br><span class="line">                     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        temp=self.maxq[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> -temp <span class="keyword">if</span> <span class="built_in">len</span>(self.maxq)&gt;<span class="built_in">len</span>(self.minq) <span class="keyword">else</span> (self.minq[<span class="number">0</span>]-temp)/<span class="number">2</span>   </span><br></pre></td></tr></table></figure><h2 id="三、-二叉堆排序"><a href="#三、-二叉堆排序" class="headerlink" title="三、 二叉堆排序"></a>三、 二叉堆排序</h2><blockquote><p>参考<a href="https://algo.itcharge.cn/01.Array/02.Array-Sort/07.Array-Heap-Sort/">《算法通关手册》排序篇</a></p><h3 id="3-1-最大堆排序思想"><a href="#3-1-最大堆排序思想" class="headerlink" title="3.1 最大堆排序思想"></a>3.1 最大堆排序思想</h3></blockquote><p>&#8195;&#8195; <strong>堆排序（Heap sort）基本思想</strong>：借用「堆结构」所设计的排序算法。将数组转化为大顶堆，重复从大顶堆中取出数值最大的节点，并让剩余的堆结构继续维持大顶堆性质。</p><p><strong>堆排序算法步骤</strong></p><ol><li><strong>建立初始堆</strong>：将无序序列构造成第 <code>1</code> 个大顶堆（初始堆），使得 <code>n</code> 个元素的最大值处于序列的第 <code>1</code> 个位置。</li><li><strong>调整堆</strong>：交换序列的第 <code>1</code> 个元素（最大值元素）与第 <code>n</code> 个元素的位置。将序列前 <code>n - 1</code> 个元素组成的子序列调整成一个新的大顶堆，使得 <code>n - 1</code> 个元素的最大值处于序列第 <code>1</code> 个位置，从而得到第 <code>2</code> 个最大值元素。</li><li><strong>调整堆</strong>：交换子序列的第 <code>1</code> 个元素（最大值元素）与第 <code>n - 1</code> 个元素的位置。将序列前 <code>n - 2</code> 个元素组成的子序列调整成一个新的大顶堆，使得 <code>n - 2</code> 个元素的最大值处于序列第 <code>1</code> 个位置，从而得到第 <code>3</code> 个最大值元素。</li><li>依次类推，不断交换子序列的第 <code>1</code> 个元素（最大值元素）与当前子序列最后一个元素位置，并将其调整成新的大顶堆。直到子序列剩下一个元素时，排序结束。此时整个序列就变成了一个有序序列。</li></ol><p>从堆排序算法步骤中可以看出：堆排序算法主要涉及「调整堆」和「建立初始堆」两个步骤。</p><h3 id="3-2-调整最大堆"><a href="#3-2-调整最大堆" class="headerlink" title="3.2 调整最大堆"></a>3.2 调整最大堆</h3><p><strong>调整堆方法</strong>：把移走了最大值元素以后的剩余元素组成的序列再构造为一个新的堆积（前面讲的新key下沉）。具体步骤如下：</p><ol><li>从根节点开始，自上而下地调整节点的位置，使其成为堆积。<ol><li>判断序号为 <code>i</code> 的节点与其左子树节点（序号为 <code>2 * i</code>）、右子树节点（序号为 <code>2 * i + 1</code>）中值关系。</li><li>如果序号为 <code>i</code> 节点大于等于左右子节点值，则排序结束。</li><li>如果序号为 <code>i</code> 节点小于左右子节点值，则将序号为 <code>i</code> 节点与左右子节点中值最大的节点交换位置。</li></ol></li><li>因为交换了位置，使得当前节点的左右子树原有的堆积特性被破坏。于是，从当前节点的左右子树节点开始，自上而下继续进行类似的调整。</li><li>依次类推，直到整棵完全二叉树成为一个大顶堆。</li></ol><p><strong>调整堆方法演示</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/1289a25a64578c2780ec5cf6548e8bbb.gif" alt=""></p><ol><li>交换序列的第 <code>1</code> 个元素 <code>90</code> 与最后 <code>1</code> 个元素 <code>19</code> 的位置，此时当前节点为根节点 <code>19</code>。</li><li>判断根节点 <code>19</code>与其左右子节点值，因为 <code>17 &lt; 19 &lt; 36</code>，所以将根节点 <code>19</code> 与左子节点 <code>36</code> 互换位置，此时当前节点为根节点 <code>19</code>。</li><li>判断当前节点 <code>36</code> 与其左右子节点值，因为 <code>19 &lt; 25 &lt; 26</code>，所以将当前节点 <code>19</code> 与右节点 <code>26</code> 互换位置。调整堆结束。</li></ol><h3 id="3-3-建立初始堆"><a href="#3-3-建立初始堆" class="headerlink" title="3.3 建立初始堆"></a>3.3 建立初始堆</h3><ol><li>如果原始序列对应的完全二叉树（不一定是堆）的深度为 <code>d</code>，则从 <code>d - 1</code> 层最右侧分支节点（序号为 $\lfloor \frac{n}{2} \rfloor$）开始，初始时令 $i = \lfloor \frac{n}{2} \rfloor$，调用调整堆算法。</li><li>每调用一次调整堆算法，执行一次 <code>i = i - 1</code>，直到 <code>i == 1</code> 时，再调用一次，就把原始序列调整为了一个初始堆。</li></ol><p><strong>方法演示</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/143f7e1be004a10794cb28e08e1643e1.gif" alt=""></p><ol><li>原始序列为 <code>[2, 7, 26, 25, 19, 17, 1, 90, 3, 36]</code>，对应完全二叉树的深度为 <code>3</code>。</li><li>从第 <code>2</code> 层最右侧的分支节点，也就序号为 <code>5</code> 的节点开始，调用堆调整算法，使其与子树形成大顶堆。</li><li>节点序号减 <code>1</code>，对序号为 <code>4</code> 的节点，调用堆调整算法，使其与子树形成大顶堆。</li><li>节点序号减 <code>1</code>，对序号为 <code>3</code> 的节点，调用堆调整算法，使其与子树形成大顶堆。</li><li>节点序号减 <code>1</code>，对序号为 <code>2</code> 的节点，调用堆调整算法，使其与子树形成大顶堆。</li><li>节点序号减 <code>1</code>，对序号为 <code>1</code> 的节点，调用堆调整算法，使其与子树形成大顶堆。</li><li>此时整个原始序列对应的完全二叉树就成了一个大顶堆，建立初始堆完毕。</li></ol><h3 id="3-4-堆排序方法完整演示"><a href="#3-4-堆排序方法完整演示" class="headerlink" title="3.4 堆排序方法完整演示"></a>3.4 堆排序方法完整演示</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/4c9941c0790d2f6339bd9f97e5d97d46.gif" alt=""></p><ol><li>原始序列为 <code>[2, 7, 26, 25, 19, 17, 1, 90, 3, 36]</code>，先根据原始序列建立一个初始堆。</li><li>交换序列中第 <code>1</code> 个元素（<code>90</code>）与第 <code>10</code> 个元素（<code>2</code>）的位置。将序列前 <code>9</code> 个元素组成的子序列调整成一个大顶堆，此时堆顶变为 <code>36</code>。</li><li>交换序列中第 <code>1</code> 个元素（<code>36</code>）与第 <code>9</code> 个元素（<code>3</code>）的位置。将序列前 <code>8</code> 个元素组成的子序列调整成一个大顶堆，此时堆顶变为 <code>26</code>。</li><li>交换序列中第 <code>1</code> 个元素（<code>26</code>）与第 <code>8</code> 个元素（<code>2</code>）的位置。将序列前 <code>7</code> 个元素组成的子序列调整成一个大顶堆，此时堆顶变为 <code>25</code>。</li><li>以此类推，不断交换子序列的第 <code>1</code> 个元素（最大值元素）与当前子序列最后一个元素位置，并将其调整成新的大顶堆。直到子序列只剩下最后一个元素 <code>1</code> 时，排序结束。此时整个序列变成了一个有序序列，即 <code>[1, 2, 3, 7, 17, 19, 25, 26, 36, 90]</code>。</li></ol><h3 id="3-5-堆排序算法分析"><a href="#3-5-堆排序算法分析" class="headerlink" title="3.5 堆排序算法分析"></a>3.5 堆排序算法分析</h3><ul><li><strong>时间复杂度</strong>：$O(n \times \log_2 n)$。<ul><li>堆积排序的时间主要花费在两个方面：「建立初始堆」和「调整堆」。</li><li>设原始序列所对应的完全二叉树深度为 $d$，算法由两个独立的循环组成：<ol><li>在第 $1$ 个循环构造初始堆积时，从 $i = d - 1$ 层开始，到 $i = 1$ 层为止，对每个分支节点都要调用一次调整堆算法，而一次调整堆算法，对于第 $i$ 层一个节点到第 $d$ 层上建立的子堆积，所有节点可能移动的最大距离为该子堆积根节点移动到最后一层（第 $d$ 层） 的距离，即 $d - i$。而第 $i$ 层上节点最多有 $2^{i-1}$ 个，所以每一次调用调整堆算法的最大移动距离为 $2^{i-1} * (d-i)$。因此，堆积排序算法的第 $1$ 个循环所需时间应该是各层上的节点数与该层上节点可移动的最大距离之积的总和，即：$\sum<em>{i = d - 1}^1 2^{i-1} (d-i) = \sum</em>{j = 1}^{d-1} 2^{d-j-1} \times j = \sum<em>{j = 1}^{d-1} 2^{d-1} \times {j \over 2^j} \le n \sum</em>{j = 1}^{d-1} {j \over 2^j} &lt; 2n$。这一部分的时间花费为 $O(n)$。                                                                                                                                                                                                                                                                 </li><li>在第 $2$ 个循环中，每次调用调整堆算法一次，节点移动的最大距离为这棵完全二叉树的深度 $d = \lfloor \log_2(n) \rfloor + 1$，一共调用了 $n - 1$ 次调整堆算法，所以，第 $2$ 个循环的时间花费为 $(n-1)(\lfloor \log_2 (n)\rfloor + 1) = O(n \times \log_2 n)$。</li></ol></li><li>因此，堆积排序的时间复杂度为 $O(n \times \log_2 n)$。</li></ul></li><li><strong>空间复杂度</strong>：$O(1)$。由于在堆积排序中只需要一个记录大小的辅助空间，因此，堆积排序的空间复杂度为：$O(1)$。</li><li><strong>排序稳定性</strong>：堆排序是一种 <strong>不稳定排序算法</strong>。</li></ul><h3 id="3-6-代码实现"><a href="#3-6-代码实现" class="headerlink" title="3.6 代码实现"></a>3.6 代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 调整为大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">self, arr: [<span class="built_in">int</span>], index: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="comment"># 根节点为 index，左节点为 2 * index + 1， 右节点为 2 * index + 2</span></span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        right = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= end:</span><br><span class="line">            <span class="comment"># 当前节点为非叶子结点</span></span><br><span class="line">            max_index = index</span><br><span class="line">            <span class="keyword">if</span> arr[left] &gt; arr[max_index]:</span><br><span class="line">                max_index = left</span><br><span class="line">            <span class="keyword">if</span> right &lt;= end <span class="keyword">and</span> arr[right] &gt; arr[max_index]:</span><br><span class="line">                max_index = right</span><br><span class="line">            <span class="keyword">if</span> index == max_index:</span><br><span class="line">                <span class="comment"># 如果不用交换，则说明已经交换结束</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            arr[index], arr[max_index] = arr[max_index], arr[index]</span><br><span class="line">            <span class="comment"># 继续调整子树</span></span><br><span class="line">            index = max_index</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            right = left + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildMaxHeap</span>(<span class="params">self, arr: [<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="comment"># (size - 2) // 2 是最后一个非叶节点，叶节点不用调整</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((size - <span class="number">2</span>) // <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            self.heapify(arr, i, size - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 升序堆排序，思路如下：</span></span><br><span class="line">    <span class="comment"># 1. 先建立大顶堆</span></span><br><span class="line">    <span class="comment"># 2. 让堆顶最大元素与最后一个交换，然后调整第一个元素到倒数第二个元素，这一步获取最大值</span></span><br><span class="line">    <span class="comment"># 3. 再交换堆顶元素与倒数第二个元素，然后调整第一个元素到倒数第三个元素，这一步获取第二大值</span></span><br><span class="line">    <span class="comment"># 4. 以此类推，直到最后一个元素交换之后完毕。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxHeapSort</span>(<span class="params">self, arr: [<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.buildMaxHeap(arr)</span><br><span class="line">        size = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            arr[<span class="number">0</span>], arr[size - i - <span class="number">1</span>] = arr[size - i - <span class="number">1</span>], arr[<span class="number">0</span>]</span><br><span class="line">            self.heapify(arr, <span class="number">0</span>, size - i - <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.maxHeapSort(nums)</span><br></pre></td></tr></table></figure><h2 id="四、堆排序题目"><a href="#四、堆排序题目" class="headerlink" title="四、堆排序题目"></a>四、堆排序题目</h2><h3 id="4-1-数组中的第K个最大元素"><a href="#4-1-数组中的第K个最大元素" class="headerlink" title="4.1 数组中的第K个最大元素"></a>4.1 数组中的第K个最大元素</h3><p>&#8195;&#8195;给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素，你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><ol><li>堆排序</li></ol><p>最小堆排序（本文1.3节代码）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.heapList = [<span class="number">0</span>]</span><br><span class="line">        self.currentSize = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 建立最小堆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">percUp</span>(<span class="params">self,i</span>):</span><span class="comment"># 上浮操作</span></span><br><span class="line">        <span class="keyword">while</span> i//<span class="number">2</span> &gt; <span class="number">0</span>:<span class="comment"># 根节点为1，比较完根节点就结束了</span></span><br><span class="line">            <span class="keyword">if</span> self.heapList[i] &lt; self.heapList[i//<span class="number">2</span>]:  <span class="comment"># 如果子节点的值小于其父节点的值，就进行节点交换</span></span><br><span class="line">                temp = self.heapList[i//<span class="number">2</span>]</span><br><span class="line">                self.heapList[i//<span class="number">2</span>] = self.heapList[i]  <span class="comment"># 与父节点交换</span></span><br><span class="line">                self.heapList[i] = temp</span><br><span class="line">            i = i//<span class="number">2</span>  <span class="comment"># 交换之后，沿路径向上，可以优化为停止交换就不再上浮</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self,k</span>):</span></span><br><span class="line">        self.heapList.append(k)  <span class="comment"># 添加到末尾</span></span><br><span class="line">        self.currentSize = self.currentSize + <span class="number">1</span></span><br><span class="line">        self.percUp(self.currentSize)  <span class="comment"># 新key上浮</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">percDown</span>(<span class="params">self,i</span>):</span><span class="comment"># 新顶下沉</span></span><br><span class="line">        <span class="keyword">while</span> (i * <span class="number">2</span>) &lt;= self.currentSize:<span class="comment"># 沿路径往下</span></span><br><span class="line">            mc = self.minChild(i)<span class="comment"># 子节点中更小的节点的下标</span></span><br><span class="line">            <span class="keyword">if</span> self.heapList[i] &gt; self.heapList[mc]:</span><br><span class="line">                tmp = self.heapList[i]</span><br><span class="line">                self.heapList[i] = self.heapList[mc]   <span class="comment"># 交换下沉</span></span><br><span class="line">                self.heapList[mc] = tmp</span><br><span class="line">            i = mc  <span class="comment"># 沿路径向下</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minChild</span>(<span class="params">self,i</span>):</span></span><br><span class="line">    <span class="comment"># 只有一个子节点，那就是最小的。二叉堆中，只会有一个内部节点只有左子节点</span></span><br><span class="line">        <span class="keyword">if</span> i*<span class="number">2</span> + <span class="number">1</span> &gt; self.currentSize:</span><br><span class="line">            <span class="keyword">return</span> i*<span class="number">2</span>  </span><br><span class="line">        <span class="keyword">else</span>:           </span><br><span class="line">            <span class="keyword">return</span> i*<span class="number">2</span> <span class="keyword">if</span> self.heapList[i*<span class="number">2</span>] &lt; self.heapList[i*<span class="number">2</span>+<span class="number">1</span>] <span class="keyword">else</span> i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delMin</span>(<span class="params">self</span>):</span></span><br><span class="line">        retval = self.heapList[<span class="number">1</span>]  </span><br><span class="line">        self.heapList[<span class="number">1</span>] = self.heapList[self.currentSize] <span class="comment"># 最后一个节点与根节点交换</span></span><br><span class="line">        self.currentSize = self.currentSize - <span class="number">1</span>     <span class="comment"># size-1</span></span><br><span class="line">        self.heapList.pop()<span class="comment"># 移除最后的节点</span></span><br><span class="line">        self.percDown(<span class="number">1</span>)  <span class="comment"># 新的根节点下沉</span></span><br><span class="line">        <span class="keyword">return</span> retval<span class="comment"># 返回原先的根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildHeap</span>(<span class="params">self,alist</span>):</span>        </span><br><span class="line">        self.currentSize = <span class="built_in">len</span>(alist)</span><br><span class="line">        self.heapList = [<span class="number">0</span>] + alist[:]<span class="comment"># 直接从无序表建堆</span></span><br><span class="line">        i = <span class="built_in">len</span>(alist) // <span class="number">2</span> </span><br><span class="line">        <span class="comment"># 从最后一个节点的父节点开始下沉，所有叶节点无需下沉 </span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            self.percDown(i)</span><br><span class="line">            i = i-<span class="number">1</span>        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k</span>):</span> </span><br><span class="line">        self.buildHeap(nums)         <span class="comment"># 第k大的数就是第n-k小的数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-k):</span><br><span class="line">            self.delMin()   <span class="comment"># 执行n-k次，移除堆顶元素（最小值）</span></span><br><span class="line">        <span class="comment">#print(self.heapList,i)</span></span><br><span class="line">        <span class="keyword">return</span> self.heapList[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>最大堆排序（本文第三章代码）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调整为大顶堆</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">nums, index, end</span>):</span></span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            right = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= end:</span><br><span class="line">                <span class="comment"># 当前节点为非叶子节点</span></span><br><span class="line">                max_index = index</span><br><span class="line">                <span class="keyword">if</span> nums[left] &gt; nums[max_index]:</span><br><span class="line">                    max_index = left</span><br><span class="line">                <span class="keyword">if</span> right &lt;= end <span class="keyword">and</span> nums[right] &gt; nums[max_index]:</span><br><span class="line">                    max_index = right</span><br><span class="line">                <span class="keyword">if</span> index == max_index:</span><br><span class="line">                    <span class="comment"># 如果不用交换，则说明已经交换结束</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                nums[index], nums[max_index] = nums[max_index], nums[index]</span><br><span class="line">                <span class="comment"># 继续调整子树</span></span><br><span class="line">                index = max_index</span><br><span class="line">                left = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                right = left + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 初始化大顶堆</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buildMaxHeap</span>(<span class="params">nums</span>):</span></span><br><span class="line">            size = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="comment"># (size-2) // 2 是最后一个非叶节点，叶节点不用调整</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((size - <span class="number">2</span>) // <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                heapify(nums, i, size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">        buildMaxHeap(nums)</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            nums[<span class="number">0</span>], nums[size-i-<span class="number">1</span>] = nums[size-i-<span class="number">1</span>], nums[<span class="number">0</span>]</span><br><span class="line">            heapify(nums, <span class="number">0</span>, size-i-<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;@[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;https://algo.itcharge.cn/04.Queue/02.Priority-Queue/01.Priority-Queue/&quot;&gt;《算法通关手册》&lt;/a&gt;、&lt;a href=&quot;https://www.bilibili.com/video/BV1gy4y1E7M5/?p=77&amp;amp;spm_id_from=333.999.top_right_bar_window_history.content.click&amp;amp;vd_source=21011151235423b801d3f3ae98b91e94&quot;&gt;B站《数据结构与算法B Python版》视频&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、二叉堆和优先队列&quot;&gt;&lt;a href=&quot;#一、二叉堆和优先队列&quot; class=&quot;headerlink&quot; title=&quot;一、二叉堆和优先队列&quot;&gt;&lt;/a&gt;一、二叉堆和优先队列&lt;/h2&gt;&lt;p&gt;&amp;#8195;&amp;#8195;队列有一种变体称为&lt;strong&gt;优先队列&lt;code&gt;Priority Queue&lt;/code&gt;&lt;/strong&gt;。优先队列的&lt;strong&gt;出队跟队列一样从队首出队，但在优先队列内部，数据项的次序却是由“优先级”来确定&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;高优先级的数据项排在队首，而低优先级的数据项排在后面。&lt;/li&gt;
&lt;li&gt;这样，优先队列的入队操作就比较复杂，需要将数据项根据其优先级尽量挤到队列前方。&lt;h3 id=&quot;1-1-Binary-Heap库实现优先队列&quot;&gt;&lt;a href=&quot;#1-1-Binary-Heap库实现优先队列&quot; class=&quot;headerlink&quot; title=&quot;1.1 Binary Heap库实现优先队列&quot;&gt;&lt;/a&gt;1.1 &lt;code&gt;Binary Heap&lt;/code&gt;库实现优先队列&lt;/h3&gt;&amp;#8195;&amp;#8195;实现优先队列的经典方案是采用二叉堆数据结构，二叉堆能够将优先队列的入队和出队复杂度都保持在$O(logn)$。&lt;ul&gt;
&lt;li&gt;二叉堆逻辑结构上像二叉树，却是用非嵌套的列表来实现的。&lt;/li&gt;
&lt;li&gt;最小key排在队首的称为&lt;strong&gt;最小堆&lt;code&gt;min heap&lt;/code&gt;&lt;/strong&gt;（优先级最高）；反之，最大key排在队首的是&lt;strong&gt;最大堆&lt;code&gt;max heap&lt;/code&gt;&lt;/strong&gt;。后续主要讲最小堆。</summary>
    
    
    
    <category term="Data Structure and Algorithms" scheme="https://zhxnlp.github.io/categories/Data-Structure-and-Algorithms/"/>
    
    
    <category term="leetcode" scheme="https://zhxnlp.github.io/tags/leetcode/"/>
    
    <category term="Tree" scheme="https://zhxnlp.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习九：树（上）——树的定义及遍历、二叉搜素树</title>
    <link href="https://zhxnlp.github.io/2023/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E4%B9%9D%EF%BC%9A%E6%A0%91%EF%BC%88%E4%B8%8A%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E9%81%8D%E5%8E%86%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://zhxnlp.github.io/2023/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E4%B9%9D%EF%BC%9A%E6%A0%91%EF%BC%88%E4%B8%8A%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E9%81%8D%E5%8E%86%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2023-04-04T16:00:00.000Z</published>
    <updated>2023-04-09T09:20:54.527Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>参考<a href="https://algo.itcharge.cn/07.Tree/01.Binary-Tree/01.Binary-Tree-Basic/">《算法通关手册》</a>、<a href="https://www.bilibili.com/video/BV1gy4y1E7M5/?p=77&amp;spm_id_from=333.999.top_right_bar_window_history.content.click&amp;vd_source=21011151235423b801d3f3ae98b91e94">B站《数据结构与算法B Python版》视频</a></p></blockquote><h2 id="一、-树"><a href="#一、-树" class="headerlink" title="一、 树"></a>一、 树</h2><h3 id="1-1-树的定义"><a href="#1-1-树的定义" class="headerlink" title="1.1 树的定义"></a>1.1 树的定义</h3><p>&#8195;&#8195; <strong>树（Tree）</strong>：由 $n \ge 0$ 个节点与节点之间的边组成的有限集合。当 $n = 0$ 时称为空树，当 $n &gt; 0$ 时称为非空树。</p><p>树由若干节点，以及两两连接节点的边组成，并具有以下性质：</p><ul><li>其中一个节点被设定为根；</li><li>每个节点n(除根节点)，都恰连接一条来自节点p的边，p是n的父节点；</li><li>每个节点从根开始的路径是唯一的。</li><li><strong>如果每个节点最多有两个子节点，这样的树称为“二叉树”</strong></li></ul><blockquote><p>&#8195;&#8195;之所以把这种数据结构称为「树」是因为这种数据结构看起来就像是一棵倒挂的树，也就是说数据结构中的「树」是根朝上，而叶朝下的。如下图所示。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/30ddc64d6b4c4c7fa13094f6423abd7d.png" alt="test"></p><span id="more"></span><ul><li>节点<code>Node</code>：组成树的基本部分，每个节点具有名称，或“键值”，节点还可以保存额外数据项，数据项根据不同的应用而变。<ul><li>子节点<code>Children</code>：入边均来自于同一个节点的若干节点，称为这个节点的子节点。</li><li>父节点<code>Parent</code>：一个节点是其所有出边所连接节点的父节点。</li><li>兄弟节点<code>Sibling</code>：具有同一个父节点的节点之间称为兄弟节点。</li><li>叶节点<code>Leaf</code>：没有子节点的节点称为叶节点。</li><li>节点的度<code>Height</code>：一个节点所含有的子树个数</li></ul></li><li><p>根<code>Root</code>：树中唯一一个没有入边的节点。<br><img src="https://img-blog.csdnimg.cn/9a712c9b43ae470290a6fefe11fce310.png" alt="在这里插入图片描述"></p></li><li><p>边<code>Edge</code>：边是组成树的另一个基本部分。每条边恰好连接两个节点，表示节点之间具有关联，边具有出入方向；每个节点(除根节点)恰有一条来自另一节点的入边；每个节点可以有多条连到其他节点的出边。</p></li><li><p>路径<code>Path</code>：由边依次连接在一起的节点的有序列表，例如图中 <code>E</code> 到 <code>G</code> 的路径为 <code>E - B - A - D - G</code>。</p></li><li>路径长度：两个节点之间路径上经过的边数。例如图中 <code>E</code> 到 <code>G</code> 的路径长度为 $4$。</li><li>子树<code>Subtree</code>：一个节点和其所有子孙节点，以及相关边的集合。<br>如上图所示，红色节点 $A$ 是根节点，除了根节点之外，还有 <code>3</code> 棵互不相交的子树 $T_1(B、E、H、I、G)$、$T_2(C)$、$T_3(D、F、G、K)$。</li><li>层级<code>Level</code>：从根节点开始到达一个节点的路径，所包含的边的数量，称为这个节点的层级。根节点层级为0。</li><li>高度<code>height</code>：树中所有节点的最大层级称为树的高度。</li></ul><p>除了上面树的集合定义（树是由节点和边组成的集合），还有一种递归的定义，树是：</p><ul><li>空集</li><li>或者由根节点和0或多个子树构成。每个子树的根节点都跟树的根节点有边相连</li></ul><h3 id="1-2-二叉树"><a href="#1-2-二叉树" class="headerlink" title="1.2 二叉树"></a>1.2 二叉树</h3><p>树根据节点的子树是否可以互换位置，可以分为有序树和无序树，二叉树是有序树的一种。</p><ul><li><strong>有序树</strong>：节点的各个⼦树从左⾄右有序， 不能互换位置。<ul><li><strong>二叉树（Binary Tree）</strong>：树中各个节点的度不大于 <code>2</code> 个的有序树，称为二叉树。<br><img src="https://img-blog.csdnimg.cn/c052081dabcc476b9589c159a1ea9841.png" alt="在这里插入图片描述"></li></ul></li><li><strong>无序树</strong>：节点的各个⼦树可互换位置。</li></ul><p>&#8195;&#8195;二叉树是种特殊的树（可以是空树），它最多有两个⼦树，分别为左⼦树和右⼦树，并且两个子树是有序的，不可以互换。也就是说，在⼆叉树中不存在度⼤于 $2$ 的节点。<br>&#8195;&#8195;二叉树在逻辑上可以分为 5种基本形态，如下图所示：<br><img src="https://img-blog.csdnimg.cn/9b11de301f544a5c86d9d5b43a0006e8.png" alt="在这里插入图片描述"><br>下面我们来介绍一些特殊的二叉树。</p><h4 id="1-2-1-完全二叉树"><a href="#1-2-1-完全二叉树" class="headerlink" title="1.2.1 完全二叉树"></a>1.2.1 完全二叉树</h4><p>&#8195;&#8195; <strong>完全二叉树（Complete Binary Tree）</strong>：如果<font color='deeppink'>叶子节点只能出现在最下面两层，并且最下层的叶子节点都依次排列在该层最左边的位置上</font>，具有这种特点的二叉树称为完全二叉树。</p><p>完全二叉树满足以下特点：</p><ul><li>叶子节点只能出现在最下面两层。</li><li>每个内部节点都有两个子节点，最多只有一个内部节点例外。</li><li>最下层的叶子节点连续集中在最左边的位置上，即不存在只有右子树的情况。倒数第二层如果有叶子节点，则该层的叶子节点一定集中在右边的位置上。</li><li>同等节点数的二叉树中，完全二叉树的深度最小。</li></ul><p>下面来看几个例子：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/22ae56f5e2874c805f0e349f66f9f33f.png" alt=""><br>&#8195;&#8195;优先队列为了保持入队和出队复杂度都是$O(logn)$，所以采用完全二叉树来实现，下文优先队列会讲到。</p><blockquote><p>&#8195;&#8195;为了使堆操作能保持在对数水平上，就必须采用<strong>二叉树结构</strong>。同时如果要使操作始终保持在对数数量级上，就必须始终<strong>保持二叉树的平衡</strong>，树根左右子树拥有相同数量的节点，所以考虑采用<strong>完全二叉树</strong>的结构来近似实现平衡。</p></blockquote><h4 id="1-2-1-满二叉树"><a href="#1-2-1-满二叉树" class="headerlink" title="1.2.1 满二叉树"></a>1.2.1 满二叉树</h4><p>&#8195;&#8195; <strong>满二叉树（Full Binary Tree）</strong>：如果所有分支节点都存在左子树和右子树，并且所有叶子节点都在同一层上，则称该二叉树为满二叉树。</p><p>满二叉树满足以下特点：</p><ul><li>叶子节点只出现在最下面一层。</li><li>非叶子节点的度一定为 $2$。</li><li>在同等深度的二叉树中，满二叉树的节点个数最多，叶子节点个数最多。</li></ul><p>&#8195;&#8195;如果我们对满二叉树的节点进行编号，根结点编号为 $1$，然后按照层次依次向下，每一层从左至右的顺序进行编号。则深度为 $k$ 的满二叉树最后一个节点的编号为 $2^k - 1$。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6ab5ec933ba456c56c4a0d108f453d3b.png" alt=""></p><h4 id="1-2-3-二叉堆"><a href="#1-2-3-二叉堆" class="headerlink" title="1.2.3 二叉堆"></a>1.2.3 二叉堆</h4><blockquote><p><strong>堆（Heap）</strong>：符合以下两个条件之一的完全二叉树：</p><ul><li><strong>大顶堆</strong>：根节点值 ≥ 子节点值。</li><li><strong>小顶堆</strong>：根节点值 ≤ 子节点值。</li></ul><p>&#8195;&#8195;完全二叉树中，只规定了元素插入的方式，没有按照元素值的大小规定其在树中的顺序。二叉堆是按照一定的<strong>堆次序<code>Heap Order</code></strong> 排列的完全二叉树，分为两种：</p><ul><li><strong>最小堆<code>min heap</code></strong>（小顶堆）：<strong>任何一个父节点的key都要小于其所有子节点的key</strong>，如下图二；</li><li><strong>最大堆<code>max heap</code></strong> （大顶堆）：<strong>任何一个父节点的key都要大于其所有子节点的key</strong>，如下图一。</li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/6cb959de8fc5457992df481d1ee173f1.png" alt="在这里插入图片描述"></p><p>二叉堆中，任何一条路径，均是一个已排序数列，所以是部分有序。</p><h4 id="1-2-4-二叉搜索树"><a href="#1-2-4-二叉搜索树" class="headerlink" title="1.2.4 二叉搜索树"></a>1.2.4 二叉搜索树</h4><p>&#8195;&#8195; <strong>二叉搜索树（Binary Search Tree）</strong>：也叫做二叉查找树。二叉搜索树中，所有左子树上的节点都小于其根节点的值，所有右子树上的节点的值都大于其根节点的值，即恒有<code>root.left.val&lt;root.val&lt;root.right.val</code>。如下图所示，这 $3$ 棵树都是二叉搜索树。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8d970c9310215ffe85bac6390e152557.png" alt=""></p><ul><li>中序遍历BST，得到的是升序数组。中序倒序遍历，会得到一个降序数组</li><li>最小值一定在根节点的最左下角（中序遍历的起点），最大值一定在根节点的最右下角（中序遍历的终点）<h4 id="1-2-5-平衡二叉搜索树"><a href="#1-2-5-平衡二叉搜索树" class="headerlink" title="1.2.5 平衡二叉搜索树"></a>1.2.5 平衡二叉搜索树</h4></li></ul><p>&#8195;&#8195; <strong>平衡二叉搜索树（Balanced Binary Tree）</strong>：一种结构平衡的二叉搜索树。即叶节点高度差的绝对值不超过 $1$，并且左右两个子树都是一棵平衡二叉搜索树。平衡二叉树可以在 $O(logn)$ 内完成插入、查找和删除操作。最早被发明的平衡二叉搜索树为 <strong>「AVL 树（Adelson-Velsky and Landis Tree））」</strong>。</p><p> AVL 树满足以下性质：</p><ul><li>空二叉树是一棵 AVL 树。</li><li>如果 T 是一棵 AVL 树，那么其左右子树也是 AVL 树，并且 $|h(ls) - h(rs)| \le 1$，$h(ls)$ 是左子树的高度，$h(rs)$ 是右子树的高度。</li><li>AVL 树的高度为 $O(log n)$。</li></ul><p>如图所示，前 $2$ 棵树是平衡二叉搜索树，最后一棵树不是平衡二叉搜索树，因为这棵树的左右子树的高度差的绝对值超过了 $1$。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2846682759a24a7f6caab7c2ce22b99a.png" alt=""></p><h3 id="1-3-二叉树的实现"><a href="#1-3-二叉树的实现" class="headerlink" title="1.3 二叉树的实现"></a>1.3 二叉树的实现</h3><h4 id="1-3-1-嵌套列表法（顺序存储）"><a href="#1-3-1-嵌套列表法（顺序存储）" class="headerlink" title="1.3.1  嵌套列表法（顺序存储）"></a>1.3.1  嵌套列表法（顺序存储）</h4><p>可以使用<code>Python List</code>来实现二叉树数据结构。<br><img src="https://img-blog.csdnimg.cn/ce455ca3523943c8bbba12ac9c9347a6.png" alt="在这里插入图片描述"></p><ul><li>递归的嵌套列表实现二叉树，由具有3个元素的列表实现： <code>[root, left, right]</code>，这里<code>left</code>和<code>right</code>指的是左子树和右子树，所以是一个递归的表示。<ol><li>第1个元素为根节点的值；</li><li>第2个元素是左子树（所以也是一个列表）；</li><li>第3个元素是右子树（所以也是一个列表）；</li><li>叶节点没有子节点，其子树是一个空列表</li></ol></li><li>对于二叉树，根是<code>myTree[0]</code>，左子树<code>myTree[1]</code>，右子树<code>myTree[2]</code>。</li><li><p>嵌套列表法的优点：子树的结构与树相同，是一种递归数据结构；很容易扩展到多叉树，仅需要增加列表元素即可。</p><p><img src="https://img-blog.csdnimg.cn/c597656437f84d158a43a61ffe56989f.png#pic_center =600x" alt="在这里插入图片描述"></p></li></ul><p>嵌套列表法代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BinaryTree</span>(<span class="params">r</span>):</span>  <span class="comment"># 创建仅有根节点的二叉树</span></span><br><span class="line">    <span class="keyword">return</span> [r, [], []]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># insertLeft是在root上插入新的左子树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertLeft</span>(<span class="params">root,newBranch</span>):</span>  <span class="comment"># 将新节点插入树中作为其直接的左子节点</span></span><br><span class="line">    t = root.pop(<span class="number">1</span>)  <span class="comment"># 将左子树pop出来，赋值给变量t</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="number">1</span>:   <span class="comment"># 长度大于1表示原先就有左子树</span></span><br><span class="line">        root.insert(<span class="number">1</span>,[newBranch,t,[]]) <span class="comment"># 新子树的根就是newbranch，新子树的左子树就是原先的左子树，右子树是空。</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        root.insert(<span class="number">1</span>,[newBranch,[],[]])<span class="comment"># 左右子树都是空，不需要继承原先左子树</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertRight</span>(<span class="params">root,newBranch</span>):</span>  <span class="comment"># 将新节点插入树中作为其直接的右子节点</span></span><br><span class="line">    t = root.pop(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="number">1</span>:</span><br><span class="line">        root.insert(<span class="number">2</span>,[newBranch,[],t])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        root.insert(<span class="number">2</span>, [newBranch, [], []])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRootVal</span>(<span class="params">root</span>):</span>  <span class="comment"># 取得根节点的值</span></span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setRootVal</span>(<span class="params">root,newVal</span>):</span>    <span class="comment"># 重设根节点的值</span></span><br><span class="line">    root[<span class="number">0</span>] = newVal</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLeftChild</span>(<span class="params">root</span>):</span>  <span class="comment"># 返回左子树</span></span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRightChild</span>(<span class="params">root</span>):</span>  <span class="comment"># 返回右子树</span></span><br><span class="line">    <span class="keyword">return</span> root[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>代码运行示例：<br> <img src="https://img-blog.csdnimg.cn/0ee2fca1738340419f5a6a8f0b97e133.png#pic_center =600x" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/722f0d3fb73d48fea918ef4e2d14c5b4.png#pic_center =600x" alt="在这里插入图片描述"></p><p>&#8195;&#8195; 对于完全二叉树（尤其是满二叉树）来说，采用顺序存储结构比较合适，它能充分利用存储空间；而对于一般二叉树，如果需要设置很多的「空节点」，则采用顺序存储结构就会浪费很多存储空间。<br>&#8195;&#8195;由于顺序存储结构固有的一些缺陷，会使得二叉树的插入、删除等操作不方便，效率也比较低。对于二叉树来说，当树的形态和大小经常发生动态变化时，更适合采用链式存储结构。</p><h4 id="1-3-2-节点链接法（链式存储）"><a href="#1-3-2-节点链接法（链式存储）" class="headerlink" title="1.3.2 节点链接法（链式存储）"></a>1.3.2 节点链接法（链式存储）</h4><p>&#8195;&#8195;二叉树采用链式存储结构时，每个链节点包含一个用于数据域 <code>val</code>，存储节点信息；还包含两个指针域 <code>left</code> 和 <code>right</code>，分别指向左右两个子节点。当左子节点或者右子节点不存在时，相应指针域值为空。二叉链节点结构如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e297d27270c8d599dd7537c68c031ede.png" alt=""></p><p>定义<code>BinaryTree</code>类</p><ul><li>每个节点的val保存其节点的数据项（数值）</li><li><p>成员<code>left/right children</code> 保存指向左右子树的引用（同样是<code>BinaryTree</code>对象）。</p><p><img src="https://img-blog.csdnimg.cn/5e0320650e1a4e95a2f2b47e4c3d6e69.png" alt="在这里插入图片描述"><br>节点链接法代码：</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        self.val = val<span class="comment"># 成员val保存根节点数据项</span></span><br><span class="line">        self.leftChild = <span class="literal">None</span>  <span class="comment"># 成员leftChild保存指向左子树的引用</span></span><br><span class="line">        self.rightChild = <span class="literal">None</span>  <span class="comment"># 成员rightChild保存指向右子树的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertLeft</span>(<span class="params">self,newNode</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.leftChild == <span class="literal">None</span>:  <span class="comment"># 如果原先的左子树为空</span></span><br><span class="line">            self.leftChild = BinaryTree(newNode)<span class="comment"># 将root左子树引用指向要插入的新节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = BinaryTree(newNode)</span><br><span class="line">            t.leftChild = self.leftChild            <span class="comment"># 插入节点的左子树是root的左子树</span></span><br><span class="line">            self.leftChild = t<span class="comment"># root的左子树指向插入节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertRight</span>(<span class="params">self,newNode</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.rightChild == <span class="literal">None</span>:</span><br><span class="line">            self.rightChild = BinaryTree(newNode)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = BinaryTree(newNode)</span><br><span class="line">            t.rightChild = self.rightChild</span><br><span class="line">            self.rightChild = t</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRightChild</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.rightChild</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeftChild</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.leftChild</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setRootVal</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRootVal</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.val</span><br></pre></td></tr></table></figure><p>代码运行示例：<br><img src="https://img-blog.csdnimg.cn/e73cd33d435f411cb368cac346aab72a.png#pic_center =500x" alt="在这里插入图片描述"></p><p>&#8195;&#8195;二叉树的链表存储结构具有灵活、方便的特点。节点的最大数目只受系统最大可存储空间的限制。一般情况下，二叉树的链表存储结构比顺序存储结构更省空间（用于存储指针域的空间开销只是二叉树中节点数的线性函数），而且对于二叉树实施相关操作也很方便，因此，一般我们使用链式存储结构来存储二叉树。 </p><h3 id="1-4-树的应用：表达式解析"><a href="#1-4-树的应用：表达式解析" class="headerlink" title="1.4 树的应用：表达式解析"></a>1.4 树的应用：表达式解析</h3><ul><li>可以将表达式表示为树结构，叶节点保存操作数，内部节点保存操作符。</li><li>表达式层次决定计算的优先级，越底层的表达式，优先级越高。例如全括号表达式：<code>((7+3)*(5-2))</code></li><li>树中的每个子树都表示一个子表达式。将子树替换为子表达式值的节点，即可实现求值。<br><img src="https://img-blog.csdnimg.cn/958797bc766e4b07b8b8f06f2c46394e.png#pic_center =500x" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4203ce827eb9497787cbc114f81921bd.png#pic_center =500x" alt="在这里插入图片描述"></li></ul><ol><li>从全括号表达式创建表达式解析树</li></ol><ul><li><p>扫描：<br>首先，全括号表达式要分解为Token列表。其单词分为括号、操作符和操作数这几类，左括号是表达式的开始，而右括号是表达式的结束。下面是一个实例演示，全括号表达式为<code>(3+(4*5))</code>，灰色表示当前节点：<br><img src="https://img-blog.csdnimg.cn/0807c7389667466f9873c065c5111523.png" alt="在这里插入图片描述">      </p></li><li><p>归纳定义表达式解析树规则<br>从左到右扫描全括号表达式的每个单词，依据规则建立解析树。</p><ul><li>当前单词是 <code>&quot;(&quot;</code>：为当前节点添加一个新节点作为其左子节点<code>insertLeft</code>，当前节点下降为这个新节点<code>getLeftChild</code>；</li><li>当前单词是操作符 <code>“+, -, *, /”</code>：将当前节点的值设为此符号<code>setRootVal</code>，为当前节点添加一个新节点作为其右子节点<code>insertRight</code>，当前节点下降为这个新节点<code>getRightChild</code>；</li><li>当前单词是操作数：将当前节点的值设为此数，当前节点上升到父节点；</li><li>当前单词是 <code>&quot;)&quot;</code>：则当前节点上升到父节点。</li></ul></li><li>创建树的过程中，关键的是<strong>对当前节点的跟踪</strong>。<br>从上面步骤可以看到，上升到父节点目前没有支持的方法。我们可以用一个栈来记录跟踪父节点。当前节点下降时，将下降前的节点push入栈；当前节点需要上升至父节点时，上升到pop出栈的节点即可。</li></ul><p>表达式解析树创建代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildParseTree</span>(<span class="params">s</span>):</span></span><br><span class="line">    ls = s.split() <span class="comment"># 从字符串创建token列表</span></span><br><span class="line">    Stack=[]<span class="comment"># 创建栈，存放父节点</span></span><br><span class="line">    eTree = BinaryTree(<span class="string">&#x27;&#x27;</span>)<span class="comment"># 创建二叉树</span></span><br><span class="line">    Stack.append(eTree)  <span class="comment"># 将根节点入栈，然后下降</span></span><br><span class="line">    currentTree = eTree</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ls:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">&#x27;(&#x27;</span>:  <span class="comment"># 表达式开始</span></span><br><span class="line">            currentTree.insertLeft(<span class="string">&#x27;&#x27;</span>)  <span class="comment"># 创建左子节点</span></span><br><span class="line">            Stack.append(currentTree)    <span class="comment"># 当前节点入栈，然后下降节点</span></span><br><span class="line">            currentTree = currentTree.getLeftChild() </span><br><span class="line">        <span class="keyword">elif</span> i <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;)&#x27;</span>]:  <span class="comment"># 操作数</span></span><br><span class="line">            currentTree.setRootVal(<span class="built_in">int</span>(i))</span><br><span class="line">            currentTree = Stack.pop()  <span class="comment"># 出栈上升</span></span><br><span class="line">        <span class="keyword">elif</span> i <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>]:    </span><br><span class="line">            currentTree.setRootVal(i)  <span class="comment"># 碰到操作符，将当前节点的值设为操作符</span></span><br><span class="line">            currentTree.insertRight(<span class="string">&#x27;&#x27;</span>)<span class="comment"># 创建右子节点，当前节点入栈然后下降节点</span></span><br><span class="line">            Stack.append(currentTree)</span><br><span class="line">            currentTree = currentTree.getRightChild()</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="string">&#x27;)&#x27;</span>:  <span class="comment"># 表达式结束</span></span><br><span class="line">            currentTree = Stack.pop()  <span class="comment"># 出栈上升</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError            <span class="comment"># 如果表达式中有不该出现的单词就报错</span></span><br><span class="line">    <span class="keyword">return</span> eTree</span><br></pre></td></tr></table></figure><ol><li>利用表达式解析树求值<br>由于二叉树<code>BinaryTree</code>是一个递归数据结构，自然可以用递归算法来处理。求值递归函数<code>evaluate</code>，可从树的底层子树开始，逐步向上层求值，最终得到整个表达式的值。</li></ol><ul><li>求值递归函数evaluate的递归三要素：<ol><li>基本结束条件：叶节点是最简单的子树，没有左右子节点，其根节点的数据项即为子表达式树的值。</li><li>缩小规模：将表达式树分为左子树、右子树，即为缩小规模。</li><li>调用自身：分别调用evaluate计算左子树和右子树的值，然后将左右子树的值依根节点的操作符进行计算，从而得到表达式的值。</li></ol></li><li>一个增加程序可读性的技巧：引用函数<code>operator</code>。<br>如果使用if-else语句，判断操作符，来进行计算，随着表达式增多，可读性会变差。这里调用python内置函数<code>operator</code>，其包含了所有的操作符。我们将<code>op</code>设为<code>+-*/</code>这些不同的操作符，就可以使用相同的语句<code>op(1,2)</code>来实现不同的计算，增加代码的可读性。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">op = operator.add</span><br><span class="line">n = op(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>表达式解析树求值代码实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span>(<span class="params">parseTree</span>):</span></span><br><span class="line"><span class="comment"># 创建字典opers，将操作符从字符映射为具体的计算功能</span></span><br><span class="line">    opers = &#123;<span class="string">&#x27;+&#x27;</span>:operator.add, <span class="string">&#x27;-&#x27;</span>:operator.sub,</span><br><span class="line">             <span class="string">&#x27;*&#x27;</span>:operator.mul, <span class="string">&#x27;/&#x27;</span>:operator.truediv&#125;</span><br><span class="line">    <span class="comment"># 缩小规模：</span></span><br><span class="line">    leftC = parseTree.getLeftChild()</span><br><span class="line">    rightC = parseTree.getRightChild()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> leftC <span class="keyword">and</span> rightC:  <span class="comment"># 如果存在左右子树，就递归调用</span></span><br><span class="line">        fn = opers[parseTree.getRootVal()]           <span class="comment"># parseTree.getRootVal()表示根节点保存的操作符</span></span><br><span class="line">        <span class="keyword">return</span> fn(evaluate(leftC),evaluate(rightC))  <span class="comment"># 递归调用</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 没有左右子树，就是叶节点，直接返回值就行</span></span><br><span class="line">        <span class="keyword">return</span> parseTree.getRootVal()  <span class="comment"># 基本结束条件</span></span><br></pre></td></tr></table></figure><h2 id="二、-树的遍历Tree-Traversals"><a href="#二、-树的遍历Tree-Traversals" class="headerlink" title="二、 树的遍历Tree Traversals"></a>二、 树的遍历Tree Traversals</h2><p>&#8195;&#8195;<strong>树的遍历</strong>：指的是从根节点出发，按照某种次序依次访问二叉树中所有节点，使得每个节点被访问一次且仅被访问一次。<br>&#8195;&#8195;树是一个递归的数据结构，所以可以按照递归您的方式进行遍历。按照对节点访问次序的不同，有4种遍历方式：</p><ul><li>前序遍历(preorder)：<strong>根-左-右</strong>。在遍历任何一棵子树时，都是先访问根节点，然后递归地前序遍历左子树，最后再递归地前序遍历右子树。</li><li>中序遍历(inorder)：<strong>左-根-右</strong>。先递归地中序访问左子树，再访问根节点，最后中序访问右子树。</li><li>后序遍历(postorder)：<strong>左-右-根</strong>。先递归地后序访问左子树，再后续访问右子树，最后访问根节点。</li><li>层序遍历：从根节点开始，逐层进行遍历，同一层节点则是按照从左至右的顺序依次访问。</li></ul><h3 id="2-1-前序遍历"><a href="#2-1-前序遍历" class="headerlink" title="2.1 前序遍历"></a>2.1 前序遍历</h3><p>如下图所示，该二叉树的前序遍历顺序为：<code>A - B - D - H - I - E - C - F - J - G - K</code>。</p><p><img src="https://img-blog.csdnimg.cn/1056cf1d9e564c27992fc82d9a40aa8b.png" alt="在这里插入图片描述"></p><h4 id="2-1-1-前序遍历的递归实现"><a href="#2-1-1-前序遍历的递归实现" class="headerlink" title="2.1.1 前序遍历的递归实现"></a>2.1.1 前序遍历的递归实现</h4><p>前序遍历递归实现代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">tree</span>):</span></span><br><span class="line">    <span class="keyword">if</span> tree:</span><br><span class="line">        <span class="built_in">print</span>(tree.getRootVal())        <span class="comment"># 访问根节点</span></span><br><span class="line">        preorder(tree.getLeftChild())</span><br><span class="line">        preorder(tree.getRightChild())</span><br></pre></td></tr></table></figure><br>在前面构造的<code>BinaryTree</code>类里，实现前序遍历，需要加入子树是否为空的判断：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(self.val)</span><br><span class="line">    <span class="keyword">if</span> self.leftChild:</span><br><span class="line">        self.leftChild.preorder()</span><br><span class="line">    <span class="keyword">if</span> self.rightChild:</span><br><span class="line">        self.rightChild.preorder()</span><br></pre></td></tr></table></figure><h4 id="2-1-2-前序遍历的显式栈实现"><a href="#2-1-2-前序遍历的显式栈实现" class="headerlink" title="2.1.2 前序遍历的显式栈实现"></a>2.1.2 前序遍历的显式栈实现</h4><p>&#8195;&#8195;二叉树的前序遍历递归实现的过程，实际上就是调用系统栈的过程。我们也可以使用一个显式栈 <code>stack</code> 来模拟递归的过程。</p><p>&#8195;&#8195;前序遍历的顺序为：根节点 - 左子树 - 右子树，而根据栈的「先入后出」特点，所以入栈的顺序应该为：先放入右子树，再放入左子树。这样可以保证最终遍历顺序为前序遍历顺序。 具体实现步骤如下：</p><ol><li>判断二叉树是否为空，为空则直接返回。</li><li>初始化维护一个栈，将根节点入栈。</li><li><p>当栈不为空时：</p><ol><li>弹出栈顶元素 <code>node</code>，并访问该元素。</li><li>如果 <code>node</code> 的右子树不为空，则将 <code>node</code> 的右子树入栈。</li><li>如果 <code>node</code> 的左子树不为空，则将 <code>node</code> 的左子树入栈。</li></ol><p>二叉树的前序遍历显式栈实现代码如下：</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:                        <span class="comment"># 二叉树为空直接返回</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:                        <span class="comment"># 栈不为空</span></span><br><span class="line">            node = stack.pop()              <span class="comment"># 弹出根节点</span></span><br><span class="line">            res.append(node.val)            <span class="comment"># 访问根节点</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)    <span class="comment"># 右子树入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)     <span class="comment"># 左子树入栈</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="2-2-中序遍历"><a href="#2-2-中序遍历" class="headerlink" title="2.2 中序遍历"></a>2.2 中序遍历</h3><p>&#8195;&#8195;遍历任何一棵子树时仍然是按照先遍历子树根节点的左子树，然后访问根节点，最后再遍历子树根节点的右子树的顺序进行遍历。如下图所示，该二叉树的中序遍历顺序为：<code>H - D - I - B - E - A - F - J - C - K - G</code>。<br><img src="https://img-blog.csdnimg.cn/61c7899bfc164d269049dd4c199dbe0e.png" alt="在这里插入图片描述"></p><h4 id="2-2-1-中序遍历的递归实现"><a href="#2-2-1-中序遍历的递归实现" class="headerlink" title="2.2.1 中序遍历的递归实现"></a>2.2.1 中序遍历的递归实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">tree</span>):</span></span><br><span class="line">    <span class="keyword">if</span> tree:</span><br><span class="line">        inorder(tree.getLeftChild())</span><br><span class="line">        <span class="built_in">print</span>(tree.getRootVal())</span><br><span class="line">        inorder(tree.getRightChild())</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;前面1.4 章节根据全括号表达式生成了表达式解析树，反过来也可以用中序遍历的方式，从表达式解析树生成全括号表达式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面代码对每个数字也加了括号，可以进一步优化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printexp</span>(<span class="params">tree</span>):</span></span><br><span class="line">s=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> tree:</span><br><span class="line">s=<span class="string">&quot;(&quot;</span>+printexp(tree.getLeftChild())</span><br><span class="line">s=s+<span class="built_in">str</span>(tree.getRootVal())</span><br><span class="line">s=s+printexp(tree.getRightChild())+<span class="string">&quot;)&quot;</span></span><br><span class="line"><span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h4 id="2-2-1-中序遍历的显式栈实现"><a href="#2-2-1-中序遍历的显式栈实现" class="headerlink" title="2.2.1 中序遍历的显式栈实现"></a>2.2.1 中序遍历的显式栈实现</h4><p>&#8195;&#8195;与前序遍历不同，访问根节点要放在左子树遍历完之后。因此我们需要保证：<strong>在左子树访问之前，当前节点不能提前出栈</strong>。</p><ul><li><p>先从根节点开始，循环遍历左子树，不断将当前子树的根节点放入栈中，直到当前节点无左子树时，从栈中弹出该节点并进行处理。</p></li><li><p>然后再访问该元素的右子树，并进行上述循环遍历左子树的操作。这样可以保证最终遍历顺序为中序遍历顺序。</p></li></ul><p>二叉树的中序遍历显式栈实现步骤如下：</p><ol><li>判断二叉树是否为空，为空则直接返回。</li><li>初始化维护一个空栈。</li><li><p>当根节点或者栈不为空时：</p><ol><li>如果当前节点不为空，则循环遍历左子树，并不断将当前子树的根节点入栈。</li><li>如果当前节点为空，说明当前节点无左子树，则弹出栈顶元素 <code>node</code>，并访问该元素，然后尝试访问该节点的右子树。</li></ol><p>二叉树的中序遍历显式栈实现代码如下：</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:                <span class="comment"># 二叉树为空直接返回</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:        <span class="comment"># 根节点或栈不为空</span></span><br><span class="line">            <span class="keyword">while</span> root:             </span><br><span class="line">                stack.append(root)  <span class="comment"># 将当前树的根节点入栈</span></span><br><span class="line">                root = root.left    <span class="comment"># 找到最左侧节点</span></span><br><span class="line">            </span><br><span class="line">            node = stack.pop()      <span class="comment"># 遍历到最左侧，当前节点无左子树时，将最左侧节点弹出</span></span><br><span class="line">            res.append(node.val)    <span class="comment"># 访问该节点</span></span><br><span class="line">            root = node.right       <span class="comment"># 尝试访问该节点的右子树</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="2-3-后序遍历"><a href="#2-3-后序遍历" class="headerlink" title="2.3 后序遍历"></a>2.3 后序遍历</h3><p>&#8195;&#8195;后序遍历过程也是一个递归过程。在遍历任何一棵子树时，先遍历子树根节点的左子树，然后遍历子树根节点的右子树，最后再访问根节点。如下图所示，该二叉树的后序遍历顺序为：<code>H - I - D - E - B - J - F - K - G - C - A</code>。<br><img src="https://img-blog.csdnimg.cn/755dad95dab94050b6e8d0f5f627719f.png" alt="在这里插入图片描述"></p><h4 id="2-3-1-后序遍历的递归实现"><a href="#2-3-1-后序遍历的递归实现" class="headerlink" title="2.3.1 后序遍历的递归实现"></a>2.3.1 后序遍历的递归实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">tree</span>):</span></span><br><span class="line">    <span class="keyword">if</span> tree:</span><br><span class="line">        postorder(tree.getLeftChild())</span><br><span class="line">        postorder(tree.getRightChild())</span><br><span class="line">        <span class="built_in">print</span>(tree.getRootVal())</span><br></pre></td></tr></table></figure><h4 id="2-3-2-后序遍历的显式栈实现"><a href="#2-3-2-后序遍历的显式栈实现" class="headerlink" title="2.3.2 后序遍历的显式栈实现"></a>2.3.2 后序遍历的显式栈实现</h4><p>&#8195;&#8195;与前序、中序遍历不同，在后序遍历中，根节点的访问要放在左右子树访问之后。因此，我们要保证：<strong>在左右孩子节点访问结束之前，当前节点不能提前出栈</strong>。</p><p>&#8195;&#8195;我们应该从根节点开始，先将根节点放入栈中，然后依次遍历左子树，不断将当前子树的根节点放入栈中，直到遍历到左子树最左侧的那个节点，从栈中弹出该元素，并判断该元素的右子树是否已经访问完毕，如果访问完毕，则访问该元素。如果未访问完毕，则访问该元素的右子树。二叉树的后序遍历显式栈实现步骤如下：</p><ol><li>判断二叉树是否为空，为空则直接返回。</li><li>初始化维护一个空栈，使用 <code>prev</code> 保存前一个访问的节点，用于确定当前节点的右子树是否访问完毕。</li><li>当根节点或者栈不为空时，从当前节点开始：<ol><li>如果当前节点有左子树，则不断遍历左子树，并将当前根节点压入栈中。</li><li>如果当前节点无左子树，则弹出栈顶元素 <code>node</code>。</li><li>如果栈顶元素 <code>node</code> 无右子树（即 <code>not node.right</code>）或者右子树已经访问完毕（即 <code>node.right == prev</code>），则访问该元素，然后记录前一节点，并将当前节点标记为空节点。</li><li>如果栈顶元素有右子树，则将栈顶元素重新压入栈中，继续访问栈顶元素的右子树。</li></ol></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        prev = <span class="literal">None</span>                 <span class="comment"># 保存前一个访问的节点，用于确定当前节点的右子树是否访问完毕</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:        <span class="comment"># 根节点或栈不为空</span></span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)  <span class="comment"># 将当前树的根节点入栈</span></span><br><span class="line">                root = root.left    <span class="comment"># 继续访问左子树，找到最左侧节点</span></span><br><span class="line"></span><br><span class="line">            node = stack.pop()      <span class="comment"># 遍历到最左侧，当前节点无左子树时，将最左侧节点弹出</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前节点无右子树或者右子树访问完毕</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.right <span class="keyword">or</span> node.right == prev:</span><br><span class="line">                res.append(node.val)<span class="comment"># 访问该节点</span></span><br><span class="line">                prev = node         <span class="comment"># 记录前一节点</span></span><br><span class="line">                root = <span class="literal">None</span>         <span class="comment"># 将当前根节点标记为空</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(node)  <span class="comment"># 右子树尚未访问完毕，将当前节点重新压回栈中</span></span><br><span class="line">                root = node.right   <span class="comment"># 继续访问右子树</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;前面1.4章节的表达式解析树求值中，其计算过程其实也是一个<strong>后序遍历</strong>的过程（左→右→根），所以可以使用后序遍历方法，重写表达式求值代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后序遍历：表达式求值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postordereval</span>(<span class="params">tree</span>):</span></span><br><span class="line">    opers = &#123;<span class="string">&#x27;+&#x27;</span>:operator.add, <span class="string">&#x27;-&#x27;</span>:operator.sub,</span><br><span class="line">             <span class="string">&#x27;*&#x27;</span>:operator.mul, <span class="string">&#x27;/&#x27;</span>:operator.truediv&#125;</span><br><span class="line">    res1 = <span class="literal">None</span></span><br><span class="line">    res2 = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> tree:</span><br><span class="line">        res1 = postordereval(tree.getLeftChild())   <span class="comment"># 左子树</span></span><br><span class="line">        res2 = postordereval(tree.getRightChild())  <span class="comment"># 右子树</span></span><br><span class="line">        <span class="keyword">if</span> res1 <span class="keyword">and</span> res2:</span><br><span class="line">        fn=opers[tree.getRootVal()]</span><br><span class="line">            <span class="keyword">return</span> fn(res1,res2)  <span class="comment"># 根节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> tree.getRootVal()</span><br></pre></td></tr></table></figure><h3 id="2-4-层序遍历"><a href="#2-4-层序遍历" class="headerlink" title="2.4 层序遍历"></a>2.4 层序遍历</h3><p>层序遍历步骤：</p><ul><li>如果二叉树为空，则返回。<ul><li>如果二叉树不为空，则：<ol><li>先依次访问二叉树第 <code>1</code> 层的节点。</li><li>然后依次访问二叉树第 <code>2</code> 层的节点。</li><li>……</li><li>依次下去，最后依次访问二叉树最下面一层的节点。</li><li>同一层节点则是按照从左至右的顺序依次访问的</li></ol></li></ul></li></ul><p>如下图所示，该二叉树的后序遍历顺序为：<code>A - B - C - D - E - F - G - H - I - J - K</code>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d4ecafb2a24e79da8ac952c2bb397002.png" alt=""></p><p>二叉树的层序遍历是通过队列来实现的。具体步骤如下：</p><ol><li>判断二叉树是否为空，为空则直接返回。</li><li>令根节点入队。</li><li>当队列不为空时，求出当前队列长度 $s_i$。</li><li>依次从队列中取出这 $s_i$ 个元素，并对这 $s_i$ 个元素依次进行访问。然后将其左右子节点入队，然后继续遍历下一层节点。</li><li>当队列为空时，结束遍历。</li></ol><p>二叉树的层序遍历代码实现如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]       <span class="comment"># 根节点入队</span></span><br><span class="line">        ans = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">        size = <span class="built_in">len</span>(queue)<span class="comment"># 当前队列长度</span></span><br><span class="line">            ls = []                <span class="comment"># 当前层的临时列表</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):            </span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)<span class="comment"># 当前层节点出队</span></span><br><span class="line">                ls.append(cur.val)<span class="comment"># 将队列中的元素都拿出来(也就是获取这一层的节点)，放到临时list中</span></span><br><span class="line">                <span class="comment"># 如果节点的左/右子树不为空，也放入队列中</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> ls:</span><br><span class="line">                ans.append(ls)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;在 while 循环的每一轮中，都是将当前层的所有结点出队列，同时将下一层的所有结点入队列，这样就实现了层序遍历<br><img src="https://img-blog.csdnimg.cn/bb62723f02294907b5c375191e7ab760.gif#pic_center" alt="在这里插入图片描述"></p><h3 id="2-5-二叉树的遍历题目"><a href="#2-5-二叉树的遍历题目" class="headerlink" title="2.5 二叉树的遍历题目"></a>2.5 二叉树的遍历题目</h3><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0144</td><td style="text-align:left"><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">二叉树的前序遍历</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.md">Python</a></td><td style="text-align:left">栈、树</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0094</td><td style="text-align:left"><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0094.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.md">Python</a></td><td style="text-align:left">栈、树、哈希表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0145</td><td style="text-align:left"><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">二叉树的后序遍历</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.md">Python</a></td><td style="text-align:left">栈、树</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0102</td><td style="text-align:left"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.md">Python</a></td><td style="text-align:left">树、广度优先搜索</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0103</td><td style="text-align:left"><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">二叉树的锯齿形层序遍历</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.md">Python</a></td><td style="text-align:left">树、广度优先搜索、二叉树</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0107</td><td style="text-align:left"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">二叉树的层序遍历 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0107.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20II.md">Python</a></td><td style="text-align:left">树、广度优先搜索</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0104</td><td style="text-align:left"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.md">Python</a></td><td style="text-align:left">树、深度优先搜索、递归</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0111</td><td style="text-align:left"><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0111.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.md">Python</a></td><td style="text-align:left">树、深度优先搜索、广度优先搜索</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0124</td><td style="text-align:left"><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">二叉树中的最大路径和</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0124.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.md">Python</a></td><td style="text-align:left">树、深度优先搜索、动态规划、二叉树</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0101</td><td style="text-align:left"><a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md">Python</a></td><td style="text-align:left">树、深度优先搜索、广度优先搜索</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0112</td><td style="text-align:left"><a href="https://leetcode.cn/problems/path-sum/">路径总和</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.md">Python</a></td><td style="text-align:left">树、深度优先搜索</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0113</td><td style="text-align:left"><a href="https://leetcode.cn/problems/path-sum-ii/">路径总和 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II.md">Python</a></td><td style="text-align:left">树、深度优先搜索、回溯、二叉树</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0236</td><td style="text-align:left"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.md">Python</a></td><td style="text-align:left">树</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0199</td><td style="text-align:left"><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">二叉树的右视图</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE.md">Python</a></td><td style="text-align:left">树、深度优先搜索、广度优先搜索、递归、队列</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0226</td><td style="text-align:left"><a href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.md">Python</a></td><td style="text-align:left">树、递归</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0958</td><td style="text-align:left"><a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">二叉树的完全性检验</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0958.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%8C%E5%85%A8%E6%80%A7%E6%A3%80%E9%AA%8C.md">Python</a></td><td style="text-align:left">树、广度优先搜索、二叉树</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0572</td><td style="text-align:left">另一棵树的子树</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0100</td><td style="text-align:left"><a href="https://leetcode.cn/problems/same-tree/">相同的树</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0100.%20%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.md">Python</a></td><td style="text-align:left">树、深度优先搜索</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0116</td><td style="text-align:left"><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">填充每个节点的下一个右侧节点指针</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0116.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88.md">Python</a></td><td style="text-align:left">树、深度优先搜索、广度优先搜索</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0117</td><td style="text-align:left"><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">填充每个节点的下一个右侧节点指针 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0117.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%20II.md">Python</a></td><td style="text-align:left">树、深度优先遍历</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0297</td><td style="text-align:left"><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">二叉树的序列化与反序列化</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0297.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.md">Python</a></td><td style="text-align:left">树、设计</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0114</td><td style="text-align:left">二叉树展开为链表</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></div><h4 id="2-5-1-二叉树的前序遍历、中序遍历"><a href="#2-5-1-二叉树的前序遍历、中序遍历" class="headerlink" title="2.5.1 二叉树的前序遍历、中序遍历"></a>2.5.1 二叉树的前序遍历、中序遍历</h4><blockquote><ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">0144 二叉树的前序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">0094 二叉树的中序遍历</a></li><li>题解<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/dong-hua-yan-shi-94-er-cha-shu-de-zhong-xu-bian-li/">《动画演示+三种实现 94. 二叉树的中序遍历》</a></li></ul></blockquote><p>下面只介绍中序遍历，因为二叉搜索树中用的较多</p><h5 id="2-5-1-1-递归"><a href="#2-5-1-1-递归" class="headerlink" title="2.5.1.1 递归"></a>2.5.1.1 递归</h5><p>&#8195;&#8195;定义 <code>preorderTraversal(self,root)</code> 表示当前遍历到 root 节点的答案。那么按照定义：</p><ul><li>递归调用self.preorderTraversal(root.left)   来遍历 root 节点的左子树，然后将 root 节点的值加入答案</li><li>递归调用preorderTraversal(root.right) 来遍历 root 节点的右子树</li><li>递归终止的条件为碰到空节点。</li></ul><p>递归的调用过程是不断往左边走，当左边走不下去了，就打印节点，并转向右边，然后右边继续这个过程。<br><img src="https://img-blog.csdnimg.cn/8526cc49d15b4378b0a3712054da503b.gif#pic_center" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,ans=[]</span>):</span></span><br><span class="line">        self.ans=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 前序遍历顺序是根左右       </span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">        self.preorderTraversal(root.left)   </span><br><span class="line">            self.ans.append(root.val)                     </span><br><span class="line">            self.preorderTraversal(root.right)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure><h5 id="2-5-1-2-迭代"><a href="#2-5-1-2-迭代" class="headerlink" title="2.5.1.2 迭代"></a>2.5.1.2 迭代</h5><p>&#8195;&#8195;递归实现时，是函数自己调用自己，一层层的嵌套下去，操作系统/虚拟机自动帮我们用 栈 来保存了每个调用的函数，现在我们需要自己模拟这样的调用过程。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stack=[]</span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">        <span class="comment"># 不断往左子树方向走，每走一次就将当前节点保存到栈中，模拟栈的调用</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root=root.left</span><br><span class="line">            <span class="comment"># 当前节点为空，说明左边走到头了，从栈中弹出节点并保存</span></span><br><span class="line">            <span class="comment"># 然后转向右边节点，继续上面整个过程(往左走到头再往右走到头）</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node=stack.pop()</span><br><span class="line">                ans.append(node.val)</span><br><span class="line">                root=node.right</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>或者是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stack=[]</span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">        <span class="comment"># 左边走到头后开始出栈，保存结果，同时往右走。</span></span><br><span class="line">        <span class="comment"># 往右走之后，下一个节点有左子节点，就往左走，循环往复</span></span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root=root.left            </span><br><span class="line">            root=stack.pop()</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">            root=root.right</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="2-5-2-二叉树的锯齿形层序遍历、二叉树的层序遍历-II"><a href="#2-5-2-二叉树的锯齿形层序遍历、二叉树的层序遍历-II" class="headerlink" title="2.5.2 二叉树的锯齿形层序遍历、二叉树的层序遍历 II"></a>2.5.2 二叉树的锯齿形层序遍历、二叉树的层序遍历 II</h4><blockquote><ul><li><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">0103二叉树的锯齿形层序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">0107二叉树的层序遍历 II</a></li></ul></blockquote><p>&#8195;&#8195;给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）<br>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：[[<span class="number">3</span>],[<span class="number">20</span>,<span class="number">9</span>],[<span class="number">15</span>,<span class="number">7</span>]]</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;此题和   <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">0094 二叉树的中序遍历</a>非常相似，前者都是从左至右遍历每一层。此题只需要将每一层遍历后得到的临时元素列表<code>ls</code>的顺序改变一下，再添加到最终答案<code>ans</code>就行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = [root]       <span class="comment"># 根节点入队</span></span><br><span class="line">        ans = []</span><br><span class="line">        level=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)<span class="comment"># 当前队列长度</span></span><br><span class="line">            ls = []                <span class="comment"># 当前层的临时列表</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):            </span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)<span class="comment"># 当前层节点出队</span></span><br><span class="line">                ls.append(cur.val)<span class="comment"># 将队列中的元素都拿出来，放到临时list中</span></span><br><span class="line">                <span class="comment"># 如果节点的左/右子树不为空，也放入队列中</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> ls:                </span><br><span class="line">                ans.append(ls) <span class="keyword">if</span> level%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">else</span> ans.append(ls[::-<span class="number">1</span>])</span><br><span class="line">                level+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;如果是  <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">0107二叉树的层序遍历 II</a>   ，将<code>ans</code>赋值改一下就行：     （如果是<code>ans+=ls</code>，就是正常的自顶向下层序遍历的答案）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;</span><span class="comment"># 前面都相同，只是不要level变量</span></span><br><span class="line">            <span class="keyword">if</span> ls:                </span><br><span class="line">                ans=[ls]+ans</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans                   </span><br></pre></td></tr></table></figure><h4 id="2-5-3-二叉树的最大深度、最小深度"><a href="#2-5-3-二叉树的最大深度、最小深度" class="headerlink" title="2.5.3 二叉树的最大深度、最小深度"></a>2.5.3 二叉树的最大深度、最小深度</h4><blockquote><ul><li><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">0104二叉树的最大深度</a></li><li><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">0111二叉树的最小深度</a> </li></ul></blockquote><p><strong>1. 二叉树的最大深度</strong><br>给定一个二叉树，找出其最大深度。示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]，返回它的最大深度 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3f4b5f3035c64db297f86425f5b97aea.png" alt="在这里插入图片描述"><br>直接套用上面层序遍历的代码，遍历每一层时<code>level+=1</code>，最后返回<code>level</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = [root]       <span class="comment"># 根节点入队</span></span><br><span class="line">        level=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">        level+=<span class="number">1</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue)<span class="comment"># 当前队列长度</span></span><br><span class="line">            ls = []                <span class="comment"># 当前层的临时列表</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):            </span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)<span class="comment"># 当前层节点出队</span></span><br><span class="line">                ls.append(cur.val)<span class="comment"># 将队列中的元素都拿出来，放到临时list中</span></span><br><span class="line">                <span class="comment"># 如果节点的左/右子树不为空，也放入队列中</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)               </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> level</span><br></pre></td></tr></table></figure><p><strong>2. 二叉树的最小深度</strong><br>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">2</span>,null,<span class="number">3</span>,null,<span class="number">4</span>,null,<span class="number">5</span>,null,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><p>套用层序遍历模板，当遍历到某一层，有叶节点时（没有左右子节点），返回level。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = [root]       <span class="comment"># 根节点入队</span></span><br><span class="line">        level=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level+=<span class="number">1</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue)<span class="comment"># 当前队列长度</span></span><br><span class="line">            ls = []                <span class="comment"># 当前层的临时列表</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):            </span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)<span class="comment"># 当前层节点出队</span></span><br><span class="line">                ls.append(cur.val)<span class="comment"># 将队列中的元素都拿出来，放到临时list中</span></span><br><span class="line">                <span class="comment"># 如果节点的左/右子树不为空，也放入队列中</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                    <span class="keyword">return</span> level</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> cur.left:</span><br><span class="line">                        queue.append(cur.left)</span><br><span class="line">                    <span class="keyword">if</span> cur.right:</span><br><span class="line">                        queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> level</span><br></pre></td></tr></table></figure><p>@[toc]</p><blockquote><p>参考<a href="https://algo.itcharge.cn/07.Tree/02.Binary-Search-Tree/01.Binary-Search-Tree/">《算法通关手册》</a>、<a href="https://www.bilibili.com/video/BV1gy4y1E7M5/?p=77&amp;spm_id_from=333.999.top_right_bar_window_history.content.click&amp;vd_source=21011151235423b801d3f3ae98b91e94">B站《数据结构与算法B Python版》视频</a></p></blockquote><h2 id="三、二叉搜索树Binary-Search-Tree"><a href="#三、二叉搜索树Binary-Search-Tree" class="headerlink" title="三、二叉搜索树Binary Search Tree"></a>三、二叉搜索树<code>Binary Search Tree</code></h2><h3 id="3-1-二叉搜索树BST的性质"><a href="#3-1-二叉搜索树BST的性质" class="headerlink" title="3.1  二叉搜索树BST的性质"></a>3.1  二叉搜索树BST的性质</h3><p>二叉搜索树（二叉查找树）：比父节点小的key都出现在左子树，比父节点大的key都出现在右子树，即恒有<code>root.left.val&lt;root.val&lt;root.right.val</code>。</p><ul><li>中序遍历BST，得到的是升序数组。中序倒序遍历，会得到一个降序数组</li><li><p>最小值一定在根节点的最左下角（中序遍历的起点），最大值一定在根节点的最右下角（中序遍历的终点）</p><p>下图是 按照<code>[70,31,93,94,14,23,73]</code>的顺序插入生成的BST。注意：插入顺序不同，生成的BST也不同。<img src="https://img-blog.csdnimg.cn/3e34c9db57d44eeba8732df7f9f96e83.png#pic_center =500x" alt="在这里插入图片描述"></p></li></ul><h3 id="3-2-二叉搜索树的实现"><a href="#3-2-二叉搜索树的实现" class="headerlink" title="3.2 二叉搜索树的实现"></a>3.2 二叉搜索树的实现</h3><p>二叉搜索树可以通过构造<code>TreeNode</code>和<code>BinarySearchTree</code>两个类来实现。</p><h4 id="3-2-1-TreeNode类"><a href="#3-2-1-TreeNode类" class="headerlink" title="3.2.1 TreeNode类"></a>3.2.1 <code>TreeNode</code>类</h4><ul><li><code>__iter__</code>：python中使用<code>__iter__</code>方法来实现for循环的迭代。在TreeNode类中重写iter迭代器之后，就可以使用for循环来枚举二叉树中所有的key。<ul><li>代码中使用中序遍历的方法实现二叉树的遍历迭代</li><li>迭代器当中，必须要使用<code>yield</code>语句，每次调用<code>yield</code>都返回一次迭代之后的返回值（elem）。</li><li>在<code>BinarySearchTree</code>中，直接调用<code>TreeNode</code>的<code>__iter__</code>方法进行迭代。</li></ul></li><li><code>findSuccessor</code>：找到当前节点的后继节点（当前节点的右子树中最小的节点），此方法在<code>BinarySearchTree</code>类的节点删除方法中会调用到。</li><li><code>spliceOut</code>：将当前节点摘除（将其子节点直接指向其父节点，跳过当前节点并返回）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mytree=BinarySearchTree()</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> mytree:</span><br><span class="line"><span class="built_in">print</span>(key,value)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,key,val,left=<span class="literal">None</span>,right=<span class="literal">None</span>,parent=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.key = key   <span class="comment"># 键值</span></span><br><span class="line">        self.payload = val   <span class="comment"># 数据项</span></span><br><span class="line">        self.leftChild = left   <span class="comment"># 左子节点</span></span><br><span class="line">        self.rightChild = right   <span class="comment"># 右子节点</span></span><br><span class="line">        self.parent = parent   <span class="comment"># 父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasLeftChild</span>(<span class="params">self</span>):</span>    <span class="comment"># 是否含有左子节点</span></span><br><span class="line">        <span class="keyword">return</span> self.leftChild</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasRightChild</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.rightChild</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isLeftChild</span>(<span class="params">self</span>):</span><span class="comment"># 是否是左子节点</span></span><br><span class="line">        <span class="keyword">return</span> self.parent <span class="keyword">and</span> self.parent.leftChild == self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isRightChild</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.parent <span class="keyword">and</span> self.parent.rightChild == self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isRoot</span>(<span class="params">self</span>):</span><span class="comment"># 是否是根节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isLeaf</span>(<span class="params">self</span>):</span><span class="comment"># 是否是叶节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (self.rightChild <span class="keyword">or</span> self.leftChild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasAnyChildren</span>(<span class="params">self</span>):</span><span class="comment"># 是否有左子节点</span></span><br><span class="line">        <span class="keyword">return</span> self.rightChild <span class="keyword">or</span> self.leftChild</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasBothChildren</span>(<span class="params">self</span>):</span><span class="comment"># 是否有右子节点</span></span><br><span class="line">        <span class="keyword">return</span> self.rightChild <span class="keyword">and</span> self.leftChild</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceNodeData</span>(<span class="params">self,key,value,lc,rc</span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.payload = value</span><br><span class="line">        self.leftChild = lc</span><br><span class="line">        self.rightChild = rc</span><br><span class="line">        <span class="keyword">if</span> self.hasLeftChild():</span><br><span class="line">            self.leftChild.parent = self</span><br><span class="line">        <span class="keyword">if</span> self.hasRightChild():</span><br><span class="line">            self.rightChild.parent = self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSuccessor</span>(<span class="params">self</span>):</span> <span class="comment"># 寻找当前节点的后继节点</span></span><br><span class="line">        succ = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.hasRightChild():             </span><br><span class="line">            succ = self.rightChild.findMin() <span class="comment"># 后继节点是当前节点右子树中最小的节点</span></span><br><span class="line">        <span class="comment"># 下面这段代码是当前节点没有右子树的情况，这样后继节点就要到其它地方去寻找</span></span><br><span class="line">        <span class="comment"># BinarySearchTree中，被删节点有两个子节点时才需要找其后继节点，所以这段代码不会用到</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">if</span> self.parent:</span><br><span class="line">                <span class="keyword">if</span> self.isLeftChild():</span><br><span class="line">                    succ = self.parent</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.parent.rightChild = <span class="literal">None</span></span><br><span class="line">                    succ = self.parent.findSuccessor()</span><br><span class="line">                    self.parent.rightChild = self</span><br><span class="line">        <span class="keyword">return</span> succ</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current.hasLeftChild():  <span class="comment"># 当前子树的最小节点，沿着当前节点一直往左找就行</span></span><br><span class="line">            current = current.leftChild</span><br><span class="line">        <span class="keyword">return</span> current</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spliceOut</span>(<span class="params">self</span>):</span>   <span class="comment"># 摘除后继节点</span></span><br><span class="line">        <span class="keyword">if</span> self.isLeaf():   <span class="comment"># 如果是叶节点，直接摘除</span></span><br><span class="line">            <span class="keyword">if</span> self.isLeftChild():    </span><br><span class="line">                self.parent.leftChild = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.parent.rightChild = <span class="literal">None</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">elif</span> self.hasAnyChildren():   <span class="comment"># 这一段不会用到，因为后继节点是被删节点右子树的左下角，不可能还有左子树</span></span><br><span class="line">            <span class="keyword">if</span> self.hasLeftChild():</span><br><span class="line">                <span class="keyword">if</span> self.isLeftChild():</span><br><span class="line">                    self.parent.leftChild = self.leftChild</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.parent.rightChild = self.leftChild</span><br><span class="line">                self.leftChild.parent = self.parent</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 后继节点可能还有右子节点</span></span><br><span class="line">                <span class="keyword">if</span> self.isLeftChild():</span><br><span class="line">                    self.parent.leftChild = self.rightChild  <span class="comment"># 摘出带右子节点的后继节点</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 这个也不会用到，后继节点只可能是左子节点</span></span><br><span class="line">                    self.parent.rightChild = self.rightChild</span><br><span class="line">                self.rightChild.parent = self.parent</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span>         <span class="comment"># 以中序遍历的方式迭代BST中的每一个key</span></span><br><span class="line">        <span class="keyword">if</span> self:</span><br><span class="line">            <span class="keyword">if</span> self.hasLeftChild():</span><br><span class="line">                <span class="keyword">for</span> elem <span class="keyword">in</span> self.leftChild:</span><br><span class="line">                    <span class="keyword">yield</span> elem</span><br><span class="line">        <span class="keyword">yield</span> self.key</span><br><span class="line">        <span class="keyword">if</span> self.hasRightChild():</span><br><span class="line">            <span class="keyword">for</span> elem <span class="keyword">in</span> self.rightChild:</span><br><span class="line">                <span class="keyword">yield</span> elem</span><br></pre></td></tr></table></figure><h4 id="3-2-2-BinarySearchTree类"><a href="#3-2-2-BinarySearchTree类" class="headerlink" title="3.2.2  BinarySearchTree类"></a>3.2.2  <code>BinarySearchTree</code>类</h4><ul><li><code>put(key,val)</code>方法：插入key构造BST。<ul><li>首先看BST是否为空，如果一个节点都没有，那么key成为根节点root；</li><li>如果不是空树，就调用一个递归函数<code>_put(key, val, root)</code>来放置key。</li></ul></li><li><code>_put(key,val,self.root)</code>的流程：<ul><li>如果key比当前节点currentNode小，那么递归_put到左子树。但如果没有左子树，那么key就成为左子节点；</li><li>如果key比currentNode大，那么递归_put到右子树，但如果没有右子树，那么key就成为右子节点。</li><li>下图显示在一个BST中插入新的节点19，每次插入操作都是从根节点开始进行比较，灰色表示当前节点。<br><img src="https://img-blog.csdnimg.cn/5f6c9c30e22742d18fa3257cf6f16e1c.png#pic_center =600x" alt="在这里插入图片描述"></li></ul></li><li><code>__setitem__</code>：python内置的索引赋值特殊方法，重写之后可以直接进行索引赋值，例如：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, k, v</span>):</span> </span><br><span class="line">self.put(k,v)            <span class="comment"># 调用put方法重写内置的索引赋值函数</span></span><br><span class="line">        </span><br><span class="line">mytree=BinarySearchTree()</span><br><span class="line">mytree[<span class="number">3</span>]=<span class="string">&#x27;red&#x27;</span>              <span class="comment"># 插入节点3，值为&#x27;red&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>__getitem__</code>：python内置函数，用于索引取值，例如输入mytree[3]，可以返回’red’。</li><li><code>__contains__</code>：python内置函数，用于调用<code>in</code>函数。<code>in</code>函数对应<code>__contains__</code>方法。</li><li><p><code>get</code>方法：在树中找到key所在的节点并返回它的值。</p><ul><li>如果是空树，直接返回None</li><li>不是空树，递归地调用<code>self._get</code>找到节点key。</li></ul></li><li><p><code>delete</code>方法：删除节点。</p><ul><li>用<code>_get</code>方法找到要删除的节点，然后调用remove来删除，找不到则提示错误。</li><li>从BST中remove一个节点，还要求仍然保持BST的性质，分以下三种情况：这个节点没有子节点；这个节点有1个子节点；这个节点有2个子节点。<ol><li>当前节点是叶节点，则直接删除。判断其是叶节点之后，在判断其是左子节点还是右子节点，然后将其父节点的左子节点或者右子节点指向None就行。<br><img src="https://img-blog.csdnimg.cn/fc96d997ad2a41859ed4d03045e8fb7b.png" alt="在这里插入图片描述"></li></ol></li></ul></li></ul><pre><code>    2. 被删节点有1个子节点，解决方法：将这个唯一的子节点上移，替换掉被删节点的位置。实际中要分好几种情况。</code></pre><p><img src="https://img-blog.csdnimg.cn/fc3f87d423e84521b972bca49806188a.png#pic_center =600x" alt="在这里插入图片描述"></p><pre><code>    3. 被删节点有2个子节点。这时无法简单地将某个子节点上移替换被删节点。但可以找到另一个合适地节点来替换被删节点，这个合适节点就是被删节点的下一个key值节点，即**被删节点右子树中最小的那个**，称为**后继节点**。（当前节点右子树中最左下角叶节点）</code></pre><p><img src="https://img-blog.csdnimg.cn/32d626db9b39405fa40b674aba27fe19.png#pic_center =600x" alt="在这里插入图片描述"></p><ul><li><code>__delitem__</code>：这是del函数的调用方法，重写之后，可以使用del语句删除节点。</li></ul><p>代码实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.root.__iter__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,key,val</span>):</span></span><br><span class="line">    <span class="comment"># 不为空，则递归调用 self._put函数，其参数self.root表示以哪个为作为根节点进行插入</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            self._put(key,val,self.root)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.root = TreeNode(key,val)   <span class="comment"># 如果树为空，则将其直接作为根节点</span></span><br><span class="line">        self.size = self.size + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_put</span>(<span class="params">self,key,val,currentNode</span>):</span>    </span><br><span class="line">    <span class="comment"># 如果key比当前节点小，递归地放到其左子树，如果没有左子树，就直接作为其左子节点  </span></span><br><span class="line">        <span class="keyword">if</span> key &lt; currentNode.key:</span><br><span class="line">            <span class="keyword">if</span> currentNode.hasLeftChild():</span><br><span class="line">                self._put(key,val,currentNode.leftChild)  <span class="comment"># 递归插入左子树</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                currentNode.leftChild = TreeNode(key,val,parent=currentNode)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> currentNode.hasRightChild():</span><br><span class="line">                self._put(key,val,currentNode.rightChild)  <span class="comment"># 递归插入右子树</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                currentNode.rightChild = TreeNode(key,val,parent=currentNode)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, k, v</span>):</span> <span class="comment"># 重写索引赋值方法</span></span><br><span class="line">        self.put(k,v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            res = self._get(key,self.root)  <span class="comment"># 递归地查找key</span></span><br><span class="line">            <span class="keyword">if</span> res:</span><br><span class="line">                <span class="keyword">return</span> res.payload  <span class="comment"># 找到节点则返回值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span><span class="comment"># 没找到返回None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span><span class="comment"># 空树直接返回None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get</span>(<span class="params">self,key,currentNode</span>):</span></span><br><span class="line"><span class="comment">#递归到最后都没找到，返回None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> currentNode:                </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> currentNode.key == key:        <span class="comment"># 如果要找的key正好是当前节点，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> currentNode</span><br><span class="line">        <span class="keyword">elif</span> key &lt; currentNode.key:<span class="comment"># 如果key小于当前节点的key，就递归地到其左子树中去找</span></span><br><span class="line">            <span class="keyword">return</span> self._get(key,currentNode.leftChild)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self._get(key,currentNode.rightChild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, key</span>):</span>             <span class="comment"># python内置的索引取值函数</span></span><br><span class="line">        <span class="keyword">return</span> self.get(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, key</span>):</span><span class="comment"># python内置的in函数</span></span><br><span class="line">        <span class="keyword">if</span> self._get(key,self.root):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.size &gt; <span class="number">1</span>:      <span class="comment"># 判断是否只剩下根节点</span></span><br><span class="line">            nodeToRemove = self._get(key, self.root)   <span class="comment"># 查找待删除节点</span></span><br><span class="line">            <span class="keyword">if</span> nodeToRemove:   <span class="comment"># 如果找到了，就执行删除操作</span></span><br><span class="line">                self.remove(nodeToRemove)</span><br><span class="line">                self.size = self.size - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Error, key not in tree&#x27;</span>)</span><br><span class="line">        <span class="comment"># 如果只剩下根节点，且就是要删的key，就将根节点的引用指向None</span></span><br><span class="line">        <span class="keyword">elif</span> self.size == <span class="number">1</span> <span class="keyword">and</span> self.root.key == key: </span><br><span class="line">            self.root = <span class="literal">None</span></span><br><span class="line">            self.size = self.size - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">&#x27;Error, key not in tree&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self,key</span>):</span></span><br><span class="line">        self.delete(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self,currentNode</span>):</span></span><br><span class="line">        <span class="keyword">if</span> currentNode.isLeaf(): <span class="comment"># 被删节点是叶节点</span></span><br><span class="line">            <span class="keyword">if</span> currentNode == currentNode.parent.leftChild:</span><br><span class="line">                currentNode.parent.leftChild = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                currentNode.parent.rightChild = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> currentNode.hasBothChildren(): <span class="comment"># 被删节点有两个子节点</span></span><br><span class="line">            succ = currentNode.findSuccessor()<span class="comment"># 找到被删节点的后继节点</span></span><br><span class="line">            succ.spliceOut()<span class="comment"># 摘出后继节点</span></span><br><span class="line">            currentNode.key = succ.key<span class="comment"># 将当前节点的key替换为后继节点的key</span></span><br><span class="line">            currentNode.payload = succ.payload</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 被删节点只有一个子节点</span></span><br><span class="line">            <span class="keyword">if</span> currentNode.hasLeftChild():<span class="comment"># 被删节点只有左子节点</span></span><br><span class="line">                <span class="keyword">if</span> currentNode.isLeftChild():  <span class="comment"># 被删的也是左子节点</span></span><br><span class="line">                    currentNode.leftChild.parent = currentNode.parent</span><br><span class="line">                    currentNode.parent.leftChild = currentNode.leftChild</span><br><span class="line">                <span class="keyword">elif</span> currentNode.isRightChild():   <span class="comment"># 被删的是右子节点</span></span><br><span class="line">                    currentNode.leftChild.parent = currentNode.parent</span><br><span class="line">                    currentNode.parent.rightChild = currentNode.leftChild</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 根节点删除</span></span><br><span class="line">                    currentNode.replaceNodeData(currentNode.leftChild.key,</span><br><span class="line">                                       currentNode.leftChild.payload,</span><br><span class="line">                                       currentNode.leftChild.leftChild,</span><br><span class="line">                                       currentNode.leftChild.rightChild)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> currentNode.isLeftChild():  <span class="comment"># 左子节点删除</span></span><br><span class="line">                    currentNode.rightChild.parent = currentNode.parent</span><br><span class="line">                    currentNode.parent.leftChild = currentNode.rightChild</span><br><span class="line">                <span class="keyword">elif</span> currentNode.isRightChild():  <span class="comment"># 右子节点删除</span></span><br><span class="line">                    currentNode.rightChild.parent = currentNode.parent</span><br><span class="line">                    currentNode.parent.rightChild = currentNode.rightChild</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 根节点删除</span></span><br><span class="line">                    currentNode.replaceNodeData(currentNode.rightChild.key,</span><br><span class="line">                                       currentNode.rightChild.payload,</span><br><span class="line">                                       currentNode.rightChild.leftChild,</span><br><span class="line">                                       currentNode.rightChild.rightChild)</span><br></pre></td></tr></table></figure><h3 id="3-3-平衡二叉搜索AVL树"><a href="#3-3-平衡二叉搜索AVL树" class="headerlink" title="3.3 平衡二叉搜索AVL树"></a>3.3 平衡二叉搜索AVL树</h3><p>二叉搜索树复杂度分析（以 put 为例）</p><ul><li><code>put</code>操作的性能，决定因素在于二叉搜索树的高度（最大层次），而其高度又受数据项 key 插入顺序的影响。<ul><li>如果 key是随机分布的话，那么大于和小于根节点 key 的键值大致相等， BST 的高度就是 $log_{2}N$ ( N是节点的个数），这样的树就是平衡树。</li><li>当key是升序或降序排列时，每次都插入到当前节点的右子树/左子树。此时二叉树类似一个单链表，其put 方法性能最差，为$O (ln)$。<br><img src="https://img-blog.csdnimg.cn/9282a85f284b4d54a0d2cf5d6c7be042.png#pic_center =500x" alt="在这里插入图片描述"><br>如何改进BST，使其不受key列表顺序的影响？由此就引入了平衡二叉树（AVL树，发明者名字的缩写）。<h4 id="3-3-1-平衡二叉搜索树的定义"><a href="#3-3-1-平衡二叉搜索树的定义" class="headerlink" title="3.3.1 平衡二叉搜索树的定义"></a>3.3.1 平衡二叉搜索树的定义</h4></li></ul></li></ul><p>平衡二叉树能在key插入时一直保持平衡。其代码结构和BST类似，只是生成和维护的过程不一样。</p><ul><li>平衡二叉树的实现中，需要对每个节点跟踪<strong>平衡因子</strong> <code>balance factor</code>。</li><li>平衡因子是根据节点的左右子树的高度来定义的，确切地说，是左右子树的高度差：<code>balanceFactor = height(leftSubTree) - height(rightSubTree)</code>。如果平衡因子大于0，称为左重<code>left-heavy</code>，小于零称为右重<code>right-heavy</code>，平衡因子<code>balanceFactor=0</code>，则称作平衡。</li><li>如果一个二叉搜素树中每个节点的平衡因子都在-1, 0, 1之间，则把这个二叉搜索树称为<strong>平衡树</strong>。</li></ul><p>在平衡树操作过程中，有节点的平衡因子超出此范围，则需要一个重新平衡的过程。<br><img src="https://img-blog.csdnimg.cn/7fab5a19d692497cbce105be1f79281e.png#pic_center =400x" alt="在这里插入图片描述"></p><h4 id="3-3-2-平衡二叉树最差情性能："><a href="#3-3-2-平衡二叉树最差情性能：" class="headerlink" title="3.3.2 平衡二叉树最差情性能："></a>3.3.2 平衡二叉树最差情性能：</h4><p>&#8195;&#8195;AVL树要求平衡因子为1或者-1。下图为平衡因子为1的<strong>左重AVL树</strong>，树的高度从1开始，来看看问题规模(总节点数N)和比对次数(树的高度h)之间的关系如何。<br> <img src="https://img-blog.csdnimg.cn/7677f62458d148eb898d34921421e4fb.png" alt="在这里插入图片描述"></p><p>观察上图h = 1~4时，总节点数N的变化：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h = <span class="number">1</span>, N = <span class="number">1</span></span><br><span class="line">h = <span class="number">2</span>, N = <span class="number">2</span> = <span class="number">1</span>+ <span class="number">1</span></span><br><span class="line">h = <span class="number">3</span>, N = <span class="number">4</span> = <span class="number">1</span> + <span class="number">1</span> + <span class="number">2</span></span><br><span class="line">h = <span class="number">4</span>, N = <span class="number">7</span> = <span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span></span><br></pre></td></tr></table></figure><p>可得通式：$N<em>h = 1 + N</em>{h-1} + N_{h-2}$ ，观察这个通式，很接近斐波那契。<br>  <img src="https://img-blog.csdnimg.cn/109bd38069dd4304abbfd3545b1ac6f2.png#pic_center =400x" alt="在这里插入图片描述"></p><h4 id="3-3-3-保持AVL树的平衡性质"><a href="#3-3-3-保持AVL树的平衡性质" class="headerlink" title="3.3.3 保持AVL树的平衡性质"></a>3.3.3 保持AVL树的平衡性质</h4><ul><li>首先，作为BST，新key必定以叶节点形式插入到AVL树中。</li><li>叶节点的平衡因子是0，其本身无需重新平衡，但会影响其父节点的平衡因子：作为左子节点插入，则父节点平衡因子会增加1；作为右子节点插入，则父节点平衡因子会减少1.</li><li>这种影响可能随着其父节点到根节点的路径一直传递上去，直到：传递到根节点为止；或者某个父节点的平衡因子被调整到0，不再影响上层节点的平衡因子为止。<br><img src="https://img-blog.csdnimg.cn/9dd42936ed0d4ddd91bcf37314f47150.png" alt="在这里插入图片描述"><blockquote><p>AVL树相比BST只需要调整put方法就行。当插入节点作为左子节点或者右子节点时有个调整平衡因子的过程</p><ul><li>第一个if：只要节点的平衡因子不在-1到1就要再次调用自己来平衡。<ul><li>如果插入节点是父节点的左子节点就+1，是右子节点就-1</li></ul></li><li>最后一个if：如果父节点调整后还不为0就继续往上调整。</li></ul></blockquote></li></ul><p><img src="https://img-blog.csdnimg.cn/1e2e1f28ac59428fb32c3abc44785ea9.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/ccdaac685f7d47e09c155ceecfce3fab.png" alt="在这里插入图片描述"></p><h4 id="3-3-4-rebalance重新平衡法：左右旋转"><a href="#3-3-4-rebalance重新平衡法：左右旋转" class="headerlink" title="3.3.4 rebalance重新平衡法：左右旋转"></a>3.3.4 rebalance重新平衡法：左右旋转</h4><ul><li><p>主要手段：将不平衡的子树进行旋转<code>rotation</code>。视左重或者右重进行不同方向的旋转，同时更新相关父节点引用，更新旋转后被影响节点的平衡因子。<br><img src="https://img-blog.csdnimg.cn/615ac171d27944359ba06c159fc3e605.png" alt="在这里插入图片描述"></p></li><li><p>如上图，是一个右重子树A的左旋转(并保持BST性质)。将右子节点B提升为子树的根，将旧根节点A作为新根节点B的左子节点；如果新根节点B原来有左子节点，则将此节点设置为A的右子节点(A的右子节点一定有空)。</p></li><li>更复杂的情况：如下图左重的子树右旋转。旋转后，新根节点将旧根节点作为右子节点，但是新根节点原来已有右子节点，需要将原有的右子节点重新定位；原有的右子节点D改到旧根节点E的左子节点，同样，E的左子节点在旋转后一定有空。<br><img src="https://img-blog.csdnimg.cn/04c3b8894a2b4bcf9dd3f4ded4258703.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/3d137ae5805147a88e413e84eb2d4c20.png" alt="在这里插入图片描述"></li></ul><h4 id="3-3-5-左旋转对平衡因子的影响："><a href="#3-3-5-左旋转对平衡因子的影响：" class="headerlink" title="3.3.5 左旋转对平衡因子的影响："></a>3.3.5 左旋转对平衡因子的影响：</h4><p><img src="https://img-blog.csdnimg.cn/37c46e8da58c44db8103a085c56e0038.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ee2deac0fe80468e8974e3cd6e3cf3ed.png" alt="在这里插入图片描述"></p><p>下图右重子树，单纯的左旋转无法实现平衡，左旋转后变成左重了，左重再右旋转，还回到右重。<br> <img src="https://img-blog.csdnimg.cn/d8f8e829d5464b1b844f17c7891bd12e.png" alt="在这里插入图片描述"></p><p>&#8195;&#8195;所以，在左旋转之前检查右子节点的因子，如果右子节点左重的话，先对它进行右旋转，再实施原来的左旋转；同样，在右旋转之前检查左子节点的因子，如果左子节点右重的话，先对它进行左旋转，再实施原来的右旋转。<br> <img src="https://img-blog.csdnimg.cn/137eda51818440f2ba7de30e055ab36a.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/fdb63027e88042e1999ee19a4de570dd.png" alt="在这里插入图片描述"></p><p>AVL树算法代价：</p><ul><li>经过复杂的put方法，AVL树始终维持平衡，get方法也始终保持$O(logn)$高性能。</li><li>将AVL树的put方法分为两个部分：<ul><li>需要插入的新节点是叶节点，更新其所有父节点和祖先节点的代价最多为$O(logn)$</li><li>如果插入的新节点引发了不平衡，重新平衡最多需要两次旋转，但旋转的代价与问题规模无关，旋转代价是常数$O(1)$。所以整个put方法的时间复杂度还是$O(logn)$。<h3 id="3-4-ADT-Map实现方法小结"><a href="#3-4-ADT-Map实现方法小结" class="headerlink" title="3.4 ADT Map实现方法小结"></a>3.4 ADT Map实现方法小结</h3>推荐使用散列表和AVL树。<br><img src="https://img-blog.csdnimg.cn/0bc4a12ca47a45b2a1253dfe335f6a43.png" alt="在这里插入图片描述"></li></ul></li><li><p>有序表插入需要按顺序找到位置，所以是$O(n)$，查找时可以使用二分查找，所以是$O(logn)$，in和get一样的二分查找。</p></li><li><p>散列表：根据散列函数计算每个值应该呆的地方，一般情况下是$O(1)$的。因为散列冲突，最坏情况退化到$O(n)$</p></li><li><p>二叉搜素树：各种操作一般都是$O(logn)$，但是随着插入顺序的而不同，极端情况会退化到线性表$O(n)$</p></li></ul><p>当对内存和计算时间要求不高的时候可以用散列表，其次是AVL数。python内置的字典就是散列表实现的。</p><h2 id="四、-二叉搜索树题目"><a href="#四、-二叉搜索树题目" class="headerlink" title="四、 二叉搜索树题目"></a>四、 二叉搜索树题目</h2><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0098</td><td style="text-align:left"><a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0098.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md">Python</a></td><td style="text-align:left">树、深度优先搜索、递归</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0173</td><td style="text-align:left"><a href="https://leetcode.cn/problems/binary-search-tree-iterator/">二叉搜索树迭代器</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0173.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8.md">Python</a></td><td style="text-align:left">栈、树、设计</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0700</td><td style="text-align:left"><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0700.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.md">Python</a></td><td style="text-align:left">树</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0701</td><td style="text-align:left"><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0701.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.md">Python</a></td><td style="text-align:left">树</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0450</td><td style="text-align:left"><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0450.%20%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.md">Python</a></td><td style="text-align:left">树</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0703</td><td style="text-align:left"><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">数据流中的第 K 大元素</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0703.%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC%20K%20%E5%A4%A7%E5%85%83%E7%B4%A0.md">Python</a></td><td style="text-align:left">树、设计、二叉搜索树、二叉树、数据流、堆（优先队列）</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">剑指 Offer 54</td><td style="text-align:left"><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">二叉搜索树的第k大节点</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/%E5%89%91%E6%8C%87%20Offer%2054.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9.md">Python</a></td><td style="text-align:left">树、深度优先搜索、二叉搜索树、二叉树</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0230</td><td style="text-align:left"><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">二叉搜索树中第K小的元素</a></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0235</td><td style="text-align:left"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0235.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.md">Python</a></td><td style="text-align:left">树</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0426</td><td style="text-align:left"><a href="https://leetcode.cn/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/">将二叉搜索树转化为排序的双向链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0426.%20%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">栈、树、深度优先搜索、二叉搜索树、链表、二叉树、双向链表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0108</td><td style="text-align:left"><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md">Python</a></td><td style="text-align:left">树、深度优先搜索</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0110</td><td style="text-align:left"><a href="https://leetcode.cn/problems/balanced-binary-tree/">平衡二叉树</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.md">Python</a></td><td style="text-align:left">树、深度优先搜索、递归</td><td style="text-align:left">简单</td></tr></tbody></table></div><h3 id="4-1-验证二叉搜索树"><a href="#4-1-验证二叉搜索树" class="headerlink" title="4.1 验证二叉搜索树"></a>4.1 验证二叉搜索树</h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><ol><li><strong>思路一：中序遍历，看结果是否是升序</strong><br>根据二叉搜索树的性质可知，中序遍历二叉树，结果一定是升序。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ans=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.ans=[]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> Fasle</span><br><span class="line">        ans=self.inorderTraversal(root)        </span><br><span class="line">        <span class="keyword">return</span> ans==<span class="built_in">sorted</span>(ans) <span class="keyword">if</span> <span class="built_in">len</span>(ans)==<span class="built_in">len</span>(<span class="built_in">set</span>(ans)) <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 中序遍历，类似中缀表达式，是左中右的顺序</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.inorderTraversal(root.left)</span><br><span class="line">            self.ans.append(root.val)</span><br><span class="line">            self.inorderTraversal(root.right)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure><ol><li><strong>思路二：递归</strong></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node, lower = <span class="built_in">float</span>(<span class="params"><span class="string">&#x27;-inf&#x27;</span></span>), upper = <span class="built_in">float</span>(<span class="params"><span class="string">&#x27;inf&#x27;</span></span>)</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            val = node.val</span><br><span class="line">            <span class="keyword">if</span> val &lt;= lower <span class="keyword">or</span> val &gt;= upper:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> helper(node.right, val, upper):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> helper(node.left, lower, val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(root)</span><br></pre></td></tr></table></figure><h3 id="4-2-二叉搜索树迭代器"><a href="#4-2-二叉搜索树迭代器" class="headerlink" title="4.2 二叉搜索树迭代器"></a>4.2 二叉搜索树迭代器</h3><p>实现一个二叉搜索树的迭代器 BSTIterator。表示一个按中序遍历二叉搜索树（BST）的迭代器：</p><ul><li><code>def __init__(self, root: TreeNode):</code>：初始化 BSTIterator 类的一个对象，会给出二叉搜索树的根节点。</li><li><code>def hasNext(self) -&gt; bool:</code>：如果向右指针遍历存在数字，则返回 True，否则返回 False。</li><li><code>def next(self) -&gt; int:</code>：将指针向右移动，返回指针处的数字。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;BSTIterator&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>]</span><br><span class="line">[[[<span class="number">7</span>, <span class="number">3</span>, <span class="number">15</span>, null, null, <span class="number">9</span>, <span class="number">20</span>]], [], [], [], [], [], [], [], [], []]</span><br><span class="line">输出</span><br><span class="line">[null, <span class="number">3</span>, <span class="number">7</span>, true, <span class="number">9</span>, true, <span class="number">15</span>, true, <span class="number">20</span>, false]</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d9f359cf022b48428d27e0139e526942.png" alt="在这里插入图片描述"></p><ol><li><strong>思路一：列表存储</strong><br>初始化时就逆序遍历二叉搜索树，将结果添加到列表中。当执行next方法时，直接pop列表的最后一个元素</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack=[]   </span><br><span class="line">        self.inorder(root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 中序遍历，类似中缀表达式，是左中右的顺序</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.inorder(root.right)</span><br><span class="line">            self.stack.append(root.val)</span><br><span class="line">            self.inorder(root.left)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.stack)</span><br><span class="line">       </span><br><span class="line"><span class="comment"># Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = BSTIterator(root)</span></span><br><span class="line"><span class="comment"># param_1 = obj.next()</span></span><br><span class="line"><span class="comment"># param_2 = obj.hasNext()</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>思路二：迭代</strong><br>中序遍历的顺序是：左、根、右。我们使用一个栈来保存节点，以便于迭代的时候取出对应节点。</p><ul><li>初始化的时候，遍历当前节点的左子树，将其路径上的节点存储到栈中。</li><li>调用 <code>next</code> 方法的时候，从栈顶取出节点<ul><li>因为之前已经将路径上的左子树全部存入了栈中，所以此时该节点的左子树为空</li><li>取出该节点的右子树，再将右子树的左子树进行递归遍历，并将其路径上的节点存储到栈中。</li></ul></li><li>调用 <code>hasNext</code> 的方法的时候，直接判断栈中是否有值即可。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root: TreeNode</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.in_order(root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_order</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            self.stack.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        node = self.stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            self.in_order(node.right)</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.stack)</span><br></pre></td></tr></table></figure><h3 id="4-3-二叉搜索树中的搜索、插入和删除"><a href="#4-3-二叉搜索树中的搜索、插入和删除" class="headerlink" title="4.3 二叉搜索树中的搜索、插入和删除"></a>4.3 二叉搜索树中的搜索、插入和删除</h3><blockquote><ul><li><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">0070 二叉搜索树中的搜索</a> </li><li><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">0701 二叉搜索树中的插入操作</a> </li><li><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">0450 删除二叉搜索树中的节点</a><h4 id="4-3-1-二叉搜索树中的搜索"><a href="#4-3-1-二叉搜索树中的搜索" class="headerlink" title="4.3.1 二叉搜索树中的搜索"></a>4.3.1 二叉搜索树中的搜索</h4>&#8195;&#8195;给定二叉搜索树（BST）的根节点 root 和一个整数值 val。找到值为val的节点并返回以这个节点为根的子树。 如果节点不存在，则返回 null 。</li></ul></blockquote></li></ul></li></ol><p>示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>], val = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">if</span> val&lt;root.val:</span><br><span class="line">                <span class="keyword">return</span> self.searchBST(root.left,val)</span><br><span class="line">            <span class="keyword">elif</span> val&gt;root.val:</span><br><span class="line">                <span class="keyword">return</span> self.searchBST(root.right,val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></p><h4 id="4-3-2-二叉搜索树中的插入操作"><a href="#4-3-2-二叉搜索树中的插入操作" class="headerlink" title="4.3.2 二叉搜索树中的插入操作"></a>4.3.2 二叉搜索树中的插入操作</h4><p>&#8195;&#8195;给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 </p><ul><li>输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</li><li>可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</li><li>示例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>], val = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/83831335a6db4a00a522a65220c139a4.png#pic_center" alt="在这里插入图片描述"><br>结果也可以是：<br><img src="https://img-blog.csdnimg.cn/0c0c43432ea948e2865a977779896ee2.png#pic_center =300x" alt="在这里插入图片描述"></li></ul><p>解题思路：<br>在二叉搜索树中，对任意节点都有：<code>root.left.val &lt; root.val&lt;root.right.val</code>。所以需要根据 <code>val</code> 和当前节点的大小关系，来确定将 <code>val</code> 插入到当前节点的哪个子树上。</p><ul><li>如果key比当前节点小，递归地放到其左子树，如果没有左子树，就直接作为其左子节点</li><li>如果key比当前节点大，递归地放到其右子树，如果没有右子树，就直接作为其右子节点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            root=TreeNode(val)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> val&gt;root.val:</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    self.insertIntoBST(root.right,val) </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    root.right=TreeNode(val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> root.left:</span><br><span class="line">                    self.insertIntoBST(root.left,val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    root.left=TreeNode(val)</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>或者是：                    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       :type root: TreeNode</span></span><br><span class="line"><span class="string">       :type val: int</span></span><br><span class="line"><span class="string">       :rtype: TreeNode</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">           root=TreeNode(val)</span><br><span class="line">           <span class="keyword">return</span> root</span><br><span class="line">       <span class="keyword">else</span>:   </span><br><span class="line">   <span class="comment"># 如果val比root的值大，就递归其右子树。当当前节点没有右子节点时，插入到其右子节点</span></span><br><span class="line">       <span class="keyword">if</span> val&gt;root.val: </span><br><span class="line">           root.right=self.insertIntoBST(root.right,val) </span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           root.left=self.insertIntoBST(root.left,val)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> root        </span><br></pre></td></tr></table></figure><h4 id="4-3-3-删除二叉树中的节点"><a href="#4-3-3-删除二叉树中的节点" class="headerlink" title="4.3.3 删除二叉树中的节点"></a>4.3.3 删除二叉树中的节点</h4><p>给定一个二叉搜索树的根节点 <code>root</code>，以及一个值 <code>key</code>。要求从二叉搜索树中删除 key 对应的节点。并保证删除后的树仍是二叉搜索树。</p><ul><li>算法时间复杂度为 $0(h)$，$h$ 为树的高度。最后返回二叉搜索树的根节点。</li><li>示例;</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,null,<span class="number">7</span>], key = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,null,null,<span class="number">7</span>]</span><br><span class="line">解释：给定需要删除的节点值是 <span class="number">3</span>，所以我们首先找到 <span class="number">3</span> 这个节点，然后删除它。</span><br><span class="line">一个正确的答案是 [<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,null,null,<span class="number">7</span>], 如下图所示。</span><br><span class="line">另一个正确答案是 [<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,null,<span class="number">4</span>,null,<span class="number">7</span>]。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2f1c529699be4ab5a76cf2c9edca9cc4.png" alt="在这里插入图片描述"><br>删除分两个步骤：查找和删除。查找通过递归查找，删除的话需要考虑情况。</p><ol><li>从根节点 <code>root</code> 开始，递归遍历搜索二叉树。<ol><li>如果当前节点节点为空，返回当前节点。</li><li>如果当前节点值大于 <code>key</code>，则去左子树中搜索并删除，此时 <code>root.left</code> 也要跟着递归更新，递归完成后返回当前节点。</li><li>如果当前节点值小于 <code>key</code>，则去右子树中搜索并删除，此时 <code>root.right</code> 也要跟着递归更新，递归完成后返回当前节点。</li><li>如果当前节点值等于 <code>key</code>，则该节点就是待删除节点。<ol><li>如果当前节点的左子树为空，则使用其右子树代替当前节点位置，返回右子树。</li><li>如果当前节点的右子树为空，则使用其左子树代替当前节点位置，返回左子树。</li><li>如果当前节点的左右子树都有，则将左子树转移到右子树最左侧的叶子节点位置上，相当于被删节点没有了左子树，然后按照没有左子树处理。</li></ol></li></ol></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root, key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 根据val的值进行递归地遍历，并更新root的左右子树</span></span><br><span class="line">        <span class="keyword">if</span> key&gt;root.val: </span><br><span class="line">            root.right=self.deleteNode(root.right,key)</span><br><span class="line">            <span class="keyword">return</span> root </span><br><span class="line">        <span class="keyword">elif</span> key&lt;root.val:</span><br><span class="line">            root.left=self.deleteNode(root.left,key)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>:            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left:       <span class="comment"># 被删除节点的左子树为空。  </span></span><br><span class="line">                <span class="keyword">return</span> root.right   <span class="comment"># 令其右子树代替被删除节点的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> root.right:    <span class="comment"># 被删除节点的右子树为空 </span></span><br><span class="line">                <span class="keyword">return</span> root.left    <span class="comment"># 令其左子树代替被删除节点的位置</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 当被删节点有两个子节点的时候，找到被删节点的后继节点，即其右子树的最左侧</span></span><br><span class="line">                cur=root.right</span><br><span class="line">                <span class="keyword">while</span> cur.left:</span><br><span class="line">                    cur=cur.left</span><br><span class="line">                <span class="comment"># 将当前节点的左子树（root.Left）挂到其后继节点左侧，当前节点就没有左子树了</span></span><br><span class="line">                cur.left=root.left </span><br><span class="line">                <span class="keyword">return</span> root.right   <span class="comment"># 使用其右子树代替当前节点位置</span></span><br></pre></td></tr></table></figure><h3 id="4-4-数据流中的第-K-大元素"><a href="#4-4-数据流中的第-K-大元素" class="headerlink" title="4.4 数据流中的第 K 大元素"></a>4.4 数据流中的第 K 大元素</h3><blockquote><p><a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">0703. 数据流中的第 K 大元素</a></p></blockquote><p>设计一个 <code>KthLargest</code> 类，用于找到数据流中第 <code>k</code> 大元素。</p><ul><li><code>KthLargest(int k, int[] nums)</code>：使用整数 k 和整数流 nums 初始化对象。</li><li><code>int add(int val)</code>：将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。      </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;KthLargest&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>]</span><br><span class="line">[[<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>]], [<span class="number">3</span>], [<span class="number">5</span>], [<span class="number">10</span>], [<span class="number">9</span>], [<span class="number">4</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">KthLargest kthLargest = new KthLargest(<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>]);</span><br><span class="line">kthLargest.add(<span class="number">3</span>);   // <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">kthLargest.add(<span class="number">5</span>);   // <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">kthLargest.add(<span class="number">10</span>);  // <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">kthLargest.add(<span class="number">9</span>);   // <span class="keyword">return</span> <span class="number">8</span></span><br><span class="line">kthLargest.add(<span class="number">4</span>);   // <span class="keyword">return</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p>思路：使用最小堆保存前K个最大的元素，堆顶就是第k大的元素</p><ul><li>建立大小为 <code>k</code> 的最小堆，将前K个最大元素压入堆中。</li><li>每次 <code>add</code> 操作时，将新元素压入堆中，如果堆中元素超出了 <code>k</code> 个，则将堆中最小元素（堆顶）移除，保证堆中元素保证不超过 <code>k</code> 个。</li><li>此时堆中最小元素（堆顶）就是整个数据流中的第 <code>k</code> 大元素。</li></ul><blockquote><ul><li>大顶堆：根节点值 ≥ 子节点值，也叫<strong>最大堆<code>max heap</code></strong>，最大key排在队首。</li><li>小顶堆：根节点值 ≤ 子节点值，也叫<strong>最小堆<code>min heap</code></strong>，最小key排在队首</li></ul><p>Python heapq库的用法介绍:</p><ul><li>heapq.heapify(list)：从列表创建最小堆</li><li>heapq._heapify_max(list)：从列表创建最大堆</li><li>heappush(heap, item)：将数据item入堆</li><li>heappop(heap)：将堆中最小元素出堆（最小的就是堆顶）</li><li>heapq.heapreplace(heap.item) ：先操作heappop(heap)，再操作heappush(heap,item)。</li><li>heapq.heappushpop(list, item)：先操作heappush(heap,item)，再操作heappop(heap)，和上一个函数相反。</li><li>heapq.merge(*iterables)：合并多个堆，例如<code>a = [2, 4, 6]，b = [1, 3, 5]，c = heapq.merge(a, b)</code></li><li>heapq.nlargest(n, iterable,[ key])：返回堆中的最大n个元素</li><li>heapq.nsmallest(n, iterable,[ key])：返回堆中最小的n个元素</li><li>heapq[0]：返回堆顶</li></ul></blockquote><p>示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = [<span class="number">10</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">7</span>, <span class="number">30</span>, <span class="number">24</span>, <span class="number">27</span>, <span class="number">45</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">36</span>, <span class="number">21</span>]</span><br><span class="line">heapq.heapify(array)</span><br><span class="line"><span class="built_in">print</span>(heapq.nlargest(<span class="number">2</span>, array))</span><br><span class="line"><span class="built_in">print</span>(heapq.nsmallest(<span class="number">3</span>, array))</span><br><span class="line"></span><br><span class="line">[<span class="number">50</span>, <span class="number">45</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><br>代码：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.k=k</span><br><span class="line">        self.queue=nums               </span><br><span class="line">        heapq.heapify(self.queue)</span><br><span class="line">        <span class="built_in">print</span>(self.queue)</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        heapq.heappush(self.queue,val)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.queue)&gt;self.k:</span><br><span class="line">            heapq.heappop(self.queue)</span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><h3 id="4-5-二叉搜索树的第k大节点"><a href="#4-5-二叉搜索树的第k大节点" class="headerlink" title="4.5 二叉搜索树的第k大节点"></a>4.5 二叉搜索树的第k大节点</h3><blockquote><ul><li><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54 二叉搜索树的第k大节点</a> </li><li><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">0230 二叉搜索树中第K小的元素</a> </li></ul></blockquote><p>给定一棵二叉搜索树，请找出其中第 k 大的节点的值。 </p><h4 id="4-5-1-中序递归遍历"><a href="#4-5-1-中序递归遍历" class="headerlink" title="4.5.1  中序递归遍历"></a>4.5.1  中序递归遍历</h4><ol><li>存储遍历结果，取第n-k个元素的值<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,ans=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.ans=[]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans=self.inorder(root)</span><br><span class="line">        <span class="keyword">return</span> ans[<span class="built_in">len</span>(ans)-k]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self,root</span>):</span></span><br><span class="line">    <span class="comment"># 中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.inorder(root.left)</span><br><span class="line">            self.ans.append(root.val)</span><br><span class="line">            self.inorder(root.right)        </span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure></li><li>中序的倒序遍历，返回第k个结果</li></ol><ul><li>终止条件： 当节点 root 为空（越过叶节点），则直接返回；</li><li>递归右子树： 即 dfs(root.right) ；<ul><li>提前返回： 若 k=0 ，代表已找到目标节点，无需继续遍历，因此直接返回；</li><li>统计序号： 执行 k=k−1 </li><li>k=0 ，代表当前节点为第 k 大的节点，因此记录 res=root.val ；</li></ul></li><li>递归左子树： 即 dfs(root.left) ；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.k = k</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.right)</span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>: </span><br><span class="line">                self.res = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">          </span><br><span class="line">        dfs(root)     </span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><blockquote><p>直接self.k == 0时，self.res存储结果，再return self.res，会返回空。</p></blockquote><h4 id="4-5-2-迭代"><a href="#4-5-2-迭代" class="headerlink" title="4.5.2 迭代"></a>4.5.2 迭代</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root=root.right</span><br><span class="line">            root=stack.pop()         <span class="comment"># 二叉树最右下角即是最小的元素</span></span><br><span class="line">            k-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> root.val</span><br><span class="line">            root=root.left</span><br></pre></td></tr></table></figure><p>或者是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root=root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node=stack.pop()</span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> node.val</span><br><span class="line">                root=node.left</span><br></pre></td></tr></table></figure><h3 id="4-6-二叉搜索树的最近公共祖先"><a href="#4-6-二叉搜索树的最近公共祖先" class="headerlink" title="4.6 二叉搜索树的最近公共祖先"></a>4.6 二叉搜索树的最近公共祖先</h3><blockquote><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">0235. 二叉搜索树的最近公共祖先</a></p></blockquote><p>给定一个二叉搜索树的根节点 <code>root</code>，以及其中两个指定节点 <code>p</code> 和 <code>q</code>，找到该这两个指定节点的最近公共祖先。</p><p><strong>说明</strong>：</p><ul><li><strong>祖先</strong>：若节点 <code>p</code> 在节点 <code>node</code> 的左子树或右子树中，或者 <code>p == node</code>，则称 <code>node</code> 是 <code>p</code> 的祖先。</li><li><strong>最近公共祖先</strong>：对于树的两个节点 <code>p</code>、<code>q</code>，最近公共祖先表示为一个节点 <code>lca_node</code>，满足 <code>lca_node</code> 是 <code>p</code>、<code>q</code> 的祖先且 <code>lca_node</code> 的深度尽可能大（一个节点也可以是自己的祖先）。</li><li>所有节点的值都是唯一的。</li><li><code>p</code>、<code>q</code> 为不同节点且均存在于给定的二叉搜索树中。</li><li>示例：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,null,null,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">8</span></span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">8</span> 的最近公共祖先是 <span class="number">6</span>。</span><br><span class="line"></span><br><span class="line">如果是节点 <span class="number">2</span> 和节点 <span class="number">4</span> ，其最近公共祖先是 <span class="number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/2befe83db5344efa8f62fafe12f4d048.png#pic_center" alt="在这里插入图片描述"></li></ul><p>&#8195;&#8195;对于节点 <code>p</code>、节点 <code>q</code>，最近公共祖先就是从根节点分别到它们路径上的分岔点，也是路径中最后一个相同的节点，现在我们的问题就是求这个分岔点。</p><p>我们可以使用递归遍历查找二叉搜索树的最近公共祖先，具体方法如下。</p><ol><li>从根节点 <code>root</code> 开始遍历。</li><li>如果当前节点的值大于 <code>p</code>、<code>q</code> 的值，说明 <code>p</code> 和 <code>q</code>  应该在当前节点的左子树，因此将当前节点移动到它的左子节点，继续遍历；</li><li>如果当前节点的值小于 <code>p</code>、<code>q</code> 的值，说明 <code>p</code> 和 <code>q</code>  应该在当前节点的右子树，因此将当前节点移动到它的右子节点，继续遍历；</li><li>如果当前节点不满足上面两种情况，则说明 <code>p</code> 和 <code>q</code> 分别在当前节点的左右子树上，则当前节点就是分岔点，直接返回该节点即可。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        ancestor = root</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> ancestor.val &gt; p.val <span class="keyword">and</span> ancestor.val &gt; q.val:</span><br><span class="line">                ancestor = ancestor.left</span><br><span class="line">            <span class="keyword">elif</span> ancestor.val &lt; p.val <span class="keyword">and</span> ancestor.val &lt; q.val:</span><br><span class="line">                ancestor = ancestor.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ancestor</span><br></pre></td></tr></table></figure><h3 id="4-7-将有序数组转换为二叉搜索树"><a href="#4-7-将有序数组转换为二叉搜索树" class="headerlink" title="4.7 将有序数组转换为二叉搜索树"></a>4.7 将有序数组转换为二叉搜索树</h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><ul><li>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</li><li>示例：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [-<span class="number">10</span>,-<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">0</span>,-<span class="number">3</span>,<span class="number">9</span>,-<span class="number">10</span>,null,<span class="number">5</span>]</span><br><span class="line">解释：[<span class="number">0</span>,-<span class="number">10</span>,<span class="number">5</span>,null,-<span class="number">3</span>,null,<span class="number">9</span>] 也将被视为正确答案：</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/87727ee5f71e403086b380321b3bb606.png#pic_center" alt="在这里插入图片描述"><br>思路 1：递归遍历</p><p>&#8195;&#8195;直观上，如果把数组的中间元素当做根，那么数组左侧元素都小于根节点，右侧元素都大于根节点，且左右两侧元素个数相同，或最多相差 $1$ 个。那么构建的树高度差也不会超过 $1$。</p><p>&#8195;&#8195;所以猜想出：如果左右子树越平均，树就越平衡。这样我们就可以每次取中间元素作为当前的根节点，两侧的元素作为左右子树递归建树，左侧区间 $[L, mid - 1]$ 作为左子树，右侧区间 $[mid + 1, R]$ 作为右子树。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            root = TreeNode(nums[mid])</span><br><span class="line">            root.left = build(left, mid - <span class="number">1</span>)</span><br><span class="line">            root.right = build(mid + <span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="4-8-平衡二叉树"><a href="#4-8-平衡二叉树" class="headerlink" title="4.8 平衡二叉树"></a>4.8 平衡二叉树</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>高度平衡二叉树：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1<br>思路：递归遍历 </p><ul><li>先递归遍历左右子树，判断左右子树是否平衡，再判断以当前节点为根节点的左右子树是否平衡。</li><li>如果遍历的子树是平衡的，则返回它的高度，否则返回 -1。</li><li>只要出现不平衡的子树，则该二叉树一定不是平衡二叉树。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            leftHeight = height(root.left)</span><br><span class="line">            rightHeight = height(root.right)</span><br><span class="line">            <span class="keyword">if</span> leftHeight == -<span class="number">1</span> <span class="keyword">or</span> rightHeight == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;@[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;https://algo.itcharge.cn/07.Tree/01.Binary-Tree/01.Binary-Tree-Basic/&quot;&gt;《算法通关手册》&lt;/a&gt;、&lt;a href=&quot;https://www.bilibili.com/video/BV1gy4y1E7M5/?p=77&amp;amp;spm_id_from=333.999.top_right_bar_window_history.content.click&amp;amp;vd_source=21011151235423b801d3f3ae98b91e94&quot;&gt;B站《数据结构与算法B Python版》视频&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、-树&quot;&gt;&lt;a href=&quot;#一、-树&quot; class=&quot;headerlink&quot; title=&quot;一、 树&quot;&gt;&lt;/a&gt;一、 树&lt;/h2&gt;&lt;h3 id=&quot;1-1-树的定义&quot;&gt;&lt;a href=&quot;#1-1-树的定义&quot; class=&quot;headerlink&quot; title=&quot;1.1 树的定义&quot;&gt;&lt;/a&gt;1.1 树的定义&lt;/h3&gt;&lt;p&gt;&amp;#8195;&amp;#8195; &lt;strong&gt;树（Tree）&lt;/strong&gt;：由 $n \ge 0$ 个节点与节点之间的边组成的有限集合。当 $n = 0$ 时称为空树，当 $n &amp;gt; 0$ 时称为非空树。&lt;/p&gt;
&lt;p&gt;树由若干节点，以及两两连接节点的边组成，并具有以下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其中一个节点被设定为根；&lt;/li&gt;
&lt;li&gt;每个节点n(除根节点)，都恰连接一条来自节点p的边，p是n的父节点；&lt;/li&gt;
&lt;li&gt;每个节点从根开始的路径是唯一的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果每个节点最多有两个子节点，这样的树称为“二叉树”&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;之所以把这种数据结构称为「树」是因为这种数据结构看起来就像是一棵倒挂的树，也就是说数据结构中的「树」是根朝上，而叶朝下的。如下图所示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/30ddc64d6b4c4c7fa13094f6423abd7d.png&quot; alt=&quot;test&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Data Structure and Algorithms" scheme="https://zhxnlp.github.io/categories/Data-Structure-and-Algorithms/"/>
    
    
    <category term="leetcode" scheme="https://zhxnlp.github.io/tags/leetcode/"/>
    
    <category term="Dynamic Programming" scheme="https://zhxnlp.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习七：线性动态规划</title>
    <link href="https://zhxnlp.github.io/2023/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E4%B8%83%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8A%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://zhxnlp.github.io/2023/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E4%B8%83%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8A%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2023-03-31T16:00:00.000Z</published>
    <updated>2023-04-08T02:36:30.301Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>参考<a href="https://oi-wiki.org/dp/">《OI Wiki动态规划》</a>、<a href="https://algo.itcharge.cn/10.Dynamic-Programming/01.Dynamic-Programming-Basic/01.Dynamic-Programming-Basic/">《算法通关手册》动态规划篇</a></p><h2 id="一、-动态规划基础知识"><a href="#一、-动态规划基础知识" class="headerlink" title="一、 动态规划基础知识"></a>一、 动态规划基础知识</h2><h3 id="1-1-动态规划简介"><a href="#1-1-动态规划简介" class="headerlink" title="1.1 动态规划简介"></a>1.1 动态规划简介</h3></blockquote><p>&#8195;&#8195; <strong>动态规划（Dynamic Programming）</strong>：简称 <strong>DP</strong>，是一种通过把原问题分解为相对简单的子问题的方式而求解复杂问题的方法。</p><p>动态规划方法与分治算法类似，却又不同于分治算法。</p><p>「动态规划的核心思想」是：</p><ol><li>把「原问题」分解为「若干个重叠的子问题」，每个子问题的求解过程都构成一个 <strong>「阶段」</strong>。在完成一个阶段的计算之后，动态规划方法才会执行下一个阶段的计算。</li><li>在求解子问题的过程中，按照自底向上的顺序求解出「子问题的解」，把结果存储在表格中，当需要再次求解此子问题时，直接从表格中查询该子问题的解，从而避免了大量的重复计算。<span id="more"></span>&#8195;&#8195;「动态规划方法与分治算法的不同点」在于：</li></ol><ul><li>适用于动态规划求解的问题，在分解之后得到的子问题往往是相互联系的，会出现若干个重叠子问题。</li><li><font color='deeppink'>使用动态规划方法会将这些重叠子问题的解保存到表格里，供随后的计算查询使用，从而避免大量的重复计算。&lt;/font &gt;</li></ul><h3 id="1-2-动态规划的特征"><a href="#1-2-动态规划的特征" class="headerlink" title="1.2 动态规划的特征"></a>1.2 动态规划的特征</h3><p>&#8195;&#8195;能够使用动态规划方法解决的问题必须满足下面三个特征：「最优子结构性质」、「重叠子问题性质」和「无后效性」。</p><h4 id="1-2-1-最优子结构性质"><a href="#1-2-1-最优子结构性质" class="headerlink" title="1.2.1 最优子结构性质"></a>1.2.1 最优子结构性质</h4><p>「最优子结构」：指的是一个问题的最优解包含其子问题的最优解。</p><p>&#8195;&#8195;举个例子，如下图所示，原问题 $S = \lbrace a<em>1, a_2, a_3, a_4 \rbrace$，在 $a_1$ 步我们选出一个当前最优解之后，问题就转换为求解子问题 $S</em>{子问题} = \lbrace a<em>2, a_3, a_4 \rbrace$。如果原问题 $S$ 的最优解可以由「第 $a_1$ 步得到的局部最优解」和「 $S</em>{子问题}$ 的最优解」构成，则说明该问题满足最优子结构性质。</p><p>也就是说，如果原问题的最优解包含子问题的最优解，则说明该问题满足最优子结构性质。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/472489157c997fe8ea270d37c3ce2b66.png" alt=""></p><h4 id="1-2-2-重叠子问题性质"><a href="#1-2-2-重叠子问题性质" class="headerlink" title="1.2.2 重叠子问题性质"></a>1.2.2 重叠子问题性质</h4><p>&#8195;&#8195;「重叠子问题性质」：指的是在求解子问题的过程中，有大量的子问题是重复的，一个子问题会在下一阶段的决策中可能会被多次用到。如果有大量重复的子问题，那么只需要对求解一次，然后用表格将结果存储下来，以后使用时可以直接查询，不需要再次求解。</p><p>&#8195;&#8195;举个例子，比如斐波那契数列的定义是：<code>f(1) = 1, f(2) = 2, f(n) = f(n - 1) + f(n - 2)</code>。对应的递推过程如下图所示，其中 <code>f(1)</code>、<code>f(2)</code>、<code>f(3)</code>、<code>f(4)</code> 都进行了多次重复计算。而如果我们在第一次计算 <code>f(1)</code>、<code>f(2)</code>、<code>f(3)</code>、<code>f(4)</code> 时就将其结果存入表格，则再次使用时可以直接查询，从而避免重复求解相同的子问题，提升效率。</p><p><img src="https://img-blog.csdnimg.cn/51d7a80bfc4e481da9de03f77a7bee44.png" alt="在这里插入图片描述"></p><h4 id="1-2-3-无后效性"><a href="#1-2-3-无后效性" class="headerlink" title="1.2.3 无后效性"></a>1.2.3 无后效性</h4><p>&#8195;&#8195;「无后效性」：指的是子问题的解（状态值）只与之前阶段有关，而与后面阶段无关。当前阶段的若干状态值一旦确定，就不再改变，不会再受到后续阶段决策的影响。换句话说，<strong>一旦某一个子问题的求解结果确定以后，就不会再被修改</strong>。</p><p>&#8195;&#8195;其实我们也可以把动态规划方法的求解过程，看做是有向无环图的最长（最短）路的求解过程。每个状态对应有向无环图上的一个节点，决策对应图中的一条有向边。</p><p>&#8195;&#8195;如果一个问题具有「后效性」，则可能需要将其转化或者逆向求解来消除后效性，然后才可以使用动态规划方法。</p><h3 id="1-3-动态规划的基本思路"><a href="#1-3-动态规划的基本思路" class="headerlink" title="1.3 动态规划的基本思路"></a>1.3 动态规划的基本思路</h3><p>&#8195;&#8195;如下图所示，我们在使用动态规划方法解决某些最优化问题时，可以将解决问题的过程按照一定顺序（时间顺序、空间顺序或其他顺序）分解为若干个相互联系的「阶段」。然后按照顺序对每一个阶段做出「决策」，这个决策既决定了本阶段的效益，也决定了下一阶段的初始状态。依次做完每个阶段的决策之后，就得到了一个整个问题的决策序列。</p><p>&#8195;&#8195;这样就将一个原问题分解为了一系列的子问题，然后通过逐步求解从而获得最终结果。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/572208acccabdd7fa6afa9d5a7cbcf83.png" alt=""></p><p>&#8195;&#8195;这种前后关联、具有链状结构的多阶段进行决策的问题也叫做「多阶段决策问题」。通常我们使用动态规划方法来解决多阶段决策问题，其基本思路如下：</p><ol><li><strong>划分阶段</strong>：将原问题按顺序（时间顺序、空间顺序或其他顺序）分解为若干个相互联系的「阶段」。划分后的阶段⼀定是有序或可排序的，否则问题⽆法求解。<ul><li>这里的「阶段」指的是⼦问题的求解过程。每个⼦问题的求解过程都构成⼀个「阶段」，在完成前⼀阶段的求解后才会进⾏后⼀阶段的求解。</li></ul></li><li><strong>定义状态</strong>：将和子问题相关的某些变量（位置、数量、体积、空间等等）作为一个「状态」表示出来。状态的选择要满⾜⽆后效性。<ul><li>一个「状态」对应一个或多个子问题，所谓某个「状态」下的值，指的就是这个「状态」所对应的子问题的解。</li></ul></li><li><strong>状态转移</strong>：根据「上一阶段的状态」和「该状态下所能做出的决策」，推导出「下一阶段的状态」。或者说根据相邻两个阶段各个状态之间的关系，确定决策，然后推导出状态间的相互转移方式（即「状态转移方程」）。</li><li><strong>初始条件和边界条件</strong>：根据问题描述、状态定义和状态转移方程，确定初始条件和边界条件。</li><li><strong>最终结果</strong>：确定问题的求解目标，然后按照一定顺序求解每一个阶段的问题。最后根据状态转移方程的递推结果，确定最终结果。</li></ol><h3 id="1-4-动态规划基础应用"><a href="#1-4-动态规划基础应用" class="headerlink" title="1.4  动态规划基础应用"></a>1.4  动态规划基础应用</h3><p>&#8195;&#8195;动态规划相关的问题往往灵活多变，思维难度大，没有特别明显的套路，并且经常会在各类算法竞赛和面试中出现。</p><p>&#8195;&#8195;动态规划问题的关键点在于「如何状态设计」和「推导状态转移条件」，还有各种各样的「优化方法」。这类问题一定要多练习、多总结，只有接触的题型多了，才能熟练掌握动态规划思想。</p><p>&#8195;&#8195;下面来介绍几道关于动态规划的基础题目。</p><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0509</td><td style="text-align:left"><a href="https://leetcode.cn/problems/fibonacci-number/">斐波那契数</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0509.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.md">Python</a></td><td style="text-align:left">数组</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0070</td><td style="text-align:left"><a href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0070.%20%E7%88%AC%E6%A5%BC%E6%A2%AF.md">Python</a></td><td style="text-align:left">动态规划</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0062</td><td style="text-align:left"><a href="https://leetcode.cn/problems/unique-paths/">不同路径</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0062.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.md">Python</a></td><td style="text-align:left">数组、动态规划</td><td style="text-align:left">中等</td></tr></tbody></table></div><h4 id="1-4-1-斐波那契数"><a href="#1-4-1-斐波那契数" class="headerlink" title="1.4.1 斐波那契数"></a>1.4.1 斐波那契数</h4><blockquote><p><a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数 - 力扣</a></p></blockquote><p>给定一个整数 <code>n</code>。：计算第 <code>n</code> 个斐波那契数。其中，斐波那契数列的定义如下：</p><ul><li><code>f(0) = 0, f(1) = 1</code>。</li><li><code>f(n) = f(n - 1) + f(n - 2)</code>，其中 <code>n &gt; 1</code>。</li></ul><p><strong>解题思路</strong></p><ol><li>划分阶段：按照整数顺序进行阶段划分，将其划分为整数 <code>0</code> ~ <code>n</code>。</li></ol><ol><li><p>定义状态：定义状态 <code>dp[i]</code> 为：第 <code>i</code> 个斐波那契数。</p><ol><li>状态转移方程<br>根据题目中所给的斐波那契数列的定义 <code>f(n) = f(n - 1) + f(n - 2)</code>，则直接得出状态转移方程为 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>。</li></ol></li><li><p>初始条件<br>根据题目中所给的初始条件 <code>f(0) = 0, f(1) = 1</code> 确定动态规划的初始条件，即 <code>dp[0] = 0, dp[1] = 1</code>。</p></li><li><p>最终结果<br>根据状态定义，最终结果为 <code>dp[n]</code>，即第 <code>n</code> 个斐波那契数为 <code>dp[n]</code>。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：$O(n)$。一重循环遍历的时间复杂度为 $O(n)$。</li><li><strong>空间复杂度</strong>：$O(n)$。<ul><li>用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。</li><li>因为 <code>dp[i]</code> 的状态只依赖于 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code>，所以可以使用 <code>3</code> 个变量来分别表示 <code>dp[i]</code>、<code>dp[i - 1]</code>、<code>dp[i - 2]</code>，从而将空间复杂度优化到 $O(1)$。</li></ul></li></ul><h4 id="1-4-2-爬楼梯"><a href="#1-4-2-爬楼梯" class="headerlink" title="1.4.2 爬楼梯"></a>1.4.2 爬楼梯</h4><blockquote><p><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯 - 力扣</a></p></blockquote><p>&#8195;&#8195;假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。现在给定一个整数 <code>n</code>。请计算出有多少种不同的方法可以爬到楼顶。</p><ul><li>$1 \le n \le 45$。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入    n = <span class="number">3</span></span><br><span class="line">输出    <span class="number">3</span></span><br><span class="line">解释    有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span> <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span> <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span> <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><ol><li>划分阶段<br>我们按照台阶的阶层划分阶段，将其划分为 <code>0</code> ~ <code>n</code> 阶。</li></ol><ol><li><p>定义状态<br>定义状态 <code>dp[i]</code> 为：爬到第 <code>i</code> 阶台阶的方案数。</p></li><li><p>状态转移方程<br>根据题目大意，每次只能爬 <code>1</code> 或 <code>2</code> 个台阶。则第 <code>i</code> 阶楼梯只能从第 <code>i - 1</code> 阶向上爬 <code>1</code>阶上来，或者从第 <code>i - 2</code> 阶向上爬 <code>2</code> 阶上来。所以可以推出状态转移方程为 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>。</p></li><li><p>初始条件</p><ul><li>第 <code>0</code> 层台阶方案数：可以看做 <code>1</code> 种方法（从 <code>0</code> 阶向上爬 <code>0</code> 阶），即 <code>dp[1] = 1</code>。</li><li>第 <code>1</code> 层台阶方案数：<code>1</code> 种方法（从 <code>0</code> 阶向上爬 <code>1</code> 阶），即 <code>dp[1] = 1</code>。</li><li>第 <code>2</code> 层台阶方案数：<code>2</code> 中方法（从 <code>0</code> 阶向上爬 <code>2</code> 阶，或者从 <code>1</code> 阶向上爬 <code>1</code> 阶）。</li></ul></li><li><p>最终结果<br>根据状态定义，最终结果为 <code>dp[n]</code>，即爬到第 <code>n</code> 阶台阶（即楼顶）的方案数为 <code>dp[n]</code>。</p></li></ol><p>&#8195;&#8195;虽然这道题跟上一道题的状态转移方程都是 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>，但是两道题的考察方式并不相同，一定程度上也可以看出来动态规划相关题目的灵活多变。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：$O(n)$。一重循环遍历的时间复杂度为 $O(n)$。</li><li><strong>空间复杂度</strong>：$O(n)$。<ul><li>用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。</li><li>因为 <code>dp[i]</code> 的状态只依赖于 <code>dp[i - 1]</code> 和 <code>dp[i - 2]</code>，所以可以使用 <code>3</code> 个变量来分别表示 <code>dp[i]</code>、<code>dp[i - 1]</code>、<code>dp[i - 2]</code>，从而将空间复杂度优化到 $O(1)$。</li></ul></li></ul><h4 id="1-4-3-不同路径"><a href="#1-4-3-不同路径" class="headerlink" title="1.4.3 不同路径"></a>1.4.3 不同路径</h4><blockquote><p><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径 - 力扣</a></p></blockquote><p>&#8195;&#8195;给定两个整数 <code>m</code> 和 <code>n</code>，代表大小为 <code>m * n</code> 的棋盘， 一个机器人位于棋盘左上角的位置，机器人每次只能向右、或者向下移动一步。要求计算出机器人从棋盘左上角到达棋盘右下角一共有多少条不同的路径。</p><ul><li>$1 \le m, n \le 100$。</li><li>题目数据保证答案小于等于 $2 * 10^9$。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入    m = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出    <span class="number">28</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ea0a3a2e06694b832f29e06ccf42e655.png" alt=""></p><p><strong>解题思路</strong></p><ol><li>划分阶段<br>按照路径的结尾位置（行位置、列位置组成的二维坐标）进行阶段划分。</li></ol><ol><li><p>定义状态<br>定义状态 <code>dp[i][j]</code> 为：从左上角到达 <code>(i, j)</code> 位置的路径数量。</p></li><li><p>状态转移方程<br>因为我们每次只能向右、或者向下移动一步，因此想要走到 <code>(i, j)</code>，只能从 <code>(i - 1, j)</code> 向下走一步走过来；或者从 <code>(i, j - 1)</code> 向右走一步走过来。所以可以写出状态转移方程为：<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，此时 <code>i &gt; 0，j &gt; 0</code>。</p></li><li><p>初始条件</p><ul><li>从左上角走到 <code>(0, 0)</code> 只有一种方法，即 <code>dp[0][0] = 1</code>。</li><li>第一行元素只有一条路径（即只能通过前一个元素向右走得到），所以 <code>dp[0][j] = 1</code>。</li><li>同理，第一列元素只有一条路径（即只能通过前一个元素向下走得到），所以 <code>dp[i][0] = 1</code>。</li></ul><ol><li>最终结果<br>根据状态定义，最终结果为 <code>dp[m - 1][n - 1]</code>，即从左上角到达右下角 <code>(m - 1, n - 1)</code> 位置的路径数量为 <code>dp[m - 1][n - 1]</code>。</li></ol></li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用一个二维列表进行存储，dp[i][j]表示i行j列有多少种路径</span></span><br><span class="line">        dp=[[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>           <span class="comment"># 第一列路径为1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                dp[<span class="number">0</span>][j]=<span class="number">1</span>       <span class="comment"># 第一行路径为1</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> j&gt;<span class="number">0</span>:  <span class="comment"># 第一行第一列之外的位置，路径数为上方位置和左边位置的路径数之和</span></span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：$O(m <em> n)$。初始条件赋值的时间复杂度为 $O(m + n)$，两重循环遍历的时间复杂度为 $O(m </em> n)$，所以总体时间复杂度为 $O(m * n)$。</li><li><strong>空间复杂度</strong>：<ul><li>$O(m <em> n)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(m </em> n)$。</li><li>因为 <code>dp[i][j]</code> 的状态只依赖于上方值 <code>dp[i - 1][j]</code> 和左侧值 <code>dp[i][j - 1]</code>，而我们在进行遍历时的顺序刚好是从上至下、从左到右。所以我们可以使用长度为 <code>m</code> 的一维数组来保存状态，从而将空间复杂度优化到 $O(m)$。</li></ul></li></ul><h3 id="1-5-个人总结"><a href="#1-5-个人总结" class="headerlink" title="1.5 个人总结"></a>1.5 个人总结</h3><ul><li><strong>枚举算法（Enumeration Algorithm）</strong>：即穷举法，指的是按照问题本身的性质，一一列举出该问题所有可能的解，并在逐一列举的过程中，将它们逐一与目标状态进行比较以得出满足问题要求的解。在列举的过程中，既不能遗漏也不能重复。</li><li><strong>分治算法（Divide and Conquer）</strong>：「分而治之」，把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</li><li><strong>递归（Recursion）</strong>：通过重复将原问题分解为同类的子问题而解决的方法。在绝大数编程语言中，可以通过在函数中再次调用函数自身的方式来实现递归。</li></ul><ul><li><strong>动态规划（Dynamic Programming）</strong>：<ul><li>类似分治，将复杂问题，分解为更简单的子问题进行求解（划分阶段）；</li><li>类似枚举，会计算出每个阶段的结果（子问题最优解），但是下一阶段的结果是根据上一阶段的结果算出，而不是直接从头计算，所以存在状态转移，提高效率</li><li>重复调用：根据上一阶段的结果来计算下一阶段的结果，所以使用动态规划方法会将各阶段的解保存到表格里，供随后的计算查询使用，从而避免大量的重复计算。</li></ul></li></ul><h2 id="二、记忆化搜索"><a href="#二、记忆化搜索" class="headerlink" title="二、记忆化搜索"></a>二、记忆化搜索</h2><h3 id="2-1-记忆化搜索简介"><a href="#2-1-记忆化搜索简介" class="headerlink" title="2.1 记忆化搜索简介"></a>2.1 记忆化搜索简介</h3><p>&#8195;&#8195;<strong>记忆化搜索（Memoization Search）</strong>：是一种通过存储已经遍历过的状态信息，从而避免对同一状态重复遍历的搜索算法。</p><p>&#8195;&#8195;记忆化搜索是动态规划的一种实现方式。在记忆化搜索中，当算法需要计算某个子问题的结果时，它首先检查是否已经计算过该问题。如果已经计算过，则直接返回已经存储的结果；否则，计算该问题，并将结果存储下来以备将来使用。</p><p>&#8195;&#8195;举个例子，比如「斐波那契数列」的定义是：$f(0) = 0, f(1) = 1, f(n) = f(n - 1) + f(n - 2)$。如果我们使用递归算法求解第 $n$ 个斐波那契数，则对应的递推过程如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d9fbadc2e667e5be0a6885c508283f43.png" alt=""></p><p>&#8195;&#8195;从图中可以看出：如果使用普通递归算法，想要计算 $f(5)$，需要先计算 $f(3)$ 和 $f(4)$，而在计算 $f(4)$ 时还需要计算 $f(3)$。这样 $f(3)$ 就进行了多次计算，同理 $f(0)$、$f(1)$、$f(2)$ 都进行了多次计算，从而导致了重复计算问题。</p><p>&#8195;&#8195;为了避免重复计算，在递归的同时，我们可以使用一个缓存（数组或哈希表）来保存已经求解过的 $f(k)$ 的结果。如上图所示，当递归调用用到 $f(k)$ 时，先查看一下之前是否已经计算过结果，如果已经计算过，则直接从缓存中取值返回，而不用再递推下去，这样就避免了重复计算问题。</p><p>我们在使用记忆化搜索解决问题的时候，其<strong>基本步骤</strong>如下：</p><ol><li>写出问题的动态规划「状态」和「状态转移方程」。</li><li>定义一个缓存（数组或哈希表），用于保存子问题的解。</li><li>定义一个递归函数，用于解决问题。在递归函数中，首先检查缓存中是否已经存在需要计算的结果，如果存在则直接返回结果，否则进行计算，并将结果存储到缓存中，再返回结果。</li><li>在主函数中，调用递归函数并返回结果。</li></ol><p>使用「记忆化搜索」方法解决斐波那契数列的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 使用数组保存已经求解过的 f(k) 的结果</span></span><br><span class="line">        memo = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> self.my_fib(n, memo)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_fib</span>(<span class="params">self, n: <span class="built_in">int</span>, memo: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 已经计算过结果</span></span><br><span class="line">        <span class="keyword">if</span> memo[n] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> memo[n]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 没有计算过结果</span></span><br><span class="line">        memo[n] = self.my_fib(n - <span class="number">1</span>, memo) + self.my_fib(n - <span class="number">2</span>, memo)</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure><h3 id="2-2-记忆化搜索与递推的区别"><a href="#2-2-记忆化搜索与递推的区别" class="headerlink" title="2.2 记忆化搜索与递推的区别"></a>2.2 记忆化搜索与递推的区别</h3><p>「记忆化搜索」与「递推」都是动态规划的实现方式，但是两者之间有一些区别。</p><ol><li><p><strong>记忆化搜索</strong>：「自顶向下」的解决问题，采用自然的递归方式编写过程，在过程中会保存每个子问题的解（通常保存在一个数组或哈希表中）来避免重复计算。</p><ul><li>优点：代码清晰易懂，可以有效的处理一些复杂的状态转移方程。有些状态转移方程是非常复杂的，使用记忆化搜索可以将复杂的状态转移方程拆分成多个子问题，通过递归调用来解决。</li><li>缺点：可能会因为递归深度过大而导致栈溢出问题。</li><li>适用场景：题的状态转移方程比较复杂，递推关系不是很明确；问题适合转换为递归形式，并且递归深度不会太深。</li></ul></li><li><p><strong>递推</strong>：「自底向上」的解决问题，采用循环的方式编写过程，在过程中通过保存每个子问题的解（通常保存在一个数组或哈希表中）来避免重复计算。</p><ul><li>优点：避免了深度过大问题，不存在栈溢出问题。计算顺序比较明确，易于实现。</li><li>缺点：无法处理一些复杂的状态转移方程。有些状态转移方程非常复杂，如果使用递推方法来计算，就会导致代码实现变得非常困难。</li><li>适用场景：问题的状态转移方程比较简单，递归关系比较明确；问题不太适合转换为递归形式，或者递归深度过大容易导致栈溢出。</li></ul></li></ol><h3 id="2-3-记忆化搜索的应用"><a href="#2-3-记忆化搜索的应用" class="headerlink" title="2.3 记忆化搜索的应用"></a>2.3 记忆化搜索的应用</h3><h4 id="2-3-1-目标和"><a href="#2-3-1-目标和" class="headerlink" title="2.3.1 目标和"></a>2.3.1 目标和</h4><blockquote><p><a href="https://leetcode.cn/problems/target-sum/">494. 目标和 - 力扣</a></p></blockquote><p>&#8195;&#8195;给定一个整数数组 $nums$ 和一个整数 $target$。数组长度不超过 $20$。向数组中每个整数前加 <code>+</code> 或 <code>-</code>。然后串联起来构造成一个表达式。返回通过上述方法构造的、运算结果等于 $target$ 的不同表达式数目。</p><p><strong>说明</strong>：</p><ul><li>$1 \le nums.length \le 20$。</li><li>$0 \le nums[i] \le 1000$。</li><li>$0 \le sum(nums[i]) \le 1000$。</li><li>$-1000 \le target \le 1000$。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一共有 <span class="number">5</span> 种方法让最终目标和为 <span class="number">3</span>。</span><br><span class="line">-<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>思路 1：深度优先搜索（超时）</strong></p><p>使用深度优先搜索对每位数字进行 <code>+</code> 或者 <code>-</code>，具体步骤如下：</p><ol><li>定义从位置 $0$、和为 $0$ 开始，到达数组尾部位置为止，和为 $target$ 的方案数为 <code>dfs(0, 0)</code>。</li><li>下面从位置 $0$、和为 $0$ 开始，以深度优先搜索遍历每个位置。</li><li>如果当前位置 $i$ 到达最后一个位置 $size$：<ol><li>如果和 <code>cur_sum</code> 等于目标和 $target$，则返回方案数 $1$。</li><li>如果和 <code>cur_sum</code> 不等于目标和 $target$，则返回方案数 $0$。</li></ol></li><li>递归搜索 $i + 1$ 位置，和为 <code>cur_sum  -  nums[i]</code> 的方案数。</li><li>递归搜索 $i + 1$ 位置，和为 <code>cur_sum  +  nums[i]</code> 的方案数。</li><li>将 4 ~ 5 两个方案数加起来就是当前位置 $i$、和为 <code>cur_sum</code> 的方案数，返回该方案数。</li><li>最终方案数为 <code>dfs(0, 0)</code>，将其作为答案返回即可。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, cur_sum</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i == size:</span><br><span class="line">                <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            ans = dfs(i + <span class="number">1</span>, cur_sum - nums[i]) + dfs(i + <span class="number">1</span>, cur_sum + nums[i])</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(2^n)$。其中 $n$ 为数组 $nums$ 的长度。</li><li><strong>空间复杂度</strong>：$O(n)$。递归调用的栈空间深度不超过 $n$。</li></ul><p><strong>思路 2：记忆化搜索</strong></p><p>&#8195;&#8195;在思路 1 中我们单独使用深度优先搜索对每位数字进行 <code>+</code> 或者 <code>-</code> 的方法超时了。所以我们考虑使用记忆化搜索的方式，避免进行重复搜索。</p><p>&#8195;&#8195;这里我们使用哈希表 $table$ 记录遍历过的位置 $i$ 及所得到的的当前和<code>cur_sum</code> 下的方案数，来避免重复搜索。具体步骤如下：</p><ol><li>定义从位置 $0$、和为 $0$ 开始，到达数组尾部位置为止，和为 $target$ 的方案数为 <code>dfs(0, 0)</code>。</li><li>下面从位置 $0$、和为 $0$ 开始，以深度优先搜索遍历每个位置。</li><li>如果当前位置 $i$ 遍历完所有位置：<ol><li>如果和 <code>cur_sum</code> 等于目标和 $target$，则返回方案数 $1$。</li><li>如果和 <code>cur_sum</code> 不等于目标和 $target$，则返回方案数 $0$。</li></ol></li><li>如果当前位置 $i$、和为 <code>cur_sum</code>  之前记录过（即使用 $table$ 记录过对应方案数），则返回该方案数。</li><li>如果当前位置 $i$、和为 <code>cur_sum</code>  之前没有记录过，则：<ol><li>递归搜索 $i + 1$ 位置，和为 <code>cur_sum  -  nums[i]</code> 的方案数。</li><li>递归搜索 $i + 1$ 位置，和为 <code>cur_sum  +  nums[i]</code> 的方案数。</li><li>将上述两个方案数加起来就是当前位置 $i$、和为 <code>cur_sum</code> 的方案数，将其记录到哈希表 $table$ 中，并返回该方案数。</li></ol></li><li>最终方案数为 <code>dfs(0, 0)</code>，将其作为答案返回</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        table = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, cur_sum</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i == size:</span><br><span class="line">                <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> (i, cur_sum) <span class="keyword">in</span> table:</span><br><span class="line">                <span class="keyword">return</span> table[(i, cur_sum)]</span><br><span class="line">            </span><br><span class="line">            cnt = dfs(i + <span class="number">1</span>, cur_sum - nums[i]) + dfs(i + <span class="number">1</span>, cur_sum + nums[i])</span><br><span class="line">            table[(i, cur_sum)] = cnt</span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(2^n)$。其中 $n$ 为数组 $nums$ 的长度。</li><li><strong>空间复杂度</strong>：$O(n)$。递归调用的栈空间深度不超过 $n$。</li></ul><p><strong>思路3：动态规划</strong></p><p>此题也可使用动态规划求解，参考<a href="https://leetcode.cn/problems/target-sum/solution/by-flix-rkb5/">《『 一文搞懂 0-1背包问题 』记忆化搜索、动态规划 + 空间优化》</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; pos + neg = total  &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; pos - neg = target &#x27;&#x27;&#x27;</span></span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(target) &gt; total:         <span class="comment"># target可能为负</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (total + target) % <span class="number">2</span> == <span class="number">1</span>:   <span class="comment"># 不能被2整除【对应于pos不是整数】</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;【0/1背包】：从nums中选出数字组成pos或neg&#x27;&#x27;&#x27;</span></span><br><span class="line">        pos = (total + target) // <span class="number">2</span></span><br><span class="line">        neg = (total - target) // <span class="number">2</span></span><br><span class="line">        capcity = <span class="built_in">min</span>(pos, neg)         <span class="comment"># 取pos和neg中的较小者，以使得dp空间最小</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (capcity+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># dp[i][j]: 从前i个元素中选出若干个其和为j的方案数</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>        <span class="comment"># 其他 dp[0][j]均为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 状态更新</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(capcity+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; nums[i-<span class="number">1</span>]:       <span class="comment"># 容量有限，无法选择第i个数字nums[i-1]</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:                   <span class="comment"># 可选择第i个数字nums[i-1]，也可不选【两种方式之和】</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][capcity]</span><br></pre></td></tr></table></figure><h4 id="2-3-2-第-N-个泰波那契数"><a href="#2-3-2-第-N-个泰波那契数" class="headerlink" title="2.3.2 第 N 个泰波那契数"></a>2.3.2 第 N 个泰波那契数</h4><blockquote><p><a href="https://leetcode.cn/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数 - 力扣</a></p></blockquote><p>给定一个整数 $n$，返回第 $n$ 个泰波那契数。</p><ul><li><strong>泰波那契数</strong>：$T<em>0 = 0, T_1 = 1, T_2 = 1$，且在 $n &gt;= 0$ 的条件下，$T</em>{n + 3} = T<em>{n} + T</em>{n+1} + T_{n+2}$。</li><li>$0 \le n \le 37$。</li><li>答案保证是一个 32 位整数，即 $answer \le 2^{31} - 1$。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">T_3 = <span class="number">0</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">T_4 = <span class="number">1</span> + <span class="number">1</span> + <span class="number">2</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>思路 1：记忆化搜索</strong></p><ol><li>问题的状态定义为：第 $n$ 个泰波那契数。其状态转移方程为：$T<em>0 = 0, T_1 = 1, T_2 = 1$，且在 $n &gt;= 0$ 的条件下，$T</em>{n + 3} = T<em>{n} + T</em>{n+1} + T_{n+2}$。</li><li>定义一个长度为 $n + 1$ 数组 $memo$ 用于保存一斤个计算过的泰波那契数。</li><li>定义递归函数 <code>my_tribonacci(n, memo)</code>。<ol><li>当 $n = 0$ 或者 $n = 1$，或者 $n = 2$ 时直接返回结果。</li><li>当 $n &gt; 2$ 时，首先检查是否计算过 $T(n)$，即判断 $memo[n]$ 是否等于 $0$。<ol><li>如果 $memo[n] \ne 0$，说明已经计算过 $T(n)$，直接返回 $memo[n]$。</li><li>如果 $memo[n] = 0$，说明没有计算过 $T(n)$，则递归调用 <code>my_tribonacci(n - 3, memo)</code>、<code>my_tribonacci(n - 2, memo)</code>、<code>my_tribonacci(n - 1, memo)</code>，并将计算结果存入 $memo[n]$ 中，并返回 $memo[n]$。</li></ol></li></ol></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tribonacci</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 使用数组保存已经求解过的 T(k) 的结果</span></span><br><span class="line">        memo = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> self.my_tribonacci(n, memo)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_tribonacci</span>(<span class="params">self, n: <span class="built_in">int</span>, memo: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> memo[n] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> memo[n]</span><br><span class="line">        memo[n] = self.my_tribonacci(n - <span class="number">3</span>, memo) + self.my_tribonacci(n - <span class="number">2</span>, memo) + self.my_tribonacci(n - <span class="number">1</span>, memo)</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n)$。</li><li><strong>空间复杂度</strong>：$O(n)$。</li></ul><p><strong>思路二：动态规划</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tribonacci</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        dp=[<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>]+dp[i-<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h2 id="三、线性动态规划简介"><a href="#三、线性动态规划简介" class="headerlink" title="三、线性动态规划简介"></a>三、线性动态规划简介</h2><blockquote><p>参考：<a href="https://chengzhaoxi.xyz/1a4a2483.html">动态规划概念和基础线性DP | 潮汐朝夕</a></p></blockquote><p>&#8195;&#8195; <strong>线性动态规划</strong>：具有「线性」阶段划分的动态规划方法统称为线性动态规划（简称为「线性 DP」），如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dddf1f28e09a5bcb71d5bd6444c13a80.png" alt=""></p><p>&#8195;&#8195;如果状态包含多个维度，但是每个维度上都是线性划分的阶段，也属于线性 DP。比如背包问题、区间 DP、数位 DP 等都属于线性 DP。</p><p>线性 DP 问题的划分方法有多种方式。</p><ul><li>如果按照「状态的维度数」进行分类，我们可以将线性 DP 问题分为：一维线性 DP 问题、二维线性 DP 问题，以及多维线性 DP 问题。</li><li>如果按照「问题的输入格式」进行分类，我们可以将线性 DP 问题分为：单串线性 DP 问题、双串线性 DP 问题、矩阵线性 DP 问题，以及无串线性 DP 问题。</li></ul><p>本文中，我们将按照问题的输入格式进行分类，对线性 DP 问题中各种类型问题进行一一讲解。</p><h3 id="3-1-单串线性-DP-问题"><a href="#3-1-单串线性-DP-问题" class="headerlink" title="3.1 单串线性 DP 问题"></a>3.1 单串线性 DP 问题</h3><h4 id="3-1-1-最长递增子序列"><a href="#3-1-1-最长递增子序列" class="headerlink" title="3.1.1 最长递增子序列"></a>3.1.1 最长递增子序列</h4><blockquote><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列 - 力扣</a></p></blockquote><p>单串线性 DP 问题中最经典的问题就是「最长递增子序列（Longest Increasing Subsequence，简称 LIS）」。</p><p>给定一个整数数组 $nums$，找到其中最长严格递增子序列的长度。</p><ul><li><strong>子序列</strong>：由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，$[3,6,2,7]$ 是数组 $[0,3,1,6,2,2,7]$ 的子序列。</li><li>$1 \le nums.length \le 2500$。</li><li>$-10^4 \le nums[i] \le 10^4$。</li></ul><p><strong>示例</strong>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长递增子序列是 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>]，因此长度为 <span class="number">4</span>。</span><br></pre></td></tr></table></figure></p><p><strong>思路 1：动态规划</strong></p><ol><li>划分阶段<br>按照子序列的结尾位置进行阶段划分。</li></ol><ol><li><p>定义状态<br>定义状态 $dp[i]$ 表示为：以 $nums[i]$ 结尾的最长递增子序列长度。</p></li><li><p>状态转移方程<br>一个较小的数后边如果出现一个较大的数，则会形成一个更长的递增子序列。对于满足 $0 \le j &lt; i$ 的数组元素 $nums[j]$ 和 $nums[i]$ 来说：</p><ul><li>如果 $nums[j] &lt; nums[i]$，则 $nums[i]$ 可以接在 $nums[j]$ 后面，此时以 $nums[i]$ 结尾的最长递增子序列长度会在「以 $nums[j]$ 结尾的最长递增子序列长度」的基础上加 $1$，即：$dp[i] = dp[j] + 1$。</li><li>如果 $nums[j] \le nums[i]$，则 $nums[i]$ 不可以接在 $nums[j]$ 后面，可以直接跳过。</li></ul></li></ol><p>综上，我们的状态转移方程为：$dp[i] = max(dp[i], dp[j] + 1)，0 \le j &lt; i，nums[j] &lt; nums[i]$。</p><ol><li><p>初始条件<br>默认状态下，把数组中的每个元素都作为长度为 $1$ 的递增子序列。即 $dp[i] = 1$。</p></li><li><p>最终结果<br>根据我们之前定义的状态，$dp[i]$ 表示为：以 $nums[i]$ 结尾的最长递增子序列长度。那为了计算出最大的最长递增子序列长度，则需要再遍历一遍 $dp$ 数组，求出最大值即为最终结果。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp) <span class="comment"># 不是dp[n-1]</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n^2)$。两重循环遍历的时间复杂度是 $O(n^2)$，最后求最大值的时间复杂度是 $O(n)$，所以总体时间复杂度为 $O(n^2)$。</li><li><strong>空间复杂度</strong>：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。</li></ul><h4 id="3-1-2-最大子数组和"><a href="#3-1-2-最大子数组和" class="headerlink" title="3.1.2 最大子数组和"></a>3.1.2 最大子数组和</h4><blockquote><p><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和 - 力扣</a></p><p>单串线性 DP 问题中除了子序列相关的线性 DP 问题，还有子数组相关的线性 DP 问题。</p><p><strong>注意</strong>：</p><ul><li><strong>子序列</strong>：由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。</li><li><strong>子数组</strong>：指的是数组中的一个连续子序列。</li></ul><p>「子序列」与「子数组」都可以看做是原数组的一部分，而且都不会改变原来数组中元素的相对顺序。其区别在于数组元素是否要求连续。</p></blockquote><p>&#8195;&#8195;给定一个整数数组 $nums$,找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><ul><li><strong>子数组</strong>：指的是数组中的一个连续部分。</li><li>$1 \le nums.length \le 10^5$。</li><li>$-10^4 \le nums[i] \le 10^4$。</li></ul><p><strong>示例</strong>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span>。</span><br></pre></td></tr></table></figure></p><h5 id="3-1-2-1-动态规划"><a href="#3-1-2-1-动态规划" class="headerlink" title="3.1.2.1 动态规划"></a>3.1.2.1 动态规划</h5><ol><li><p>划分阶段<br>按照连续子数组的结束位置进行阶段划分。</p></li><li><p>定义状态<br>定义状态 $dp[i]$ 为：以第 $i$ 个数结尾的连续子数组的最大和。</p></li><li><p>状态转移方程<br>状态 $dp[i]$ 为：以第 $i$ 个数结尾的连续子数组的最大和。则我们可以从<code>dp[i-1]</code>来讨论 <code>dp[i]</code>。</p><ul><li>如果 <code>dp[i - 1] &lt; 0</code>，则<code>dp[i - 1] + nums[i] &lt; nums[i]</code>。所以，此时 <code>dp[i]</code> 应取第 $i$ 个数的值，即 <code>dp[i] = nums[i]</code>。</li><li>如果 <code>dp[i - 1] ≥0</code>，则 <code>dp[i] = dp[i - 1] + nums[i]</code>。</li></ul></li></ol><p>&#8195;&#8195;归纳一下，状态转移方程为：</p><script type="math/tex; mode=display">dp[i] = \begin{cases} nums[i], &  dp[i - 1] < 0 \cr dp[i - 1] + nums[i] & dp[i - 1] \ge 0 \end{cases}</script><ol><li><p>初始条件<br>第 $0$ 个数结尾的连续子数组的最大和为 $nums[0]$，即 $dp[0] = nums[0]$。</p></li><li><p>最终结果<br>根据状态定义，$dp[i]$ 为：以第 $i$ 个数结尾的连续子数组的最大和。则最终结果应为所有 $dp[i]$ 的最大值，即 $max(dp)$。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> dp[i - <span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n)$，其中 $n$ 为数组 $nums$ 的元素个数。</li><li><strong>空间复杂度</strong>：$O(n)$。</li></ul><h5 id="3-1-2-2-动态规划-滚动数组"><a href="#3-1-2-2-动态规划-滚动数组" class="headerlink" title="3.1.2.2 动态规划+滚动数组"></a>3.1.2.2 动态规划+滚动数组</h5><p>&#8195;&#8195;因为 $dp[i]$ 只和 $dp[i - 1]$ 和当前元素 $nums[i]$ 相关，我们也可以使用一个变量 $subMax$ 来表示以第 $i$ 个数结尾的连续子数组的最大和。然后使用 $ansMax$ 来保存全局中最大值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        subMax = nums[<span class="number">0</span>]</span><br><span class="line">        ansMax = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> subMax &lt; <span class="number">0</span>:</span><br><span class="line">                subMax = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                subMax += nums[i]</span><br><span class="line">            ansMax = <span class="built_in">max</span>(ansMax, subMax)</span><br><span class="line">        <span class="keyword">return</span> ansMax</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n)$，其中 $n$ 为数组 $nums$ 的元素个数。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h4 id="3-1-3-最长的斐波那契子序列的长度"><a href="#3-1-3-最长的斐波那契子序列的长度" class="headerlink" title="3.1.3 最长的斐波那契子序列的长度"></a>3.1.3 最长的斐波那契子序列的长度</h4><p>&#8195;&#8195;有一些单串线性 DP 问题在定义状态时需要考虑两个结束位置，只考虑一个结束位置的无法清楚描述问题。这时候我们就需要需要增加一个结束位置维度来定义状态。</p><blockquote><p><a href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/">873. 最长的斐波那契子序列的长度 - 力扣</a></p></blockquote><p>&#8195;&#8195;给定一个严格递增的正整数数组 $arr$，要求从数组 $arr$ 中找出最长的斐波那契式的子序列的长度。如果不存斐波那契式的子序列，则返回 0。</p><ul><li><strong>斐波那契式序列</strong>：如果序列 $X_1, X_2, …, X_n$ 满足<ul><li>$n \ge 3$；</li><li>对于所有 $i + 2 \le n$，都有 $X<em>i + X</em>{i+1} = X_{i+2}$，则称该序列为斐波那契式序列。</li></ul></li></ul><ul><li><p><strong>斐波那契式子序列</strong>：从序列 $A$ 中挑选若干元素组成子序列，并且子序列满足斐波那契式序列，则称该序列为斐波那契式子序列。例如：$A = [3, 4, 5, 6, 7, 8]$。则 $[3, 5, 8]$ 是 $A$ 的一个斐波那契式子序列。</p></li><li><p>$3 \le arr.length \le 1000$。</p></li><li><p>$1 \le arr[i] &lt; arr[i + 1] \le 10^9$。</p></li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">18</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 最长的斐波那契式子序列有 [<span class="number">1</span>,<span class="number">11</span>,<span class="number">12</span>]、[<span class="number">3</span>,<span class="number">11</span>,<span class="number">14</span>] 以及 [<span class="number">7</span>,<span class="number">11</span>,<span class="number">18</span>]。</span><br></pre></td></tr></table></figure><h5 id="3-1-3-1-暴力枚举（超时）"><a href="#3-1-3-1-暴力枚举（超时）" class="headerlink" title="3.1.3.1 暴力枚举（超时）"></a>3.1.3.1 暴力枚举（超时）</h5><p>&#8195;&#8195;假设 $arr[i]$、$arr[j]$、$arr[k]$ 是序列 $arr$ 中的 $3$ 个元素，且满足关系：$arr[i] + arr[j] == arr[k]$，则 $arr[i]$、$arr[j]$、$arr[k]$ 就构成了 $arr$ 的一个斐波那契式子序列。</p><p>&#8195;&#8195;通过  $arr[i]$、$arr[j]$，我们可以确定下一个斐波那契式子序列元素的值为 $arr[i] + arr[j]$。</p><p>&#8195;&#8195;因为给定的数组是严格递增的，所以对于一个斐波那契式子序列，如果确定了 $arr[i]$、$arr[j]$，则可以顺着 $arr$ 序列，从第 $j + 1$ 的元素开始，查找值为 $arr[i] + arr[j]$ 的元素 。找到 $arr[i] + arr[j]$ 之后，然后再顺着查找子序列的下一个元素。</p><p>&#8195;&#8195;简单来说，就是确定了 $arr[i]$、$arr[j]$，就能尽可能的得到一个长的斐波那契式子序列，此时我们记录下子序列长度。然后对于不同的  $arr[i]$、$arr[j]$，统计不同的斐波那契式子序列的长度。</p><p>&#8195;&#8195;最后将这些长度进行比较，其中最长的长度就是答案。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(arr)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">                temp_ans = <span class="number">0</span></span><br><span class="line">                temp_i = i</span><br><span class="line">                temp_j = j</span><br><span class="line">                k = j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> k &lt; size:</span><br><span class="line">                    <span class="keyword">if</span> arr[temp_i] + arr[temp_j] == arr[k]:</span><br><span class="line">                        temp_ans += <span class="number">1</span></span><br><span class="line">                        temp_i = temp_j</span><br><span class="line">                        temp_j = k</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> temp_ans &gt; ans:</span><br><span class="line">                    ans = temp_ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ans &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ans + <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n^3)$，其中 $n$ 为数组 $arr$ 的元素个数。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h5 id="3-1-3-2-哈希表"><a href="#3-1-3-2-哈希表" class="headerlink" title="3.1.3.2 哈希表"></a>3.1.3.2 哈希表</h5><p>&#8195;&#8195;对于 $arr[i]$、$arr[j]$，要查找的元素 $arr[i] + arr[j]$ 是否在 $arr$ 中，我们可以预先建立一个反向的哈希表。键值对关系为 $value : idx$，这样就能在 $O(1)$ 的时间复杂度通过 $arr[i] + arr[j]$ 的值查找到对应的 $arr[k]$，而不用像原先一样线性查找 $arr[k]$ 了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(arr)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        idx_map = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> idx, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr):</span><br><span class="line">            idx_map[value] = idx</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">                temp_ans = <span class="number">0</span></span><br><span class="line">                temp_i = i</span><br><span class="line">                temp_j = j</span><br><span class="line">                <span class="keyword">while</span> arr[temp_i] + arr[temp_j] <span class="keyword">in</span> idx_map:</span><br><span class="line">                    temp_ans += <span class="number">1</span></span><br><span class="line">                    k = idx_map[arr[temp_i] + arr[temp_j]]</span><br><span class="line">                    temp_i = temp_j</span><br><span class="line">                    temp_j = k</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> temp_ans &gt; ans:</span><br><span class="line">                    ans = temp_ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ans &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ans + <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n^2)$，其中 $n$ 为数组 $arr$ 的元素个数。</li><li><strong>空间复杂度</strong>：$O(n)$。</li></ul><h5 id="3-1-3-3-动态规划-哈希表"><a href="#3-1-3-3-动态规划-哈希表" class="headerlink" title="3.1.3.3 动态规划 + 哈希表"></a>3.1.3.3 动态规划 + 哈希表</h5><ol><li><p>划分阶段<br>按照斐波那契式子序列相邻两项的结尾位置进行阶段划分。</p><ol><li>定义状态<br>定义状态 $dp[i][j]$ 表示为：以 $arr[i]$、$arr[j]$ 为结尾的斐波那契式子序列的最大长度。</li></ol></li><li><p>状态转移方程<br>如果$arr[i] + arr[j] = arr[k]$ ，则以 $arr[i]$、$arr[k]$ 结尾的斐波那契式子序列的最大长度，等于以 $arr[i]$、$arr[j]$ 为结尾的斐波那契式子序列的最大长度加 $1$。即状态转移方程为：$dp[j][k] = max_{(A[i] + A[j] = A[k]，i &lt; j &lt; k)}(dp[i][j] + 1)$。</p></li><li><p>初始条件<br>默认状态下，数组中任意相邻两项元素都可以作为长度为 $2$ 的斐波那契式子序列，即 $dp[i][j] = 2$。</p></li><li><p>最终结果<br>根据我们之前定义的状态，$dp[i][j]$ 表示为：以 $arr[i]$、$arr[j]$ 为结尾的斐波那契式子序列的最大长度。那为了计算出最大的最长递增子序列长度，则需要在进行状态转移时，求出最大值 $ans$ 即为最终结果。</p></li></ol><p>因为题目定义中，斐波那契式中 $n \ge 3$，所以只有当 $ans \ge 3$ 时，返回 $ans$。如果 $ans &lt; 3$，则返回 $0$。</p><blockquote><p><strong>注意</strong>：在进行状态转移的同时，我们应和「思路 2：哈希表」一样采用哈希表优化的方式来提高效率，降低算法的时间复杂度。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">if</span> size&lt;<span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化 dp</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">                dp[i][j] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="comment"># 将 value : idx 映射为哈希表，这样可以快速通过 value 获取到 idx</span></span><br><span class="line">        <span class="keyword">for</span> idx, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr):</span><br><span class="line">            d[value] = idx</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, size):</span><br><span class="line">                <span class="keyword">if</span> arr[i] + arr[j] <span class="keyword">in</span> idx_map:    </span><br><span class="line">                    <span class="comment"># 获取 arr[i] + arr[j] 的 idx，即斐波那契式子序列下一项元素</span></span><br><span class="line">                    k = d[arr[i] + arr[j]]</span><br><span class="line">                    </span><br><span class="line">                    dp[j][k] = <span class="built_in">max</span>(dp[j][k], dp[i][j] + <span class="number">1</span>)</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, dp[j][k])</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> ans        </span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n^2)$，其中 $n$ 为数组 $arr$ 的元素个数。</li><li><strong>空间复杂度</strong>：$O(n)$。</li></ul><h3 id="3-2-双串线性-DP-问题"><a href="#3-2-双串线性-DP-问题" class="headerlink" title="3.2 双串线性 DP 问题"></a>3.2 双串线性 DP 问题</h3><p> <strong>双串线性 DP 问题</strong>：问题的输入为两个数组或两个字符串的线性 DP 问题。状态一般可定义为 $dp[i][j]$，表示为：</p><ol><li>「以第一个数组中第 $i$ 个位置元素 $nums1[i]$ 为结尾的子数组（$nums1[0]…nums1[i]$）」与「以第二个数组中第 $j$ 个位置元素 $nums2[j]$ 为结尾的子数组（$nums2[0]…nums2[j]$）」的相关解。<ol><li>「以第一个数组中第 $i - 1$ 个位置元素 $nums1[i - 1]$ 为结尾的子数组（$nums1[0]…nums1[i - 1]$）」与「以第二个数组中第 $j - 1$ 个位置元素 $nums2[j - 1]$ 为结尾的子数组（$nums2[0]…nums2[j - 1]$）」的相关解。</li><li>「以第一个数组中前 $i$ 个元素为子数组（$nums1[0]…nums1[i - 1]$）」与「以第二个数组中前 $j$ 个元素为子数组（$nums2[0]…nums2[j - 1]$）」的相关解。</li></ol></li></ol><p>这 $3$ 种状态的定义区别在于相差一个元素 $nums1[i]$ 或 $nums2[j]$。</p><ol><li>第 $1$ 种状态：子数组的长度为 $i + 1$ 或 $j + 1$，子数组长度可为空</li><li>第 $2$ 种状态、第 $3$ 种状态：子数组的长度为 $i$ 或 $j$，子数组长度不可为空。</li></ol><p>双串线性 DP 问题中最经典的问题就是「最长公共子序列（Longest Common Subsequence，简称 LCS）」。</p><h4 id="3-2-1-最长公共子序列"><a href="#3-2-1-最长公共子序列" class="headerlink" title="3.2.1 最长公共子序列"></a>3.2.1 最长公共子序列</h4><blockquote><p><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列 - 力扣</a></p></blockquote><p>&#8195;&#8195;给定两个字符串 $text1$ 和 $text2$，要求返回两个字符串的最长公共子序列的长度。如果不存在公共子序列，则返回 $0$。</p><ul><li><strong>子序列</strong>：原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</li><li><strong>公共子序列</strong>：两个字符串所共同拥有的子序列。</li><li>$1 \le text1.length, text2.length \le 1000$。</li><li>$text1$ 和 $text2$ 仅由小写英文字符组成。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：text1 = <span class="string">&quot;abcde&quot;</span>, text2 = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">输出：<span class="number">3</span>  </span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;ace&quot;</span>，它的长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p><strong>思路 1：动态规划</strong></p><ol><li>划分阶段<br>按照两个字符串的结尾位置进行阶段划分。</li></ol><ol><li><p>定义状态<br>定义状态 $dp[i][j]$ 表示为：「以 $text1$ 中前 $i$ 个元素组成的子字符串 $str1$ 」与「以 $text2$ 中前 $j$ 个元素组成的子字符串 $str2$」的最长公共子序列长度为 $dp[i][j]$。</p></li><li><p>状态转移方程<br>双重循环遍历字符串 $text1$ 和 $text2$，则状态转移方程为：</p><ol><li>如果 $text1[i - 1] = text2[j - 1]$，说明两个子字符串的最后一位是相同的，所以最长公共子序列长度加 $1$。即：$dp[i][j] = dp[i - 1][j - 1] + 1$。</li><li>如果 $text1[i - 1] \ne text2[j - 1]$，说明两个子字符串的最后一位是不同的，则 $dp[i][j]$ 需要考虑以下两种情况，取两种情况中最大的那种：$dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])$。<ol><li>$str1[0:i-1]$与$str2[j]$的最长公共子序列长度，即 $dp[i - 1][j]$。</li><li>$str1[0:i]$与$str2[j-1]$的最长公共子序列长度，即 $dp[i][j - 1]$。</li></ol></li></ol></li><li><p>初始条件</p><ol><li>当 $i = 0$ 时，$str1$ 表示的是空串，空串与 $str2$ 的最长公共子序列长度为 $0$，即 $dp[0][j] = 0$。</li><li>当 $j = 0$ 时，$str2$ 表示的是空串，$str1$ 与 空串的最长公共子序列长度为 $0$，即 $dp[i][0] = 0$。</li></ol></li><li><p>最终结果<br>根据状态定义，最后输出 $dp[sise1][size2]$（即 $text1$ 与 $text2$ 的最长公共子序列长度）即可，其中 $size1$、$size2$ 分别为 $text1$、$text2$ 的字符串长度。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/74617861bb8445a7a2403acbff1dcffc.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size1 = <span class="built_in">len</span>(text1)</span><br><span class="line">        size2 = <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size2 + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size1 + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[size1][size2]</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n \times m)$，其中 $n$、$m$ 分别是字符串 $text1$、$text2$ 的长度。两重循环遍历的时间复杂度是 $O(n \times m)$，所以总的时间复杂度为 $O(n \times m)$。</li><li><strong>空间复杂度</strong>：$O(n \times m)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(n \times m)$。</li></ul><h4 id="3-2-2-最长重复子数组"><a href="#3-2-2-最长重复子数组" class="headerlink" title="3.2.2 最长重复子数组"></a>3.2.2 最长重复子数组</h4><blockquote><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组 - 力扣</a></p></blockquote><p>&#8195;&#8195;给定两个整数数组 $nums1$、$nums2$，计算两个数组中公共的、长度最长的子数组长度。</p><ul><li>$1 \le nums1.length, nums2.length \le 1000$。</li><li>$0 \le nums1[i], nums2[i] \le 100$。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], nums2 = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：长度最长的公共子数组是 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><p><strong>思路 1：动态规划</strong></p><ol><li><p>划分阶段<br>按照子数组结尾位置进行阶段划分。</p></li><li><p>定义状态<br>定义状态 $dp[i][j]$ 为：「以 $nums1$ 中前 $i$ 个元素为子数组（$nums1[0]…nums2[i - 1]$）」和「以 $nums2$ 中前 $j$ 个元素为子数组（$nums2[0]…nums2[j - 1]$）」的最长公共子数组长度。</p></li><li><p>状态转移方程</p><ol><li>如果 $nums1[i - 1] = nums2[j - 1]$，则当前元素可以构成公共子数组，此时 $dp[i][j] = dp[i - 1][j - 1] + 1$。</li><li>如果 $nums1[i - 1] \ne nums2[j - 1]$，则当前元素不能构成公共子数组，此时 $dp[i][j] = 0$。</li></ol></li><li><p>初始条件</p><ul><li>当 $i = 0$ 时，$nums1[0]…nums1[i - 1]$ 表示的是空数组，空数组与 $nums2[0]…nums2[j - 1]$ 的最长公共子序列长度为 $0$，即 $dp[0][j] = 0$。</li><li>当 $j = 0$ 时，$nums2[0]…nums2[j - 1]$ 表示的是空数组，空数组与 $nums1[0]…nums1[i - 1]$ 的最长公共子序列长度为 $0$，即 $dp[i][0] = 0$。</li></ul></li><li><p>最终结果<br>根据状态定义， $dp[i][j]$ 为：「以 $nums1$ 中前 $i$ 个元素为子数组（$nums1[0]…nums2[i - 1]$）」和「以 $nums2$ 中前 $j$ 个元素为子数组（$nums2[0]…nums2[j - 1]$）」的最长公共子数组长度。在遍历过程中，我们可以使用 $res$ 记录下所有 $dp[i][j]$ 中最大值即为答案。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        size2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size2 + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size1 + <span class="number">1</span>)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j] &gt; res:</span><br><span class="line">                    res = dp[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n \times m)$。其中 $n$ 是数组 $nums1$ 的长度，$m$ 是数组 $nums2$ 的长度。</li><li><strong>空间复杂度</strong>：$O(n \times m)$。</li></ul><h4 id="3-3-3-编辑距离"><a href="#3-3-3-编辑距离" class="headerlink" title="3.3.3 编辑距离"></a>3.3.3 编辑距离</h4><p>双串线性 DP 问题中除了经典的最长公共子序列问题之外，还包括字符串的模糊匹配问题。</p><blockquote><p><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离 - 力扣</a></p></blockquote><p>给定两个单词 $word1$、$word2$。对一个单词可以进行以下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>请计算出将 $word1$ 转换为 $word2$ 所使用的最少操作数。</p><ul><li>$0 \le word1.length, word2.length \le 500$。</li><li>$word1$ 和 $word2$ 由小写英文字母组成。</li></ul><p><strong>示例</strong>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：word1 = <span class="string">&quot;intention&quot;</span>, word2 = <span class="string">&quot;execution&quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">inention -&gt; enention (将 <span class="string">&#x27;i&#x27;</span> 替换为 <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">enention -&gt; exention (将 <span class="string">&#x27;n&#x27;</span> 替换为 <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">exention -&gt; exection (将 <span class="string">&#x27;n&#x27;</span> 替换为 <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">exection -&gt; execution (插入 <span class="string">&#x27;u&#x27;</span>)</span><br></pre></td></tr></table></figure></p><p><strong>思路 1：动态规划</strong></p><ol><li><p>划分阶段<br>按照两个字符串的结尾位置进行阶段划分。</p></li><li><p>定义状态<br>定义状态 $dp[i][j]$ 表示为：「以 $word1$ 中前 $i$ 个字符组成的子字符串 $str1$」变为「以  $word2$ 中前 $j$ 个字符组成的子字符串 $str2$」，所需要的最少操作次数。</p></li><li><p>状态转移方程</p><ol><li>如果当前字符相同（$word1[i - 1] = word2[j - 1]$），无需插入、删除、替换。$dp[i][j] = dp[i - 1][j - 1]$。</li><li>如果当前字符不同（$word1[i - 1] \ne word2[j - 1]$），$dp[i][j]$ 取源于以下三种情况中的最小情况：<ol><li>替换（$word1[i - 1]$ 替换为 $word2[j - 1]$）：最少操作次数依赖于「以 $word1$ 中前 $i - 1$ 个字符组成的子字符串 $str1$」变为「以  $word2$ 中前 $j - 1$ 个字符组成的子字符串 $str2$」，再加上替换的操作数 $1$，即：$dp[i][j] = dp[i - 1][j - 1] + 1$。</li><li>插入（$word1$ 在第 $i - 1$ 位置上插入元素）：最少操作次数依赖于「以 $word1$ 中前 $i - 1$ 个字符组成的子字符串 $str1$」 变为「以  $word2$ 中前 $j$ 个字符组成的子字符串 $str2$」，再加上插入需要的操作数 $1$，即：$dp[i][j] = dp[i - 1][j] + 1$。</li><li>删除（$word1$ 删除第 $i - 1$ 位置元素）：最少操作次数依赖于「以 $word1$ 中前 $i$ 个字符组成的子字符串 $str1$」变为「以  $word2$ 中前 $j - 1$ 个字符组成的子字符串 $str2$」，再加上删除需要的操作数 $1$，即：$dp[i][j] = dp[i][j - 1] + 1$。</li></ol></li></ol></li></ol><p>&#8195;&#8195;综合上述情况，状态转移方程为：</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases} dp[i - 1][j - 1] & word1[i - 1] = word2[j - 1] \cr min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1 & word1[i - 1] \ne word2[j - 1] \end{cases}</script><ol><li><p>初始条件</p><ul><li>当 $i = 0$， $str1$为空字符串，$str1$变为$str2$时，至少需要插入 $j$ 次，即：$dp[0][j] = j$。</li><li>当 $j = 0$，$str2$为空字符串， $str1$变为$str2$时，至少需要删除 $i$ 次，即：$dp[i][0] = i$。</li></ul></li><li><p>最终结果<br>根据状态定义，最后输出 $dp[sise1][size2]$（即 $word1$ 变为 $word2$ 所使用的最少操作数）即可。其中 $size1$、$size2$ 分别为 $word1$、$word2$ 的字符串长度。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size1 = <span class="built_in">len</span>(word1)</span><br><span class="line">        size2 = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size2 + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size1 + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size1 + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size2 + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[size1][size2]</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n \times m)$，其中 $n$、$m$ 分别是字符串 $word1$、$word2$ 的长度。两重循环遍历的时间复杂度是 $O(n \times m)$，所以总的时间复杂度为 $O(n \times m)$。</li><li><strong>空间复杂度</strong>：$O(n \times m)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(n \times m)$。</li></ul><h3 id="3-3-矩阵线性-DP问题"><a href="#3-3-矩阵线性-DP问题" class="headerlink" title="3.3 矩阵线性 DP问题"></a>3.3 矩阵线性 DP问题</h3><p>&#8195;&#8195; <strong>矩阵线性 DP 问题</strong>：问题的输入为二维矩阵的线性 DP 问题。状态一般可定义为 $dp[i][j]$，表示为：从「位置 $(0, 0)$」到达「位置 $(i, j)$」的相关解。</p><h4 id="3-3-1-最小路径和"><a href="#3-3-1-最小路径和" class="headerlink" title="3.3.1 最小路径和"></a>3.3.1 最小路径和</h4><blockquote><p><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和 - 力扣</a></p></blockquote><p>&#8195;&#8195;给定一个包含非负整数的 $m \times n$  大小的网格 $grid$,找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><ul><li>每次只能向下或者向右移动一步。</li><li>$m == grid.length$。</li><li>$n == grid[i].length$。</li><li>$1 \le m, n \le 200$。</li><li>$0 \le grid[i][j] \le 100$。</li></ul><p><strong>示例</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9e6ba00606fa07e0b9c0287799c9cd9c.jpeg" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></table></figure><p><strong>思路 1：动态规划</strong></p><ol><li><p>划分阶段<br>按照路径的结尾位置（行位置、列位置组成的二维坐标）进行阶段划分。</p><ol><li>定义状态<br>定义状态 $dp[i][j]$ 为：从位置 $(0, 0)$ 到达位置 $(i, j)$ 的最小路径和。</li></ol></li><li><p>状态转移方程<br>当前位置 $(i, j)$ 只能从左侧位置 $(i, j - 1)$ 或者上方位置 $(i - 1, j)$ 到达。为了使得从左上角到达 $(i, j)$ 位置的最小路径和最小，应从 $(i, j - 1)$ 位置和 $(i - 1, j)$ 位置选择路径和最小的位置达到 $(i, j)$。即状态转移方程为：<script type="math/tex">dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]</script></p></li><li><p>初始条件</p><ul><li>当左侧和上方是矩阵边界时（即 $i = 0, j = 0$），$dp[i][j] = grid[i][j]$。</li><li>当只有左侧是矩阵边界时（即 $i \ne 0, j = 0$），只能从上方到达，$dp[i][j] = dp[i - 1][j] + grid[i][j]$。</li><li>当只有上方是矩阵边界时（即 $i = 0, j \ne 0$），只能从左侧到达，$dp[i][j] = dp[i][j - 1] + grid[i][j]$。</li></ul></li><li><p>最终结果<br>根据状态定义，最后输出 $dp[rows - 1][cols - 1]$（即从左上角到达 $(rows - 1, cols - 1)$ 位置的最小路径和）即可。其中 $rows$、$cols$ 分别为 $grid$ 的行数、列数。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cols)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols):</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + grid[i][j]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[rows - <span class="number">1</span>][cols - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(m * n)$，其中 $m$、$n$ 分别为 $grid$ 的行数和列数。</li><li><strong>空间复杂度</strong>：$O(m * n)$。</li></ul><h4 id="3-3-2最大正方形"><a href="#3-3-2最大正方形" class="headerlink" title="3.3.2最大正方形"></a>3.3.2最大正方形</h4><blockquote><p><a href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形 - 力扣</a></p></blockquote><p>给定一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵 $matrix$，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p><ul><li>$m == matrix.length$。</li><li>$n == matrix[i].length$。</li><li>$1 \le m, n \le 300$。</li><li>$matrix[i][j]$ 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code>。</li></ul><p><strong>示例</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1687084f2a15394343d9005211b338df.jpeg" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>],[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>思路 1：动态规划</strong></p><ol><li><p>划分阶段<br>按照正方形的右下角坐标进行阶段划分。</p></li><li><p>定义状态<br>定义状态 $dp[i][j]$ 表示为：以矩阵位置 $(i, j)$ 为右下角，且值包含 $1$ 的正方形的最大边长。</p></li><li><p>状态转移方程<br>只有当矩阵位置 $(i, j)$ 值为 $1$ 时，才有可能存在正方形。</p><ul><li>如果矩阵位置 $(i, j)$ 上值为 $0$，则 $dp[i][j] = 0$。</li><li>如果矩阵位置 $(i, j)$ 上值为 $1$，则 $dp[i][j]$ 的值由该位置上方、左侧、左上方三者共同约束的，为三者中最小值加 $1$。即：$dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1$。</li></ul></li><li><p>初始条件<br>默认所有以矩阵位置 $(i, j)$ 为右下角，且值包含 $1$ 的正方形的最大边长都为 $0$，即 $dp[i][j] = 0$。</p></li><li><p>最终结果<br>根据我们之前定义的状态， $dp[i][j]$ 表示为：以矩阵位置 $(i, j)$ 为右下角，且值包含 $1$ 的正方形的最大边长。则最终结果为所有 $dp[i][j]$ 中的最大值。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        max_size = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cols)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                 <span class="comment"># 第一行或第一列某个位置为“1”，则其dp值为1，因为是最小正方形</span></span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 其它位置为“1”时，只有左侧、上方和左上方三个位置都是“1”，这个位置值才+1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                    max_size = <span class="built_in">max</span>(max_size, dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> max_size * max_size</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(m \times n)$，其中 $m$、$n$ 分别为二维矩阵 $matrix$ 的行数和列数。</li><li><strong>空间复杂度</strong>：$O(m \times n)$。</li></ul><h3 id="3-4无串线性-DP-问题"><a href="#3-4无串线性-DP-问题" class="headerlink" title="3.4无串线性 DP 问题"></a>3.4无串线性 DP 问题</h3><p><strong>无串线性 DP 问题</strong>：问题的输入不是显式的数组或字符串，但依然可分解为若干子问题的线性 DP 问题。</p><h4 id="3-4-1-整数拆分"><a href="#3-4-1-整数拆分" class="headerlink" title="3.4.1 整数拆分"></a>3.4.1 整数拆分</h4><blockquote><p><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分 - 力扣</a></p></blockquote><p>&#8195;&#8195;给定一个正整数 $n$，将其拆分为 $k (k \ge 2)$ 个正整数的和，并使这些整数的乘积最大化，返回可以获得的最大乘积。</p><ul><li>$2 \le n \le 58$。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: n = <span class="number">10</span></span><br><span class="line">输出: <span class="number">36</span></span><br><span class="line">解释: <span class="number">10</span> = <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span>, <span class="number">3</span> × <span class="number">3</span> × <span class="number">4</span> = <span class="number">36</span>。</span><br></pre></td></tr></table></figure><p><strong>思路 1：动态规划</strong></p><ol><li><p>划分阶段<br>按照正整数进行划分。</p></li><li><p>定义状态<br>定义状态 $dp[i]$ 表示为：将正整数 $i$ 拆分为至少 $2$ 个正整数的和之后，这些正整数的最大乘积。</p></li><li><p>状态转移方程<br><font color='red'> 始终要记得自己定义的dp数组的含义&lt;/font &gt;<br>当 $i \ge 2$ 时，假设正整数 $i$ 拆分出的第 $1$ 个正整数是 $j(1 \le j &lt; i)$，则有两种方法：</p><ol><li>将 $i$ 拆分为 $j$ 和 $i - j$ 的和，且 $i - j$ 不再拆分为多个正整数，此时乘积为：$j \times (i - j)$。</li><li>将 $i$ 拆分为 $j$ 和 $i - j$ 的和，且 $i - j$ 继续拆分为多个正整数，此时乘积为：$j \times dp[i - j]$。</li></ol></li></ol><p>则 $dp[i]$ 取两者中的最大值。即：$dp[i] = max(j \times (i - j), j \times dp[i - j])$。</p><p>由于 $1 \le j &lt; i$，需要遍历 $j$ 得到 $dp[i]$ 的最大值，则状态转移方程如下：</p><script type="math/tex; mode=display">dp[i] = max_{1 \le j < i}\lbrace max(j \times (i - j), j \times dp[i - j]) \rbrace</script><ol><li><p>初始条件<br>$0$ 和 $1$ 都不能被拆分，所以 $dp[0] = 0, dp[1] = 0$。</p></li><li><p>最终结果<br>根据我们之前定义的状态，$dp[i]$ 表示为：将正整数 $i$ 拆分为至少 $2$ 个正整数的和之后，这些正整数的最大乘积。则最终结果为 $dp[n]$。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], (i - j) * j, dp[i - j] * j)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n^2)$。</li><li><strong>空间复杂度</strong>：$O(n)$。</li></ul><p><strong>思路 2：动态规划优化</strong><br>&#8195;&#8195;思路1中计算dp[i] 时，j 的值遍历了从 1 到 i−1 的所有值，因此总时间复杂度是$O(n^2)$。继续分析可知，要想得到最大乘积，j只能取2或者3（详见<a href="https://leetcode.cn/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/">《官方题解》</a>），则状态转移方程为：</p><script type="math/tex; mode=display">dp[i]=max(2×(i−2),2×dp[i−2],3×(i−3),3×dp[i−3])</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(<span class="number">2</span> * (i - <span class="number">2</span>), <span class="number">2</span> * dp[i - <span class="number">2</span>], <span class="number">3</span> * (i - <span class="number">3</span>), <span class="number">3</span> * dp[i - <span class="number">3</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h4 id="3-4-2-只有两个键的键盘"><a href="#3-4-2-只有两个键的键盘" class="headerlink" title="3.4.2 只有两个键的键盘"></a>3.4.2 只有两个键的键盘</h4><p> <a href="https://leetcode.cn/problems/2-keys-keyboard/">650. 只有两个键的键盘</a></p><p>最初记事本上只有一个字符 <code>&#39;A&#39;</code>。你每次可以对这个记事本进行两种操作：</p><ul><li><strong>Copy All（复制全部）</strong>：复制这个记事本中的所有字符（不允许仅复制部分字符）。</li><li><strong>Paste（粘贴）</strong>：粘贴上一次复制的字符。</li></ul><p>现在，给定一个数字 $n$，需要使用最少的操作次数，在记事本上输出恰好 $n$ 个 <code>&#39;A&#39;</code> ，请返回能够打印出 $n$ 个 <code>&#39;A&#39;</code> 的最少操作次数。</p><ul><li><p>$1 \le n \le 1000$。</p></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释</span><br><span class="line">最初, 只有一个字符 <span class="string">&#x27;A&#x27;</span>。</span><br><span class="line">第 <span class="number">1</span> 步, 使用 Copy All 操作。</span><br><span class="line">第 <span class="number">2</span> 步, 使用 Paste 操作来获得 <span class="string">&#x27;AA&#x27;</span>。</span><br><span class="line">第 <span class="number">3</span> 步, 使用 Paste 操作来获得 <span class="string">&#x27;AAA&#x27;</span>。</span><br></pre></td></tr></table></figure><p><strong>思路 1：动态规划</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSteps</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        dp=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="comment"># 每次复制一个，n至多操作n次</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">0</span></span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i):</span><br><span class="line">                <span class="keyword">if</span> i%j==<span class="number">0</span>:</span><br><span class="line">                    dp[i]=<span class="built_in">min</span>(dp[i],dp[j]+i//j)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p>  其实<code>j</code>是<code>i</code>的因子，所以<code>j</code>应该不超过$\sqrt{i}$ 。    将其优化：</p><ol><li>划分阶段</li></ol><p>按照字符 <code>&#39;A&#39;</code>  的个数进行阶段划分。</p><ol><li>定义状态</li></ol><p>定义状态 $dp[i]$ 表示为：通过「复制」和「粘贴」操作，得到 $i$ 个字符 <code>&#39;A&#39;</code>，最少需要的操作数。</p><ol><li><p>状态转移方程</p><ol><li>对于 $i$ 个字符 <code>&#39;A&#39;</code>，如果 $i$ 可以被一个小于 $i$ 的整数 $j$ 除尽（$j$ 是 $i$ 的因子），则说明 $j$ 个字符 <code>&#39;A&#39;</code> 可以通过「复制」+「粘贴」总共 $\frac{i}{j}$ 次得到 $i$ 个字符 <code>&#39;A&#39;</code>。</li><li>而得到 $j$ 个字符 <code>&#39;A&#39;</code>，最少需要的操作数可以通过 $dp[j]$ 获取。</li></ol></li></ol><p>则我们可以枚举 $i$ 的因子，从中找到在满足 $j$ 能够整除 $i$ 的条件下，最小的 $dp[j] + \frac{i}{j}$，即为 $dp[i]$，即 $dp[i] = min_{j | i}(dp[i], dp[j] + \frac{i}{j})$。</p><p>由于 $j$ 能够整除 $i$，则 $j$ 与 $\frac{i}{j}$ 都是 $i$ 的因子，两者中必有一个因子是小于等于 $\sqrt{i}$ 的，所以在枚举 $i$ 的因子时，我们只需要枚举区间 $[1, \sqrt{i}]$ 即可。</p><p>综上所述，状态转移方程为：<script type="math/tex">dp[i] = min_{j | i}(dp[i], dp[j] + \frac{i}{j}, dp[\frac{i}{j}] + j)</script></p><ol><li><p>初始条件<br>当 $i = 1$ 时，最少需要的操作数为 $0$。所以 $dp[1] = 0$。</p></li><li><p>最终结果<br>根据我们之前定义的状态，$dp[i]$ 表示为：通过「复制」和「粘贴」操作，得到 $i$ 个字符 <code>&#39;A&#39;</code>，最少需要的操作数。 所以最终结果为 $dp[n]$。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSteps</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(math.sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + i // j, dp[i // j] + j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n \sqrt{n})$。外层循环遍历的时间复杂度是 $O(n)$，内层循环遍历的时间复杂度是 $O(\sqrt{n})$，所以总体时间复杂度为 $O(n \sqrt{n})$。</li><li><strong>空间复杂度</strong>：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。</li></ul><h3 id="3-5-线性-DP-题目大全"><a href="#3-5-线性-DP-题目大全" class="headerlink" title="3.5 线性 DP 题目大全"></a>3.5 线性 DP 题目大全</h3><p>单串线性 DP 问题</p><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0300</td><td style="text-align:left"><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.md">Python</a></td><td style="text-align:left">二分查找、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0673</td><td style="text-align:left"><a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/">最长递增子序列的个数</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0673.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0.md">Python</a></td><td style="text-align:left">动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0354</td><td style="text-align:left"><a href="https://leetcode.cn/problems/russian-doll-envelopes/">俄罗斯套娃信封问题</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0354.%20%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98.md">Python</a></td><td style="text-align:left">动态规划、二分查找</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0053</td><td style="text-align:left"><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0053.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C.md">Python</a></td><td style="text-align:left">数组、分治算法、动态规划</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0152</td><td style="text-align:left"><a href="https://leetcode.cn/problems/maximum-product-subarray/">乘积最大子数组</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84.md">Python</a></td><td style="text-align:left">数组、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0918</td><td style="text-align:left"><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">环形子数组的最大和</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0918.%20%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.md">Python</a></td><td style="text-align:left">数组、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0198</td><td style="text-align:left"><a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.md">Python</a></td><td style="text-align:left">动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0213</td><td style="text-align:left"><a href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II.md">Python</a></td><td style="text-align:left">动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0740</td><td style="text-align:left">删除并获得点数</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1388</td><td style="text-align:left">3n 块披萨</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0873</td><td style="text-align:left"><a href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/">最长的斐波那契子序列的长度</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0873.%20%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6.md">Python</a></td><td style="text-align:left">数组、哈希表、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">1027</td><td style="text-align:left">最长等差数列</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1055</td><td style="text-align:left">形成字符串的最短路径</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0368</td><td style="text-align:left">最大整除子集</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0032</td><td style="text-align:left"><a href="https://leetcode.cn/problems/longest-valid-parentheses/">最长有效括号</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0032.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.md">Python</a></td><td style="text-align:left">栈、字符串、动态规划</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0413</td><td style="text-align:left">等差数列划分</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0091</td><td style="text-align:left"><a href="https://leetcode.cn/problems/decode-ways/">解码方法</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0091.%20%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95.md">Python</a></td><td style="text-align:left">字符串、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0639</td><td style="text-align:left"><a href="https://leetcode.cn/problems/decode-ways-ii/">解码方法 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0639.%20%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%20II.md">Python</a></td><td style="text-align:left">字符串、动态规划</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0132</td><td style="text-align:left">分割回文串 II</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1220</td><td style="text-align:left"><a href="https://leetcode.cn/problems/count-vowels-permutation/">统计元音字母序列的数目</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/1220.%20%E7%BB%9F%E8%AE%A1%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE.md">Python</a></td><td style="text-align:left">动态规划</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0338</td><td style="text-align:left"><a href="https://leetcode.cn/problems/counting-bits/">比特位计数</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0.md">Python</a></td><td style="text-align:left">位运算、动态规划</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0801</td><td style="text-align:left"><a href="https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/">使序列递增的最小交换次数</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0801.%20%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0.md">Python</a></td><td style="text-align:left">动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0871</td><td style="text-align:left">最低加油次数</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0045</td><td style="text-align:left"><a href="https://leetcode.cn/problems/jump-game-ii/">跳跃游戏 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0045.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%20II.md">Python</a></td><td style="text-align:left">贪心、数组、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0813</td><td style="text-align:left">最大平均值和的分组</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0887</td><td style="text-align:left"><a href="https://leetcode.cn/problems/super-egg-drop/">鸡蛋掉落</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0887.%20%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD.md">Python</a></td><td style="text-align:left">数学、二分查找、动态规划</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0256</td><td style="text-align:left">粉刷房子</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0265</td><td style="text-align:left">粉刷房子 II</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1473</td><td style="text-align:left">粉刷房子 III</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0975</td><td style="text-align:left">奇偶跳</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0403</td><td style="text-align:left"><a href="https://leetcode.cn/problems/frog-jump/">青蛙过河</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0403.%20%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3.md">Python</a></td><td style="text-align:left">数组、动态规划</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">1478</td><td style="text-align:left">安排邮筒</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1230</td><td style="text-align:left">抛掷硬币</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0410</td><td style="text-align:left"><a href="https://leetcode.cn/problems/split-array-largest-sum/">分割数组的最大值</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0410.%20%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.md">Python</a></td><td style="text-align:left">二分查找、动态规划</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">1751</td><td style="text-align:left">最多可以参加的会议数目 II</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1787</td><td style="text-align:left">使所有区间的异或结果为零</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0121</td><td style="text-align:left"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.md">Python</a></td><td style="text-align:left">数组、动态规划</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0122</td><td style="text-align:left"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II.md">Python</a></td><td style="text-align:left">数组、贪心算法</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0123</td><td style="text-align:left"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0123.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20III.md">Python</a></td><td style="text-align:left">数组、动态规划</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0188</td><td style="text-align:left"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机 IV</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0188.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20IV.md">Python</a></td><td style="text-align:left">数组、动态规划</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0309</td><td style="text-align:left"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0309.%20%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.md">Python</a></td><td style="text-align:left">数组、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0714</td><td style="text-align:left"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0714.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.md">Python</a></td><td style="text-align:left">贪心、数组、动态规划</td><td style="text-align:left">中等</td></tr></tbody></table></div><p>双串线性 DP 问题</p><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">1143</td><td style="text-align:left"><a href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/1143.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.md">Python</a></td><td style="text-align:left">字符串、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0712</td><td style="text-align:left">两个字符串的最小ASCII删除和</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0718</td><td style="text-align:left"><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">最长重复子数组</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0718.%20%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.md">Python</a></td><td style="text-align:left">数组、二分查找、动态规划、滑动窗口、哈希函数、滚动哈希</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0583</td><td style="text-align:left"><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">两个字符串的删除操作</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0583.%20%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.md">Python</a></td><td style="text-align:left">字符串、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0072</td><td style="text-align:left"><a href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0072.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.md">Python</a></td><td style="text-align:left">字符串、动态规划</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0044</td><td style="text-align:left"><a href="https://leetcode.cn/problems/wildcard-matching/">通配符匹配</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0044.%20%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D.md">Python</a></td><td style="text-align:left">贪心、递归、字符串、动态规划</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0010</td><td style="text-align:left"><a href="https://leetcode.cn/problems/regular-expression-matching/">正则表达式匹配</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0010.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.md">Python</a></td><td style="text-align:left">递归、字符串、动态规划</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0097</td><td style="text-align:left">交错字符串</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0115</td><td style="text-align:left"><a href="https://leetcode.cn/problems/distinct-subsequences/">不同的子序列</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0115.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.md">Python</a></td><td style="text-align:left">字符串、动态规划</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0087</td><td style="text-align:left">扰乱字符串</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></div><p>矩阵线性 DP 问题</p><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0118</td><td style="text-align:left"><a href="https://leetcode.cn/problems/pascals-triangle/">杨辉三角</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92.md">Python</a></td><td style="text-align:left">数组</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0119</td><td style="text-align:left"><a href="https://leetcode.cn/problems/pascals-triangle-ii/">杨辉三角 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II.md">Python</a></td><td style="text-align:left">数组</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0120</td><td style="text-align:left"><a href="https://leetcode.cn/problems/triangle/">三角形最小路径和</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0120.%20%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.md">Python</a></td><td style="text-align:left">数组、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0064</td><td style="text-align:left"><a href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0064.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.md">Python</a></td><td style="text-align:left">数组、动态规划、矩阵</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0174</td><td style="text-align:left">地下城游戏</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0221</td><td style="text-align:left"><a href="https://leetcode.cn/problems/maximal-square/">最大正方形</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0221.%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2.md">Python</a></td><td style="text-align:left">数组、动态规划、矩阵</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0931</td><td style="text-align:left">下降路径最小和</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0576</td><td style="text-align:left"><a href="https://leetcode.cn/problems/out-of-boundary-paths/">出界的路径数</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0576.%20%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0.md">Python</a></td><td style="text-align:left">动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0085</td><td style="text-align:left">最大矩形</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0363</td><td style="text-align:left">矩形区域不超过 K 的最大数值和</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">面试题 17.24</td><td style="text-align:left">最大子矩阵</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1444</td><td style="text-align:left">切披萨的方案数</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></div><p>无串线性 DP 问题</p><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">1137</td><td style="text-align:left"><a href="https://leetcode.cn/problems/n-th-tribonacci-number">第 N 个泰波那契数</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/1137.%20%E7%AC%AC%20N%20%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.md">Python</a></td><td style="text-align:left">记忆化搜索、数学、动态规划</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0650</td><td style="text-align:left"><a href="https://leetcode.cn/problems/2-keys-keyboard/">只有两个键的键盘</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0650.%20%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98.md">Python</a></td><td style="text-align:left">数学、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0264</td><td style="text-align:left"><a href="https://leetcode.cn/problems/ugly-number-ii/">丑数 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0264.%20%E4%B8%91%E6%95%B0%20II.md">Python</a></td><td style="text-align:left">哈希表、数学、动态规划、堆（优先队列）</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0279</td><td style="text-align:left"><a href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.md">Python</a></td><td style="text-align:left">广度优先搜索、数学、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0343</td><td style="text-align:left"><a href="https://leetcode.cn/problems/integer-break">整数拆分</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0343.%20%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.md">Python</a></td><td style="text-align:left">数学、动态规划</td><td style="text-align:left">中等</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;@[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;https://oi-wiki.org/dp/&quot;&gt;《OI Wiki动态规划》&lt;/a&gt;、&lt;a href=&quot;https://algo.itcharge.cn/10.Dynamic-Programming/01.Dynamic-Programming-Basic/01.Dynamic-Programming-Basic/&quot;&gt;《算法通关手册》动态规划篇&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、-动态规划基础知识&quot;&gt;&lt;a href=&quot;#一、-动态规划基础知识&quot; class=&quot;headerlink&quot; title=&quot;一、 动态规划基础知识&quot;&gt;&lt;/a&gt;一、 动态规划基础知识&lt;/h2&gt;&lt;h3 id=&quot;1-1-动态规划简介&quot;&gt;&lt;a href=&quot;#1-1-动态规划简介&quot; class=&quot;headerlink&quot; title=&quot;1.1 动态规划简介&quot;&gt;&lt;/a&gt;1.1 动态规划简介&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;&amp;#8195;&amp;#8195; &lt;strong&gt;动态规划（Dynamic Programming）&lt;/strong&gt;：简称 &lt;strong&gt;DP&lt;/strong&gt;，是一种通过把原问题分解为相对简单的子问题的方式而求解复杂问题的方法。&lt;/p&gt;
&lt;p&gt;动态规划方法与分治算法类似，却又不同于分治算法。&lt;/p&gt;
&lt;p&gt;「动态规划的核心思想」是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把「原问题」分解为「若干个重叠的子问题」，每个子问题的求解过程都构成一个 &lt;strong&gt;「阶段」&lt;/strong&gt;。在完成一个阶段的计算之后，动态规划方法才会执行下一个阶段的计算。&lt;/li&gt;
&lt;li&gt;在求解子问题的过程中，按照自底向上的顺序求解出「子问题的解」，把结果存储在表格中，当需要再次求解此子问题时，直接从表格中查询该子问题的解，从而避免了大量的重复计算。</summary>
    
    
    
    <category term="Data Structure and Algorithms" scheme="https://zhxnlp.github.io/categories/Data-Structure-and-Algorithms/"/>
    
    
    <category term="leetcode" scheme="https://zhxnlp.github.io/tags/leetcode/"/>
    
    <category term="Dynamic Programming" scheme="https://zhxnlp.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习八：背包问题</title>
    <link href="https://zhxnlp.github.io/2023/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E5%85%AB%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8B%EF%BC%9A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://zhxnlp.github.io/2023/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E5%85%AB%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8B%EF%BC%9A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-27T16:00:00.000Z</published>
    <updated>2023-04-08T02:34:14.239Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h2 id="一、背包问题简介"><a href="#一、背包问题简介" class="headerlink" title="一、背包问题简介"></a>一、背包问题简介</h2><blockquote><p>参考：</p><ul><li>【资料】<a href="https://algo.itcharge.cn/10.Dynamic-Programming/04.Knapsack-Problem/01.Knapsack-Problem-01/">算法通关手册</a>、<a href="https://github.com/tianyicui/pack">背包九讲 - 崔添翼</a></li><li>【文章】<a href="https://oi-wiki.org/dp/knapsack/">背包 DP - OI Wiki</a></li><li>【B站视频】<a href="https://www.bilibili.com/video/BV1cg411g7Y6/?spm_id_from=333.337.search-card.all.click&amp;vd_source=21011151235423b801d3f3ae98b91e94">代码随想录详解0-1背包</a></li></ul></blockquote><p>&#8195;&#8195; <strong>背包问题</strong>：背包问题是线性 DP 问题中一类经典而又特殊的模型。背包问题可以描述为：给定一组物品，每种物品都有自己的重量、价格以及数量。再给定一个最多能装重量为 $W$ 的背包。现在选择将一些物品放入背包中，请问在总重量不超过背包载重上限的情况下，能装入背包的最大价值总和是多少？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c10c789493f59d73c79ed764fa202957.png" alt=""><br><span id="more"></span><br>根据物品限制条件的不同，背包问题可分为：</p><ul><li>0-1 背包问题</li><li>完全背包问题</li><li>多重背包问题</li><li>分组背包问题</li><li>混合背包问题</li></ul><p><strong>背包问题的暴力解题思路</strong></p><p>&#8195;&#8195;背包问题的暴力解题思路比较简单。假设有 $n$ 件物品。我们先枚举出这 $n$ 件物品所有可能的组合（<strong>每个物品都是取与不取两个状态</strong>）。然后再判断这些组合中的物品是否能放入背包，以及是否能得到最大价值。这种做法的时间复杂度是 $O(2^n)$。</p><p>&#8195;&#8195;背包问题暴力解法的时间复杂度是指数级别的，我们可以利用动态规划算法减少一下时间复杂度。下面我们来讲解一下如何使用动态规划方法解决各种类型的背包问题。</p><h2 id="二、-0-1-背包问题"><a href="#二、-0-1-背包问题" class="headerlink" title="二、 0-1 背包问题"></a>二、 0-1 背包问题</h2><ul><li><strong>0-1 背包问题</strong>：有 $n$ 件物品和有一个最多能装重量为 $W$ 的背包。第 $i$ 件物品的重量为 $weight[i]$，价值为 $value[i]$，每件物品有且只有 $1$ 件。请问在总重量不超过背包载重上限的情况下，能装入背包的最大价值是多少？</li><li><strong>0-1 背包问题的特点</strong>：每种物品有且仅有 $1$ 件，可以选择不放入背包，也可以选择放入背包。<br><img src="https://img-blog.csdnimg.cn/img_convert/e29401dd67e9df4516ca35c533c6669a.png" alt=""></li></ul><h3 id="2-1-二维dp解法"><a href="#2-1-二维dp解法" class="headerlink" title="2.1 二维dp解法"></a>2.1 二维dp解法</h3><p>假如有编号0到2三件物品，其重量和价值分别为：<br>物品|重量    |价值<br>———— | ——-|——<br>物品0|    1|    15<br>物品1|    3|    20<br>物品2|    4|    30</p><p>现在背包重量为4，求其能装的物品最大价值是多少？</p><p>本题根据二维dp数组构造时，<font color='red'>第一行是否表示0个物品&lt;/font &gt;，有两种写法，其初始化也略有不同。</p><h4 id="2-1-1-第一行表示第一个物品"><a href="#2-1-1-第一行表示第一个物品" class="headerlink" title="2.1.1 第一行表示第一个物品"></a>2.1.1 第一行表示第一个物品</h4><blockquote><p>参考<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E4%BA%8C%E7%BB%B4dp%E6%95%B0%E7%BB%8401%E8%83%8C%E5%8C%85">《代码随想录》背包问题篇</a></p><ol><li>划分阶段<br>按照物品的序号、当前背包的载重上限进行阶段划分。</li><li>定义状态<br>构造二维数组，每行表示遍历的物品编码，每列表示遍历的背包重量<br><code>dp[i][j]</code> 表示<strong>遍历到第<code>i</code>个物品，背包剩余容量为<code>j</code>时，背包所装物品的最大价值</strong>。</li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/5592b5af7cbd462cabe59d810fcb497c.png" alt="在这里插入图片描述"></p><ol><li>状态转移方程<br>前<code>i</code>个物品的最大价值<code>dp[i][j]</code> ，可以由前<code>i-1</code>个物品的最大价值转换而来，这取决于是否放入第<code>i</code>个物品：</li></ol><ul><li>不放物品<code>i</code>：此时<code>dp[i][j]=dp[i - 1][j]</code>；<br>  当物品<code>i</code>的重量大于背包剩余容量<code>j</code>时，物品<code>i</code>无法放进背包中，背包内的价值依然和前面相同。</li><li>放物品<code>i</code>：<code>dp[i-1][j-weight[i]]</code> 为背包容量<code>j-weight[i]</code>时候不放物品<code>i</code>的最大价值，放入物品<code>i</code>后，其价值为<code>dp[i - 1][j - weight[i]] + value[i]</code> </li><li>最终结果取上述两种情况的最大值，即$max \lbrace dp[i - 1][w], \quad dp[i - 1][w - weight[i ]] + value[i] \rbrace$</li></ul><p>最终 <code>dp[i][j]</code> 取上述两种方式的最大值，所以状态转移方程为：</p><script type="math/tex; mode=display">dp[i][w] = \begin{cases} dp[i - 1][w] & w < weight[i ] \cr max \lbrace dp[i - 1][w], \quad dp[i - 1][w - weight[i ]] + value[i] \rbrace & w \ge weight[i] \end{cases}</script><blockquote><p>&#8195;&#8195;个人理解，之所以背包问题可以求得限定重量下的最大值，就在于每个阶段都取到当前的最优解，而这个最优解是每次都考虑是否取物品<code>i</code>而得来的，即$dp[i][j]=max \lbrace dp[i - 1][w], \quad dp[i - 1][w - weight[i ]] + value[i] \rbrace$</p><ol><li>状态初始化<ul><li>重量为0时，值为0，即<code>dp[i][0]=0</code></li><li>根据重量w是否大于value[0]，判断第一行是否可以装入物品0。</li></ul></li><li>最终结果<br>根据我们之前定义的状态，最终结果为 $dp[size][W]$，其中 $n$ 为物品的件数，$W$ 为背包的载重上限。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 思路 1：动态规划 + 二维基本思路</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zeroOnePackMethod1</span>(<span class="params">self, weight: [<span class="built_in">int</span>], value: [<span class="built_in">int</span>], W: <span class="built_in">int</span></span>):</span></span><br><span class="line">    size=<span class="built_in">len</span>(weight) <span class="comment"># 物品数量，weight和value分别是物品重量和价值的数组</span></span><br><span class="line"><span class="comment"># dp矩阵的行代表物品，列代表重量</span></span><br><span class="line">        dp=[[-<span class="number">1</span>]*(W+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment"># 初始化为任何值都可以</span></span><br><span class="line">        <span class="comment">#  重量为0时值为0，即初始化dp[i][0] = 0.也可以直接初始化数组值为0，跳过这一步</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 第1行，重量≥weight[0]时才初始化为value[0]</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j&gt;=weight[<span class="number">0</span>]:</span><br><span class="line">                dp[<span class="number">0</span>][j]=value[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j&lt;weight[i]:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-weight[i]]+value[i])</span><br><span class="line">        <span class="keyword">return</span> dp[size-<span class="number">1</span>][weight]</span><br></pre></td></tr></table></figure><h4 id="2-1-2-第一行表示0个物品"><a href="#2-1-2-第一行表示0个物品" class="headerlink" title="2.1.2 第一行表示0个物品"></a>2.1.2 第一行表示0个物品</h4><p>&#8195;&#8195;上述解法中，要根据重量W是否大于value[0]来判断第一行取值，单独进行初始化。为了简化这一步，可以将第一行表示为0个物品，这样第一行也初始化为0。<br>&#8195;&#8195;另外因为第一列也要初始化为0（<code>dp[i][0]=0</code>），所以整个dp数组都初始化为0 就行，简化了初始化步骤。唯一不同的是，构造dp数组时，<code>dp=[[-1]*(W+1) for _ in range(n+1)]</code> ，遍历物品数是物品数量+1</p><ol><li><p>划分阶段<br>按照物品的序号、当前背包的载重上限进行阶段划分。</p></li><li><p>定义状态</p><ul><li>定义状态 $dp[i][w]$ 表示为：前 $i$ 件物品放入一个最多能装重量为 $w$ 的背包中，可以获得的最大价值。</li><li>状态 $dp[i][w]$ 是一个二维数组，其中第一维代表<font color='red'>「当前正在考虑的物品」&lt;/font &gt;，第二维表示<font color='red'> 「当前背包的载重上限」&lt;/font &gt;，二维数组值表示「可以获得的最大价值」。</li></ul></li><li><p>状态转移方程</p><ul><li><p>根据第<code>i-1</code>件物品放与不放，可将问题转换为一个只跟前 $i - 1$ 件物品相关的问题。</p><ol><li><strong>第 $i - 1$ 件物品不放入背包</strong>：问题转换为「前 $i - 1$ 件物品放入一个最多能装重量为 $w$ 的背包中 ，可以获得的最大价值」，即 $dp[i - 1][w]$。</li><li><strong>第 $i - 1$ 件物品放入背包</strong>：问题转换为「前 $i - 1$ 件物品放入一个最多能装重量为 $w - weight[i - 1]$ 的背包中，可以获得的最大价值」为 $dp[i - 1][w - weight[i - 1]]$，再加上「放入的第 $i - 1$ 件物品的价值」为 $value[i - 1]$，则此时可以获得的最大价值为 $dp[i - 1][w - weight[i - 1]] + value[i - 1]$。</li></ol></li><li><p>接下来我们再来考虑一下第 $i - 1$ 件物品满足什么条件时才能考虑是否放入背包，并且在什么条件下一定不能放入背包。</p><ol><li>如果当前背包的载重不足时（即 $w &lt; weight[i - 1]$）：第 $i - 1$ 件物品一定不能放入背包，此时背包的价值 $dp[i][w]$ 仍为 $dp[i - 1][w]$ 时的价值，即 $dp[i][w] = dp[i - 1][w]$。</li><li>如果当前背包的载重足够时（即 $w \ge weight[i - 1]$）：第 $i - 1$ 件物品可以考虑放入背包，或者不放入背包，此时背包的价值取两种情况下的最大值，即 $dp[i][w] = max \lbrace dp[i - 1][w], dp[i - 1][w - weight[i - 1]] + value[i - 1] \rbrace$。</li></ol></li></ul></li></ol><ul><li>则状态转移方程为：</li></ul><script type="math/tex; mode=display">dp[i][w] = \begin{cases} dp[i - 1][w] & w < weight[i - 1] \cr max \lbrace dp[i - 1][w], \quad dp[i - 1][w - weight[i - 1]] + value[i - 1] \rbrace & w \ge weight[i - 1] \end{cases}</script><ol><li><p>初始条件</p><ul><li>如果背包容量为 $0$，则无论选取什么物品，可以获得的最大价值一定是 $0$，即 $dp[i][0] = 0$。</li><li>前 $0$ 件物品所能获得的最大价值一定为 $0$，即 $dp[0][w] = 0$。</li></ul></li><li><p>最终结果<br>根据我们之前定义的状态，$dp[i][w]$ 表示为：前 $i$ 件物品放入一个最多能装重量为 $w$ 的背包中，可以获得的最大价值。则最终结果为 $dp[size][W]$，其中 $size$ 为物品的件数，$W$ 为背包的载重上限。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 思路 1：动态规划 + 二维基本思路</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zeroOnePackMethod1</span>(<span class="params">self, weight: [<span class="built_in">int</span>], value: [<span class="built_in">int</span>], W: <span class="built_in">int</span></span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(weight)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(W + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举前 i 种物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size + <span class="number">1</span>): <span class="comment"># 遍历数是size+1，所以第i件物品下标是i-1</span></span><br><span class="line">            <span class="comment"># 枚举背包装载重量</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(W + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 第 i - 1 件物品装不下</span></span><br><span class="line">                <span class="keyword">if</span> j &lt; weight[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># dp[i][w] 取「前 i - 1 件物品装入载重为 w 的背包中的最大价值」</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># dp[i][w] 取「前 i - 1 件物品装入载重为 w 的背包中的最大价值」与「前 i - 1 件物品装入载重为 w - weight[i - 1] 的背包中，再装入第 i - 1 物品所得的最大价值」两者中的最大值</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>])</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> dp[size][W]</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n \times W)$，其中 $n$ 为物品数量，$W$ 为背包的载重上限。</li><li><strong>空间复杂度</strong>：$O(n \times W)$。</li></ul><h3 id="2-2-一维dp解法"><a href="#2-2-一维dp解法" class="headerlink" title="2.2 一维dp解法"></a>2.2 一维dp解法</h3><h4 id="2-2-1-使用两个一维数组"><a href="#2-2-1-使用两个一维数组" class="headerlink" title="2.2.1 使用两个一维数组"></a>2.2.1 使用两个一维数组</h4><p>二维dp的状态转移方程为：</p><script type="math/tex; mode=display">dp[i][w] = \begin{cases} dp[i - 1][w] & w < weight[i - 1] \cr max \lbrace dp[i - 1][w], \quad dp[i - 1][w - weight[i - 1]] + value[i - 1] \rbrace & w \ge weight[i - 1] \end{cases}</script><p>&#8195;&#8195;由此可知，第 $i$ 行的值 $dp[i][w]$ ，只跟上一行的状态$dp[i - 1][w]$、$dp[i - 1][w - weight[i - 1]]$有关。这样使用两个一维数组分别保存相邻两个阶段的所有状态就可以实现了。即：用 $dp[0][w]$ 保存原先 $dp[i - 1][w]$ 的状态，用 $dp[1][w]$ 保存当前 $dp[i][w]$ 的状态。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 思路 2：动态规划 + 滚动数组优化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zeroOnePackMethod2</span>(<span class="params">self, weight: [<span class="built_in">int</span>], value: [<span class="built_in">int</span>], W: <span class="built_in">int</span></span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(weight)</span><br><span class="line">        dp = [<span class="number">0</span>] * (W+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举前 i 种物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size + <span class="number">1</span>):</span><br><span class="line">            dp2 = [<span class="number">0</span>] * (W+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(W+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; nums[i-<span class="number">1</span>]:       <span class="comment"># 容量有限，无法选择第i个数字nums[i-1]</span></span><br><span class="line">                    dp2[j] = dp[j]</span><br><span class="line">                <span class="keyword">else</span>:                   <span class="comment"># 可选择第i个数字nums[i-1]，也可不选【两种方式之和】</span></span><br><span class="line">                    dp2[j] = <span class="built_in">max</span>(dp[j] , dp[j-weight[i-<span class="number">1</span>]]+value[i-<span class="number">1</span>]</span><br><span class="line">            dp = dp2</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[W]</span><br></pre></td></tr></table></figure></p><ul><li><strong>时间复杂度</strong>：$O(n \times W)$，其中 $n$ 为物品数量，$W$ 为背包的载重上限。</li><li><strong>空间复杂度</strong>：$O(W)$。<h4 id="2-2-2-使用一个一维数组"><a href="#2-2-2-使用一个一维数组" class="headerlink" title="2.2.2 使用一个一维数组"></a>2.2.2 使用一个一维数组</h4>&#8195;&#8195;更进一步的，我们将上一行的状态复制到当前行，然后在当前行进行计算，这样只需要使用一个一维数组 $dp[w]$ 就可以了。<br>&#8195;&#8195;每次都将上一层覆盖到当前层进行计算，再覆盖到下一层计算……，每次计算都在更新数组，这就是「滚动数组」的由来，最终去掉动态规划状态的第一维。</li></ul><ol><li><p>划分阶段<br>按照当前背包的载重上限进行阶段划分。</p></li><li><p>定义状态<br>定义状态 $dp[w]$ 表示为：将物品装入最多能装重量为 $w$ 的背包中，可以获得的最大价值。</p></li><li><p>状态转移方程</p><ul><li>不放物品<code>i-1</code>时，将上一层数组复制下来，所以也是$dp[w]$</li><li>放入物品<code>i-1</code>时，则为$dp[w - weight[i - 1]]  + value[i - 1]$</li></ul></li></ol><p>最终取最大就是dp[w]的值：<br>&#8195;&#8195;$dp[w] = \begin{cases} dp[w] &amp; w &lt; weight[i - 1] \cr max \lbrace dp[w], dp[w - weight[i - 1]]  + value[i - 1] \rbrace &amp; w \ge weight[i - 1] \end{cases}$</p><ol><li>倒序遍历（保证每个物品只被选取一次）</li></ol><p>&#8195;&#8195;在第 $i$ 轮计算之前，$dp[w]$ 中保存的是「第 $i - 1$ 阶段的所有状态值」。在第 $i$ 轮计算之后，$d[w]$ 中保存的是「第 $i$ 阶段的所有状态值」。<br>&#8195;&#8195;为了保证第 $i$ 轮计算过程中，$dp[w]$ 是由第 $i - 1$ 轮中 $dp[w]$ 和 $dp[w - weight[i - 1]]$ 两个状态递推而来的值，我们需要按照「从 $W \sim 0$ 逆序的方式」倒推 $dp[w]$。<br>&#8195;&#8195;这是因为如果我们采用「从 $0 \sim W$ 正序递推的方式」递推 $dp[w]$，如果当前状态 $dp[w - weight[i]]$ 已经更新为当前第 $i$ 阶段的状态值。那么在向右遍历到 $dp[w]$ 时，我们需要的是第 $i - 1$ 阶段的状态值（即上一阶段的 $dp[w - weight[i - 1]]$），而此时 $dp[w - weight[i - 1]]$ 已经更新了，会破坏当前阶段的状态值，从而无法推出正确结果。<br>&#8195;&#8195;而如果按照「从 $W \sim 0$ 逆序的方式」倒推 $dp[w]$ 则不会出现该问题。<br>&#8195;&#8195;因为 $w &lt; weight[i - 1]$ 时，$dp[w]$ 只能取上一阶段的 $dp[w]$，其值相当于没有变化，这部分可以不做处理。所以我们在逆序倒推 $dp[w]$ 时，只需遍历到 $weight[i - 1]$ 时即可。</p><ol><li><p>初始条件</p><ul><li>$dp[0] = 0$。</li><li>dp数组中其它数值也必须初始化为0，因为涉及到计算$max(dp[w],dp[w - weight[i - 1]]  + value[i - 1]$</li></ul></li><li><p>最终结果<br>根据我们之前定义的状态， $dp[w]$ 表示为：将物品装入最多能装重量为 $w$ 的背包中，可以获得的最大价值。则最终结果为 $dp[W]$，其中 $W$ 为背包的载重上限。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 思路 2：动态规划 + 滚动数组优化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zeroOnePackMethod2</span>(<span class="params">self, weight: [<span class="built_in">int</span>], value: [<span class="built_in">int</span>], W: <span class="built_in">int</span></span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(weight)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(W + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举前 i 种物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 倒序枚举背包装载重量（避免状态值错误）</span></span><br><span class="line">            <span class="comment"># 因为是倒序，起点是W而不是W-1,终点是 weight[i-1]-1保证可以遍历到weight[i-1]</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(W, weight[i - <span class="number">1</span>] - <span class="number">1</span>, -<span class="number">1</span>): </span><br><span class="line">                <span class="comment"># dp[w] 取「前 i - 1 件物品装入载重为 w 的背包中的最大价值」与「前 i - 1 件物品装入载重为 w - weight[i - 1] 的背包中，再装入第 i - 1 物品所得的最大价值」两者中的最大值</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[W]</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n \times W)$，其中 $n$ 为物品数量，$W$ 为背包的载重上限。</li><li><strong>空间复杂度</strong>：$O(W)$。</li></ul><h3 id="2-3-0-1背包应用"><a href="#2-3-0-1背包应用" class="headerlink" title="2.3 0-1背包应用"></a>2.3 0-1背包应用</h3><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0416</td><td style="text-align:left"><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0416.%20%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.md">Python</a></td><td style="text-align:left">数组、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0494</td><td style="text-align:left"><a href="https://leetcode.cn/problems/target-sum/">目标和</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0494.%20%E7%9B%AE%E6%A0%87%E5%92%8C.md">Python</a></td><td style="text-align:left">深度优先搜索、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">1049</td><td style="text-align:left"><a href="https://leetcode.cn/problems/last-stone-weight-ii/">最后一块石头的重量 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/1049.%20%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F%20II.md">Python</a></td><td style="text-align:left">数组、动态规划</td><td style="text-align:left">中等</td></tr></tbody></table></div><h4 id="2-3-1-分割等和子集（最大背包价值）"><a href="#2-3-1-分割等和子集（最大背包价值）" class="headerlink" title="2.3.1 分割等和子集（最大背包价值）"></a>2.3.1 分割等和子集（最大背包价值）</h4><blockquote><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集 - 力扣</a></p></blockquote><p>&#8195;&#8195;给定一个只包含正整数的非空数组 $nums$，判断是否可以将这个数组分成两个子集，使得两个子集的元素和相等。</p><ul><li>$1 \le nums.length \le 200$。</li><li>$1 \le nums[i] \le 100$。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">5</span>]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>] 和 [<span class="number">11</span>]。</span><br></pre></td></tr></table></figure><p><strong>思路 1：动态规划</strong></p><p>这道题换一种说法就是：从数组中选择一些元素组成一个子集，使子集的元素和恰好等于整个数组元素和的一半。这样的话，这道题就可以转变为「0-1 背包问题」。</p><ol><li>把整个数组中的元素和记为 $sum$，把元素和的一半 $target = \frac{sum}{2}$ 看做是「0-1 背包问题」中的背包容量。</li><li>把数组中的元素 $nums[i]$ 看做是「0-1 背包问题」中的物品。</li><li>第 $i$ 件物品的重量为 $nums[i]$，价值也为 $nums[i]$。</li><li>因为物品的重量和价值相等，如果能装满载重上限为 $target$ 的背包，那么得到的最大价值也应该是 $target$。</li></ol><p>&#8195;&#8195;这样问题就转变为：给定一个数组 $nums$ 代表物品，数组元素和的一半 $target = \frac{sum}{2}$ 代表背包的载重上限。其中第 $i$ 件物品的重量为 $nums[i]$，价值为 $nums[i]$，每件物品有且只有 $1$ 件。请问在总重量不超过背包载重上限的情况下，能否将背包装满从而得到最大价值？</p><ol><li><p>划分阶段<br>按照当前背包的载重上限进行阶段划分。</p></li><li><p>定义状态<br>定义状态 $dp[w]$ 表示为：从数组 $nums$ 中选择一些元素，放入最多能装元素和为 $w$ 的背包中，得到的元素和最大为多少。</p></li><li><p>状态转移方程<br>$dp[w] = \begin{cases} dp[w] &amp; w &lt; nums[i - 1] \cr max \lbrace dp[w], \quad dp[w - nums[i - 1]] + nums[i - 1] \rbrace &amp; w \ge nums[i - 1] \end{cases}$</p></li><li><p>初始条件<br>如果背包容量为 $0$，则无论选取什么元素，可以获得的元素和一定是 $0$，即 $dp[0] = 0$。</p></li><li><p>最终结果<br>&#8195;&#8195;根据我们之前定义的状态，$dp[target]$ 表示为：从数组 $nums$ 中选择一些元素，放入最多能装元素和为 $target = \frac{sum}{2}$ 的背包中，得到的元素和最大值。<br>&#8195;&#8195;所以最后判断一下 $dp[target]$ 是否等于 $target$。如果 $dp[target] == target$，则说明集合中的子集刚好能够凑成总和 $target$，此时返回 <code>True</code>；否则返回 <code>False</code>。</p></li></ol><h5 id="2-3-1-1-二维dp数组"><a href="#2-3-1-1-二维dp数组" class="headerlink" title="2.3.1.1 二维dp数组"></a>2.3.1.1 二维dp数组</h5><ol><li><code>for i in range(n)</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s=<span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> s%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        weight=s/<span class="number">2</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">       <span class="comment"># dp矩阵的行代表物品，列代表重量，第一行表示第一种物品</span></span><br><span class="line">        dp=[[-<span class="number">1</span>]*(weight+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment">#  重量为0时值为0，即初始化dp[i][0] = 0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 第1行，重量≥nums[0]时才初始化为nums[0]</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j&gt;=nums[<span class="number">0</span>]:</span><br><span class="line">                dp[<span class="number">0</span>][j]=nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j&lt;nums[i]:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-nums[i]]+nums[i])</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][weight]==weight</span><br></pre></td></tr></table></figure></li><li><code>for i in range(1,n+1)</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s=<span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> s%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        weight=s/<span class="number">2</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">       <span class="comment"># dp矩阵的行代表物品，列代表重量，第一行表示第一种物品</span></span><br><span class="line">        dp=[[<span class="number">0</span>]*(weight+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j&lt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]]+nums[i-<span class="number">1</span>])</span><br><span class="line">        <span class="comment">#print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][weight]==weight        </span><br></pre></td></tr></table></figure></li></ol><h5 id="2-3-1-2-一维dp数组"><a href="#2-3-1-2-一维dp数组" class="headerlink" title="2.3.1.2 一维dp数组"></a>2.3.1.2 一维dp数组</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 从数组中选择一些元素组成一个子集，使子集的元素和恰好等于整个数组元素和的一半。这样的话，这道题就可以转变为「0-1 背包问题」</span></span><br><span class="line">        s=<span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> s%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        weight=s/<span class="number">2</span></span><br><span class="line">        <span class="comment">#n=len(nums)</span></span><br><span class="line">        </span><br><span class="line">       <span class="comment"># dp矩阵的行代表物品，列代表重量.特别的，第一行表示0个物品，dp[0][j]=0，方便初始化</span></span><br><span class="line">        dp=[<span class="number">0</span>] *(weight+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:  <span class="comment"># 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight,num - <span class="number">1</span>,-<span class="number">1</span>):  <span class="comment"># 遍历到上一层容量，nums[i]-1保证遍历到nums[i]</span></span><br><span class="line">         </span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-num]+num)</span><br><span class="line">                <span class="comment">#print(nums[i],dp)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[weight]==weight</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight,nums[i] - <span class="number">1</span>,-<span class="number">1</span>):  <span class="comment"># 遍历到上一层容量，nums[i]-1保证遍历到nums[i]</span></span><br><span class="line"> </span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-nums[i]]+nums[i])</span><br><span class="line">        <span class="comment">#print(nums[i],dp)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[weight]==weight</span><br></pre></td></tr></table></figure><p>也可以是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):  <span class="comment"># 遍历物品</span></span><br><span class="line">     <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight,nums[i-<span class="number">1</span>] - <span class="number">1</span>,-<span class="number">1</span>):  <span class="comment"># 遍历到上一层容量，nums[i]-1保证遍历到nums[i]</span></span><br><span class="line">  </span><br><span class="line">         dp[j]=<span class="built_in">max</span>(dp[j],dp[j-nums[i-<span class="number">1</span>]]+nums[i-<span class="number">1</span>])</span><br><span class="line">         <span class="comment">#print(nums[i],dp)</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> dp[weight]==weight</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n \times target)$，其中 $n$ 为数组 $nums$ 的元素个数，$target$ 是整个数组元素和的一半。</li><li><strong>空间复杂度</strong>：$O(target)$。</li></ul><h4 id="2-3-2-目标和（装满背包的方式）"><a href="#2-3-2-目标和（装满背包的方式）" class="headerlink" title="2.3.2 目标和（装满背包的方式）"></a>2.3.2 目标和（装满背包的方式）</h4><blockquote><ul><li>题目：<a href="https://leetcode.cn/problems/target-sum/">494 目标和</a></li><li>参考题解：<a href="https://leetcode.cn/problems/target-sum/solution/by-flix-rkb5/">《『 一文搞懂 0-1背包问题 』记忆化搜索、动态规划 + 空间优化》</a></li></ul><p>&#8195;&#8195;给定一个整数数组 nums 和一个整数 target。数组长度不超过 20。向数组中每个整数前加 + 或 -。然后串联起来构造成一个表达式。<br>&#8195;&#8195;返回通过上述方法构造的、运算结果等于 target 的不同表达式数目。</p></blockquote><p>示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一共有 <span class="number">5</span> 种方法让最终目标和为 <span class="number">3</span>。</span><br><span class="line">-<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">+<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> - <span class="number">1</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h5 id="2-3-2-1-记忆化搜索"><a href="#2-3-2-1-记忆化搜索" class="headerlink" title="2.3.2.1 记忆化搜索"></a>2.3.2.1 记忆化搜索</h5><p>&#8195;&#8195;使用哈希表 $table$ 记录遍历过的位置 $i$ 及所得到的的当前和<code>cur_sum</code> 下的方案数，来避免重复搜索。具体步骤如下：</p><ol><li>定义从位置 $0$、和为 $0$ 开始，到达数组尾部位置为止，和为 $target$ 的方案数为 <code>dfs(0, 0)</code>。</li><li>下面从位置 $0$、和为 $0$ 开始，以深度优先搜索遍历每个位置。</li><li>如果当前位置 $i$ 遍历完所有位置：<ol><li>如果和 <code>cur_sum</code> 等于目标和 $target$，则返回方案数 $1$。</li><li>如果和 <code>cur_sum</code> 不等于目标和 $target$，则返回方案数 $0$。</li></ol></li><li>如果当前位置 $i$、和为 <code>cur_sum</code>  之前记录过（即使用 $table$ 记录过对应方案数），则返回该方案数。</li><li>如果当前位置 $i$、和为 <code>cur_sum</code>  之前没有记录过，则：<ol><li>递归搜索 $i + 1$ 位置，和为 <code>cur_sum  -  nums[i]</code> 的方案数。</li><li>递归搜索 $i + 1$ 位置，和为 <code>cur_sum  +  nums[i]</code> 的方案数。</li><li>将上述两个方案数加起来就是当前位置 $i$、和为 <code>cur_sum</code> 的方案数，将其记录到哈希表 $table$ 中，并返回该方案数。</li></ol></li><li>最终方案数为 <code>dfs(0, 0)</code>，将其作为答案返回</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        table = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, cur_sum</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i == size:</span><br><span class="line">                <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> (i, cur_sum) <span class="keyword">in</span> table:</span><br><span class="line">                <span class="keyword">return</span> table[(i, cur_sum)]</span><br><span class="line">            </span><br><span class="line">            cnt = dfs(i + <span class="number">1</span>, cur_sum - nums[i]) + dfs(i + <span class="number">1</span>, cur_sum + nums[i])</span><br><span class="line">            table[(i, cur_sum)] = cnt</span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(2^n)$。其中 $n$ 为数组 $nums$ 的长度。</li><li><strong>空间复杂度</strong>：$O(n)$。递归调用的栈空间深度不超过 $n$。</li></ul><h5 id="2-3-2-2-二维dp数组"><a href="#2-3-2-2-二维dp数组" class="headerlink" title="2.3.2.2 二维dp数组"></a>2.3.2.2 二维dp数组</h5><p><strong>1. 解题思路</strong><br>&#8195;&#8195;假设数组中所有元素和为 sum，数组中所有符号为 + 的元素为 pos，符号为 - 的元素和为neg。则 target = pos-neg。而 sum=pos+neg。根据两个式子可以求出 neg=(sum-target)/2。</p><p>&#8195;&#8195;那么这道题就变成了，如何在数组中找到一个集合，使集合中元素和为 (target + sum) / 2。这就变为了求容量为 (target + sum) / 2 的 0-1 背包问题。</p><p>&#8195;&#8195;对于本题而言，nums[i] 则对应于常规背包问题中第 i 件物品的重量。我们要做的是从数组 nums 中选出若干个数字（每个元素最多选一次）使得其和刚好等于 (target + sum) / 2 ，并计算有多少种不同的选择方式。</p><p><strong>2. 解题步骤</strong></p><ol><li>定义：定义 <code>dp[i][j]</code> 表示：从前 i 个数字中选出若干个，使得被选出的数字其和为 j 的方案数目（没有价值表示）。</li><li>状态转移方程：<br>根据本题的要求，上述「0-1 背包问题」的状态转移方程（1）可修改为：<script type="math/tex; mode=display">dp[i][j]=dp[i−1][j] + dp[i−1][j−nums[i]]</script></li><li>初始化</li></ol><p>&#8195;&#8195;最优解的背包问题中，有的题目要求<font color='red'> 恰好装满背包时的最优解&lt;/font &gt;，有的题目则要求<font color='red'> 不超过背包容量时的最优解&lt;/font &gt;。一种区别这两种问法的实现方法是在状态初始化的时候有所不同。</p><ul><li>如果要求<strong>恰好装满背包</strong>，那么在初始化时 dp[i][0]=0，其它 dp[i][1,2,…,∗] 均设为 −∞。这是因为此时只有容量为 0 的背包可能被价值为 0 的 nothing “恰好装满”，而其它容量的背包均没有合法的解，属于未定义的状态。</li><li>如果只是要求不超过背包容量而使得背包中的物品价值尽量大，初始化时应将 dp[∗][∗] 全部设为 0。这是因为对应于任何一个背包，都有一个合法解为 “什么都不装”，价值为 0</li></ul><p>&#8195;&#8195;本题中，构造dp二维数组时，其维度为<code>[neg+1,n+1]</code>，即第一行可以为0个物品，则初始化为：</p><ul><li><code>dp[0][0]=1</code>：表示从前 0 个数字中选出若干个数字使得其和为 0 的方案数为 1，即「空集合」不选任何数字即可得到 0。</li><li>对于其他 <code>dp[0][j]</code>,  <code>j≥1</code>，则有 <code>dp[0][j]=0</code>：「空集合」无法选出任何数字使得其和为 <code>j≥1</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        total=<span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> (total-target)%<span class="number">2</span>==<span class="number">1</span>: <span class="comment"># 不能被2整除的不行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(target)&gt;total:  <span class="comment"># 目标可能为负，绝对值大于总和都不行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        neg,pos=(total-target)//<span class="number">2</span> ,(total+target)//<span class="number">2</span></span><br><span class="line">        weight=<span class="built_in">min</span>(neg,pos) <span class="comment"># 取二者最小值</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 求和为weight的背包问题</span></span><br><span class="line">        <span class="comment"># 定义 dp[i][j] 表示：从前 i 个数字中选出若干个，使得被选出的数字其和为 j 的方案数目</span></span><br><span class="line">        dp=[[<span class="number">0</span>]*(weight+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span> <span class="comment">#  其他 dp[0][j]均为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j&lt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[n][weight]</span><br></pre></td></tr></table></figure><h5 id="2-3-2-3-一维数组"><a href="#2-3-2-3-一维数组" class="headerlink" title="2.3.2.3 一维数组"></a>2.3.2.3 一维数组</h5><p>&#8195;&#8195;在状态转移过程中，每一行的 dp 状态值都只与其正上方和左上方的状态值有关，即<code>dp[j]=dp[j]+dp[j-nums[i-1]]</code><br><img src="https://img-blog.csdnimg.cn/700df5fd0da44d508483ea7906bfcc4d.png" alt="在这里插入图片描述"><br>&#8195;&#8195;考虑到我我们在更新 dp[j] 时，使用的其实是上一行的 dp 值；而如果第二层循环从小到大计算的话，那么 dp[j−nums[i−1]] 先于 dp[j] 被更新，因此当我们计算 dp[j] 值的时候，dp[j−nums[i−1]] 已经是被更新过的状态，而不再是上一行的 dp 值了。</p><p>&#8195;&#8195;而在第二层循环中，通过从大到小倒序计算则可巧妙地保证在计算 dp[j] 时所用到的 dp[j] 和 dp[j−nums[i−1]] 均来自上一行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        total=<span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> (total-target)%<span class="number">2</span>==<span class="number">1</span>: <span class="comment"># 不能被2整除的不行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(target)&gt;total:  <span class="comment"># 目标可能为负，绝对值大于总和都不行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        neg,pos=(total-target)//<span class="number">2</span>,(total+target)//<span class="number">2</span></span><br><span class="line">        weight=<span class="built_in">min</span>(neg,pos)</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 求和为weight的背包问题</span></span><br><span class="line">        <span class="comment"># 定义 dp[w] 表示：被选出的数字其和为 w 的方案数目</span></span><br><span class="line">        dp=[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(weight+<span class="number">1</span>)]        </span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight,nums[i-<span class="number">1</span>]-<span class="number">1</span>,-<span class="number">1</span>):               </span><br><span class="line">                    dp[j]=dp[j]+dp[j-nums[i-<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[weight]</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight,num-<span class="number">1</span>,-<span class="number">1</span>):               </span><br><span class="line">    dp[j]=dp[j]+dp[j-num]</span><br></pre></td></tr></table></figure><h4 id="2-3-3-最后一块石头的重量-II-（最大背包价值）"><a href="#2-3-3-最后一块石头的重量-II-（最大背包价值）" class="headerlink" title="2.3.3 最后一块石头的重量 II  （最大背包价值）"></a>2.3.3 最后一块石头的重量 II  （最大背包价值）</h4><blockquote><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">最后一块石头的重量 II</a>   </p></blockquote><p>&#8195;&#8195;有一堆石头，用整数数组 <code>stones</code> 表示，其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。每一回合，从石头中选出任意两块石头，将这两块石头一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>。且 <code>x ≤ y</code>，则结果如下：</p><ul><li>如果 <code>x == y</code>，则两块石头都会被完全粉碎；</li><li>如果 <code>x &lt; y</code>，则重量为 x 的石头被完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y - x</code>。</li><li>最后，最多只会剩下一块石头，返回此石头的最小可能重量。如果没有石头剩下，则返回 <code>0</code>。       </li></ul><p><strong>解题思路</strong><br>&#8195;&#8195;选取两块石头，重新放回去的重量是两块石头的差值绝对值。重新放回去的石头还会进行选取，然后进行粉碎，直到最后只剩一块或者不剩石头。</p><p>&#8195;&#8195;这个问题其实可以转化为：把一堆石头尽量平均的分成两对，求两堆石头重量差的最小值。这就和「 0416. 分割等和子集」有点相似。两堆石头的重量要尽可能的接近数组总数量和的一半。</p><p>&#8195;&#8195;进一步可以变为：假设石头总重量和为 <code>sum</code>，则问题为将一堆石头放进容量最多为 <code>sum / 2</code> 的背包中，获得的最大价值为 <code>max_weight</code>（即其中一堆石子的重量），则另一堆石子的重量为 <code>sum - max_weight</code>。则两者的差值为 <code>sum - 2 * max_weight</code>，即为答案。</p><h5 id="2-3-3-1-二维dp解法：遍历物品数-n-1"><a href="#2-3-3-1-二维dp解法：遍历物品数-n-1" class="headerlink" title="2.3.3.1  二维dp解法：遍历物品数=n+1"></a>2.3.3.1  二维dp解法：遍历物品数=n+1</h5><p>&#8195;&#8195;二维dp数组，第一行表示没有物品，则遍历物品数为物品数+1（n+1），此时数组全部初始化为 0即可：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeightII</span>(<span class="params">self, stones</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type stones: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        weight=<span class="built_in">sum</span>(stones)//<span class="number">2</span></span><br><span class="line">        n=<span class="built_in">len</span>(stones)</span><br><span class="line">        dp=[[<span class="number">0</span>]*(weight+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j&lt;stones[i-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-stones[i-<span class="number">1</span>]]+stones[i-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stones)-<span class="number">2</span>*dp[n][weight]</span><br></pre></td></tr></table></figure></p><h5 id="2-3-3-2-二维dp解法：遍历物品数-n"><a href="#2-3-3-2-二维dp解法：遍历物品数-n" class="headerlink" title="2.3.3.2  二维dp解法：遍历物品数=n"></a>2.3.3.2  二维dp解法：遍历物品数=n</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeightII</span>(<span class="params">self, stones</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type stones: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        weight=<span class="built_in">sum</span>(stones)//<span class="number">2</span></span><br><span class="line">        n=<span class="built_in">len</span>(stones)</span><br><span class="line">        dp=[[<span class="number">0</span>]*(weight+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight+<span class="number">1</span>): <span class="comment"># 重量大于stones[0]才能装下第一个物品</span></span><br><span class="line">            <span class="keyword">if</span> j&gt;=stones[<span class="number">0</span>]:</span><br><span class="line">                dp[<span class="number">0</span>][j]=stones[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 这里写成range(1，n)也行</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j&lt;stones[i]:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-stones[i]]+stones[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stones)-<span class="number">2</span>*dp[n-<span class="number">1</span>][weight]</span><br></pre></td></tr></table></figure><h5 id="2-3-3-3-一维dp解法：遍历物品数-n"><a href="#2-3-3-3-一维dp解法：遍历物品数-n" class="headerlink" title="2.3.3.3 一维dp解法：遍历物品数=n"></a>2.3.3.3 一维dp解法：遍历物品数=n</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeightII</span>(<span class="params">self, stones</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type stones: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        weight=<span class="built_in">sum</span>(stones)//<span class="number">2</span></span><br><span class="line">        n=<span class="built_in">len</span>(stones)</span><br><span class="line">        dp=[<span class="number">0</span>]*(weight+<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight,stones[i]-<span class="number">1</span>,-<span class="number">1</span>):               </span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-stones[i]]+stones[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stones)-<span class="number">2</span>*dp[weight]</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> stones:</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight,num-<span class="number">1</span>,-<span class="number">1</span>):               </span><br><span class="line">    dp[j]=<span class="built_in">max</span>(dp[j],dp[j-num]+num)</span><br></pre></td></tr></table></figure><h2 id="三、-完全背包问题"><a href="#三、-完全背包问题" class="headerlink" title="三、 完全背包问题"></a>三、 完全背包问题</h2><blockquote><p>参考：</p><ul><li>【资料】<a href="https://github.com/tianyicui/pack">背包九讲 - 崔添翼</a></li><li>【文章】<a href="https://oi-wiki.org/dp/knapsack/">背包 DP - OI Wiki</a></li><li>【文章】<a href="https://juejin.cn/post/7003243733604892685">背包问题 第四讲 - 宫水三叶的刷题日记</a></li><li>【题解】<a href="https://leetcode.cn/problems/perfect-squares/solution/by-flix-sve5/">『 套用完全背包模板 』详解完全背包（含数学推导） - 完全平方数 - 力扣</a></li><li>【题解】<a href="https://leetcode.cn/problems/coin-change/solution/by-flix-su7s/">『 一文搞懂完全背包问题 』从0-1背包到完全背包，逐层深入+推导 - 零钱兑换 - 力扣</a></li><li><strong>完全背包问题</strong>：有 $n$ 种物品和一个最多能装重量为 $W$ 的背包，第 $i$ 种物品的重量为 $weight[i]$，价值为 $value[i]$，每种物品数量没有限制。请问在总重量不超过背包载重上限的情况下，能装入背包的最大价值是多少？</li><li><strong>完全背包问题的特点</strong>：每种物品有无限件。<br><img src="https://img-blog.csdnimg.cn/img_convert/7fa677a31bdc61c85a2e6654d726538d.png" alt=""></li></ul></blockquote><h3 id="3-1-基础思路：二维数组（三重循环）"><a href="#3-1-基础思路：二维数组（三重循环）" class="headerlink" title="3.1 基础思路：二维数组（三重循环）"></a>3.1 基础思路：二维数组（三重循环）</h3><p>&#8195;&#8195;我们可以参考「0-1 背包问题」的状态定义和基本思路，对于容量为 $w$ 的背包，最多可以装 $\frac{w}{weight[i - 1]}$ 件第 $i - 1$ 件物品。那么我们可以多加一层循环，枚举第 $i - 1$ 件物品可以选择的件数（$0 \sim \frac{w}{weight[i - 1]}$），从而将「完全背包问题」转换为「0-1 背包问题」。</p><ol><li><p>划分阶段<br>按照物品种类的序号、当前背包的载重上限进行阶段划分。</p><ol><li>定义状态<ul><li>定义状态 $dp[i][w]$ 表示为：前 $i$ 种物品放入一个最多能装重量为 $w$ 的背包中，可以获得的最大价值。</li><li>状态 $dp[i][w]$ 是一个二维数组，其中第一维代表「当前正在考虑的物品种类」，第二维表示「当前背包的载重上限」，二维数组值表示「可以获得的最大价值」。</li></ul></li></ol></li><li><p>状态转移方程<br>由于每种物品可选的数量没有限制，因此状态 $dp[i][w]$ 可能从以下方案中选择最大值：</p><ol><li>选择 $0$ 件第 $i - 1$ 件物品：可以获得的最大价值为 $dp[i - 1][w]$</li><li>选择 $1$ 件第 $i - 1$ 件物品：可以获得的最大价值为 $dp[i - 1][w - weight[i - 1]] + value[i - 1]$。</li><li>选择 $2$ 件第 $i - 1$ 件物品：可以获得的最大价值为 $dp[i - 1][w - 2 \times weight[i - 1]] + 2 \times value[i - 1]$。</li><li>……</li><li>选择 $k$ 件第 $i - 1$ 件物品：可以获得的最大价值为 $dp[i - 1][w - k \times weight[i - 1]] + k \times value[i - 1]$。</li></ol></li></ol><blockquote><p>注意：选择 $k$ 件第 $i - 1$ 件物品的条件是 $0 \le k \times weight[i - 1] \le w$。</p></blockquote><p>则状态转移方程为：</p><script type="math/tex; mode=display">dp[i][w] = max \lbrace dp[i - 1][w - k \times weight[i - 1]] + k \times value[i - 1] \rbrace，\quad 0 \le k \times weight[i - 1] \le w</script><ol><li><p>初始条件</p><ul><li>如果背包容量为 $0$，则无论选取什么物品，可以获得的最大价值一定是 $0$，即 $dp[i][0] = 0$。</li><li>前 $0$ 种物品所能获得的最大价值一定为 $0$，即 $dp[0][w] = 0$。</li></ul></li><li><p>最终结果<br>根据我们之前定义的状态，$dp[i][w]$ 表示为：前 $i$ 种物品放入一个最多能装重量为 $w$ 的背包中，可以获得的最大价值。则最终结果为 $dp[size][W]$，其中 $size$ 为物品的种类数，$W$ 为背包的载重上限。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 思路 1：动态规划 + 二维数组</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">completePackMethod1</span>(<span class="params">self, weight: [<span class="built_in">int</span>], value: [<span class="built_in">int</span>], W: <span class="built_in">int</span></span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(weight)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(W + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举前 i 种物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 枚举背包装载重量</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(W + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 枚举第 i 种物品能取个数</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(w // weight[i - <span class="number">1</span>] + <span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># dp[i][w] 取所有 dp[i - 1][w - k * weight[i - 1] + k * value[i - 1] 中最大值</span></span><br><span class="line">                    dp[i][w] = <span class="built_in">max</span>(dp[i][w], dp[i - <span class="number">1</span>][w - k * weight[i - <span class="number">1</span>]] + k * value[i - <span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[size][W]</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n \times W \times \sum\frac{W}{weight[i]})$，其中 $n$ 为物品种类数量，$W$ 为背包的载重上限，$weight[i]$ 是第 $i$ 种物品的重量。</li><li><strong>空间复杂度</strong>：$O(n \times W)$。</li></ul><h3 id="3-2-状态转移方程优化（两重循环）"><a href="#3-2-状态转移方程优化（两重循环）" class="headerlink" title="3.2 状态转移方程优化（两重循环）"></a>3.2 状态转移方程优化（两重循环）</h3><p><strong>1. 优化思路</strong></p><p>&#8195;&#8195;之前的思路中，对于每种物品而言，每次我们都需要枚举所有可行的物品数目 $k$，这就大大增加了时间复杂度。实际上，我们可以对之前的状态转移方程进行一些优化，从而减少一下算法的时间复杂度。</p><p>我们将之前的状态转移方程 </p><script type="math/tex; mode=display">dp[i][w] = max \lbrace dp[i - 1][w - k \times weight[i - 1]] + k \times value[i - 1] \rbrace，\quad 0 \le k \times weight[i - 1] \le w</script><p>进行展开：</p><script type="math/tex; mode=display">(1) \quad dp[i][w] = max \begin{cases} dp[i - 1][w] \cr dp[i - 1][w - weight[i - 1]] + value[i - 1]  \cr dp[i - 1][w - 2 \times weight[i - 1]] + 2 \times value[i - 1] \cr …… \cr  \cr dp[i - 1][w - k \times weight[i - 1]] + k \times value[i - 1] \end{cases}，\quad 0 \le k \times weight[i - 1] \le w</script><p>而对于 $dp[i][w - weight[i - 1]]$ 我们有：</p><script type="math/tex; mode=display">(2) \quad dp[i][w - weight[i - 1]] = max \begin{cases} dp[i - 1][w - weight[i - 1]] \cr dp[i - 1][w - 2 \times weight[i - 1]] + value[i - 1]  \cr dp[i - 1][w - 3 \times weight[i - 1]] + 2 \times value[i - 1] \cr …… \cr dp[i - 1][w - k \times weight[i - 1]] + (k - 1) \times value[i - 1] \end{cases}，\quad weight[i - 1] \le k \times weight[i - 1] \le w</script><p>通过观察可以发现：</p><ol><li>$(1)$ 式中共有 $k + 1$ 项，$(2)$ 式中共有 $k$ 项；</li><li>$(2)$ 式整个式子与 $(1)$ 式第 $1 \sim k + 1$ 项刚好相差一个 $value[i - 1]$。</li></ol><p>则我们将 $(2)$ 式加上 $value[i - 1]$，再代入 $(1)$ 式中，可得到简化后的「状态转移方程」为：</p><script type="math/tex; mode=display">(3) \quad dp[i][w] = max \lbrace dp[i - 1][w], \quad dp[i][w - weight[i - 1]] + value[i - 1]  \rbrace, \quad 0 \le weight[i - 1] \le w</script><p>简化后的「状态转移方程」去除了对物品件数的依赖，也就不需要遍历 $k$ 了，三层循环降为了两层循环。</p><blockquote><p>注意：式 $(3)$ 的满足条件为 $0 \le weight[i - 1] \le w$。当 $w &lt; weight[i - 1]$ 时，$dp[i][w] = dp[i - 1][w]$。</p></blockquote><p>则状态转移方程为：</p><script type="math/tex; mode=display">\quad dp[i][w] = \begin{cases}  dp[i - 1][w] & w < weight[i - 1] \cr max \lbrace dp[i - 1][w], \quad dp[i][w - weight[i - 1]] + value[i - 1]  \rbrace & w \ge weight[i - 1] \end{cases}</script><p>从上述状态转移方程我们可以看出：该式子与 0-1 背包问题中「思路 1」的状态转移式极其相似, 唯一区别点在于：</p><p><strong>1.  0-1 背包问题中状态为 $dp[i - 1][w - weight[i - 1]] + value[i - 1]$，这是第 $i - 1$ 阶段上的状态值。</strong><br><strong>2.  完全背包问题中状态为 $dp[i][w - weight[i - 1]] + value[i - 1]$，这是第 $i$ 阶段上的状态值。</strong></p><p><strong>2. 解题步骤</strong></p><ol><li><p>划分阶段<br>按照物品种类的序号、当前背包的载重上限进行阶段划分。</p><ol><li>定义状态<ul><li>定义状态 $dp[i][w]$ 表示为：前 $i$ 种物品放入一个最多能装重量为 $w$ 的背包中，可以获得的最大价值。</li><li>状态 $dp[i][w]$ 是一个二维数组，其中第一维代表「当前正在考虑的物品种类」，第二维表示「当前背包的载重上限」，二维数组值表示「可以获得的最大价值」。</li></ul></li></ol></li><li><p>状态转移方程</p></li></ol><script type="math/tex; mode=display">\quad dp[i][w] = \begin{cases}  dp[i - 1][w] & w < weight[i - 1] \cr max \lbrace dp[i - 1][w], \quad dp[i][w - weight[i - 1]] + value[i - 1]  \rbrace & w \ge weight[i - 1] \end{cases}</script><ol><li><p>初始条件</p><ul><li>如果背包容量为 $0$，则无论选取什么物品，可以获得的最大价值一定是 $0$，即 $dp[i][0] = 0$。</li><li>前 $0$ 种物品所能获得的最大价值一定为 $0$，即 $dp[0][w] = 0$。</li></ul></li><li><p>最终结果<br>根据我们之前定义的状态，$dp[i][w]$ 表示为：前 $i$ 种物品放入一个最多能装重量为 $w$ 的背包中，可以获得的最大价值。则最终结果为 $dp[size][W]$，其中 $size$ 为物品的种类数，$W$ 为背包的载重上限。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 思路 2：动态规划 + 状态转移方程优化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">completePackMethod2</span>(<span class="params">self, weight: [<span class="built_in">int</span>], value: [<span class="built_in">int</span>], W: <span class="built_in">int</span></span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(weight)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(W + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举前 i 种物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 枚举背包装载重量</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(W + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 第 i - 1 件物品装不下</span></span><br><span class="line">                <span class="keyword">if</span> w &lt; weight[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># dp[i][w] 取「前 i - 1 种物品装入载重为 w 的背包中的最大价值」</span></span><br><span class="line">                    dp[i][w] = dp[i - <span class="number">1</span>][w]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># dp[i][w] 取「前 i - 1 种物品装入载重为 w 的背包中的最大价值」与「前 i 种物品装入载重为 w - weight[i - 1] 的背包中，再装入 1 件第 i - 1 种物品所得的最大价值」两者中的最大值</span></span><br><span class="line">                    dp[i][w] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][w], dp[i][w - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>])</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> dp[size][W]</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n \times W)$，其中 $n$ 为物品种类数量，$W$ 为背包的载重上限。</li><li><strong>空间复杂度</strong>：$O(n \times W)$。</li></ul><h3 id="3-3-滚动数组优化：一维数组"><a href="#3-3-滚动数组优化：一维数组" class="headerlink" title="3.3 滚动数组优化：一维数组"></a>3.3 滚动数组优化：一维数组</h3><p>通过观察「思路 2」中的状态转移方程 </p><script type="math/tex; mode=display">dp[i][w] = \begin{cases}  dp[i - 1][w] & w < weight[i - 1] \cr max \lbrace dp[i - 1][w], \quad dp[i][w - weight[i - 1]] + value[i - 1]  \rbrace & w \ge weight[i - 1] \end{cases}</script><p>&#8195;&#8195;可以看出：我们只用到了当前行（第 $i$ 行）的 $dp[i][w]$、$dp[i][w - weight[i - 1]]$，以及上一行（第 $i - 1$ 行）的 $dp[i - 1][w]$。</p><p>&#8195;&#8195;所以我们没必要保存所有阶段的状态，只需要使用一个一维数组 $dp[w]$ 保存上一阶段的所有状态，采用使用「滚动数组」的方式对空间进行优化（去掉动态规划状态的第一维）。</p><p>下面是具体的解题步骤：</p><ol><li><p>划分阶段<br>按照当前背包的载重上限进行阶段划分。</p></li><li><p>定义状态<br>定义状态 $dp[w]$ 表示为：将物品装入最多能装重量为 $w$ 的背包中，可以获得的最大价值。</p></li><li><p>状态转移方程</p><script type="math/tex; mode=display">dp[w] = \begin{cases}  dp[w] & w < weight[i - 1] \cr max \lbrace dp[w], \quad dp[w - weight[i - 1]]  + value[i - 1] \rbrace & w \ge weight[i - 1] \end{cases}</script></li></ol><blockquote><p>注意：这里的 $dp[w - weight[i - 1]]$ 是第 $i$ 轮计算之后的「第 $i$ 阶段的状态值」。</p></blockquote><p>&#8195;&#8195;因为在计算 $dp[w]$ 时，我们需要用到第 $i$ 轮计算之后的 $dp[w - weight[i - 1]]$，所以我们需要按照「从 $0 \sim W$ 正序递推的方式」递推 $dp[w]$，这样才能得到正确的结果。</p><p>&#8195;&#8195;因为 $w &lt; weight[i - 1]$ 时，$dp[w]$ 只能取上一阶段的 $dp[w]$，其值相当于没有变化，这部分可以不做处理。所以我们在正序递推 $dp[w]$ 时，只需从 $weight[i - 1]$ 开始遍历即可。</p><ol><li><p>初始条件<br>如果背包容量为 $0$，则无论选取什么物品，可以获得的最大价值一定是 $0$，即 $dp[0] = 0$。</p></li><li><p>最终结果<br>根据我们之前定义的状态， $dp[w]$ 表示为：将物品装入最多能装重量为 $w$ 的背包中，可以获得的最大价值。则最终结果为 $dp[W]$，其中 $W$ 为背包的载重上限。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 思路 3：动态规划 + 滚动数组优化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">completePackMethod3</span>(<span class="params">self, weight: [<span class="built_in">int</span>], value: [<span class="built_in">int</span>], W: <span class="built_in">int</span></span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(weight)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(W + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举前 i 种物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 正序枚举背包装载重量</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(weight[i - <span class="number">1</span>], W + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># dp[w] 取「前 i - 1 种物品装入载重为 w 的背包中的最大价值」与「前 i 种物品装入载重为 w - weight[i - 1] 的背包中，再装入 1 件第 i - 1 种物品所得的最大价值」两者中的最大值</span></span><br><span class="line">                dp[w] = <span class="built_in">max</span>(dp[w], dp[w - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[W]</span><br></pre></td></tr></table></figure><p> &#8195;&#8195;通过观察「0-1 背包问题滚动数组优化的代码」和「完全背包问题滚动数组优化的代码」可以看出，两者的唯一区别在于：</p><p><strong>1. 0-1 背包问题滚动数组优化的代码采用了「从 $W \sim weight[i - 1]$ 逆序递推的方式」。</strong><br><strong>2. 完全背包问题滚动数组优化的代码采用了「从 $weight[i - 1] \sim W$ 正序递推的方式」。</strong></p><ul><li><strong>时间复杂度</strong>：$O(n \times W)$，其中 $n$ 为物品种类数量，$W$ 为背包的载重上限。</li><li><strong>空间复杂度</strong>：$O(W)$。</li></ul><h3 id="3-4-多重背包应用"><a href="#3-4-多重背包应用" class="headerlink" title="3.4 多重背包应用"></a>3.4 多重背包应用</h3><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0279</td><td style="text-align:left"><a href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.md">Python</a></td><td style="text-align:left">广度优先搜索、数学、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0322</td><td style="text-align:left"><a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0322.%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.md">Python</a></td><td style="text-align:left">动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0518</td><td style="text-align:left"><a href="https://leetcode.cn/problems/coin-change-ii/">零钱兑换 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0518.%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%20II.md">Python</a></td><td style="text-align:left">数组、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0139</td><td style="text-align:left"><a href="https://leetcode.cn/problems/word-break/">单词拆分</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.md">Python</a></td><td style="text-align:left">字典树、记忆化搜索、哈希表、字符串、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0377</td><td style="text-align:left"><a href="https://leetcode.cn/problems/combination-sum-iv/">组合总和 Ⅳ</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0377.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20%E2%85%A3.md">Python</a></td><td style="text-align:left">数组、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0638</td><td style="text-align:left"><a href="https://leetcode.cn/problems/shopping-offers/">大礼包</a></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1449</td><td style="text-align:left"><a href="https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/">数位成本和为目标值的最大数字</a></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></div><h4 id="3-4-1-应用：零钱兑换"><a href="#3-4-1-应用：零钱兑换" class="headerlink" title="3.4.1 应用：零钱兑换"></a>3.4.1 应用：零钱兑换</h4><blockquote><p><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换 - 力扣</a></p></blockquote><p>&#8195;&#8195;给定代表不同面额的硬币数组 <code>coins</code> 和一个总金额 <code>amount</code>，求出凑成总金额所需的最少的硬币个数。如果无法凑出，则返回 -1。</p><p><strong>说明</strong>：</p><ul><li>$1 \le coins.length \le 12$。</li><li>$1 \le coins[i] \le 2^{31} - 1$。</li><li>$0 \le amount \le 10^4$。</li></ul><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：<span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>思路 1：完全背包问题</strong></p><p>&#8195;&#8195;这道题可以转换为：有 $n$ 种不同的硬币，$coins[i]$ 表示第 $i$ 种硬币的面额，每种硬币可以无限次使用。请问凑成总金额为 $amount$ 的背包，最少需要多少硬币？</p><p>&#8195;&#8195;与普通完全背包问题不同的是，这里求解的是最少硬币数量。我们可以改变一下「状态定义」和「状态转移方程」。</p><ol><li><p>划分阶段<br>按照当前背包的载重上限进行阶段划分。</p></li><li><p>定义状态<br>定义状态 $dp[c]$ 表示为：凑成总金额为 $c$ 的最少硬币数量。</p></li><li><p>状态转移方程<br>$dp[c] = \begin{cases} dp[c] &amp; c &lt; coins[i - 1] \cr min \lbrace dp[c], dp[c - coins[i - 1]]  + 1 \rbrace &amp; c \ge coins[i - 1] \end{cases}$</p><ol><li>当 $c &lt; coins[i - 1]$ 时：<ol><li>不使用第 $i - 1$ 枚硬币，只使用前 $i - 1$ 枚硬币凑成金额 $w$ 的最少硬币数量，即 $dp[c]$。</li></ol></li><li>当 $c \ge coins[i - 1]$ 时，取下面两种情况中的较小值：<ol><li>不使用第 $i - 1$ 枚硬币，只使用前 $i - 1$ 枚硬币凑成金额 $w$ 的最少硬币数量，即 $dp[c]$。</li><li>凑成金额 $c - coins[i - 1]$ 的最少硬币数量，再加上当前硬币的数量 $1$，即 $dp[c - coins[i - 1]]  + 1$。</li></ol></li></ol></li><li><p>初始条件<br>凑成总金额为 $0$ 的最少硬币数量为 $0$，即 $dp[0] = 0$。</p></li><li><p>最终结果<br>根据我们之前定义的状态，$dp[c]$ 表示为：凑成总金额为 $c$ 的最少硬币数量。则最终结果为 $dp[amount]$。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 枚举前 i 种物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="comment"># 正序枚举背包装载重量</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(coins[i], amount + <span class="number">1</span>):</span><br><span class="line">                dp[c] = <span class="built_in">min</span>(dp[c], dp[c - coins[i]] + <span class="number">1</span>)    </span><br><span class="line">                           </span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line"><span class="comment"># 正序枚举背包装载重量</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">dp[c] = <span class="built_in">min</span>(dp[c], dp[c - coin] + <span class="number">1</span>) </span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(amount \times size)$。其中 $amount$ 表示总金额，$size$ 表示硬币的种类数。</li><li><strong>空间复杂度</strong>：$O(amount)$。</li></ul><h4 id="3-4-2-零钱兑换-II"><a href="#3-4-2-零钱兑换-II" class="headerlink" title="3.4.2  零钱兑换 II"></a>3.4.2  零钱兑换 II</h4><blockquote><p><a href="https://leetcode.cn/problems/coin-change-ii/">518 零钱兑换 II</a></p></blockquote><p>&#8195;&#8195;给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p><ul><li>假设每一种面额的硬币有无限个。 </li><li>题目数据保证结果符合 32 位带符号整数。</li></ul><p>&#8195;&#8195;此题可参考<a href="https://leetcode.cn/problems/target-sum/">494 目标和</a>，唯一不同的是前者是0-1背包，本题是完全背包。</p><h5 id="3-4-2-1-二维dp数组"><a href="#3-4-2-1-二维dp数组" class="headerlink" title="3.4.2.1 二维dp数组"></a>3.4.2.1 二维dp数组</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount, coins</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        size=<span class="built_in">len</span>(coins)</span><br><span class="line">        <span class="comment"># 一维dp数组，dp[w]表示装满w的背包最少需要多少硬币，dp[0]=0</span></span><br><span class="line">        n = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp=[[<span class="number">0</span>]*(amount+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span> <span class="comment">#  其他 dp[0][j]均为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j&lt;coins[i-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-coins[i-<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][amount]</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;此题和<a href="https://leetcode.cn/problems/target-sum/">494 目标和</a>代码不同之处，是<code>dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]]</code>，而非<code>dp[i][j]=dp[i-1][j]+dp[i-][j-coins[i-1]]</code>        </p><blockquote><p><strong>1.  0-1 背包问题中状态为 $dp[i - 1][w - weight[i - 1]] + value[i - 1]$，这是第 $i - 1$ 阶段上的状态值。</strong><br><strong>2.  完全背包问题中状态为 $dp[i][w - weight[i - 1]] + value[i - 1]$，这是第 $i$ 阶段上的状态值。</strong></p></blockquote><h5 id="3-4-2-2-一维dp数组"><a href="#3-4-2-2-一维dp数组" class="headerlink" title="3.4.2.2 一维dp数组"></a>3.4.2.2 一维dp数组</h5><p>&#8195;&#8195;动态规划的状态 <code>dp[i]</code> 可以表示为：凑成总金额为 <code>i</code> 的组合数。</p><p>&#8195;&#8195;动态规划的状态转移方程为：<code>dp[i] = dp[i] + dp[i - coin]</code>，意思为凑成总金额为 <code>i</code> 的组合数 = 「不使用当前 <code>coin</code>，只使用之前硬币凑成金额 <code>i</code> 的组合数」+「使用当前 <code>coin</code> 凑成金额 <code>i - coin</code> 的方案数」。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount, coins</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        size=<span class="built_in">len</span>(coins)</span><br><span class="line">        <span class="comment"># 一维dp数组，dp[w]表示装满w的背包最少需要多少硬币，dp[0]=1</span></span><br><span class="line">        size = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(amount + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 枚举前 i 种物品</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="comment"># 正序枚举背包装载重量</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[j] = dp[j]+dp[j - coin] </span><br><span class="line">                                </span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>1. 0-1 背包问题滚动数组优化的代码采用了「从 $W \sim weight[i - 1]$ 逆序递推的方式」。</strong><br><strong>2. 完全背包问题滚动数组优化的代码采用了「从 $weight[i - 1] \sim W$ 正序递推的方式」。</strong></p></blockquote><h4 id="3-4-3-组合总和-Ⅳ"><a href="#3-4-3-组合总和-Ⅳ" class="headerlink" title="3.4.3 组合总和 Ⅳ"></a>3.4.3 组合总和 Ⅳ</h4><blockquote><p><a href="https://leetcode.cn/problems/combination-sum-iv/">377 组合总和 Ⅳ</a></p></blockquote><p>&#8195;&#8195;给你一个由 不同 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p>示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], target = <span class="number">4</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合</span><br></pre></td></tr></table></figure></p><p>由于需要考虑选取元素的顺序，因此这道题需要计算的是<strong>选取元素的排列数</strong>。</p><ol><li><p>定义<br>用 dp[x] 表示选取的元素之和等于 x 的方案数，目标是求 dp[target]。</p></li><li><p>初始化<br>动态规划的边界是 dp[0]=1。只有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/e2a0a3ea645f42e1a8349649de08cf69.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        dp=[<span class="number">0</span>]*(target+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 完全背包，恰好装满背包容量的方式,且还有排列组合</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(nums):</span><br><span class="line">                <span class="keyword">if</span> j&gt;=num:            </span><br><span class="line">                    dp[j]+=dp[j-num]    </span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure><h3 id="3-5-总结-一种规律搞定背包问题"><a href="#3-5-总结-一种规律搞定背包问题" class="headerlink" title="3.5 总结:一种规律搞定背包问题"></a>3.5 总结:一种规律搞定背包问题</h3><blockquote><p>参考<a href="https://leetcode.cn/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/">《希望用一种规律搞定背包问题》</a></p><p>背包问题技巧：常见的背包问题有组合问题、True/False问题、最大最小问题。</p><ol><li>如果是0-1背包，即数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序；</li></ol></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(target, nums-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">...</span><br><span class="line">dp[i] += dp[i-num]</span><br></pre></td></tr></table></figure><ol><li>如果是完全背包，即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums, target+<span class="number">1</span>):</span><br><span class="line">...</span><br><span class="line">dp[i] = dp[i] <span class="keyword">or</span> dp[i-num]</span><br></pre></td></tr></table></figure><ol><li>如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    ...</span><br><span class="line">    dp[i] = <span class="built_in">min</span>(dp[i], dp[i-num]+<span class="number">1</span>)</span><br><span class="line">    dp[i] = <span class="built_in">max</span>(dp[i], dp[i-num]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="四、-多重背包问题"><a href="#四、-多重背包问题" class="headerlink" title="四、 多重背包问题"></a>四、 多重背包问题</h2><blockquote><p>参考</p><ul><li>【资料】<a href="https://github.com/tianyicui/pack">背包九讲 - 崔添翼</a></li><li>【文章】<a href="https://oi-wiki.org/dp/knapsack/">背包 DP - OI Wiki</a></li><li>【文章】<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247486796&amp;idx=1&amp;sn=a382b38f8aed295410550bb1767437bd&amp;chksm=fd9ca653caeb2f456262bbf70ffe1eeda8758b426a901a6ac15be184e7017870020e456c6fa2&amp;scene=178&amp;cur_album_id=1869157771795841024#rd">【动态规划/背包问题】多重背包の二进制优化</a></li></ul></blockquote><p> <strong>多重背包问题</strong>：有 $n$ 种物品和一个最多能装重量为 $W$ 的背包，第 $i$ 种物品的重量为 $weight[i]$，价值为 $value[i]$，件数为 $count[i]$。请问在总重量不超过背包载重上限的情况下，能装入背包的最大价值是多少？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d94c0712afb8b09d3e7719d6429b825c.png" alt=""></p><h3 id="4-1-多重背包问题基本思路"><a href="#4-1-多重背包问题基本思路" class="headerlink" title="4.1 多重背包问题基本思路"></a>4.1 多重背包问题基本思路</h3><p>&#8195;&#8195;我们可以参考「0-1 背包问题」的状态定义和基本思路，对于容量为 $w$ 的背包，最多可以装 $min \lbrace count[i - 1]，\frac{w}{weight[i - 1]} \rbrace$ 件第 $i - 1$ 件物品。那么我们可以多加一层循环，枚举第 $i - 1$ 件物品可以选择的件数（$0 \sim min \lbrace count[i - 1]，\frac{w}{weight[i - 1]} \rbrace$），从而将「完全背包问题」转换为「0-1 背包问题」。</p><p><strong>思路 1：动态规划 + 二维基本思路</strong></p><ol><li><p>划分阶段<br>按照物品种类的序号、当前背包的载重上限进行阶段划分。</p></li><li><p>定义状态</p><ul><li><p>定义状态 $dp[i][w]$ 表示为：前 $i$ 种物品放入一个最多能装重量为 $w$ 的背包中，可以获得的最大价值。</p></li><li><p>状态 $dp[i][w]$ 是一个二维数组，其中第一维代表「当前正在考虑的物品种类」，第二维表示「当前背包的载重上限」，二维数组值表示「可以获得的最大价值」。</p></li></ul></li><li><p>状态转移方程<br>$dp[i][w] = max \lbrace dp[i - 1][w - k \times weight[i - 1]] + k \times value[i - 1] \rbrace，\quad 0 \le k \le min \lbrace count[i - 1]，\frac{w}{weight[i - 1]} \rbrace$。</p></li><li><p>初始条件</p><ul><li>如果背包容量为 $0$，则无论选取什么物品，可以获得的最大价值一定是 $0$，即 $dp[i][0] = 0$。</li><li>前 $0$ 种物品所能获得的最大价值一定为 $0$，即 $dp[0][w] = 0$。</li></ul></li><li><p>最终结果<br>根据我们之前定义的状态，$dp[i][w]$ 表示为：前 $i$ 种物品放入一个最多能装重量为 $w$ 的背包中，可以获得的最大价值。则最终结果为 $dp[size][W]$，其中 $size$ 为物品的种类数，$W$ 为背包的载重上限。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiplePackMethod1</span>(<span class="params">self, weight: [<span class="built_in">int</span>], value: [<span class="built_in">int</span>], count: [<span class="built_in">int</span>], W: <span class="built_in">int</span></span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(weight)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(W + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举前 i 种物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 枚举背包装载重量</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, W + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 枚举第 i 种物品能取个数</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(count[i - <span class="number">1</span>], w // weight[i - <span class="number">1</span>]) + <span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># dp[i][w] 取所有 dp[i - 1][w - k * weight[i - 1] + k * value[i - 1] 中最大值</span></span><br><span class="line">                    dp[i][w] = <span class="built_in">max</span>(dp[i][w], dp[i - <span class="number">1</span>][w - k * weight[i - <span class="number">1</span>]] + k * value[i - <span class="number">1</span>])</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> dp[size][W]</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n \times W \times \sum count[i])$，其中 $n$ 为物品种类数量，$W$ 为背包的载重上限，$count[i]$ 是第 $i$ 种物品的重量。</li><li><strong>空间复杂度</strong>：$O(n \times W)$。</li></ul><h3 id="4-2-多重背包问题滚动数组优化"><a href="#4-2-多重背包问题滚动数组优化" class="headerlink" title="4.2 多重背包问题滚动数组优化"></a>4.2 多重背包问题滚动数组优化</h3><p>&#8195;&#8195;在「完全背包问题」中，我们通过优化「状态转移方程」的方式，成功去除了对物品件数 $k$ 的依赖，从而将时间复杂度下降了一个维度。</p><p>&#8195;&#8195;而在「多重背包问题」中，我们在递推 $dp[i][w]$ 时，是无法从 $dp[i][w - weight[i - 1]]$ 状态得知目前究竟已经使用了多个件第 $i - 1$ 种物品，也就无法判断第 $i - 1$ 种物品是否还有剩余数量可选。这就导致了我们无法通过优化「状态转移方程」的方式将「多重背包问题」的时间复杂度降低。</p><p>&#8195;&#8195;但是我们可以参考「完全背包问题」+「滚动数组优化」的方式，将算法的空间复杂度下降一个维度。</p><p><strong>思路 2：动态规划 + 滚动数组优化</strong></p><ol><li><p>划分阶段<br>按照当前背包的载重上限进行阶段划分。</p><ol><li>定义状态<br>定义状态 $dp[w]$ 表示为：将物品装入最多能装重量为 $w$ 的背包中，可以获得的最大价值。</li></ol></li><li><p>状态转移方程<br>$dp[w] = max \lbrace dp[w - k \times weight[i - 1]] + k \times value[i - 1] \rbrace , \quad 0 \le k \le min \lbrace count[i - 1]，\frac{w}{weight[i - 1]} \rbrace$</p></li><li><p>初始条件<br>如果背包容量为 $0$，则无论选取什么物品，可以获得的最大价值一定是 $0$，即 $dp[0] = 0$。</p></li><li><p>最终结果<br>根据我们之前定义的状态， $dp[w]$ 表示为：将物品装入最多能装重量为 $w$ 的背包中，可以获得的最大价值。则最终结果为 $dp[W]$，其中 $W$ 为背包的载重上限。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiplePackMethod2</span>(<span class="params">self, weight: [<span class="built_in">int</span>], value: [<span class="built_in">int</span>], count: [<span class="built_in">int</span>], W: <span class="built_in">int</span></span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(weight)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(W + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举前 i 种物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 逆序枚举背包装载重量（避免状态值错误）</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(W, weight[i - <span class="number">1</span>] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 枚举第 i 种物品能取个数</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(count[i - <span class="number">1</span>], w // weight[i - <span class="number">1</span>]) + <span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># dp[w] 取所有 dp[w - k * weight[i - 1]] + k * value[i - 1] 中最大值</span></span><br><span class="line">                    dp[w] = <span class="built_in">max</span>(dp[w], dp[w - k * weight[i - <span class="number">1</span>]] + k * value[i - <span class="number">1</span>])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[W]</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n \times W \times C)$，其中 $n$ 为物品种类数量，$W$ 为背包的载重上限，$C$ 是物品的数量数组长度。因为 $n \times C = \sum count[i]$，所以时间复杂度也可以写成 $O(W \times \sum count[i])$。</li><li><strong>空间复杂度</strong>：$O(W)$。</li></ul><h3 id="4-3-多重背包问题二进制优化"><a href="#4-3-多重背包问题二进制优化" class="headerlink" title="4.3 多重背包问题二进制优化"></a>4.3 多重背包问题二进制优化</h3><p>&#8195;&#8195;在「思路 2」中，我们通过「滚动数组优化」的方式，降低了算法的空间复杂度。同时也提到了无法通过优化「状态转移方程」的方式将「多重背包问题」的时间复杂度降低。</p><p>&#8195;&#8195;但我们还是可以从物品数量入手，通过「二进制优化」的方式，将算法的时间复杂度降低。</p><p>&#8195;&#8195; <strong>二进制优化</strong>：简单来说，就是把物品的数量 $count[i]$ 拆分成「由 $1、2、4、…、2^m$ 件单个物品组成的大物品」，以及「剩余不足 $2$ 的整数次幂数量的物品，由 $count[i] -2^{\lfloor \log_2(count[i] + 1) \rfloor - 1}$ 件单个物品组成大物品」。</p><p>&#8195;&#8195;举个例子，第 $i$ 件物品的数量为 $31$，采用「二进制优化」的方式，可以拆分成 $31 = 1 + 2 + 4 + 8 + 16$ 一共 $5$ 件物品。也将是将 $31$ 件物品分成了 $5$ 件大物品：</p><ol><li>第 $1$ 件大物品有 $1$ 件第 $i$ 种物品组成；</li><li>第 $2$ 件大物品有 $2$ 件第 $i$ 种物品组成；</li><li>第 $3$ 件大物品有 $4$ 件第 $i$ 种物品组成；</li><li>第 $4$ 件大物品有 $8$ 件第 $i$ 种物品组成；</li><li>第 $5$ 件大物品有 $16$ 件第 $i$ 种物品组成。</li></ol><p>&#8195;&#8195;这 <code>5</code> 件大物品通过不同的组合，可表达出第 $i$ 种物品的数量范围刚好是 <code>0 ~31</code>。这样本来第 <code>i</code>件物品数量需要枚举共计 <code>32</code> 次（$0 \sim 31$），而现在只需要枚举 <code>5</code> 次即可。</p><p>再举几个例子：</p><ol><li>第 $i$ 件物品的数量为 $6$，可以拆分为 $6 = 1 + 2 + 3$ 一共 $3$ 件物品。</li><li>第 $i$ 件物品的数量为 $8$，可以拆分为 $8 = 1 + 2 + 4 + 1$ 一共 $4$ 件物品。</li><li>第 $i$ 件物品的数量为 $18$，可以拆分为 $18 = 1 + 2 + 4 + 8 + 3$ 一共 $5$ 件物品。</li></ol><p>&#8195;&#8195;经过「二进制优化」之后，算法的时间复杂度从 $O(W \times \sum count[i])$  降到了 $O(W \times \sum \log_2{count[i]})$。</p><p><strong>思路 3：动态规划 + 二进制优化</strong></p><ol><li><p>划分阶段<br>按照当前背包的载重上限进行阶段划分。</p></li><li><p>定义状态<br>定义状态 $dp[w]$ 表示为：将物品装入最多能装重量为 $w$ 的背包中，可以获得的最大价值。</p></li><li><p>状态转移方程<br>$dp[w] = max \lbrace dp[w - weight \underline{ } new[i - 1]] + value \underline{ } new[i - 1] \rbrace$</p></li><li><p>初始条件<br>如果背包容量为 $0$，则无论选取什么物品，可以获得的最大价值一定是 $0$，即 $dp[0] = 0$。</p></li><li><p>最终结果<br>根据我们之前定义的状态， $dp[w]$ 表示为：将物品装入最多能装重量为 $w$ 的背包中，可以获得的最大价值。则最终结果为 $dp[W]$，其中 $W$ 为背包的载重上限。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiplePackMethod3</span>(<span class="params">self, weight: [<span class="built_in">int</span>], value: [<span class="built_in">int</span>], count: [<span class="built_in">int</span>], W: <span class="built_in">int</span></span>):</span></span><br><span class="line">        weight_new, value_new = [], []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(weight)):</span><br><span class="line">            cnt = count[i]</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> k &lt;= cnt:</span><br><span class="line">                cnt -= k</span><br><span class="line">                weight_new.append(weight[i] * k)</span><br><span class="line">                value_new.append(value[i] * k)</span><br><span class="line">                k *= <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">                weight_new.append(weight[i] * cnt)</span><br><span class="line">                value_new.append(value[i] * cnt)</span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(W + <span class="number">1</span>)]</span><br><span class="line">        size = <span class="built_in">len</span>(weight_new)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举前 i 种物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 逆序枚举背包装载重量（避免状态值错误）</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(W, weight_new[i - <span class="number">1</span>] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># dp[w] 取「前 i - 1 件物品装入载重为 w 的背包中的最大价值」与「前 i - 1 件物品装入载重为 w - weight_new[i - 1] 的背包中，再装入第 i - 1 物品所得的最大价值」两者中的最大值</span></span><br><span class="line">                dp[w] = <span class="built_in">max</span>(dp[w], dp[w - weight_new[i - <span class="number">1</span>]] + value_new[i - <span class="number">1</span>])</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> dp[W]</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(W \times \sum \log_2{count[i]})$，其中 $W$ 为背包的载重上限，$count[i]$ 是第 $i$ 种物品的数量。</li><li><strong>空间复杂度</strong>：$O(W)$。<h3 id="4-4-多重背包问题应用"><a href="#4-4-多重背包问题应用" class="headerlink" title="4.4 多重背包问题应用"></a>4.4 多重背包问题应用</h3></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0474</td><td style="text-align:left"><a href="https://leetcode.cn/problems/ones-and-zeroes/">一和零</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0474.%20%E4%B8%80%E5%92%8C%E9%9B%B6.md">Python</a></td><td style="text-align:left">数组、字符串、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0879</td><td style="text-align:left">盈利计划</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1995</td><td style="text-align:left">统计特殊四元组</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></div><h2 id="五、-分组背包问题应用"><a href="#五、-分组背包问题应用" class="headerlink" title="五、 分组背包问题应用"></a>五、 分组背包问题应用</h2><blockquote><p><strong>分组背包问题</strong>：有 $n$ 组物品和一个最多能装重量为 $W$ 的背包，第 $i$ 组物品的件数为 $count[i]$，第 $i$ 组的第 $j$ 个物品重量为 $weight[i][j]$，价值为 $value[i][j]$。每组物品中最多只能选择 $1$ 件物品装入背包。请问在总重量不超过背包载重上限的情况下，能装入背包的最大价值是多少？</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">1155</td><td style="text-align:left">掷骰子的N种方法</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">2585</td><td style="text-align:left">获得分数的方法数</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h2 id=&quot;一、背包问题简介&quot;&gt;&lt;a href=&quot;#一、背包问题简介&quot; class=&quot;headerlink&quot; title=&quot;一、背包问题简介&quot;&gt;&lt;/a&gt;一、背包问题简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;【资料】&lt;a href=&quot;https://algo.itcharge.cn/10.Dynamic-Programming/04.Knapsack-Problem/01.Knapsack-Problem-01/&quot;&gt;算法通关手册&lt;/a&gt;、&lt;a href=&quot;https://github.com/tianyicui/pack&quot;&gt;背包九讲 - 崔添翼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;【文章】&lt;a href=&quot;https://oi-wiki.org/dp/knapsack/&quot;&gt;背包 DP - OI Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;【B站视频】&lt;a href=&quot;https://www.bilibili.com/video/BV1cg411g7Y6/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=21011151235423b801d3f3ae98b91e94&quot;&gt;代码随想录详解0-1背包&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;#8195;&amp;#8195; &lt;strong&gt;背包问题&lt;/strong&gt;：背包问题是线性 DP 问题中一类经典而又特殊的模型。背包问题可以描述为：给定一组物品，每种物品都有自己的重量、价格以及数量。再给定一个最多能装重量为 $W$ 的背包。现在选择将一些物品放入背包中，请问在总重量不超过背包载重上限的情况下，能装入背包的最大价值总和是多少？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/c10c789493f59d73c79ed764fa202957.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;</summary>
    
    
    
    <category term="Data Structure and Algorithms" scheme="https://zhxnlp.github.io/categories/Data-Structure-and-Algorithms/"/>
    
    
    <category term="leetcode" scheme="https://zhxnlp.github.io/tags/leetcode/"/>
    
    <category term="Dynamic Programming" scheme="https://zhxnlp.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习六：字符串</title>
    <link href="https://zhxnlp.github.io/2023/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E5%85%AD%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://zhxnlp.github.io/2023/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E5%85%AD%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-03-19T16:00:00.000Z</published>
    <updated>2023-04-08T01:20:59.178Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>参考<a href="https://algo.itcharge.cn/06.String/01.String-Basic/01.String-Basic/">《算法通关手册》字符串篇</a></p><h2 id="一、字符串基础"><a href="#一、字符串基础" class="headerlink" title="一、字符串基础"></a>一、字符串基础</h2><h3 id="1-1-字符串基础知识"><a href="#1-1-字符串基础知识" class="headerlink" title="1.1 字符串基础知识"></a>1.1 字符串基础知识</h3><h4 id="1-1-1-字符串简介"><a href="#1-1-1-字符串简介" class="headerlink" title="1.1.1 字符串简介"></a>1.1.1 字符串简介</h4><ol><li>字符串的表示:字符串是由0个或多个字符组成的有序字符序列，由一对单引号或一对双引号表示<br><img src="https://img-blog.csdnimg.cn/4f88e8eacc4b429e88f9284acaeec927.png" alt="在这里插入图片描述"><span id="more"></span></li></ol></blockquote><ol><li>字符串有2类共4种表示方法:<ul><li>由1对单引号或双引号表示,仅表示单行字符串;</li><li>由1对三单引号或三双引号表示,可表示多行字符串;</li></ul></li><li><p>字符串是字符的有序序列，可以对其中的字符进行索引。</p></li><li><p>特殊字符：使用转义符<code>\</code>，<code>\b</code>表示回退；<code>\n</code>表换行（光标移动到下行首；<code>\r</code>表示回车（光标移动到本行首），<code>\t</code>表示制表符（4格）</p><h4 id="1-1-2-字符串处理"><a href="#1-1-2-字符串处理" class="headerlink" title="1.1.2 字符串处理"></a>1.1.2 字符串处理</h4><blockquote><p><a href="https://docs.python.org/3/library/string.html#formatstrings">format官方文档</a>、<a href="https://docs.python.org/3/library/re.html">re文档</a></p></blockquote></li><li>字符串操作符</li></ol><div class="table-container"><table><thead><tr><th>操作符及查找</th><th>描述</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>x+y    |连接两个字符串x和y<br>n<em>x或x</em>n |    复制n次字符串x<br>x in s    |如果x是s的子串，返回True，否则返回False<br>str.index(‘’)    |子串第一次出现的位置，不存在报错ValueError<br>str.rindex(‘’)    |子串最后一次出现的位置，不存在报错ValueError<br>str.find(‘’)    |子串第一次出现的位置，不存在返回-1<br>str.rfind(‘’)|    子串最后一次出现的位置，不存在返回-1</p><ol><li>字符串处理函数</li></ol><p>函数及使用|    描述<br>|—|—|<br>len(x)    |返回字符串的长度，非空字符串都有长度（换行符、空格和符号长度1）<br>str(x)    |将x转换为string类型<br>hex(x)或oct(x)     |将整数x转换成16进制或8进制字符串<br>chr(x)    |将一个(0-255)10或16进制整数(Unicode编码)，转换成对应ASCII字符<br>ord(x)    |x为字符，返回其对应的Unicode编码(原始值0-65535)</p><ol><li>字符串大小写</li></ol><p>大小写转换|    描述<br>|—|—|<br>str.lower()或str.upper() |    全部字符小写或大写，产生新字符串<br>str.swapcase()    |字符串大写改小写，小写改大写，产生新字符串<br>str.capitalize()|    首字符大写，其余小写，产生新字符串<br>str.title()    |每个字符首字符大写，其余小写，产生新字符串</p><ol><li>字符串对齐</li></ol><p>字符串对齐|    描述<br>|—|—|<br>str.center(width,’stp’)|    <strong>居中对齐</strong>，width指定宽度，stp指定分隔符，默认空格分割。<br>str.ljust(width,’stp’)|    <strong>左对齐</strong>，width指定宽度，stp指定分隔符，默认空格分割。<br>str.rjust(width,’stp’)|    <strong>右对齐</strong>，width指定宽度，stp指定分隔符，默认空格分割。<br>str.zfill(width)|    <strong>右对齐，左侧用0填充</strong>，width指定宽度。</p><blockquote><p>以上对齐方式，指定宽度小于实际宽度时返回原字符串</p><ol><li>字符串处理函数</li></ol></blockquote><p>函数及使用|    描述<br>|—|—|<br>str.split(‘sep’,maxsplit)    |从str左侧开始分割，分隔符为sep，默认空格。第二个参数指定最大分割次数。最大分割后剩余字符串成一个元素<br>str.rsplit(‘sep’,maxsplit)|    同上，从右侧开始分割。直接写’/’或者sep=’/’都可以。最大分割后的元素不同。没有指定最大分割时是一样的<br>str.count(sub)|    返回子串sub在str中的出现的次数<br>str.replace(old,new,num)|    返回字符串str副本，所有old子串被替换为new,num为最大替换次数<br>str.center(width[,fillchar])|    字符串str根据宽度width居中，fillchar可选填<br>str.strip(chars)|    从str中去掉在其左侧和右侧chars中列出的字符<br>str.join(iter)|    在iter变量除最后元素外每个元素后增加一个str<br>str.isidentifier()    |判断字符串是否是合法标识符（汉字也算）<br>str.isspace()    |判断字符串是否都是由空白字符组成（回车、换行、水平制表符）<br>str.isalpha()    |判断字符串是否都是由字母组成（汉字也算）<br>str.isdecimal()|    判断字符串是否都是由十进制数字组成<br>str.isnumeric()|    判断字符串是否都是由数字组成（包括罗马数字）<br>str.isalnum()    |判断字符串是否都是由数字和字母组成</p><ol><li>字符串的比较<br>字符串可以用&lt;、&gt;、=、&gt;=、&lt;=、==、!=来比较。比较原理是比较每个字符的原始值（unicode编码），可用ord查看</li><li><p>编码与解码</p><ul><li>编码：将字符串转换成二进制数据（byte）（gbk中文两个字节，utf-8中文三个字节）</li><li>格式：<code>str.encode(encoding=’gbk’)</code>(gbk大小写都可以,开头b表二进制)</li><li>解码：将二进制数据（byte）转换成字符串</li><li>格式：<code>byte.decode((encoding=’gbk’)</code>(byte为二进制编码)，解码格式应该与编码格式一致<h4 id="1-1-3-字符串类型的格式化"><a href="#1-1-3-字符串类型的格式化" class="headerlink" title="1.1.3 字符串类型的格式化"></a>1.1.3 字符串类型的格式化</h4>字符串格式化有两种方式：<ol><li>用%占位输出<br>如print(‘我是%s,今年%d岁，%(name,age))<br>print(‘我今年%10.2f岁’ % age)<br>结果：我是name，今年age岁</li><li>用{}输出，如<br>print(f‘我是(name),今年(age)岁)<br>print(‘我是{0},今年{1}岁’.format(name,age))(槽中0 和1可以不写)</li></ol></li></ul><p>整数类型输出格式：</p></li></ol><ul><li>b:输出整数的二进制方式</li><li>c:输出整数对应的Unicode字符</li><li>d:输出整数的十进制方式</li><li>o:输出整数的八进制方式</li><li>x:输出整数的小写十六进制方式</li><li>X:输出整数的大写十六进制方式</li></ul><p>浮点数类型输出格式：</p><ul><li>e:输出浮点数对应的小写字母e的指数形式</li><li>E:输出浮点数对应的大写字母E的指数形式</li><li>f:输出浮点数的标准浮点形式</li><li>%:输出浮点数的百分比形式<ul><li>{:.2f}表示小数点后两位的小数</li><li>{:.2}表示一共两位数，有十位时表示为3e+01的形式</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/1763d1b7dced4c5fb4db6e0f5dd70511.png" alt="在这里插入图片描述"></p><p>②格式控制</p><p><img src="https://img-blog.csdnimg.cn/234b26b7d1ee499caf184b3b42e3615b.png" alt="在这里插入图片描述"></p><h3 id="1-2-字符串基础题目"><a href="#1-2-字符串基础题目" class="headerlink" title="1.2 字符串基础题目"></a>1.2 字符串基础题目</h3><h4 id="1-2-1-字符串基础题目列表"><a href="#1-2-1-字符串基础题目列表" class="headerlink" title="1.2.1 字符串基础题目列表"></a>1.2.1 字符串基础题目列表</h4><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0125</td><td style="text-align:left"><a href="https://leetcode.cn/problems/valid-palindrome/">验证回文串</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0125.%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2.md">Python</a></td><td style="text-align:left">字符串、双指针</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0005</td><td style="text-align:left"><a href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0005.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.md">Python</a></td><td style="text-align:left">字符串、动态规划</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0003</td><td style="text-align:left"><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0003.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.md">Python</a></td><td style="text-align:left">字符串、哈希表、双指针、字符串、滑动窗口</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0344</td><td style="text-align:left"><a href="https://leetcode.cn/problems/reverse-string/">反转字符串</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0344.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.md">Python</a></td><td style="text-align:left">字符串</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0557</td><td style="text-align:left"><a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">反转字符串中的单词 III</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0557.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%20III.md">Python</a></td><td style="text-align:left">字符串</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0049</td><td style="text-align:left"><a href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0049.%20%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84.md">Python</a></td><td style="text-align:left">字符串、哈希表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0415</td><td style="text-align:left"><a href="https://leetcode.cn/problems/add-strings/">字符串相加</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0415.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0.md">Python</a></td><td style="text-align:left">字符串、大数加法</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0151</td><td style="text-align:left"><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">颠倒字符串中的单词</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0151.%20%E9%A2%A0%E5%80%92%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D.md">Python</a></td><td style="text-align:left">双指针、字符串</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0043</td><td style="text-align:left"><a href="https://leetcode.cn/problems/multiply-strings/">字符串相乘</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0043.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98.md">Python</a></td><td style="text-align:left">数学、字符串、模拟</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0014</td><td style="text-align:left"><a href="https://leetcode.cn/problems/longest-common-prefix/">最长公共前缀</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0014.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.md">Python</a></td><td style="text-align:left">字符串</td><td style="text-align:left">简单</td></tr></tbody></table></div><h4 id="1-2-2-验证回文串"><a href="#1-2-2-验证回文串" class="headerlink" title="1.2.2 验证回文串"></a>1.2.2 验证回文串</h4><p>&#8195;&#8195;如果将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。<br>&#8195;&#8195;给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        s = <span class="string">&quot;&quot;</span>.join(ch.lower() <span class="keyword">for</span> ch <span class="keyword">in</span> s <span class="keyword">if</span> ch.isalnum())</span><br><span class="line">        <span class="keyword">return</span> s == s[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/valid-palindrome/solution/yan-zheng-hui-wen-chuan-by-leetcode-solution/">https://leetcode.cn/problems/valid-palindrome/solution/yan-zheng-hui-wen-chuan-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h4 id="1-2-3-最长回文子串"><a href="#1-2-3-最长回文子串" class="headerlink" title="1.2.3 最长回文子串"></a>1.2.3 最长回文子串</h4><p>&#8195;&#8195;给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>思路 1：动态规划</strong></p><ul><li><p>初始化一个 <code>n * n</code> 大小的布尔类型数组 <code>dp[][]</code> ，<code>dp[i][j]</code> 表示字符串 <code>s</code> 上 从位置 <code>i</code> 到 <code>j</code> 的子串 <code>s[i...j]</code> 是否是一个回文串，下面进行判断：</p><ul><li><p>当子串只有 <code>1</code> 位或 <code>2</code> 位的时候，如果 <code>s[i] == s[j]</code>，该子串为回文子串， <code>dp[i][j] = (s[i] == s[j])</code>。</p></li><li><p>如果子串大于 <code>2</code> 位，则如果 <code>s[i + 1...j - 1]</code> 是回文串，且 <code>s[i] == s[j]</code>，则 <code>s[i...j]</code> 也是回文串，<code>dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]</code>。</p></li></ul></li><li><p>当判断完 <code>s[i: j]</code> 是否为回文串时，判断并更新最长回文子串的起始位置和最大长度。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        n=<span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义dp[i][j]表示从i到j的子串是否是回文串，初始设为False</span></span><br><span class="line">        dp=[[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        max_len=<span class="number">1</span> <span class="comment"># 回文串最大长度</span></span><br><span class="line">        start=<span class="number">0</span>   <span class="comment"># 最长回文串起始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j):</span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j]:</span><br><span class="line">                    <span class="comment"># 子串长度只有1或2时，一定是回文串</span></span><br><span class="line">                    <span class="keyword">if</span> j-i&lt;<span class="number">3</span>:</span><br><span class="line">                        dp[i][j]=<span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> j-i+<span class="number">1</span>&gt;max_len:</span><br><span class="line">                   max_len=j-i+<span class="number">1</span></span><br><span class="line">                   start=i</span><br><span class="line">                   </span><br><span class="line">        <span class="keyword">return</span> s[start:start+max_len]</span><br></pre></td></tr></table></figure><h4 id="1-2-4-无重复字符的最长子串"><a href="#1-2-4-无重复字符的最长子串" class="headerlink" title="1.2.4 无重复字符的最长子串"></a>1.2.4 无重复字符的最长子串</h4><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        se=<span class="built_in">set</span>()</span><br><span class="line">        ans=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right&lt;<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[right] <span class="keyword">not</span> <span class="keyword">in</span> se:</span><br><span class="line">                se.add(s[right])</span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">                ans=<span class="built_in">max</span>(ans,right-left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                se.remove(s[left])</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l,r=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        ans=<span class="number">0</span></span><br><span class="line">        se=<span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">while</span> s[r] <span class="keyword">in</span> se:</span><br><span class="line">                se.remove(s[l])</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">            se.add(s[r])</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,r-l+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="1-2-5-字符串相加"><a href="#1-2-5-字符串相加" class="headerlink" title="1.2.5 字符串相加"></a>1.2.5 字符串相加</h4><p>&#8195;&#8195;给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>&#8195;&#8195;你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。<br>&#8195;&#8195;<strong>解题思路</strong>：本题不能将字符串直接转为整数之后，在整数之间相加计算。只能对两个大整数模拟「竖式加法」的过程，如下所示：<br><img src="https://img-blog.csdnimg.cn/fb5e6836b75b41acbe1430b7faaea780.png#pic_center =500x" alt="在这里插入图片描述"><br>算法流程： </p><ul><li>设定 <code>i</code>，<code>j</code> 两指针分别指向 <code>num1</code>，<code>num2</code> 尾部，模拟人工加法；</li><li>计算进位： 计算 <code>add= tmp // 10</code>，代表当前位相加是否产生<strong>进位</strong>；</li><li>添加当前位： 计算 <code>tmp = n1 + n2 + add</code>，即当前位的结果。但是这其中要除去进位，所以当前位实际结果是 <code>tmp % 10</code> ，将其添加至 <code>ans</code> 头部；（比如计算9+4=13，当前位计算结果是3，但是进位<code>add=1</code>，累积到高一位的计算中）</li><li>索引溢出处理： 当指针 <code>i</code>或<code>j</code> 走过数字首部后，给 <code>n1</code>，<code>n2</code> 赋值为 <code>0</code>，相当于给 <code>num1</code>，<code>num2</code> 中长度较短的数字前面填 0，以便后续计算。</li><li>当遍历完 <code>num1</code>，<code>num2</code> 后跳出循环，并根据<code>add</code> 值决定是否在头部添加进位 1，最终返回 res 即可。<blockquote><p>&#8195;&#8195;这其中的关键点，就是用add来表示前一位是否对当前位产生了进位，并将这个进位状态不断累加到后续每一位的计算中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        ans=<span class="string">&quot;&quot;</span></span><br><span class="line">        i,j,add=<span class="built_in">len</span>(num1)-<span class="number">1</span>,<span class="built_in">len</span>(num2)-<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">or</span> j&gt;=<span class="number">0</span>:<span class="comment"># 只要有一个数还可以计算</span></span><br><span class="line">            <span class="comment">#位数减为负则补0</span></span><br><span class="line">            n1=<span class="built_in">int</span>(num1[i]) <span class="keyword">if</span> i&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> </span><br><span class="line">            n2=<span class="built_in">int</span>(num2[j]) <span class="keyword">if</span> j&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            temp=n1+n2+add <span class="comment"># 当前位计算结果</span></span><br><span class="line">            add=temp//<span class="number">10</span> <span class="comment">#判断是否要进一位</span></span><br><span class="line">            ans=<span class="built_in">str</span>(temp%<span class="number">10</span>)+ans<span class="comment"># 当前位写入的结果</span></span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>+ans <span class="keyword">if</span> add==<span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure><h4 id="1-2-6-字符串相乘"><a href="#1-2-6-字符串相乘" class="headerlink" title="1.2.6   字符串相乘"></a>1.2.6   字符串相乘</h4><p>&#8195;&#8195;给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p></blockquote></li></ul><p>&#8195;&#8195;注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: num1 = <span class="string">&quot;123&quot;</span>, num2 = <span class="string">&quot;456&quot;</span></span><br><span class="line">输出: <span class="string">&quot;56088&quot;</span></span><br></pre></td></tr></table></figure><p><strong>思路一：先算乘数的每一位相乘结果再相加</strong></p><ul><li>将较长的字符作为被乘数（<code>num1</code>），较短的作为乘数（<code>num2</code>）。</li><li>遍历<code>num2</code>的每一位<code>j</code>，将<code>num2[j]</code>乘以<code>num1</code>的每一位，得到结果<code>ans</code></li><li>将结果<code>ans</code>存在列表<code>ls</code>中，最后再将<code>ls</code>的所有中间结果依次相加（借用上一题的相加函数）</li></ul><p>比如<code>996*32=1992+29980=31872</code>。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span>    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, num1, num2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num1: str</span></span><br><span class="line"><span class="string">        :type num2: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> num1==<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> num2==<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span> <span class="comment"># 如果没有这一步，会算出&#x27;00000&#x27;之类的</span></span><br><span class="line">        <span class="comment"># 将nums1设为更长的数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(num1)-<span class="number">1</span>&lt;<span class="built_in">len</span>(num2)-<span class="number">1</span>:</span><br><span class="line">            num1,num2=num2,num1</span><br><span class="line"></span><br><span class="line">        ls=[]  <span class="comment"># 记录nums2每一位和nums1相乘的结果</span></span><br><span class="line">        count=<span class="number">0</span> <span class="comment"># 记录nums2的位数，每进一位中间结果要乘以10</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num2)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            n2=<span class="built_in">int</span>(num2[j]) <span class="comment"># 用nums2的每一位乘以nums1的所有位</span></span><br><span class="line">            add=<span class="number">0</span></span><br><span class="line">            ans=<span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num1)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>): </span><br><span class="line">                n1=<span class="built_in">int</span>(num1[i]) </span><br><span class="line">                <span class="comment">#print(n1,n2)          </span></span><br><span class="line">                temp=n1*n2+add</span><br><span class="line">                add=temp//<span class="number">10</span></span><br><span class="line">                ans=<span class="built_in">str</span>(temp%<span class="number">10</span>)+ans</span><br><span class="line">            ans=<span class="built_in">str</span>(add)+ans <span class="keyword">if</span> add!=<span class="number">0</span> <span class="keyword">else</span> ans <span class="comment"># 因为是相乘，进位可以是1到8（9*9=81）</span></span><br><span class="line">            ls.append(ans+<span class="string">&#x27;0&#x27;</span>*count)</span><br><span class="line">            count+=<span class="number">1</span>  </span><br><span class="line">        <span class="comment">#print(ls)</span></span><br><span class="line"></span><br><span class="line">        res=<span class="string">&#x27;0&#x27;</span>            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ls)):</span><br><span class="line">            res=self.addStrings(res,ls[i])</span><br><span class="line">        <span class="keyword">return</span>  res </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1, num2</span>):</span> <span class="comment"># 加法函数</span></span><br><span class="line">        ans=<span class="string">&quot;&quot;</span></span><br><span class="line">        i,j,add=<span class="built_in">len</span>(num1)-<span class="number">1</span>,<span class="built_in">len</span>(num2)-<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">or</span> j&gt;=<span class="number">0</span>:<span class="comment"># 只要有一个数还可以计算</span></span><br><span class="line">            <span class="comment">#位数减为负则补0</span></span><br><span class="line">            n1=<span class="built_in">int</span>(num1[i]) <span class="keyword">if</span> i&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> </span><br><span class="line">            n2=<span class="built_in">int</span>(num2[j]) <span class="keyword">if</span> j&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            temp=n1+n2+add <span class="comment"># 当前位计算结果</span></span><br><span class="line">            add=temp//<span class="number">10</span> <span class="comment">#判断是否要进一位</span></span><br><span class="line">            ans=<span class="built_in">str</span>(temp%<span class="number">10</span>)+ans<span class="comment"># 当前位写入的结果</span></span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>+ans <span class="keyword">if</span> add==<span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></p><p><strong>思路二：各位相乘后，再相加</strong></p><p>&#8195;&#8195;长度为 <code>len(num1)</code> 的整数 <code>num1</code> 与长度为 <code>len(num2)</code> 的整数 <code>num2</code> 相乘的结果长度为 <code>len(num1) + len(num2) - 1</code> 或 <code>len(num1) + len(num2)</code>。所以我们可以使用长度为 <code>len(num1) + len(num2)</code> 的整数数组 <code>nums</code> 来存储两个整数相乘之后的结果。（相当于首位可能补了0，如果最终结果没有进位的话）</p><p>整个计算流程的步骤如下：</p><ol><li>从个位数字由低位到高位开始遍历 <code>num1</code>，取得每一位数字 <code>digit1</code>。从个位数字由低位到高位开始遍历 <code>num2</code>，取得每一位数字 <code>digit2</code>。</li><li><strong>将 <code>digit1 * digit2</code> 的结果累积存储到 <code>nums</code> 对应位置 <code>i + j + 1</code> 上。</strong>（比如<code>1996*23</code>时，<code>nums=[0, 2, 21, 45, 39, 18]</code>）</li><li>从 <code>len(num1) + len(num2) - 1</code> 的位置由低位到高位遍历数组 <code>nums</code>。将每个数位上大于等于 <code>10</code> 的数字进行进位操作，然后对该位置上的数字进行取余操作。</li><li>最后判断首位是否有进位。如果首位为 <code>0</code>，则从第 <code>1</code> 个位置开始将答案数组拼接成字符串。如果首位不为 <code>0</code>，则从第 <code>0</code> 个位置开始将答案数组拼接成字符串。并返回答案字符串。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num1 == <span class="string">&quot;0&quot;</span> <span class="keyword">or</span> num2 == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">        len1, len2 = <span class="built_in">len</span>(num1), <span class="built_in">len</span>(num2)</span><br><span class="line">        nums = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(len1 + len2)] <span class="comment"># 首位补0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len1 - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            digit1 = <span class="built_in">int</span>(num1[i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(len2 - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                digit2 = <span class="built_in">int</span>(num2[j])</span><br><span class="line">                <span class="comment"># 比如num1的十位*num2的个位，和num2的十位*num1的个位，结果都在十位上，要累加起来</span></span><br><span class="line">                nums[i + j + <span class="number">1</span>] += digit1 * digit2 </span><br><span class="line">                </span><br><span class="line"><span class="comment"># nums是每一位乘法计算之后的结果，比如[0, 2, 21, 45, 39, 18]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len1 + len2 - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>): <span class="comment"># 从个位遍历到最高位的前一位</span></span><br><span class="line">            nums[i - <span class="number">1</span>] += nums[i] // <span class="number">10</span>        <span class="comment"># 先计算进位，并累加到下一位</span></span><br><span class="line">            nums[i] %= <span class="number">10</span><span class="comment"># 再将当前位结果取余数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            ans = <span class="string">&quot;&quot;</span>.join(<span class="built_in">str</span>(digit) <span class="keyword">for</span> digit <span class="keyword">in</span> nums[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans = <span class="string">&quot;&quot;</span>.join(<span class="built_in">str</span>(digit) <span class="keyword">for</span> digit <span class="keyword">in</span> nums[:])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans    </span><br></pre></td></tr></table></figure><h4 id="1-2-7-最长公共前缀"><a href="#1-2-7-最长公共前缀" class="headerlink" title="1.2.7 最长公共前缀"></a>1.2.7 最长公共前缀</h4><p>&#8195;&#8195;编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。<br><strong>思路一：纵向比较</strong></p><p>&#8195;&#8195;从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        le=[<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> strs]</span><br><span class="line">        min_le=<span class="built_in">min</span>(le) <span class="comment"># 最短的长度</span></span><br><span class="line"></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;min_le:</span><br><span class="line">            se=<span class="built_in">set</span>(strs[<span class="number">0</span>][i]) <span class="comment"># 从第一个字符串的第一个字符开始比较</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> strs[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> ch[i] <span class="keyword">not</span> <span class="keyword">in</span> se:</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br></pre></td></tr></table></figure><br>或者是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        s = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(*strs): <span class="comment"># 直接取出所有字符串的第i列</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(i)) == <span class="number">1</span>:</span><br><span class="line">                s += i[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>           </span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h2 id="二、单模式串匹配算法"><a href="#二、单模式串匹配算法" class="headerlink" title="二、单模式串匹配算法"></a>二、单模式串匹配算法</h2><blockquote><p>参考<a href="https://algo.itcharge.cn/06.String/02.String-Single-Pattern-Matching/03.String-KMP/">《算法通关手册》单模式串匹配篇</a></p><h3 id="2-1-Brute-Force-算法（暴力匹配）"><a href="#2-1-Brute-Force-算法（暴力匹配）" class="headerlink" title="2.1 Brute Force 算法（暴力匹配）"></a>2.1 Brute Force 算法（暴力匹配）</h3><h4 id="2-1-1-算法介绍"><a href="#2-1-1-算法介绍" class="headerlink" title="2.1.1 算法介绍"></a>2.1.1 算法介绍</h4><ul><li><strong>Brute Force 算法</strong>：简称为 BF 算法。中文意思是暴力匹配算法，也可以叫做朴素匹配算法。</li></ul></blockquote><ul><li><strong>BF 算法思想</strong>：对于给定文本串 <code>T</code> 与模式串 <code>p</code>，从文本串的第一个字符开始与模式串 <code>p</code> 的第一个字符进行比较，如果相等，则继续逐个比较后续字符，否则从文本串 <code>T</code> 的第二个字符起重新和模式串 <code>p</code> 进行比较。依次类推，直到模式串 <code>p</code> 中每个字符依次与文本串 <code>T</code> 的一个连续子串相等，则模式匹配成功。否则模式匹配失败。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/06d03ed3c0516d54823fbf3d30413319.png" alt=""></p><ul><li><p><strong>Brute Force 算法步骤</strong></p><ol><li>对于给定的文本串 <code>T</code> 与模式串 <code>p</code>，求出文本串 <code>T</code> 的长度为 <code>n</code>，模式串 <code>p</code> 的长度为 <code>m</code>。</li><li>同时遍历文本串 <code>T</code> 和模式串 <code>p</code>，先将 <code>T[0]</code> 与 <code>p[0]</code> 进行比较。<ol><li>如果相等，则继续比较 <code>T[1]</code> 和 <code>p[1]</code>。以此类推，一直到模式串 <code>p</code> 的末尾 <code>p[m - 1]</code> 为止。</li><li>如果不相等，则将文本串 <code>T</code> 移动到上次匹配开始位置的下一个字符位置，模式串 <code>p</code> 则回退到开始位置，再依次进行比较。</li></ol></li><li>当遍历完文本串 <code>T</code> 或者模式串 <code>p</code> 的时候停止搜索。</li></ol></li></ul><h4 id="2-1-2-代码实现"><a href="#2-1-2-代码实现" class="headerlink" title="2.1.2 代码实现"></a>2.1.2 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bruteForce</span>(<span class="params">T: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    n, m = <span class="built_in">len</span>(T), <span class="built_in">len</span>(p)</span><br><span class="line">    </span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span>                     <span class="comment"># i 表示文本串 T 的当前位置，j 表示模式串 p 的当前位置</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:          <span class="comment"># i 或 j 其中一个到达尾部时停止搜索</span></span><br><span class="line">        <span class="keyword">if</span> T[i] == p[j]:            <span class="comment"># 如果相等，则继续进行下一个字符匹配</span></span><br><span class="line">            i += <span class="number">1</span><span class="comment"># i和j同步右移</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = i - (j - <span class="number">1</span>)         <span class="comment"># 如果匹配失败则将 i 移动到上次匹配开始位置的下一个位置，</span></span><br><span class="line">            j = <span class="number">0</span>                   <span class="comment"># 匹配失败 j 回退到模式串开始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> j == m:</span><br><span class="line">        <span class="keyword">return</span> i - j                <span class="comment"># 匹配成功，返回匹配的开始位置</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>                   <span class="comment"># 匹配失败，返回 -1</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-算法分析"><a href="#2-2-3-算法分析" class="headerlink" title="2.2.3 算法分析"></a>2.2.3 算法分析</h4><p>&#8195;&#8195;BF 算法非常简单，容易理解，但其效率很低。主要是因为在匹配过程中可能会出现回溯：当遇到一对字符不同时，模式串 <code>p</code> 直接回到开始位置，文本串也回到匹配开始位置的下一个位置，再重新开始比较。</p><ul><li><p>最坏时间复杂度为 $O(m \times n)$。在回溯之后，文本串和模式串中一些部分的比较是没有必要的。由于这种操作策略，导致 BF 算法的效率很低。最坏情况是每一趟比较都在模式串的最后遇到了字符不匹配的情况，每轮比较需要进行 <code>m</code> 次字符对比，总共需要进行 <code>n - m + 1</code> 轮比较，总的比较次数为 <code>m * (n - m + 1)</code>。</p></li><li><p>最佳时间复杂度是 $O(m)$。最理想的情况下（第一次匹配直接匹配成功）。</p></li><li><p>平均时间复杂度为 $O(n + m)$。在一般情况下，根据等概率原则，平均搜索次数为 $\frac{(n + m)}{2}$。</p></li></ul><h3 id="2-2-KMP-算法介绍"><a href="#2-2-KMP-算法介绍" class="headerlink" title="2.2 KMP 算法介绍"></a>2.2 KMP 算法介绍</h3><blockquote><p>参考：</p><ul><li><a href="https://algo.itcharge.cn/06.String/02.String-Single-Pattern-Matching/03.String-KMP/">《算法通关手册：KMP 算法》</a></li><li><a href="https://www.zhihu.com/question/21923021/answer/281346746">《如何更好地理解和掌握 KMP 算法?》</a></li><li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/">《【宫水三叶】简单题学 KMP 算法》</a></li></ul><p>&#8195;&#8195;<strong>KMP 算法</strong>：全称叫做 <strong>「Knuth Morris Pratt 算法」</strong>，是由它的三位发明者 Donald Knuth、James H. Morris、 Vaughan Pratt 的名字来命名的。KMP 算法是他们三人在 1977 年联合发表的。</p></blockquote><p>&#8195;&#8195; <strong>KMP 算法思想</strong>：对于给定文本串 <code>T</code> 与模式串 <code>p</code>，当发现文本串 <code>T</code> 的某个字符与模式串 <code>p</code> 不匹配的时候，可以利用匹配失败后的信息，尽量减少模式串与文本串的匹配次数，避免文本串位置的回退，以达到快速匹配的目的。</p><h4 id="2-2-1-朴素匹配算法的缺陷"><a href="#2-2-1-朴素匹配算法的缺陷" class="headerlink" title="2.2.1 朴素匹配算法的缺陷"></a>2.2.1 朴素匹配算法的缺陷</h4><p>&#8195;&#8195;在朴素匹配算法的匹配过程中，我们分别用指针 <code>i</code> 和指针 <code>j</code> 指示文本串 <code>T</code> 和模式串 <code>p</code> 中当前正在对比的字符。当发现文本串 <code>T</code> 的某个字符与模式串 <code>p</code> 不匹配的时候，<code>j</code> 回退到开始位置，<code>i</code> 回退到之前匹配开始位置的下一个位置上（下图的B），继续匹配，直到能够与匹配串对上位置（下图第二个A），如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/90419f77b5ec3db563a3388170214c8e.png" alt=""></p><p>&#8195;&#8195;那么有没有哪种算法，可以让 <code>i</code> 不发生回退，一直向右移动呢？</p><h4 id="2-2-1-改进算法：KMP"><a href="#2-2-1-改进算法：KMP" class="headerlink" title="2.2.1 改进算法：KMP"></a>2.2.1 改进算法：KMP</h4><p>&#8195;&#8195;如果我们可以通过每一次的失配而得到一些「信息」，并且这些「信息」可以帮助我们跳过那些不可能匹配成功的位置，那么我们就能大大减少模式串与文本串的匹配次数，从而达到快速匹配的目的。</p><ol><li>每一次失配所告诉我们的信息是：<strong>主串的某一个子串等于模式串的某一个前缀</strong>。</li></ol><blockquote><ul><li><p>比如文本串 <code>T[i: i + m]</code> 与模式串 <code>p</code> 的失配是下标位置 <code>j</code> 上发生的，那么文本串 <code>T</code> 从下标位置 <code>i</code> 开始连续的 <code>j - 1</code> 个字符，一定与模式串 <code>p</code> 的前 <code>j - 1</code> 个字符一模一样，即：<code>T[i: i + j] == p[0: j]</code>。</p></li><li><p>例如上图中，失配是在下标<code>i+5</code>这个位置发生的，那么失配位置的前<code>5</code>个字符，一定与模式串 <code>p</code> 的前 <code>5</code> 个字符一模一样，即：<code>&quot;ABCAB&quot; == &quot;ABCAB&quot;</code>。</p></li></ul><ol><li>模式串的前 <code>5</code> 个字符中，前 <code>2</code> 位前缀和后 <code>2</code> 位后缀又是相同的，即 <code>&quot;AB&quot; == &quot;AB&quot;</code>。</li></ol></blockquote><p>&#8195;&#8195;所以根据上面的信息，我们可以推出：文本串子串的后 <code>2</code> 位后缀和模式串子串的前 <code>2</code> 位是相同的，即 <code>T[i + 3: i + 5] == p[0: 2]</code>，而这部分（即下图中的蓝色部分）是之前已经比较过的，不需要再比较了，可以直接跳过。</p><p>&#8195;&#8195;那么我们就可以将文本串中的 <code>T[i + 5]</code> 对准模式串中的 <code>p[2]</code>，继续进行对比。这样 <code>i</code> 就不再需要回退了，可以一直向右移动匹配下去。在这个过程中，我们只需要将模式串 <code>j</code> 进行回退操作即可。</p><blockquote><p>&#8195;&#8195;实际上，我们会创建一个next数组作为「部分匹配表」，<code>next[j]</code> 表示的含义是：<strong>记录下标 j 之前（包括 j）的模式串 <code>p</code> 中，最长相等前后缀的长度。</strong>下一节会详细说明。<br>&#8195;&#8195; 由于模式串数组中，<code>next[4] == 2</code>，所以不用回退 <code>i</code>，而是将 <code>j</code> 移动到下标为 <code>2</code> 的位置，让 <code>T[i + 5]</code> 直接对准 <code>p[2]</code>，然后继续进行比对。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1c10c21b12d64b6db024073f4eded908.png" alt=""><br>下图参考<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/">《【宫水三叶】简单题学 KMP 算法》</a></p><p>&#8195;&#8195;也就是说，匹配失败时，匹配串会检查之前已经匹配成功的部分中里是否存在相同的「前缀」和「后缀」。如果存在，则跳转到「前缀」的下一个位置继续往下匹配：<br><img src="https://img-blog.csdnimg.cn/97af9b72d61e4a59b44c03b9a1b17687.png" alt="在这里插入图片描述"><br>&#8195;&#8195;跳转到下一匹配位置后，尝试匹配，发现两个指针的字符对不上，并且此时匹配串指针前面不存在相同的「前缀」和「后缀」，这时候只能回到匹配串的起始位置重新开始：<br><img src="https://img-blog.csdnimg.cn/7e9f01f66079472a96bf2d09ef779543.png" alt="在这里插入图片描述"></p></blockquote><p>&#8195;&#8195;KMP 算法就是使用了这样的思路，对模式串 <code>p</code> 进行了预处理，计算出一个 <strong>「部分匹配表」</strong>(也叫PMT:Partial Match Table)**，用一个数组 <code>next</code> 来记录。然后在每次失配发生时，不回退文本串的指针 <code>i</code>，而是根据「部分匹配表」中模式串失配位置 <code>j</code> 的前一个位置的值，即 <code>next[j - 1]</code> 的值来决定模式串可以向右移动的位数。</p><ul><li>KMP 利用已匹配部分中相同的「前缀」和「后缀」来加速下一次的匹配</li><li>KMP 的原串指针不会进行回溯（没有朴素匹配中回到下一个「发起点」的过程）<h4 id="2-2-3-next-数组"><a href="#2-2-3-next-数组" class="headerlink" title="2.2.3 next 数组"></a>2.2.3 next 数组</h4></li></ul><p>&#8195;&#8195;上文提到的「部分匹配表PMT」，也叫做「前缀表」，在 KMP 算法中使用 <code>next</code> 数组存储。<code>next[j]</code> 表示的含义是：<strong>记录下标 j 之前（包括 j）的模式串 <code>p</code> 中，最长相等前后缀的长度。</strong> 也可以理解为，PMT中的值是<font color='red'> <strong>字符串的前缀集合与后缀集合的交集中最长元素的长度。</strong>&lt;/font &gt;</p><blockquote><ul><li><strong>前缀</strong>：<ul><li>如果字符串A和B，存在<code>A=BS</code>，其中S是任意的非空字符串，那就称<code>B</code>为<code>A</code>的前缀。</li><li>例如，”<code>Harry</code>”的前缀包括{<code>”H”, ”Ha”, ”Har”, ”Harr”</code>}，我们把所有前缀组成的集合，称为字符串的<strong>前缀集合</strong>。</li></ul></li><li><strong>后缀</strong>：<ul><li>若有<code>A=SB</code>， 其中S是任意的非空字符串，那就称<code>B</code>为<code>A</code>的后缀</li><li>例如，”<code>Potter</code>”的后缀包括{<code>”otter”, ”tter”, ”ter”, ”er”, ”r”</code>}，然后把所有后缀组成的集合，称为字符串的<strong>后缀集合</strong>。</li></ul></li><li>对于字符串”<code>ababa</code>”，它的前缀集合为<code>&#123;”a”, ”ab”, ”aba”, ”abab”</code>}，它的后缀集合为<code>&#123;”baba”, ”aba”, ”ba”, ”a”</code>}， 两个集合的交集为{”<code>a”, ”aba”</code>}，其中最长的元素为”<code>aba</code>”，长度为<code>3</code>。</li><li>要注意的是，字符串本身并不是自己的前缀或者后缀。<br><img src="https://img-blog.csdnimg.cn/4c668faba22c48d5acf90557e0ba6846.png" alt="在这里插入图片描述"></li></ul></blockquote><p>举个例子来说明一下，以 <code>p = &quot;ABCABCD&quot;</code> 为例。</p><ul><li><code>next[0] = 0</code>，因为 <code>&quot;A&quot;</code> 中无有相同前缀后缀，最大长度为 <code>0</code>。</li><li><code>next[1] = 0</code>，因为 <code>&quot;AB&quot;</code> 中无相同前缀后缀，最大长度为 <code>0</code>。</li><li><code>next[2] = 0</code>，因为 <code>&quot;ABC&quot;</code> 中无相同前缀后缀，最大长度为 <code>0</code>。</li><li><code>next[3] = 1</code>，因为 <code>&quot;ABCA&quot;</code> 中有相同的前缀后缀 <code>&quot;a&quot;</code>，最大长度为 <code>1</code>。</li><li><code>next[4] = 2</code>，因为 <code>&quot;ABCAB&quot;</code>  中有相同的前缀后缀 <code>&quot;AB&quot;</code>，最大长度为 <code>2</code>。</li><li><code>next[5] = 3</code>，因为 <code>&quot;ABCABC&quot;</code>  中有相同的前缀后缀 <code>&quot;ABC&quot;</code>，最大长度为 <code>3</code>。</li><li><code>next[6] = 0</code>，因为 <code>&quot;ABCABCD&quot;</code>  中无相同前缀后缀，最大长度为 <code>0</code>。</li></ul><p>&#8195;&#8195;同理也可以计算出 <code>&quot;ABCABDEF&quot;</code>  的前缀表为 <code>[0, 0, 0, 1, 2, 0, 0, 0]</code>。<code>&quot;AABAAAB&quot;</code>  的前缀表为 <code>[0, 1, 0, 1, 2, 2, 3]</code>。<code>&quot;ABCDABD&quot;</code> 的前缀表为 <code>[0, 0, 0, 0, 1, 2, 0]</code>。</p><p>&#8195;&#8195;在之前的例子中，当 <code>p[5]</code> 和 <code>T[i + 5]</code> 匹配失败后，根据模式串失配位置 <code>j</code> 的前一个位置的值，即 <code>next[4] = 2</code>，我们直接让 <code>T[i + 5]</code> 直接对准了 <code>p[2]</code>，然后继续进行比对，如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e398bec5a4f92734b7243cf2fa26ea87.png" alt=""></p><p><strong>但是这样移动的原理是什么？</strong></p><p>如果文本串 <code>T[i: i + m]</code> 与模式串 <code>p</code> 的失配是在第 <code>j</code> 个下标位置发生的，那么：</p><ul><li>文本串 <code>T</code> 从下标位置 <code>i</code> 开始连续的 <code>j</code> 个字符，一定与模式串 <code>p</code> 的前 <code>j</code> 个字符一模一样，即：<code>T[i: i + j] == p[0: j]</code>（上图中的<code>&quot;ABCAB&quot; == &quot;ABCAB&quot;</code>）。</li><li><p>而如果模式串 <code>p</code> 的前 <code>j</code> 个字符中，前 <code>k</code> 位前缀和后 <code>k</code> 位后缀相同，（<code>&quot;ABCAB&quot;</code>中有相同的前后缀<code>&quot;AB&quot;</code>，即<code>k=2</code>）那么可以断言：文本串中<code>i</code>指针失配位置之前的 <code>k</code> 位（”<code>AB</code>“）一定与模式字符串的第<code>0</code>位至第 <code>k</code>位是相同的（”<code>AB</code>“），即长度为 <code>k</code>的后缀与前缀相同。</p></li><li><p>这样一来，我们就可以将这些字符段的比较省略掉。具体的做法是，保持<code>i</code>指针不动，然后将<code>j</code>指针指向模式字符串的<code>next[j −1]</code>位即可（表示模式串中，前<code>j-1</code>个子符里，最长相同前后缀的长度<code>k</code>）。</p></li></ul><blockquote><p>其实相当于因为模式串存在相同的前后缀，所以失配后，模式串不用退回起始位置，退到相同前缀的下一位置就行。</p></blockquote><h4 id="2-2-4-next-数组的构造"><a href="#2-2-4-next-数组的构造" class="headerlink" title="2.2.4 next 数组的构造"></a>2.2.4 next 数组的构造</h4><p>&#8195;&#8195;其实，求<code>next</code>数组的过程完全可以看成字符串匹配的过程，即以模式字符串为文本串串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的<code>next</code>值就是匹配成功的字符串的长度。<br>&#8195;&#8195;具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的<code>next</code>值。如下图所示。</p><blockquote><p>数组下标从0开始，所以图中应该是<code>next[5]=4</code>，以此类推。下图模式串有<code>next=[0, 0, 1, 2, 3, 4, 0, 1]</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/7e695da5918c470fae67e1d37a8dec2e.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6cb1c32ec6ef4effadca78ea25d3fb4e.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d8d42bb313bd426aa620c599926a437b.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/727e4cd34a894196ac94d707d2c7a645.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/529c2c60c5e240dfb93577cb45eeabfb.png" alt="在这里插入图片描述"></p><p>这样我们就可以使用KMP本身的匹配原理来计算next数组。</p><ul><li>我们将模式串p本身即作为文本串也作为模式串，同样用指针<code>i</code>和<code>j</code>来遍历。因为文本串第一个位置即使匹配上 ，也有next[0]=0，而不等于1，所以初始时令<code>j = 0</code>，<code>i = 1</code>。</li><li>遍历文本串和模式串：<ul><li>如果 <code>p[i] != p[j]</code>，说明文本串在此位置失配，同上面所讲， <code>i</code> 不动，模式串指针 <code>j</code> 不断回退到 <code>next[j - 1]</code> 位置。<ul><li>如果回退几次后，有 <code>p[i] == p[j]</code> ，说明匹配上了一个字符，令<code>j</code>右移，此时此时 <code>j</code>  既是前缀下一次进行比较的下标位置，又是当前最长前后缀的长度，所以<code>next[i]=j</code>。最后移动指针i遍历下一个位置；</li><li>如果一直回退到<code>j=0</code>，表示文本串在<code>i</code>位置匹配不到任何一个字符，<code>next[i]=0=j</code>，<code>i+=1</code>；</li></ul></li><li>如果 <code>p[i] == p[j]</code>，同样先将 <code>j += 1</code>，<code>next[i]=j</code>，<code>i+=1</code>；</li></ul></li></ul><blockquote><ul><li>如果<code>p[j]==p[i]</code>，<code>j</code>先后移，<code>next[i]=j</code>，然后<code>i</code>后移；</li><li>如果不匹配，前缀指针回退，退到前一位置的<code>next</code>值，即<code>j=next[j-1]</code>，不停回退，直到<code>p[j]==p[i]</code>，或者j=0表示退到模式串开头位置，此时<code>next[i]=0</code>（因为<code>j=0</code>，所以依旧有<code>next[i]=j</code>），表示没有匹配的共同前后缀。<br><img src="https://img-blog.csdnimg.cn/90342fcb20f34047a644b63e7ee17243.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ec32c5699af645b5aa49c526e8fc83db.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/68b7376aadef44d3a103d7dd705f584e.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c08fe49b0df0499d94c4ffa3dcba5787.png" alt="在这里插入图片描述"></li></ul></blockquote><h4 id="2-2-5-KMP-算法整体步骤和代码实现"><a href="#2-2-5-KMP-算法整体步骤和代码实现" class="headerlink" title="2.2.5 KMP 算法整体步骤和代码实现"></a>2.2.5 KMP 算法整体步骤和代码实现</h4><ol><li>根据 <code>next</code> 数组的构造步骤生成「前缀表」<code>next</code>。</li><li>使用两个指针 <code>i</code>、<code>j</code>，其中 <code>i</code> 指向文本串中当前匹配的位置，<code>j</code> 指向模式串中当前匹配的位置。初始时，<code>i = 0</code>，<code>j = 0</code>。</li><li>循环判断模式串前缀是否匹配成功，如果模式串前缀匹配不成功，将模式串进行回退，即 <code>j = next[j - 1]</code>，直到 <code>j == 0</code> 时或前缀匹配成功时停止回退。</li><li>如果当前模式串前缀匹配成功，则令模式串向右移动 <code>1</code> 位，即 <code>j += 1</code>。</li><li>如果当前模式串 <strong>完全</strong> 匹配成功，则返回模式串 <code>p</code> 在文本串 <code>T</code> 中的开始位置，即 <code>i - j + 1</code>。</li><li>如果还未完全匹配成功，则令文本串向右移动 <code>1</code> 位，即 <code>i += 1</code>，然后继续匹配。</li><li>如果直到文本串遍历完也未完全匹配成功，则说明匹配失败，返回 <code>-1</code>。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 next 数组</span></span><br><span class="line"><span class="comment"># next[j] 表示下标 j 之前的模式串 p 中，最长相等前后缀的长度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateNext</span>(<span class="params">p: <span class="built_in">str</span></span>):</span></span><br><span class="line">    m = <span class="built_in">len</span>(p)</span><br><span class="line">    <span class="built_in">next</span> = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]                <span class="comment"># 初始化数组元素全部为 0</span></span><br><span class="line">    </span><br><span class="line">    left = <span class="number">0</span>                                    <span class="comment"># left 表示前缀串开始所在的下标位置</span></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):                   <span class="comment"># right 表示后缀串开始所在的下标位置</span></span><br><span class="line">        <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> p[left] != p[right]: <span class="comment"># 匹配不成功, left 进行回退, left == 0 时停止回退</span></span><br><span class="line">            left = <span class="built_in">next</span>[left - <span class="number">1</span>]               <span class="comment"># left 进行回退操作</span></span><br><span class="line">        <span class="keyword">if</span> p[left] == p[right]:                 <span class="comment"># 匹配成功，找到相同的前后缀，先让 left += 1，此时 left 为前缀长度</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="built_in">next</span>[right] = left                      <span class="comment"># 记录前缀长度，更新 next[right], 结束本次循环, right += 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># KMP 匹配算法，T 为文本串，p 为模式串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmp</span>(<span class="params">T: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    n, m = <span class="built_in">len</span>(T), <span class="built_in">len</span>(p)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">next</span> = generateNext(p)                      <span class="comment"># 生成 next 数组</span></span><br><span class="line">    </span><br><span class="line">    j = <span class="number">0</span>                                       <span class="comment"># j 为模式串中当前匹配的位置</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):                          <span class="comment"># i 为文本串中当前匹配的位置</span></span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> T[i] != p[j]:           <span class="comment"># 如果模式串前缀匹配不成功, 将模式串进行回退, j == 0 时停止回退</span></span><br><span class="line">            j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> T[i] == p[j]:                        <span class="comment"># 当前模式串前缀匹配成功，令 j += 1，继续匹配</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j == m:                              <span class="comment"># 当前模式串完全匹配成功，返回匹配开始位置</span></span><br><span class="line">            <span class="keyword">return</span> i - j + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>                                   <span class="comment"># 匹配失败，返回 -1            </span></span><br></pre></td></tr></table></figure><h4 id="2-2-5-KMP-算法分析"><a href="#2-2-5-KMP-算法分析" class="headerlink" title="2.2.5 KMP 算法分析"></a>2.2.5 KMP 算法分析</h4><ul><li>KMP 算法在构造前缀表阶段的时间复杂度为 $O(m)$，其中 $m$ 是模式串 <code>p</code> 的长度。</li><li>KMP 算法在匹配阶段，是根据前缀表不断调整匹配的位置，文本串的下标 <code>i</code> 并没有进行回退，可以看出匹配阶段的时间复杂度是 $O(n)$，其中 $n$ 是文本串 <code>T</code> 的长度。</li><li>所以 KMP 整个算法的时间复杂度是 $O(n + m)$，相对于朴素匹配算法的 $O(n * m)$ 的时间复杂度，KMP 算法的效率有了很大的提升。</li></ul><blockquote><p>参考资料</p><ul><li>【博文】<a href="https://blog.csdn.net/v_JULY_v/article/details/7041827?spm=1001.2014.3001.5502">从头到尾彻底理解 KMP - 结构之法 算法之道 - CSDN博客</a></li><li>【博文】<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html">字符串匹配的 KMP 算法 - 阮一峰的网络日志</a></li><li>【题解】<a href="https://leetcode.cn/problems/implement-strstr/solution/duo-tu-yu-jing-xiang-jie-kmp-suan-fa-by-w3c9c/">多图预警👊🏻详解 KMP 算法 - 实现 strStr() - 力扣</a></li><li>【题解】<a href="https://leetcode.cn/problems/implement-strstr/solution/dai-ma-sui-xiang-lu-kmpsuan-fa-xiang-jie-mfbs/">「代码随想录」KMP算法详解 - 实现 strStr() - 力扣</a></li></ul></blockquote><h2 id="三、单模式串匹配练习"><a href="#三、单模式串匹配练习" class="headerlink" title="三、单模式串匹配练习"></a>三、单模式串匹配练习</h2><h3 id="3-1-单模式串匹配题目"><a href="#3-1-单模式串匹配题目" class="headerlink" title="3.1 单模式串匹配题目"></a>3.1 单模式串匹配题目</h3><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0028</td><td style="text-align:left"><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">找出字符串中第一个匹配项的下标</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0028.%20%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87.md">Python</a></td><td style="text-align:left">字符串、双指针</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0459</td><td style="text-align:left"><a href="https://leetcode.cn/problems/repeated-substring-pattern/">重复的子字符串</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0459.%20%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.md">Python</a></td><td style="text-align:left">字符串、字符串匹配</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0686</td><td style="text-align:left"><a href="https://leetcode.cn/problems/repeated-string-match/">重复叠加字符串匹配</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0686.%20%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D.md">Python</a></td><td style="text-align:left">字符串、字符串匹配</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">1668</td><td style="text-align:left">最大重复子字符串</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0796</td><td style="text-align:left"><a href="https://leetcode.cn/problems/rotate-string/">旋转字符串</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0796.%20%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.md">Python</a></td><td style="text-align:left">字符串、字符串匹配</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">1408</td><td style="text-align:left"><a href="https://leetcode.cn/problems/string-matching-in-an-array/">数组中的字符串匹配</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/1408.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D.md">Python</a></td><td style="text-align:left">字符串、字符串匹配</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">2156</td><td style="text-align:left"><a href="https://leetcode.cn/problems/find-substring-with-given-hash-value/">查找给定哈希值的子串</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/2156.%20%E6%9F%A5%E6%89%BE%E7%BB%99%E5%AE%9A%E5%93%88%E5%B8%8C%E5%80%BC%E7%9A%84%E5%AD%90%E4%B8%B2.md">Python</a></td><td style="text-align:left">字符串、滑动窗口、哈希函数、滚动哈希</td><td style="text-align:left">中等</td></tr></tbody></table></div><h3 id="3-2-找出字符串中第一个匹配项的下标"><a href="#3-2-找出字符串中第一个匹配项的下标" class="headerlink" title="3.2 找出字符串中第一个匹配项的下标"></a>3.2 找出字符串中第一个匹配项的下标</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack, needle</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type haystack: str</span></span><br><span class="line"><span class="string">        :type needle: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># KMP 匹配算法，haystack 为文本串，needle 为模式串</span></span><br><span class="line">        m,n = <span class="built_in">len</span>(haystack), <span class="built_in">len</span>(needle)</span><br><span class="line">        <span class="built_in">next</span> = self.<span class="built_in">next</span>(needle)  <span class="comment"># 生成 next 数组</span></span><br><span class="line">        j = <span class="number">0</span>                                             <span class="comment"># j 为模式串中当前匹配的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):                                <span class="comment"># i 为文本串中当前匹配的位置</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j]:     <span class="comment"># 如果模式串前缀匹配不成功, 将模式串进行回退, j == 0 时停止回退</span></span><br><span class="line">                j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:                  <span class="comment"># 当前模式串前缀匹配成功，令 j += 1，继续匹配</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == n:                                <span class="comment"># 当前模式串完全匹配成功，返回匹配开始位置</span></span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self,p</span>):</span></span><br><span class="line">        <span class="comment"># 等同于模式串自己和自己匹配，只不过文本串从1开始（第一位匹配到结果也应该是0不是1），模式串从0开始</span></span><br><span class="line">        <span class="built_in">next</span>=[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p))]</span><br><span class="line">        j=<span class="number">0</span> <span class="comment"># 模式串匹配起始位置，也是匹配到的长度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(p)):</span><br><span class="line">            <span class="comment">#次序反过来，left右移，下一步判定就不对了</span></span><br><span class="line">            <span class="comment">#if p[left]==p[right]:</span></span><br><span class="line">                <span class="comment">#left+=1</span></span><br><span class="line">            <span class="comment"># 先判定不相等就回退，直到相等再右移模式串指针，进行下一步比较</span></span><br><span class="line">            <span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> p[j]!=p[i]:</span><br><span class="line">                j=<span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> p[i]==p[j]:</span><br><span class="line">                j+=<span class="number">1</span> <span class="comment"># 匹配上了，公共前后缀长度+1</span></span><br><span class="line">            <span class="built_in">next</span>[i]=j</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span> </span><br></pre></td></tr></table></figure><h3 id="3-3-重复的子字符串"><a href="#3-3-重复的子字符串" class="headerlink" title="3.3 重复的子字符串"></a>3.3 重复的子字符串</h3><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;abcabcabcabc&quot;</span></span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 <span class="string">&quot;abc&quot;</span> 重复四次构成。 (或子串 <span class="string">&quot;abcabc&quot;</span> 重复两次构成。)</span><br></pre></td></tr></table></figure></p><ol><li>思路一：<a href="https://leetcode.cn/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/">官方题解</a><br><img src="https://img-blog.csdnimg.cn/11a7f3154b684b7aad14871b250b7618.png" alt="在这里插入图片描述"></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (s+s).find(s,<span class="number">1</span>)!=<span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure><p>思路二：KMP（参考<a href="https://algo.itcharge.cn/Solutions/0400-0499/repeated-substring-pattern/">《算法通关手册》</a>）<br>&#8195;&#8195;我们知道 <code>next[j]</code> 表示的含义是：记录下标 <code>j</code> 之前（包括 j）的模式串 <code>p</code> 中，最长相等前后缀的长度。<br>&#8195;&#8195;而如果整个模式串 p 的最长相等前后缀长度不为 0，即 <code>next[len(p) - 1] != 0</code> ，则说明整个模式串 p 中有最长相同的前后缀。假设 <code>next[len(p) - 1] == k</code>，则说明 <code>p[0: k] == p[m - k: m]</code>。比如字符串 “abcabcabc”，最长相同前后缀为 “abcabc” = “abcabc”。</p><ul><li>如果最长相等的前后缀是重叠的，比如之前的例子 “abcabcabc”。<ul><li>如果我们去除字符串中相同的前后缀的重叠部分，剩下两头前后缀部分（这两部分是相同的）。然后再去除剩余的后缀部分，只保留剩余的前缀部分。比如字符串 “abcabcabc” 去除重叠部分和剩余的后缀部分之后就是 “abc”。实际上这个部分就是字符串去除整个后缀部分的剩余部分。</li><li>如果整个字符串可以通过子串重复构成的话，那么这部分就是最小周期的子串。</li><li>我们只需要判断整个子串的长度是否是剩余部分长度的整数倍即可。也就是判断 <code>len(p) % (len(p) - next[size - 1]) == 0</code> 是否成立，如果成立，则字符串 s 可由 <code>s[0: len(p) - next[size - 1]]</code> 构成的子串重复构成，返回 <code>True</code>。否则返回 <code>False</code>。</li></ul></li><li>如果最长相等的前后缀是不重叠的，那我们可将重叠部分视为长度为 <code>0</code> 的空串，则剩余的部分其实就是去除后缀部分的剩余部分，上述结论依旧成立。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="comment"># 创建next数组</span></span><br><span class="line">        le=<span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> le==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="built_in">next</span>=[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(le)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,le):</span><br><span class="line">            <span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> s[i]!=s[j]:</span><br><span class="line">                j=<span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> s[i]==s[j]:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="built_in">next</span>[i]=j</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># next数组最后一位的值，表示模式串的最长相等前后缀长度。</span></span><br><span class="line">        <span class="comment"># 将其除去前后缀重叠部分和剩余的后缀部分，就是剩余前缀部分。</span></span><br><span class="line">        <span class="comment"># 这部分就是最小周期长度，可以被模式串长度整除</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">next</span>[le-<span class="number">1</span>]!=<span class="number">0</span> <span class="keyword">and</span> le%(le-<span class="built_in">next</span>[le-<span class="number">1</span>])==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="3-4-重复叠加字符串匹配"><a href="#3-4-重复叠加字符串匹配" class="headerlink" title="3.4 重复叠加字符串匹配"></a>3.4 重复叠加字符串匹配</h3>&#8195;&#8195;给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：a = <span class="string">&quot;abcd&quot;</span>, b = <span class="string">&quot;cdabcdab&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：a 重复叠加三遍后为 <span class="string">&quot;abcdabcdabcd&quot;</span>, 此时 b 是其子串。    </span><br></pre></td></tr></table></figure><p>首先，可以分析复制次数的「下界」和「上界」为何值：</p><ul><li>「下界」：至少将 a 复制长度大于等于 b 的长度，才有可能匹配</li><li>「上界」：由于主串是由 a 复制多次而来，并且是从主串中找到子串 b，因此可以明确子串的起始位置，不会超过 a 的长度。即长度越过 a 长度的起始匹配位置，必然在此前已经被匹配过了。由此，我们可知复制次数「上界」最多为「下界 + 1」<br><img src="https://img-blog.csdnimg.cn/da8507eccbac4687a8ef8648ce7e15a4.png#pic_center =500x" alt="在这里插入图片描述"></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedStringMatch</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="comment"># 将b看做模式串，a最低重复次数是len([a]*count)=len(b)，即至少的是一样长</span></span><br><span class="line">    <span class="comment"># 最大重复次数是count+1。</span></span><br><span class="line">    <span class="comment"># 将a复制（n+1）次后匹配b，如果匹配下标超过n，则表示无法重复，否则返回count</span></span><br><span class="line">        m,n=<span class="built_in">len</span>(a),<span class="built_in">len</span>(b)</span><br><span class="line">        count=(n//m)+<span class="number">1</span> <span class="keyword">if</span> n%m!=<span class="number">0</span> <span class="keyword">else</span> n//m</span><br><span class="line">        a=a*(count+<span class="number">1</span>)</span><br><span class="line">        idx=a.find(b)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> idx ==-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx=idx+n-<span class="number">1</span> <span class="comment"># 匹配串的结束位置</span></span><br><span class="line">            <span class="keyword">return</span> count <span class="keyword">if</span> idx&lt;m*count <span class="keyword">else</span> count +<span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果用KMP算法代替find函数写，就是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedStringMatch</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="comment"># 将b看做模式串，a最低重复次数是len([a]*count)=len(b)，即至少的是一样长</span></span><br><span class="line">    <span class="comment"># 最大重复次数是count+1。</span></span><br><span class="line">    <span class="comment"># 将a复制（n+1）次后匹配b，如果匹配下标超过n，则表示无法重复，否则返回count</span></span><br><span class="line">        m,n=<span class="built_in">len</span>(a),<span class="built_in">len</span>(b)</span><br><span class="line">        count=(n//m)+<span class="number">1</span> <span class="keyword">if</span> n%m!=<span class="number">0</span> <span class="keyword">else</span> n//m</span><br><span class="line">        a=a*(count+<span class="number">1</span>)</span><br><span class="line">        idx=self.KMP(a,b)</span><br><span class="line">        <span class="built_in">print</span>(idx)</span><br><span class="line">        <span class="keyword">if</span> idx ==-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:        </span><br><span class="line">            <span class="keyword">return</span> count <span class="keyword">if</span> idx&lt;m*count <span class="keyword">else</span> count +<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KMP</span>(<span class="params">self, t, p</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type haystack: str</span></span><br><span class="line"><span class="string">        :type needle: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># KMP 匹配算法，haystack 为文本串，needle 为模式串</span></span><br><span class="line">        m,n = <span class="built_in">len</span>(t), <span class="built_in">len</span>(p)</span><br><span class="line">        <span class="built_in">next</span> = self.<span class="built_in">next</span>(p)  <span class="comment"># 生成 next 数组</span></span><br><span class="line">        j = <span class="number">0</span>                                               <span class="comment"># j 为模式串中当前匹配的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):                          <span class="comment"># i 为文本串中当前匹配的位置</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> t[i] != p[j]:           <span class="comment"># 如果模式串前缀匹配不成功, 将模式串进行回退, j == 0 时停止回退</span></span><br><span class="line">                j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> t[i] == p[j]:                        <span class="comment"># 当前模式串前缀匹配成功，令 j += 1，继续匹配</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == n:                              <span class="comment"># 当前模式串完全匹配成功，返回匹配结束位置</span></span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self,p</span>):</span></span><br><span class="line">        <span class="comment"># 等同于模式串自己和自己匹配看前缀，只不过文本串从1开始（第一位匹配到结果也应该是0不是1），模式串从0开始</span></span><br><span class="line">        <span class="built_in">next</span>=[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p))]</span><br><span class="line">        j=<span class="number">0</span> <span class="comment"># 共同前缀下标</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(p)):</span><br><span class="line">            <span class="comment">#次序反过来，left右移，下一步判定就不对了</span></span><br><span class="line">            <span class="comment">#if p[left]==p[right]:</span></span><br><span class="line">                <span class="comment">#left+=1</span></span><br><span class="line">            <span class="comment"># 先判定不相等就回退，直到相等再右移模式串指针，进行下一步比较</span></span><br><span class="line">            <span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> p[j]!=p[i]:</span><br><span class="line">                j=<span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> p[i]==p[j]:</span><br><span class="line">                j+=<span class="number">1</span> <span class="comment"># 匹配时，公共前后缀长度+1</span></span><br><span class="line">            <span class="built_in">next</span>[i]=j</span><br><span class="line">        <span class="comment">#print(next)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="3-5-最大重复子字符串"><a href="#3-5-最大重复子字符串" class="headerlink" title="3.5 最大重复子字符串"></a>3.5 最大重复子字符串</h3><p>&#8195;&#8195;给你一个字符串 sequence ，如果字符串 word 连续重复 k 次形成的字符串是 sequence 的一个子字符串，那么单词 word 的 重复值为 k 。单词 word 的 最大重复值 是单词 word 在 sequence 中最大的重复值。如果 word 不是 sequence 的子串，那么重复值 k 为 0 。</p><p>&#8195;&#8195;给你一个字符串 sequence 和 word ，请你返回 最大重复值 k 。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：sequence = <span class="string">&quot;ababc&quot;</span>, word = <span class="string">&quot;ba&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="string">&quot;ba&quot;</span> 是 <span class="string">&quot;ababc&quot;</span> 的子字符串，但 <span class="string">&quot;baba&quot;</span> 不是 <span class="string">&quot;ababc&quot;</span> 的子字符串。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxRepeating</span>(<span class="params">self, sequence, word</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type sequence: str</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (ans*word) <span class="keyword">in</span> sequence:</span><br><span class="line">            ans+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans -<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxRepeating</span>(<span class="params">self, sequence, word</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type sequence: str</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m,n=<span class="built_in">len</span>(sequence),<span class="built_in">len</span>(word)</span><br><span class="line">        max_count=m//n</span><br><span class="line">        ans,count=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> count&lt;=max_count:</span><br><span class="line">            temp=word*count</span><br><span class="line">            <span class="keyword">if</span> sequence.find(temp)!=-<span class="number">1</span>:</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,count)</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="3-6-旋转字符串"><a href="#3-6-旋转字符串" class="headerlink" title="3.6 旋转字符串"></a>3.6 旋转字符串</h3><ul><li>给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。</li><li>s 的 旋转操作 就是将 s 最左边的字符移动到最右边。 </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;abcde&quot;</span>, goal = <span class="string">&quot;cdeab&quot;</span></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateString</span>(<span class="params">self, s, goal</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type goal: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> goal <span class="keyword">in</span> s+s <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="built_in">len</span>(goal) <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;@[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;https://algo.itcharge.cn/06.String/01.String-Basic/01.String-Basic/&quot;&gt;《算法通关手册》字符串篇&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、字符串基础&quot;&gt;&lt;a href=&quot;#一、字符串基础&quot; class=&quot;headerlink&quot; title=&quot;一、字符串基础&quot;&gt;&lt;/a&gt;一、字符串基础&lt;/h2&gt;&lt;h3 id=&quot;1-1-字符串基础知识&quot;&gt;&lt;a href=&quot;#1-1-字符串基础知识&quot; class=&quot;headerlink&quot; title=&quot;1.1 字符串基础知识&quot;&gt;&lt;/a&gt;1.1 字符串基础知识&lt;/h3&gt;&lt;h4 id=&quot;1-1-1-字符串简介&quot;&gt;&lt;a href=&quot;#1-1-1-字符串简介&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 字符串简介&quot;&gt;&lt;/a&gt;1.1.1 字符串简介&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;字符串的表示:字符串是由0个或多个字符组成的有序字符序列，由一对单引号或一对双引号表示&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/4f88e8eacc4b429e88f9284acaeec927.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;</summary>
    
    
    
    <category term="Data Structure and Algorithms" scheme="https://zhxnlp.github.io/categories/Data-Structure-and-Algorithms/"/>
    
    
    <category term="leetcode" scheme="https://zhxnlp.github.io/tags/leetcode/"/>
    
    <category term="String" scheme="https://zhxnlp.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习五：哈希表</title>
    <link href="https://zhxnlp.github.io/2023/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E4%BA%94%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://zhxnlp.github.io/2023/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E4%BA%94%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2023-03-11T16:00:00.000Z</published>
    <updated>2023-04-08T00:40:37.975Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>参考</p><ul><li><a href="https://algo.itcharge.cn/05.Hash-Table/01.Hash-Table/">《算法通关手册》-哈希表篇</a></li><li>【博文】<a href="https://time.geekbang.org/column/article/64233">散列表（上）- 数据结构与算法之美 - 极客时间</a><h2 id="一、哈希表"><a href="#一、哈希表" class="headerlink" title="一、哈希表"></a>一、哈希表</h2><h3 id="1-1-哈希表简介"><a href="#1-1-哈希表简介" class="headerlink" title="1.1 哈希表简介"></a>1.1 哈希表简介</h3></li></ul></blockquote><p>&#8195;&#8195; <strong>哈希表（Hash Table）</strong>：也叫做散列表。是根据关键码值（Key Value）直接进行访问的数据结构。<br>&#8195;&#8195; 哈希表通过「键 <code>key</code> 」和「映射函数 <code>Hash(key)</code> 」计算出对应的「值 <code>value</code>」，把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做「哈希函数（散列函数）」，存放记录的数组叫做「哈希表（散列表）」。</p><p>哈希表的关键思想是使用哈希函数，将键 <code>key</code> 映射到对应表的某个区块中。我们可以将算法思想分为两个部分：</p><ul><li><strong>向哈希表中插入一个关键码值</strong>：哈希函数决定该关键字的对应值应该存放到表中的哪个区块，并将对应值存放到该区块中。</li><li><strong>在哈希表中搜索一个关键码值</strong>：使用相同的哈希函数从哈希表中查找对应的区块，并在特定的区块搜索该关键字对应的值。</li></ul><p>哈希表的原理示例图如下所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/130e45ed6844703a636560c67a3bb15a.png" alt=""><br><span id="more"></span><br>&#8195;&#8195;在上图例子中，我们使用 <code>value = Hash(key) =  key // 1000</code> 作为哈希函数。<code>//</code> 符号代表整除。我们以这个例子来说明一下哈希表的插入和查找策略。</p><ul><li><strong>向哈希表中插入一个关键码值</strong>：通过哈希函数解析关键字，并将对应值存放到该区块中。<ul><li>比如：<code>0138</code> 通过哈希函数 <code>Hash(key) = 0138 // 100 = 0</code>，得出应将 <code>0138</code> 分配到<code>0</code> 所在的区块中。</li></ul></li><li><strong>在哈希表中搜索一个关键码值</strong>：通过哈希函数解析关键字，并在特定的区块搜索该关键字对应的值。<ul><li>比如：查找 <code>2321</code>，通过哈希函数，得出 <code>2321</code> 应该在 <code>2</code> 所对应的区块中。然后我们从 <code>2</code> 对应的区块中继续搜索，并在 <code>2</code> 对应的区块中成功找到了 <code>2321</code>。</li><li>比如：查找 <code>3214</code>，通过哈希函数，得出 <code>3214</code> 应该在 <code>3</code> 所对应的区块中。然后我们从 <code>3</code> 对应的区块中继续搜索，但并没有找到对应值，则说明 <code>3214</code> 不在哈希表中。</li></ul></li></ul><p>哈希表在生活中的应用也很广泛，其中一个常见例子就是「查字典」。</p><p>比如为了查找 <code>赞</code> 这个字的具体意思，我们在字典中根据这个字的拼音索引 <code>zan</code>，查找到对应的页码为 <code>599</code>。然后我们就可以翻到字典的第 <code>599</code> 页查看 <code>赞</code> 字相关的解释了。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a1d771327baf674b4683336facef993b.png" alt=""></p><p>在这个例子中：</p><ul><li>存放所有拼音和对应地址的表可以看做是 <strong>「哈希表」</strong>。</li><li><code>赞</code> 字的拼音索引 <code>zan</code> 可以看做是哈希表中的 <strong>「关键字 <code>key</code>」</strong>。</li><li>根据拼音索引 <code>zan</code> 来确定字对应页码的过程可以看做是哈希表中的 <strong>「哈希函数 <code>Hash(key)</code>」</strong>。</li><li>查找到的对应页码 <code>599</code> 可以看做是哈希表中的 <strong>「哈希地址 <code>value</code>」</strong>。</li></ul><h3 id="1-2-哈希函数"><a href="#1-2-哈希函数" class="headerlink" title="1.2 哈希函数"></a>1.2 哈希函数</h3><blockquote><p><strong>哈希函数（Hash Function）</strong>：将哈希表中元素的关键键值映射为元素存储位置的函数。</p></blockquote><p>哈希函数是哈希表中最重要的部分。一般来说，哈希函数会满足以下几个条件：</p><ul><li>哈希函数应该易于计算，并且尽量使计算出来的索引值均匀分布。</li><li>哈希函数计算得到的哈希值是一个固定长度的输出值。</li><li>如果 <code>Hash(key1)</code> 不等于 <code>Hash(key2)</code>，那么 <code>key1</code>、<code>key2</code> 一定不相等。</li><li>如果 <code>Hash(key1)</code> 等于 <code>Hash(key2)</code>，那么 <code>key1</code>、<code>key2</code> 可能相等，也可能不相等（会发生哈希碰撞）。</li></ul><p>&#8195;&#8195;在哈希表的实际应用中，关键字的类型除了数字类，还有可能是字符串类型、浮点数类型、大整数类型，甚至还有可能是几种类型的组合。一般我们会将各种类型的关键字先转换为整数类型，再通过哈希函数，将其映射到哈希表中。</p><p>&#8195;&#8195;而关于整数类型的关键字，通常用到的哈希函数方法有：直接定址法、除留余数法、平方取中法、基数转换法、数字分析法、折叠法、随机数法、乘积法、点积法等。下面我们介绍几个常用的哈希函数方法。</p><h4 id="1-2-1-直接定址法"><a href="#1-2-1-直接定址法" class="headerlink" title="1.2.1 直接定址法"></a>1.2.1 直接定址法</h4><ul><li><strong>直接定址法</strong>：取关键字本身 / 关键字的某个线性函数值 作为哈希地址。即：<code>Hash(key) = key</code> 或者 <code>Hash(key) = a * key + b</code>，其中 <code>a</code> 和 <code>b</code> 为常数。</li></ul><p>&#8195;&#8195;这种方法计算最简单，且不会产生冲突。适合于关键字分布基本连续的情况，如果关键字分布不连续，空位较多，则会造成存储空间的浪费。</p><p>&#8195;&#8195;举一个例子，假设我们有一个记录了从 <code>1</code> 岁到 <code>100</code> 岁的人口数字统计表。其中年龄为关键字，哈希函数取关键字自身，如下表所示。</p><div class="table-container"><table><thead><tr><th style="text-align:center">年龄</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">…</th><th style="text-align:center">25</th><th style="text-align:center">26</th><th style="text-align:center">27</th><th style="text-align:center">…</th><th style="text-align:center">100</th></tr></thead><tbody><tr><td style="text-align:center">人数</td><td style="text-align:center">3000</td><td style="text-align:center">2000</td><td style="text-align:center">5000</td><td style="text-align:center">…</td><td style="text-align:center">1050</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table></div><p>比如我们想要查询 <code>25</code> 岁的人有多少，则只要查询表中第 <code>25</code> 项即可。</p><h4 id="1-2-2-除留余数法"><a href="#1-2-2-除留余数法" class="headerlink" title="1.2.2 除留余数法"></a>1.2.2 除留余数法</h4><ul><li><strong>除留余数法</strong>：假设哈希表的表长为 <code>m</code>，取一个不大于 <code>m</code> 但接近或等于 <code>m</code> 的质数 <code>p</code>，利用取模运算，将关键字转换为哈希地址。即：<code>Hash(key) = key % p</code>，其中 <code>p</code> 为不大于 <code>m</code> 的质数。</li></ul><p>&#8195;&#8195;这也是一种简单且常用的哈希函数方法。其关键点在于 <code>p</code> 的选择。根据经验而言，一般 <code>p</code> 取素数或者 <code>m</code>，这样可以尽可能的减少冲突。</p><p>&#8195;&#8195;比如我们需要将 <code>7</code> 个数 <code>[432, 5, 128, 193, 92, 111, 88]</code> 存储在 <code>11</code> 个区块中（长度为 <code>11</code> 的数组），通过除留余数法将这 <code>7</code> 个数应分别位于如下地址：</p><div class="table-container"><table><thead><tr><th style="text-align:center">索引</th><th style="text-align:center">00</th><th style="text-align:center">01</th><th style="text-align:center">02</th><th style="text-align:center">03</th><th style="text-align:center">04</th><th style="text-align:center">05</th><th style="text-align:center">06</th><th style="text-align:center">07</th><th style="text-align:center">08</th><th style="text-align:center">09</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">数据</td><td style="text-align:center">88</td><td style="text-align:center">111</td><td style="text-align:center"></td><td style="text-align:center">432</td><td style="text-align:center">92</td><td style="text-align:center">5</td><td style="text-align:center">193</td><td style="text-align:center"></td><td style="text-align:center">128</td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="1-2-3-平方取中法"><a href="#1-2-3-平方取中法" class="headerlink" title="1.2.3 平方取中法"></a>1.2.3 平方取中法</h4><ul><li><strong>平方取中法</strong>：先通过求关键字平方值的方式扩大相近数之间的差别，然后根据表长度取关键字平方值的中间几位数为哈希地址。<ul><li>比如：<code>Hash(key) = (key * key) // 100 % 1000</code>，先计算平方，去除末尾的 2 位数，再取中间 3 位数作为哈希地址。</li></ul></li></ul><p>&#8195;&#8195;这种方法因为关键字平方值的中间几位数和原关键字的每一位数都相关，所以产生的哈希地址也比较均匀，有利于减少冲突的发生。</p><h3 id="2-4-基数转换法"><a href="#2-4-基数转换法" class="headerlink" title="2.4 基数转换法"></a>2.4 基数转换法</h3><ul><li><strong>基数转换法</strong>：将关键字看成另一种进制的数再转换成原来进制的数，然后选其中几位作为哈希地址。<ul><li>比如，将关键字看做是 <code>13</code> 进制的数，再将其转变为 <code>10</code> 进制的数，将其作为哈希地址。</li></ul></li></ul><p>以 <code>343246</code> 为例，哈希地址计算方式如下：</p><p>$343246<em>{13} = 3 \times 13^5 + 4 \times 13^4 + 3 \times 13^3 + 2 \times 13^2 + 4 \times 13^1 + 6 \times 13^0 = 1235110</em>{10}$</p><h3 id="1-3-哈希冲突"><a href="#1-3-哈希冲突" class="headerlink" title="1.3 哈希冲突"></a>1.3 哈希冲突</h3><blockquote><p><strong>哈希冲突（Hash Collision）</strong>：不同的关键字通过同一个哈希函数可能得到同一哈希地址，即 <code>key1 ≠ key2</code>，而 <code>Hash(key1) = Hash(key2)</code>，这种现象称为哈希冲突。</p></blockquote><p>&#8195;&#8195;理想状态下，我们的哈希函数是完美的一对一映射，即一个关键字（key）对应一个值（value），不需要处理冲突。但是一般情况下，不同的关键字 <code>key</code> 可能对应了同一个值 <code>value</code>，这就发生了哈希冲突。</p><p>&#8195;&#8195;设计再好的哈希函数也无法完全避免哈希冲突。所以就需要通过一定的方法来解决哈希冲突问题。常用的哈希冲突解决方法主要是两类：<strong>「开放地址法（Open Addressing）」</strong> 和 <strong>「链地址法（Chaining）」</strong>。</p><h4 id="1-3-1-开放地址法"><a href="#1-3-1-开放地址法" class="headerlink" title="1.3.1 开放地址法"></a>1.3.1 开放地址法</h4><blockquote><p><strong>开放地址法（Open Addressing）</strong>：指的是将哈希表中的「空地址」向处理冲突开放。当哈希表未满时，处理冲突时需要尝试另外的单元，直到找到空的单元为止。</p></blockquote><p>&#8195;&#8195;当发生冲突时，开放地址法按照下面的方法求得后继哈希地址：<code>H(i) = (Hash(key) + F(i)) % m</code>，<code>i = 1, 2, 3, ..., n (n ≤ m - 1)</code>。</p><ul><li><code>H(i)</code> 是在处理冲突中得到的地址序列。即在第 1 次冲突（<code>i = 1</code>）时经过处理得到一个新地址 <code>H(1)</code>，如果在 <code>H(1)</code> 处仍然发生冲突（<code>i = 2</code>）时经过处理时得到另一个新地址 <code>H(2)</code> …… 如此下去，直到求得的 <code>H(n)</code> 不再发生冲突。</li><li><code>Hash(key)</code> 是哈希函数，<code>m</code> 是哈希表表长，对哈希表长取余的目的是为了使得到的下一个地址一定落在哈希表中。</li><li><code>F(i)</code> 是冲突解决方法，取法可以有以下几种：<ul><li>线性探测法：$F(i) = 1, 2, 3, …, m - 1$。</li><li>二次探测法：$F(i) = 1^2, -1^2, 2^2, -2^2, …, \pm n^2(n \le m / 2)$。</li><li>伪随机数序列：$F(i) = 伪随机数序列$。</li></ul></li></ul><p>&#8195;&#8195;举个例子说说明一下如何用以上三种冲突解决方法处理冲突，并得到新地址 <code>H(i)</code>。例如，在长度为 <code>11</code> 的哈希表中已经填有关键字分别为 <code>28</code>、<code>49</code>、<code>18</code> 的记录（哈希函数为 <code>Hash(key) = key % 11</code>）。现在将插入关键字为 <code>38</code> 的新纪录。根据哈希函数得到的哈希地址为 <code>5</code>，产生冲突。接下来分别使用这三种冲突解决方法处理冲突。</p><ul><li>使用线性探测法：得到下一个地址 <code>H(1) = (5 + 1) % 11 = 6</code>，仍然冲突；继续求出 <code>H(2) = (5 + 2) % 11 = 7</code>，仍然冲突；继续求出 <code>H(3) = (5 + 3) % 11 = 8</code>，<code>8</code> 对应的地址为空，处理冲突过程结束，记录填入哈希表中序号为 <code>8</code> 的位置。</li><li>使用二次探测法：得到下一个地址 <code>H(1) = (5 + 1*1) % 11 = 6</code>，仍然冲突；继续求出 <code>H(2) = (5 - 1*1) % 11 = 4</code>，<code>4</code> 对应的地址为空，处理冲突过程结束，记录填入哈希表中序号为 <code>4</code> 的位置。</li><li>使用伪随机数序列：假设伪随机数为 <code>9</code>，则得到下一个地址 <code>H(1) = (9 + 5) % 11 = 3</code>，<code>3</code> 对应的地址为空，处理冲突过程结束，记录填入哈希表中序号为 <code>3</code> 的位置。</li></ul><p>使用这三种方法处理冲突的结果如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/85955751ce269dfc86480478bf93ad9e.png" alt=""></p><h4 id="1-3-2-链地址法"><a href="#1-3-2-链地址法" class="headerlink" title="1.3.2 链地址法"></a>1.3.2 链地址法</h4><blockquote><p><strong>链地址法（Chaining）</strong>：将具有相同哈希地址的元素（或记录）存储在同一个线性链表中。</p></blockquote><p>链地址法是一种更加常用的哈希冲突解决方法。相比于开放地址法，链地址法更加简单。</p><p>我们假设哈希函数产生的哈希地址区间为 <code>[0, m - 1]</code>，哈希表的表长为 <code>m</code>。则可以将哈希表定义为一个有 <code>m</code> 个头节点组成的链表指针数组 <code>T</code>。</p><ul><li><p>这样在插入关键字的时候，我们只需要通过哈希函数 <code>Hash(key)</code> 计算出对应的哈希地址 <code>i</code>，然后将其以链表节点的形式插入到以 <code>T[i]</code> 为头节点的单链表中。在链表中插入位置可以在表头或表尾，也可以在中间。如果每次插入位置为表头，则插入操作的时间复杂度为 $O(1)$。</p></li><li><p>而在在查询关键字的时候，我们只需要通过哈希函数 <code>Hash(key)</code> 计算出对应的哈希地址 <code>i</code>，然后将对应位置上的链表整个扫描一遍，比较链表中每个链节点的键值与查询的键值是否一致。查询操作的时间复杂度跟链表的长度 <code>k</code> 成正比，也就是 $O(k)$。对于哈希地址比较均匀的哈希函数来说，理论上讲，<code>k = n // m</code>，其中 <code>n</code> 为关键字的个数，<code>m</code> 为哈希表的表长。</p></li></ul><p>&#8195;&#8195;举个例子来说明如何使用链地址法处理冲突。假设现在要存入的关键字集合 <code>keys = [88, 60, 65, 69, 90, 39, 07, 06, 14, 44, 52, 70, 21, 45, 19, 32]</code>。再假定哈希函数为 <code>Hash(key) = key % 13</code>，哈希表的表长 <code>m = 13</code>，哈希地址范围为 <code>[0, m - 1]</code>。将这些关键字使用链地址法处理冲突，并按顺序加入哈希表中（图示为插入链表表尾位置），最终得到的哈希表如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/341f1856e9d4ee354ada2888f9a1f9ce.png" alt=""></p><p>&#8195;&#8195;相对于开放地址法，采用链地址法处理冲突要多占用一些存储空间（主要是链节点占用空间）。但它可以<strong>减少在进行插入和查找具有相同哈希地址的关键字的操作过程中的平均查找长度</strong>。这是因为在链地址法中，待比较的关键字都是具有相同哈希地址的元素，而在开放地址法中，待比较的关键字不仅包含具有相同哈希地址的元素，而且还包含哈希地址不相同的元素。</p><h3 id="1-4-哈希表总结"><a href="#1-4-哈希表总结" class="headerlink" title="1.4 哈希表总结"></a>1.4 哈希表总结</h3><p>&#8195;&#8195;本文讲解了一些比较基础、偏理论的哈希表知识。包含哈希表的定义，哈希函数、哈希冲突以及哈希冲突的解决方法。</p><ul><li><strong>哈希表（Hash Table）</strong>：通过键 <code>key</code> 和一个映射函数 <code>Hash(key)</code> 计算出对应的值 <code>value</code>，把关键码值映射到表中一个位置来访问记录，以加快查找的速度。</li><li><strong>哈希函数（Hash Function）</strong>：将哈希表中元素的关键键值映射为元素存储位置的函数。</li><li><strong>哈希冲突（Hash Collision）</strong>：不同的关键字通过同一个哈希函数可能得到同一哈希地址。</li></ul><p>哈希表的两个核心问题是：<strong>「哈希函数的构建」</strong> 和 <strong>「哈希冲突的解决方法」</strong>。</p><ul><li>常用的哈希函数方法有：直接定址法、除留余数法、平方取中法、基数转换法、数字分析法、折叠法、随机数法、乘积法、点积法等。</li><li>常用的哈希冲突的解决方法有两种：开放地址法和链地址法。</li></ul><h2 id="二、哈希表应用"><a href="#二、哈希表应用" class="headerlink" title="二、哈希表应用"></a>二、哈希表应用</h2><h3 id="2-1-哈希表题目列表"><a href="#2-1-哈希表题目列表" class="headerlink" title="2.1 哈希表题目列表"></a>2.1 哈希表题目列表</h3><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0705</td><td style="text-align:left"><a href="https://leetcode.cn/problems/design-hashset/">设计哈希集合</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0705.%20%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88.md">Python</a></td><td style="text-align:left">哈希表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0706</td><td style="text-align:left"><a href="https://leetcode.cn/problems/design-hashmap/">设计哈希映射</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0706.%20%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84.md">Python</a></td><td style="text-align:left">哈希表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0217</td><td style="text-align:left"><a href="https://leetcode.cn/problems/contains-duplicate/">存在重复元素</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0217.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.md">Python</a></td><td style="text-align:left">数组、哈希表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0219</td><td style="text-align:left"><a href="https://leetcode.cn/problems/contains-duplicate-ii/">存在重复元素 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0219.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II.md">Python</a></td><td style="text-align:left">数组、哈希表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0220</td><td style="text-align:left"><a href="https://leetcode.cn/problems/contains-duplicate-iii/">存在重复元素 III</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0220.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20III.md">Python</a></td><td style="text-align:left">排序、有序集合、哈希表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">1941</td><td style="text-align:left"><a href="https://leetcode.cn/problems/check-if-all-characters-have-equal-number-of-occurrences/">检查是否所有字符出现次数相同</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/1941.%20%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E7%9B%B8%E5%90%8C.md">Python</a></td><td style="text-align:left">哈希表、字符串、计数</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0136</td><td style="text-align:left"><a href="https://leetcode.cn/problems/single-number/">只出现一次的数字</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.md">Python</a></td><td style="text-align:left">位运算、数组</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0383</td><td style="text-align:left"><a href="https://leetcode.cn/problems/ransom-note">赎金信</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0383.%20%E8%B5%8E%E9%87%91%E4%BF%A1.md">Python</a></td><td style="text-align:left">哈希表、字符串、计数</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0349</td><td style="text-align:left"><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">两个数组的交集</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0349.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.md">Python</a></td><td style="text-align:left">数组、哈希表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0350</td><td style="text-align:left"><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/">两个数组的交集 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0350.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II.md">Python</a></td><td style="text-align:left">数组、哈希表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0036</td><td style="text-align:left"><a href="https://leetcode.cn/problems/valid-sudoku/">有效的数独</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0036.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC.md">Python</a></td><td style="text-align:left">哈希表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0001</td><td style="text-align:left"><a href="https://leetcode.cn/problems/two-sum/">两数之和</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0001.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.md">Python</a></td><td style="text-align:left">数组、哈希表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0015</td><td style="text-align:left"><a href="https://leetcode.cn/problems/3sum/">三数之和</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0015.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.md">Python</a></td><td style="text-align:left">数组、双指针</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0018</td><td style="text-align:left"><a href="https://leetcode.cn/problems/4sum/">四数之和</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0018.%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.md">Python</a></td><td style="text-align:left">数组、哈希表、双指针</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0454</td><td style="text-align:left"><a href="https://leetcode.cn/problems/4sum-ii/">四数相加 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0454.%20%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%20II.md">Python</a></td><td style="text-align:left">哈希表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0041</td><td style="text-align:left"><a href="https://leetcode.cn/problems/first-missing-positive/">缺失的第一个正数</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0041.%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0.md">Python</a></td><td style="text-align:left">数组、哈希表</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0128</td><td style="text-align:left"><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">最长连续序列</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0128.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97.md">Python</a></td><td style="text-align:left">并查集、数组、哈希表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0202</td><td style="text-align:left"><a href="https://leetcode.cn/problems/happy-number/">快乐数</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0202.%20%E5%BF%AB%E4%B9%90%E6%95%B0.md">Python</a></td><td style="text-align:left">哈希表、数学</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0242</td><td style="text-align:left"><a href="https://leetcode.cn/problems/valid-anagram/">有效的字母异位词</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0242.%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.md">Python</a></td><td style="text-align:left">字符串、哈希表、排序</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0205</td><td style="text-align:left"><a href="https://leetcode.cn/problems/isomorphic-strings/">同构字符串</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0205.%20%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2.md">Python</a></td><td style="text-align:left">哈希表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0442</td><td style="text-align:left">数组中重复的数据</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">剑指 Offer 61</td><td style="text-align:left"><a href="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">扑克牌中的顺子</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/%E5%89%91%E6%8C%87%20Offer%2061.%20%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90.md">Python</a></td><td style="text-align:left">数组、排序</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0268</td><td style="text-align:left"><a href="https://leetcode.cn/problems/missing-number/">丢失的数字</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0268.%20%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97.md">Python</a></td><td style="text-align:left">位运算、数组、数学</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">剑指 Offer 03</td><td style="text-align:left"><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">数组中重复的数字</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.md">Python</a></td><td style="text-align:left">数组、哈希表、排序</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0451</td><td style="text-align:left"><a href="https://leetcode.cn/problems/sort-characters-by-frequency/">根据字符出现频率排序</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0451.%20%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F.md">Python</a></td><td style="text-align:left">哈希表、字符串、桶排序、计数、排序、堆（优先队列）</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0049</td><td style="text-align:left"><a href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0049.%20%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84.md">Python</a></td><td style="text-align:left">字符串、哈希表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0599</td><td style="text-align:left"><a href="https://leetcode.cn/problems/minimum-index-sum-of-two-lists/">两个列表的最小索引总和</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0599.%20%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C.md">Python</a></td><td style="text-align:left">哈希表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0387</td><td style="text-align:left"><a href="https://leetcode.cn/problems/first-unique-character-in-a-string/">字符串中的第一个唯一字符</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0387.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6.md">Python</a></td><td style="text-align:left">字符串、哈希表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0447</td><td style="text-align:left"><a href="https://leetcode.cn/problems/number-of-boomerangs/">回旋镖的数量</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0447.%20%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F.md">Python</a></td><td style="text-align:left">哈希表、数学</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0149</td><td style="text-align:left"><a href="https://leetcode.cn/problems/max-points-on-a-line/">直线上最多的点数</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0149.%20%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0.md">Python</a></td><td style="text-align:left">哈希表、数学</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0359</td><td style="text-align:left"><a href="https://leetcode.cn/problems/logger-rate-limiter/">日志速率限制器</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0359.%20%E6%97%A5%E5%BF%97%E9%80%9F%E7%8E%87%E9%99%90%E5%88%B6%E5%99%A8.md">Python</a></td><td style="text-align:left">设计、哈希表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0811</td><td style="text-align:left"><a href="https://leetcode.cn/problems/subdomain-visit-count/">子域名访问计数</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0811.%20%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0.md">Python</a></td><td style="text-align:left">数组、哈希表、字符串、计数</td><td style="text-align:left">中等</td></tr></tbody></table></div><h3 id="2-2-设计哈希集合-、设计哈希映射"><a href="#2-2-设计哈希集合-、设计哈希映射" class="headerlink" title="2.2 设计哈希集合 、设计哈希映射"></a>2.2 设计哈希集合 、设计哈希映射</h3><blockquote><ul><li><a href="https://leetcode.cn/problems/design-hashset/">0705. 设计哈希集合</a></li><li><a href="https://leetcode.cn/problems/design-hashmap/">0706 设计哈希映射</a></li></ul></blockquote><p>要求不使用内建的哈希表库，自行实现一个哈希集合（HashSet），满足以下操作：</p><ul><li>void add(key) 向哈希集合中插入值 key 。</li><li>bool contains(key) 返回哈希集合中是否存在这个值 key 。</li><li>void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输入：</span></span><br><span class="line">[<span class="string">&quot;MyHashSet&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;contains&quot;</span>, <span class="string">&quot;contains&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;contains&quot;</span>, <span class="string">&quot;remove&quot;</span>, <span class="string">&quot;contains&quot;</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">1</span>], [<span class="number">3</span>], [<span class="number">2</span>], [<span class="number">2</span>], [<span class="number">2</span>], [<span class="number">2</span>]]</span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line">[null, null, null, true, false, null, true, null, false]</span><br><span class="line"></span><br><span class="line"><span class="comment">#解释：</span></span><br><span class="line">MyHashSet myHashSet = new MyHashSet();</span><br><span class="line">myHashSet.add(<span class="number">1</span>);      // <span class="built_in">set</span> = [<span class="number">1</span>]</span><br><span class="line">myHashSet.add(<span class="number">2</span>);      // <span class="built_in">set</span> = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">myHashSet.contains(<span class="number">1</span>); // 返回 <span class="literal">True</span></span><br><span class="line">myHashSet.contains(<span class="number">3</span>); // 返回 <span class="literal">False</span> ，（未找到）</span><br><span class="line">myHashSet.add(<span class="number">2</span>);      // <span class="built_in">set</span> = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">myHashSet.contains(<span class="number">2</span>); // 返回 <span class="literal">True</span></span><br><span class="line">myHashSet.remove(<span class="number">2</span>);   // <span class="built_in">set</span> = [<span class="number">1</span>]</span><br><span class="line">myHashSet.contains(<span class="number">2</span>); // 返回 <span class="literal">False</span> ，（已移除）</span><br></pre></td></tr></table></figure><p>思路：利用「数组+链表」的方式实现哈希集合<br>&#8195;&#8195;定义一个一维长度为 buckets 的二维数组 table。第一维度用于计算哈希函数，为 key 分桶。第二个维度用于寻找 key 存放的具体位置。第二维度的数组会根据 key 值动态增长，模拟真正的链表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.buckets = <span class="number">1003</span></span><br><span class="line">        self.table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.buckets)]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">return</span> key % self.buckets</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        hash_key = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.table[hash_key]:</span><br><span class="line">            <span class="keyword">return</span> self.table[hash_key].append(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        hash_key = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.table[hash_key]:</span><br><span class="line">            <span class="keyword">return</span> self.table[hash_key].remove(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">contains</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        hash_key = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.table[hash_key]</span><br></pre></td></tr></table></figure><p>设计哈希映射和上一题其实是一样的，可以直接套用代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.buckets=<span class="number">1003</span> <span class="comment"># 使用质数</span></span><br><span class="line">        self.table=[[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.buckets)]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        hash_key,pos=self.<span class="built_in">hash</span>(key)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.table[hash_key]:</span><br><span class="line">                self.table[hash_key]=[-<span class="number">1</span>]*self.buckets</span><br><span class="line">        self.table[hash_key][pos]=value</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span>(<span class="params">self,key</span>):</span></span><br><span class="line">        <span class="comment">#哈希函数，等同于将数字分为1000个桶</span></span><br><span class="line">        <span class="keyword">return</span> key%self.buckets,key//self.buckets</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        hash_key,pos=self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">if</span> self.table[hash_key]:        </span><br><span class="line">            self.table[hash_key][pos]=-<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        hash_key,pos=self.<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> self.table[hash_key]==[] <span class="keyword">else</span> self.table[hash_key][pos]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyHashSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyHashSet()</span></span><br><span class="line"><span class="comment"># obj.add(key)</span></span><br><span class="line"><span class="comment"># obj.remove(key)</span></span><br><span class="line"><span class="comment"># param_3 = obj.contains(key)</span></span><br><span class="line"><span class="comment"># Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyHashMap()</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.remove(key)</span></span><br></pre></td></tr></table></figure><h3 id="2-3-存在重复元素I、II、III"><a href="#2-3-存在重复元素I、II、III" class="headerlink" title="2.3 存在重复元素I、II、III"></a>2.3 存在重复元素I、II、III</h3><blockquote><ul><li>0217  <a href="https://leetcode.cn/problems/contains-duplicate/">存在重复元素</a></li><li>0219   <a href="https://leetcode.cn/problems/contains-duplicate-ii/">存在重复元素 II</a> </li><li>0220 <a href="https://leetcode.cn/problems/contains-duplicate-iii/">存在重复元素 III</a> </li></ul></blockquote><h4 id="2-3-1-存在重复元素"><a href="#2-3-1-存在重复元素" class="headerlink" title="2.3.1 存在重复元素"></a>2.3.1 存在重复元素</h4><p>&#8195;&#8195;给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="built_in">len</span>(<span class="built_in">set</span>(nums)) <span class="keyword">else</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-存在重复元素-II"><a href="#2-3-2-存在重复元素-II" class="headerlink" title="2.3.2 存在重复元素 II"></a>2.3.2 存在重复元素 II</h4><p>&#8195;&#8195;给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，判断数组中是否存在两个 不同的索引 <code>i</code> 和 <code>j</code> ，满足 <code>nums[i] == nums[j]</code> 且 <code>abs(i - j) &lt;= k</code> 。如果存在，返回 true ；否则，返回 false 。<br><strong>解法一：</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        d=<span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            d.add(nums[i])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(d)&gt;k:</span><br><span class="line">                d.remove(nums[i-k])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><br><strong>解法二：</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        d=<span class="built_in">dict</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果k值超过数组长度，将其赋值为数组长度-1，然后统计前k个数字的出现此数。</span></span><br><span class="line">        <span class="comment"># 如果某个元素已经出现在字典中，直接返回True</span></span><br><span class="line">        <span class="keyword">if</span> k&gt;<span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">            k=<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        l,r=<span class="number">0</span>,k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>):                        </span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[nums[i]]=d.get(nums[i],<span class="number">0</span>)+<span class="number">1</span>                    </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 依次往右滑动窗口，每次删除左边界元素，加入右边界元素（次数+1）</span></span><br><span class="line">        <span class="keyword">while</span> r&lt;<span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">            l+=<span class="number">1</span></span><br><span class="line">            r+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">del</span> d[nums[l-<span class="number">1</span>]]</span><br><span class="line">            <span class="keyword">if</span> nums[r] <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[nums[r]]=d.get(nums[r],<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p><h4 id="2-3-3-存在重复元素-III"><a href="#2-3-3-存在重复元素-III" class="headerlink" title="2.3.3 存在重复元素 III"></a>2.3.3 存在重复元素 III</h4><p>&#8195;&#8195;给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>t</code> 。请你判断是否存在 两个不同下标 <code>i</code> 和 <code>j</code>，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code> 。</p><p><strong>思路 1：滑动窗口（固定长度）</strong></p><ol><li>使用一个长度为 <code>k</code> ，右指针为<code>i</code>的滑动窗口，每次遍历到 <code>nums[i]</code> 时，只需要检查前 <code>k</code> 个元素是否有某个元素在 <code>[nums[i] - t, nums[i + t]</code> 区间内即可。</li><li>检查 <code>k</code> 个元素是否在 <code>[nums[i] - t, nums[i + t]</code> 区间，可以借助有序数组（比如 <code>SortedList</code>）+ 二分查找来解决，从而减少时间复杂度。<blockquote><p>&#8195;&#8195;如果是无序数组，则滑动窗口内只能对于每个元素都遍历一次队列来检查是否有元素符合条件。如果数组的长度为 <code>n</code>，则使用队列的时间复杂度为 <code>O(nk)</code>，会超出时间限制。</p></blockquote></li></ol><p>具体步骤如下：</p><ol><li>使用有序数组类 <code>window</code> 维护一个长度为 <code>k</code> 的窗口，满足数组内元素有序，且支持增加和删除操作。</li><li>将当前元素填入窗口中，即 <code>window.add(nums[i])</code>。</li><li>当窗口元素大于 <code>k</code> 个时，移除窗口最左侧元素。</li><li><p>当窗口元素小于等于 <code>k</code> 个时（即i&lt;k时窗口才移动，不到k个元素，后面固定有k个元素）：</p><ol><li>使用二分查找算法<code>windows.bisect_left</code>，查找 <code>nums[i]</code> 在 <code>window</code> 中的位置 <code>idx</code>（windows是有序数组，每次遍历的元素<code>nums[i]</code> 会放到窗口中的合适位置）。</li><li>判断 <code>window[idx]</code> 与相邻位置上元素差值绝对值，若果满足 <code>abs(window[idx] - window[idx - 1]) &lt;= t</code> 或者 <code>abs(window[idx + 1] - window[idx]) &lt;= t</code> 时返回 <code>True</code>。</li></ol></li><li><p>重复 <code>2</code> ~ <code>4</code> 步，直到遍历至数组末尾，如果还没找到满足条件的情况，则返回 <code>False</code>。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], indexDiff: <span class="built_in">int</span>, valueDiff: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedList</span><br><span class="line">        k,t=indexDiff,valueDiff</span><br><span class="line">        windows=SortedList()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):           </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(windows)&gt;k:</span><br><span class="line">                windows.remove(nums[i-k-<span class="number">1</span>])</span><br><span class="line">            windows.add(nums[i])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># idx和i的区别是，idx是nums[i]在有序数组windows中的位置</span></span><br><span class="line">            idx=windows.bisect_left(nums[i]) </span><br><span class="line">            <span class="comment"># 判断nums[i]和它在窗口中相邻的两个元素只差的绝对值，是否在t之内</span></span><br><span class="line">            <span class="keyword">if</span> idx&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">abs</span>(windows[idx]-windows[idx-<span class="number">1</span>])&lt;=t: <span class="comment"># idx&gt;0则idx-1最小为0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> idx&lt;<span class="built_in">len</span>(windows)-<span class="number">1</span> <span class="keyword">and</span> <span class="built_in">abs</span>(windows[idx+<span class="number">1</span>]-windows[idx])&lt;=t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：TreeSet 基于红黑树，查找和插入都是 O(logk) 复杂度。整体复杂度为 O(nlogk)</li><li>空间复杂度：O(k)</li></ul><blockquote><p>SortedList详情请参考<a href="https://blog.csdn.net/bmicnj/article/details/120070558?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167853143916782425182505%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167853143916782425182505&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-120070558-null-null.142%5Ev73%5Econtrol,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=SortedList&amp;spm=1018.2226.3001.4187">《SortedList【python类】》</a></p></blockquote><p><strong>思路 2：桶排序</strong><br>&#8195;&#8195;述解法无法做到线性的原因是：我们需要在大小为 <code>k</code> 的滑动窗口所在的「有序集合」中找到与 <code>nums[i]</code> 接近的数。如果我们能够将 <code>k</code> 个数字分到 <code>k</code> 个桶的话，那么我们就能 在O(1) 的复杂度确定是否有 <code>[nums[i]−t,nums[i]+t]</code> 的数字（检查目标桶是否有元素）。</p><ol><li>利用桶排序的思想，将桶的大小设置为 <code>t + 1</code>。只需要使用一重循环遍历位置 <code>i</code>，然后根据 <code>nums[i] // (t + 1)</code>，从而决定将 <code>nums[i]</code> 放入哪个桶中。</li><li>这样在同一个桶内各个元素之间的差值绝对值都小于等于 <code>t</code>。而相邻桶之间的元素，只需要校验一下两个桶之间的差值是否不超过 <code>t</code>。这样就可以以 $O(1)$ 的时间复杂度检测相邻 <code>2 * k</code> 个元素是否满足 <code>abs(nums[i] - nums[j]) &lt;= t</code>。</li><li>而 <code>abs(i - j) &lt;= k</code> 条件则可以通过在一重循环遍历时，将超出范围的 <code>nums[i - k]</code> 从对应桶中删除，从而保证桶中元素一定满足 <code>abs(i - j) &lt;= k</code>。</li></ol><p>具体步骤如下：</p><ol><li>将每个桶的大小设置为 <code>t + 1</code>。我们将元素按照大小依次放入不同的桶中。</li><li>遍历数组 <code>nums</code> 中的元素，对于元素<code>nums[i]</code> ：<ol><li>如果 <code>nums[i]</code> 放入桶之前桶里已经有元素了，那么这两个元素必然满足 <code>abs(nums[i] - nums[j]) &lt;= t</code>，</li><li>如果之前桶里没有元素，那么就将 <code>nums[i]</code> 放入对应桶中。</li><li>再判断左右桶的左右两侧桶中是否有元素满足 <code>abs(nums[i] - nums[j]) &lt;= t</code>。</li><li>然后将 <code>nums[i - k]</code> 之前的桶清空，因为这些桶中的元素与 <code>nums[i]</code> 已经不满足 <code>abs(i - j) &lt;= k</code> 了。</li></ol></li><li>最后上述满足条件的情况就返回 <code>True</code>，最终遍历完仍不满足条件就返回 <code>False</code>。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">       bucket_dict = <span class="built_in">dict</span>()</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">           <span class="comment"># 将 nums[i] 划分到大小为 t + 1 的不同桶中</span></span><br><span class="line">           num = nums[i] // (t + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">           <span class="comment"># 桶中已经有元素了</span></span><br><span class="line">           <span class="keyword">if</span> num <span class="keyword">in</span> bucket_dict:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">           <span class="comment"># 把 nums[i] 放入桶中</span></span><br><span class="line">           bucket_dict[num] = nums[i]</span><br><span class="line"></span><br><span class="line">           <span class="comment"># 判断左侧桶是否满足条件</span></span><br><span class="line">           <span class="keyword">if</span> (num - <span class="number">1</span>) <span class="keyword">in</span> bucket_dict <span class="keyword">and</span> <span class="built_in">abs</span>(bucket_dict[num - <span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">           <span class="comment"># 判断右侧桶是否满足条件</span></span><br><span class="line">           <span class="keyword">if</span> (num + <span class="number">1</span>) <span class="keyword">in</span> bucket_dict <span class="keyword">and</span> <span class="built_in">abs</span>(bucket_dict[num + <span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">           <span class="comment"># 将 i-k 之前的旧桶清除，因为之前的桶已经不满足条件了</span></span><br><span class="line">           <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">               bucket_dict.pop(nums[i-k] // (t + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">False</span>                       </span><br></pre></td></tr></table></figure><h3 id="2-4-只出现一次的数字"><a href="#2-4-只出现一次的数字" class="headerlink" title="2.4 只出现一次的数字"></a>2.4 只出现一次的数字</h3><blockquote><p><a href="https://leetcode.cn/problems/single-number/">136 只出现一次的数字</a>      </p></blockquote></li></ol><p>&#8195;&#8195;给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p>&#8195;&#8195;如果没有时间复杂度和空间复杂度的限制，可以使用哈希表 / 集合来存储每个元素出现的次数，如果哈希表中没有该数字，则将该数字加入集合，如果集合中有了该数字，则从集合中删除该数字，最终成对的数字都被删除了，只剩下单次出现的元素。</p><p>&#8195;&#8195;但是题目要求不使用额外的存储空间，就需要用到位运算中的异或运算。</p><blockquote><p>异或运算 $\oplus$ 的三个性质：</p><ol><li>任何数和 $0$ 做异或运算，结果仍然是原来的数，即 $a \oplus 0 = a$。</li><li>数和其自身做异或运算，结果是 $0$，即 $a \oplus a = 0$。</li><li>异或运算满足交换率和结合律：$a \oplus b \oplus a = b \oplus a \oplus a = b \oplus (a \oplus a) = b \oplus 0 = b$。</li></ol></blockquote><p>根据异或运算的性质，对 $n$ 个数不断进行异或操作，最终可得到单次出现的元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="built_in">sum</span>^=i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><h3 id="2-5-有效的数独"><a href="#2-5-有效的数独" class="headerlink" title="2.5 有效的数独"></a>2.5 有效的数独</h3><blockquote><p><a href="https://leetcode.cn/problems/valid-sudoku/">0036. 有效的数独</a></p></blockquote><p>请你判断一个 9 x 9 的数独是否有效。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[<span class="string">&quot;5&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>]</span><br><span class="line">,[<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>]</span><br><span class="line">,[<span class="string">&quot;.&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>]</span><br><span class="line">,[<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;3&quot;</span>]</span><br><span class="line">,[<span class="string">&quot;4&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;1&quot;</span>]</span><br><span class="line">,[<span class="string">&quot;7&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>]</span><br><span class="line">,[<span class="string">&quot;.&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>]</span><br><span class="line">,[<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;5&quot;</span>]</span><br><span class="line">,[<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;9&quot;</span>]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/609ac90735d048609ca1f40e6f0c0fe7.png" alt="在这里插入图片描述"></p><p><strong>思路一：哈希表</strong></p><p>&#8195;&#8195;判断数独是否有效，需要分别看每一行、每一列、每一个 <code>3 * 3</code> 的小方格是否出现了重复数字，如果都没有出现重复数字就是一个有效的数独，如果出现了重复数字则不是有效的数独。</p><ul><li>用 <code>3</code> 个 <code>9 * 9</code> 的数组分别来表示该数字是否在所在的行，所在的列，所在的方格出现过。其中方格角标的计算用 <code>box[(i / 3) * 3 + (j / 3)][n]</code> 来表示。</li><li>双重循环遍历数独矩阵。如果对应位置上的数字如果已经在在所在的行 / 列 / 方格出现过，则返回 <code>False</code>。</li><li>遍历完没有重复出现，则返回 <code>Ture</code>。</li></ul><blockquote><ul><li>九宫格1-3坐标：（0-2,0-2）,（0-2,3-5）,（0-2,6-8）</li><li>九宫格4-6坐标：（3-5,0-2）,（3-5,3-5）,（3-5,6-8）</li><li>九宫格7-9坐标：（6-8,0-2）,（6-8,3-5）,（6-8,6-8）</li><li>所以每个元素属于第几个九宫格，是<code>i//3</code>的三倍<code>+j//3</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span>(<span class="params">self, board</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        row=[<span class="built_in">dict</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)] <span class="comment"># 创建一个包含9个字典的列表，其中每个字典统计每一行元素出现的次数</span></span><br><span class="line">        col=[<span class="built_in">dict</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)] <span class="comment"># 统计每一列元素出现的次数</span></span><br><span class="line">        box=[<span class="built_in">dict</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)] <span class="comment"># 统计每个九宫格元素出现的次数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):               </span><br><span class="line">                <span class="keyword">if</span> board[i][j]==<span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"> </span><br><span class="line">                num=<span class="built_in">int</span>(board[i][j])</span><br><span class="line">                idx=(i//<span class="number">3</span>)*<span class="number">3</span>+j//<span class="number">3</span></span><br><span class="line">                <span class="comment"># 查找各行、各列、各九宫格中，是否出现过num这个元素。没有出现就返回0</span></span><br><span class="line">                a,b,c=row[i].get(num,<span class="number">0</span>),col[j].get(num,<span class="number">0</span>),box[idx].get(num,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> a!=<span class="number">0</span> <span class="keyword">or</span> b!=<span class="number">0</span> <span class="keyword">or</span> c!=<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># 在各行、列、九宫格中，将出现的数字次数计为1</span></span><br><span class="line">                row[i][num]=<span class="number">1</span></span><br><span class="line">                col[j][num]=<span class="number">1</span></span><br><span class="line">                box[idx][num]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><strong>思路二：列表查找</strong></li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span>(<span class="params">self, board</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):                        <span class="comment">#对每一行进行判断</span></span><br><span class="line">            row = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] <span class="keyword">in</span> row:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    row.append(board[i][j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):                         <span class="comment">#对每一列进行判断</span></span><br><span class="line">            col = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[j][i] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> board[j][i] <span class="keyword">in</span> col:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    col.append(board[j][i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>):                 <span class="comment"># 对每个九宫格进行判断</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>):</span><br><span class="line">                box=[]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                        <span class="keyword">if</span> board[i+x][j+y]==<span class="string">&#x27;.&#x27;</span> :</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="keyword">if</span> board[i+x][j+y] <span class="keyword">in</span> box:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            box.append(board[i+x][j+y])</span><br><span class="line">                 </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="2-6-两数之和、三数之和、四数之和、四数相加"><a href="#2-6-两数之和、三数之和、四数之和、四数相加" class="headerlink" title="2.6 两数之和、三数之和、四数之和、四数相加"></a>2.6 两数之和、三数之和、四数之和、四数相加</h3><blockquote><ul><li><a href="https://leetcode.cn/problems/two-sum/">0001. 两数之和</a></li><li><a href="https://leetcode.cn/problems/3sum/">0015. 三数之和</a></li><li><a href="https://leetcode.cn/problems/4sum/">0018. 四数之和</a></li><li><a href="https://leetcode.cn/problems/4sum-ii/">0454. 四数相加 II</a><h4 id="2-6-1-两数之和"><a href="#2-6-1-两数之和" class="headerlink" title="2.6.1 两数之和"></a>2.6.1 两数之和</h4>&#8195;&#8195;给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 和为 <code>target</code>  的那 两个 整数，并返回它们的数组下标（任意顺序）。</li><li>输入：nums = [2,7,11,15], target = 9</li><li>输出：[0,1]</li><li>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        d=<span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> target-nums[i] <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span> i,d[target-nums[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[nums[i]]=i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="2-6-2-三数之和"><a href="#2-6-2-三数之和" class="headerlink" title="2.6.2 三数之和"></a>2.6.2 三数之和</h4><p><strong>思路 1：对撞指针</strong></p><p>&#8195;&#8195;直接三重遍历查找 <code>a</code>、<code>b</code>、<code>c</code> 的时间复杂度是：$O(n^3)$。我们可以通过一些操作来降低复杂度。</p><p>&#8195;&#8195;<font color='red'> 先将数组进行排序，再使用对撞指针&lt;/font &gt;，从而保证所找到的三个元素是不重复的，且使用双指针减少一重遍历。时间复杂度为：$O(nlogn)$。</p><p>&#8195;&#8195;第一重循环遍历 <code>i</code>，对于每个 <code>nums[i]</code> 元素，从 <code>i</code> 元素的下一个位置开始，使用对撞指针 <code>left</code>，<code>right</code>。<code>left</code> 指向 <code>i</code> 的下一个位置，<code>right</code> 指向末尾位置。先将 <code>left</code> 右移、<code>right</code> 左移去除重复元素，再进行下边的判断。</p><ol><li>如果 <code>nums[a] + nums[left] + nums[right] = 0</code>，则得到一个解，将其加入答案数组中，并继续将 <code>left</code> 右移，<code>right</code> 左移；</li><li>如果 <code>nums[a] + nums[left] + nums[right] &gt; 0</code>，说明 <code>nums[right]</code> 值太大，将 <code>right</code> 向左移；</li><li>如果 <code>nums[a] + nums[left] + nums[right] &lt; 0</code>，说明 <code>nums[left]</code> 值太小，将 <code>left</code> 右移。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br><span class="line">        ans=[]</span><br><span class="line">        le=<span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(le):                     </span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>]: <span class="comment"># 如果下一位置和前一位置元素重复，就不需要再遍历</span></span><br><span class="line">                <span class="keyword">continue</span>    </span><br><span class="line"></span><br><span class="line">            left,right=i+<span class="number">1</span>,le-<span class="number">1</span><span class="comment">#左指针起点i+1       </span></span><br><span class="line">            <span class="keyword">while</span> left&lt;right:<span class="comment">#判断条件</span></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[left]+nums[right]&gt;<span class="number">0</span>:</span><br><span class="line">                    right-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]+nums[left]+nums[right]&lt;<span class="number">0</span>:</span><br><span class="line">                    left+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append([nums[i],nums[left],nums[right]])</span><br><span class="line">                    <span class="comment"># 找到解之后，如果left或right下一个元素重复，则需要跳过重复位置</span></span><br><span class="line">                    <span class="keyword">while</span> left!=right <span class="keyword">and</span> nums[left]==nums[left+<span class="number">1</span>]:left+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left!=right <span class="keyword">and</span> nums[right]==nums[right-<span class="number">1</span>]:right-=<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 找到解后也要移动指针</span></span><br><span class="line">                    left+=<span class="number">1</span></span><br><span class="line">                    right-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="2-6-3-四数之和"><a href="#2-6-3-四数之和" class="headerlink" title="2.6.3 四数之和"></a>2.6.3 四数之和</h4><p>&#8195;&#8195;给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li>0 &lt;= a, b, c, d &lt; n</li><li>a、b、c 和 d 互不相同</li><li>nums[a] + nums[b] + nums[c] + nums[d] == target</li><li>你可以按 任意顺序 返回答案 。</li><li>示例：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">2</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出：[[-<span class="number">2</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],[-<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>],[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>基本上就是套用三数之和的思路，也使用排序数组和对撞指针，去除一次循环遍历。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        le=<span class="built_in">len</span>(nums)</span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(le):</span><br><span class="line">            <span class="comment">#if nums[a]&gt;target:</span></span><br><span class="line">               <span class="comment"># break</span></span><br><span class="line">            <span class="comment"># 这里和三数之和不一样。三数之和nums[i]＞0，所有都是正数不用计算了。这里第一个数&gt;target，还可以有负数使和变得更小</span></span><br><span class="line">            <span class="keyword">if</span> a&gt;<span class="number">0</span> <span class="keyword">and</span> nums[a]==nums[a-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(a+<span class="number">1</span>,le):</span><br><span class="line">                <span class="keyword">if</span> b&gt;a+<span class="number">1</span> <span class="keyword">and</span> nums[b]==nums[b-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left,right=b+<span class="number">1</span>,le-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left&lt;right:</span><br><span class="line">                    <span class="keyword">if</span> nums[a]+nums[b]+nums[left]+nums[right]&gt;target:</span><br><span class="line">                        right-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[a]+nums[b]+nums[left]+nums[right]&lt;target:</span><br><span class="line">                        left+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        ans.append([nums[a],nums[b],nums[left],nums[right]])</span><br><span class="line">                        <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> nums[left]==nums[left+<span class="number">1</span>]:left+=<span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> nums[right]==nums[right-<span class="number">1</span>]:right-=<span class="number">1</span></span><br><span class="line">                        left+=<span class="number">1</span></span><br><span class="line">                        right-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p><h4 id="2-6-4-四数相加"><a href="#2-6-4-四数相加" class="headerlink" title="2.6.4 四数相加"></a>2.6.4 四数相加</h4><p>&#8195;&#8195;直接暴力搜索的时间复杂度是 $O(n^4)$。我们可以降低一下复杂度。将四个数组分为两组。nums1 和 nums2 分为一组，nums3 和 nums4 分为一组。</p><p>&#8195;&#8195;已知 $nums1[i] + nums2[j] + nums3[k] + nums4[l] = 0$，可以得到 $nums1[i] + nums2[j] = -(nums3[k] + nums4[l])$</p><p>&#8195;&#8195;建立一个哈希表。两重循环遍历数组 <code>nums1</code>、<code>nums2</code>，先将 $nums[i] + nums[j]$ 的和记录到哈希表中，然后再用两重循环遍历数组 <code>nums3</code>、<code>nums4</code>。如果 $-(nums3[k] + nums4[l])$ 的结果出现在哈希表中，则将结果数累加到答案中。最终输出累加之后的答案。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span>(<span class="params">self, nums1, nums2, nums3, nums4</span>):</span></span><br><span class="line"></span><br><span class="line">        d=<span class="built_in">dict</span>()</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                <span class="built_in">sum</span>=i+j</span><br><span class="line">                d[<span class="built_in">sum</span>]=d.get(<span class="built_in">sum</span>,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> nums3:</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> nums4:               </span><br><span class="line">                <span class="keyword">if</span> -k-l <span class="keyword">in</span> d:</span><br><span class="line">                    count+=d[-k-l]</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="2-7-缺失的第一个正数"><a href="#2-7-缺失的第一个正数" class="headerlink" title="2.7 缺失的第一个正数"></a>2.7 缺失的第一个正数</h3><blockquote><p><a href="https://leetcode.cn/problems/first-missing-positive/">0041. 缺失的第一个正数</a></p></blockquote><p>&#8195;&#8195;给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><p>如果本题没有额外的时空复杂度要求，那么就很容易实现：</p><ul><li><p>我们可以将数组所有的数放入哈希表，随后从 1 开始依次枚举正整数，并判断其是否在哈希表中。这种解法时空复杂度都是<code>O(n)</code>；</p></li><li><p>我们可以从 1 开始依次枚举正整数，并遍历数组，判断其是否在数组中。这种解法时间复杂度$O(n^2)$，空间复杂度<code>O(1)</code></p></li></ul><p>&#8195;&#8195;所以可以考虑利用给定数组中的空间来存储一些状态。即：如果题目给定的数组是不可修改的，那么就不存在满足时空复杂度要求的算法；但如果我们可以修改给定的数组，那么是存在满足要求的算法的。</p><p><strong>思路 1：原地哈希</strong></p><p>&#8195;&#8195;我们可以将当前数组视为哈希表。一个长度为 <code>n</code> 的数组，对应存储的元素值应该为 <code>[1, n + 1]</code> 之间，其中还包含一个缺失的元素。</p><ol><li>遍历当前数组，将当前元素放到其对应位置上（比如元素值为 <code>1</code> 的元素放到数组第 <code>0</code> 个位置上、元素值为 <code>2</code> 的元素放到数组第 <code>1</code> 个位置上，等等）。<ul><li>对于遍历到的数 $x=nums[i]$，如果 $x∈[1,N]$，我们就知道 $x$ 应当出现在数组中的 $x−1$ 的位置（下标从0开始），因此交换 $nums[i]$ 和 $nums[x−1]$，这样 $x$ 就出现在了正确的位置。在完成交换后，新的 $nums[i]$ 可能还在 $[1,N]$ 的范围内，我们需要继续进行交换操作，直到 $x\notin   [1,N]$。</li><li>上面的方法可能会陷入死循环。如果 $nums[i] == nums[x−1]$ ，那么就会无限交换下去。此时$x$ 已经出现在了正确的位置。因此我们可以跳出循环，开始遍历下一个数。</li></ul></li></ol><ol><li>然后再次遍历一遍数组。遇到第一个元素值不等于下标 + 1 的元素，就是答案要求的缺失的第一个正数。</li><li>如果遍历完没有在数组中找到缺失的第一个正数，则缺失的第一个正数是 <code>n + 1</code>。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        <span class="comment"># 对于1到size范围内的数，才进行交换，放到正确位置</span></span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span> &lt;= nums[i] &lt;= size <span class="keyword">and</span> nums[i] != nums[nums[i] - <span class="number">1</span>]:</span><br><span class="line">                index1 = i</span><br><span class="line">                index2 = nums[i] - <span class="number">1</span></span><br><span class="line">                nums[index1], nums[index2] = nums[index2], nums[index1]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> size + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-8-最长连续序列"><a href="#2-8-最长连续序列" class="headerlink" title="2.8 最长连续序列"></a>2.8 最长连续序列</h3><blockquote><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128 最长连续序列</a></p></blockquote><p>思路一：排序+滑动窗口，时间复杂度是 $O(nlogn)$<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums=<span class="built_in">list</span>(<span class="built_in">set</span>(nums)) <span class="comment"># 去除重复元素</span></span><br><span class="line">            nums.sort()</span><br><span class="line">            left,right=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">            ans=<span class="number">1</span>                <span class="comment"># 默认起始的连续序列长度为1（只有一个元素时）</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果差值不为1，左右指针右移；否则差值为1，右指针不停右移，同时记录连续序列的长度</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> right&lt;<span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">if</span> nums[right]!=nums[left]+<span class="number">1</span>:</span><br><span class="line">                    left+=<span class="number">1</span></span><br><span class="line">                    right+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> right&lt;<span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[right]==nums[right-<span class="number">1</span>]+<span class="number">1</span>:</span><br><span class="line">                        ans=<span class="built_in">max</span>(ans,right-left+<span class="number">1</span>)</span><br><span class="line">                        right+=<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 右移到差值不为1时右指针停止移动，left跳到right前一个位置</span></span><br><span class="line">                    left=right-<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><br><strong>思路二：哈希表</strong></p><ol><li>先 将数组存储到集合中进行去重，然后使用 <code>curr_streak</code> 维护当前连续序列长度，使用 <code>ans</code> 维护最长连续序列长度。</li><li>遍历集合中的元素，对每个元素进行判断，如果该元素不是序列的开始（即 <code>num - 1</code> 在集合中），则跳过。</li><li>如果 <code>num - 1</code> 不在集合中，说明 <code>num</code> 是序列的开始，判断 <code>num + 1</code> 、<code>nums + 2</code>、<code>...</code> 是否在哈希表中，并不断更新当前连续序列长度 <code>curr_streak</code>。并在遍历结束之后更新最长序列的长度。</li><li>最后输出最长序列长度。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans=<span class="number">0</span>  <span class="comment"># 记录最长序列长度</span></span><br><span class="line">        nums=<span class="built_in">set</span>(nums) <span class="comment"># 去重</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num-<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> nums: <span class="comment"># 比当前元素小1的不在集合中，则连续序列需要从头开始计算</span></span><br><span class="line">                cur=num</span><br><span class="line">                res=<span class="number">1</span> <span class="comment"># 初始化连续序列长度=1</span></span><br><span class="line">                <span class="keyword">while</span> cur+<span class="number">1</span> <span class="keyword">in</span> nums:</span><br><span class="line">                    cur+=<span class="number">1</span></span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">                ans=<span class="built_in">max</span>(ans,res)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="2-9-根据字符出现频率排序"><a href="#2-9-根据字符出现频率排序" class="headerlink" title="2.9 根据字符出现频率排序"></a>2.9 根据字符出现频率排序</h3><blockquote><p><a href="https://leetcode.cn/problems/sort-characters-by-frequency/">451 根据字符出现频率排序</a></p></blockquote><p>&#8195;&#8195;给定一个字符串 s ，根据字符出现的 频率 对其进行 降序排序 。一个字符出现的 频率 是它出现在字符串中的次数。返回 已排序的字符串 。如果有多个答案，返回其中任何一个。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;tree&quot;</span></span><br><span class="line">输出: <span class="string">&quot;eert&quot;</span></span><br><span class="line">解释: <span class="string">&#x27;e&#x27;</span>出现两次，<span class="string">&#x27;r&#x27;</span>和<span class="string">&#x27;t&#x27;</span>都只出现一次。</span><br><span class="line">因此<span class="string">&#x27;e&#x27;</span>必须出现在<span class="string">&#x27;r&#x27;</span>和<span class="string">&#x27;t&#x27;</span>之前。此外，<span class="string">&quot;eetr&quot;</span>也是一个有效的答案。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frequencySort</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        d=<span class="built_in">dict</span>(Counter(s)) <span class="comment"># 统计每个字母出现的次数</span></span><br><span class="line">        <span class="comment"># 根据次数对字母进行降序排列，结果是一个列表</span></span><br><span class="line">        d=<span class="built_in">sorted</span>(d.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">         </span><br><span class="line">        ans=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> d:</span><br><span class="line">            ans+=k*v</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="2-10-字母异位词分组"><a href="#2-10-字母异位词分组" class="headerlink" title="2.10 字母异位词分组"></a>2.10 字母异位词分组</h3><blockquote><p><a href="https://leetcode.cn/problems/group-anagrams/">49 字母异位词分组</a></p></blockquote><p>&#8195;&#8195;给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: strs = [<span class="string">&quot;eat&quot;</span>, <span class="string">&quot;tea&quot;</span>, <span class="string">&quot;tan&quot;</span>, <span class="string">&quot;ate&quot;</span>, <span class="string">&quot;nat&quot;</span>, <span class="string">&quot;bat&quot;</span>]</span><br><span class="line">输出: [[<span class="string">&quot;bat&quot;</span>],[<span class="string">&quot;nat&quot;</span>,<span class="string">&quot;tan&quot;</span>],[<span class="string">&quot;ate&quot;</span>,<span class="string">&quot;eat&quot;</span>,<span class="string">&quot;tea&quot;</span>]]</span><br></pre></td></tr></table></figure><p>解题思路：</p><ul><li><p>对每一个字符串先进行排序，然后使用哈希表记录字母相同的子字符串。（排序后结果一样的子串，存储在一个列表里）</p></li><li><p>最终将哈希表的值转换为对应数组返回结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">self, strs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        d=<span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> strs:</span><br><span class="line">        <span class="comment"># 子串进行字母排序，sorted的结果是一个列表，str将其转为字符串</span></span><br><span class="line">            sort_ch=<span class="built_in">str</span>(<span class="built_in">sorted</span>(ch)) </span><br><span class="line">            <span class="keyword">if</span> sort_ch <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[sort_ch]=[ch]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[sort_ch]+=[ch]</span><br><span class="line"></span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">            ans+=[v]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="2-11-两个列表的最小索引总和"><a href="#2-11-两个列表的最小索引总和" class="headerlink" title="2.11 两个列表的最小索引总和"></a>2.11 两个列表的最小索引总和</h3><blockquote><p><a href="https://leetcode.cn/problems/minimum-index-sum-of-two-lists/solution/liang-ge-lie-biao-de-zui-xiao-suo-yin-zo-5m9w/">599 两个列表的最小索引总和</a> </p></blockquote></li></ul><p>&#8195;&#8195;假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</p><p>&#8195;&#8195;你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> 输入:list1 = [<span class="string">&quot;Shogun&quot;</span>, <span class="string">&quot;Tapioca Express&quot;</span>, <span class="string">&quot;Burger King&quot;</span>, <span class="string">&quot;KFC&quot;</span>]，list2 = [<span class="string">&quot;KFC&quot;</span>, <span class="string">&quot;Shogun&quot;</span>, <span class="string">&quot;Burger King&quot;</span>]</span><br><span class="line">输出: [<span class="string">&quot;Shogun&quot;</span>]</span><br><span class="line">解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和<span class="number">1</span>(<span class="number">0</span>+<span class="number">1</span>)。</span><br></pre></td></tr></table></figure><p><strong>思路1</strong></p><ul><li><p>遍历 <code>list1</code>，建立一个哈希表<code>d1</code>，以 <code>list1[i] : i</code> 键值对的方式，将 <code>list1</code> 的下标存储起来。</p></li><li><p>遍历 <code>list2</code>，判断 <code>list2[i]</code> 是否在哈希表中，如果在，则根据 <code>i + list1_dict[i]</code> 和 <code>min_sum</code> 的比较，判断是否需要更新最小索引和。</p><ul><li>如果 <code>i + list1_dict[i] &lt; min_sum</code>，则更新最小索引和，并清空答案数据，添加新的答案；</li><li>如果 <code>i + list1_dict[i] == min_sum</code>，则更新最小索引和，并添加答案。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRestaurant</span>(<span class="params">self, list1: <span class="type">List</span>[<span class="built_in">str</span>], list2: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        d1 = <span class="built_in">dict</span>()</span><br><span class="line">        len1 = <span class="built_in">len</span>(list1)</span><br><span class="line">        len2 = <span class="built_in">len</span>(list2)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len1):</span><br><span class="line">            d1[list1[i]] = i</span><br><span class="line"></span><br><span class="line">        min_sum = len1 + len2</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len2):</span><br><span class="line">            <span class="keyword">if</span> list2[i] <span class="keyword">in</span> d1:</span><br><span class="line">                <span class="built_in">sum</span> = i + d1[list2[i]]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span> &lt; min_sum:</span><br><span class="line">                    res = [list2[i]]</span><br><span class="line">                    min_sum = <span class="built_in">sum</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">sum</span> == min_sum:</span><br><span class="line">                    res.append(list2[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>思路2</strong>：</p><ul><li>遍历 <code>list1</code>，建立一个哈希表<code>d1</code>，以 <code>list1[i] : i</code> 键值对的方式，将 <code>list1</code> 的下标存储起来。</li><li>遍历 <code>list2</code>，如果<code>list2[j]</code> 在哈希表中，将这个字符和其在两个列表中的下标和分别存储在列表<code>ls</code>和<code>res</code>中</li><li>最终遍历<code>res</code>，当遍历到最小下标和时，将ls对应位置的字符取出，存到最终结果中</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRestaurant</span>(<span class="params">self, list1, list2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type list1: List[str]</span></span><br><span class="line"><span class="string">        :type list2: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        d1=<span class="built_in">dict</span>()</span><br><span class="line">        ls=[]  <span class="comment"># 存储相同字符</span></span><br><span class="line">        res=[] <span class="comment"># 存储相同字符的下标和</span></span><br><span class="line">        ans=[] <span class="comment"># 存储最终答案</span></span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list1)):</span><br><span class="line">            d1[list1[i]]=i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list2)):</span><br><span class="line">            <span class="keyword">if</span> list2[j] <span class="keyword">in</span> d1:</span><br><span class="line">                idx=d1[list2[j]]+j  <span class="comment"># 相同字符的下标和</span></span><br><span class="line">                ls.append(list2[j]) <span class="comment"># 同步存储这个字符</span></span><br><span class="line">                res.append(idx)      </span><br><span class="line"></span><br><span class="line">        min_idx=<span class="built_in">min</span>(res) <span class="comment"># 最小下标和</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)):</span><br><span class="line">            <span class="keyword">if</span> res[i]==min_idx:</span><br><span class="line">                ans.append(ls[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="2-12-字符串中的第一个唯一字符"><a href="#2-12-字符串中的第一个唯一字符" class="headerlink" title="2.12 字符串中的第一个唯一字符"></a>2.12 字符串中的第一个唯一字符</h3><blockquote><p><a href="https://leetcode.cn/problems/first-unique-character-in-a-string/submissions/">387 字符串中的第一个唯一字符</a> </p></blockquote><p>给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。        </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;leetcode&quot;</span></span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        d=<span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            d[ch]=d.get(ch,<span class="number">0</span>)+<span class="number">1</span> <span class="comment"># 统计每个字符出现的次数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> d[s[i]]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-13-直线上最多的点数"><a href="#2-13-直线上最多的点数" class="headerlink" title="2.13 直线上最多的点数"></a>2.13 直线上最多的点数</h3><blockquote><p><a href="https://leetcode.cn/problems/max-points-on-a-line/">149 直线上最多的点数</a></p></blockquote><p>给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/579c9577312745bdbcbdd7f08ae2c449.png" alt="在这里插入图片描述"><br><strong>解题思路</strong></p><p>&#8195;&#8195;两个点可以确定一条直线，固定其中一个点，求其他点与该点的斜率，斜率相同的点则在同一条直线上。可以考虑把斜率当做哈希表的键值，存储经过该点，不同斜率的直线上经过的点数目。</p><p>&#8195;&#8195;对于点 <code>i</code>，查找经过该点的直线只需要考虑 <code>(i+1,n-1)</code> 位置上的点即可，因为 <code>i-1</code> 之前的点已经在遍历点 <code>i-2</code> 的时候考虑过了。</p><p>&#8195;&#8195;斜率的计算公式为 $\frac{dy}{dx} = \frac{y_j - y_i}{x_j - x_i}$。因为斜率是小数会有精度误差，所以我们考虑使用 <code>(dx, dy)</code> 的元组作为哈希表的 <code>key</code>。</p><blockquote><p> &#8195;&#8195;注意： 需要处理倍数关系，dy、dx 异号情况，以及处理垂直直线（两点横坐标差为 0）的水平直线（两点横坐标差为 0）的情况。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/524b67fe3d2d453aa3baacebc5d8c1b0.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            line_dict = <span class="built_in">dict</span>()</span><br><span class="line">            line_dict[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            same = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                dx = points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>]</span><br><span class="line">                dy = points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> dx == <span class="number">0</span> <span class="keyword">and</span> dy == <span class="number">0</span>:</span><br><span class="line">                    same += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                gcd_dx_dy = math.gcd(<span class="built_in">abs</span>(dx), <span class="built_in">abs</span>(dy))</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (dx &gt; <span class="number">0</span> <span class="keyword">and</span> dy &gt; <span class="number">0</span>) <span class="keyword">or</span> (dx &lt; <span class="number">0</span> <span class="keyword">and</span> dy &lt; <span class="number">0</span>):</span><br><span class="line">                    dx = <span class="built_in">abs</span>(dx) // gcd_dx_dy</span><br><span class="line">                    dy = <span class="built_in">abs</span>(dy) // gcd_dx_dy</span><br><span class="line">                <span class="keyword">elif</span> dx &lt; <span class="number">0</span> <span class="keyword">and</span> dy &gt; <span class="number">0</span>:</span><br><span class="line">                    dx = -dx // gcd_dx_dy</span><br><span class="line">                    dy = -dy // gcd_dx_dy</span><br><span class="line">                <span class="keyword">elif</span> dx &gt; <span class="number">0</span> <span class="keyword">and</span> dy &lt; <span class="number">0</span>:</span><br><span class="line">                    dx = dx // gcd_dx_dy</span><br><span class="line">                    dy = dy // gcd_dx_dy</span><br><span class="line">                <span class="keyword">elif</span> dx == <span class="number">0</span> <span class="keyword">and</span> dy != <span class="number">0</span>:</span><br><span class="line">                    dy = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> dx != <span class="number">0</span> <span class="keyword">and</span> dy == <span class="number">0</span>:</span><br><span class="line">                    dx = <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                key = (dx, dy)</span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">in</span> line_dict:</span><br><span class="line">                    line_dict[key] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    line_dict[key] = <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, same + <span class="built_in">max</span>(line_dict.values()))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="2-14-子域名访问计数"><a href="#2-14-子域名访问计数" class="headerlink" title="2.14 子域名访问计数"></a>2.14 子域名访问计数</h3><blockquote><p><a href="https://leetcode.cn/problems/subdomain-visit-count/">811 子域名访问计数</a></p></blockquote><p>&#8195;&#8195;网站域名 “discuss.leetcode.com” 由多个子域名组成。顶级域名为 “com” ，二级域名为 “leetcode.com” ，最低一级为 “discuss.leetcode.com” 。当访问域名 “discuss.leetcode.com” 时，同时也会隐式访问其父域名 “leetcode.com” 以及 “com” 。</p><p>&#8195;&#8195;计数配对域名 是遵循 “rep d1.d2.d3” 或 “rep d1.d2” 格式的一个域名表示，其中 rep 表示访问域名的次数，d1.d2.d3 为域名本身。例如，”9001 discuss.leetcode.com” 就是一个 计数配对域名 ，表示 discuss.leetcode.com 被访问了 9001 次。<br>&#8195;&#8195;给你一个 计数配对域名 组成的数组 cpdomains ，解析得到输入中每个子域名对应的 计数配对域名 ，并以数组形式返回。可以按 任意顺序 返回答案。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：cpdomains = [<span class="string">&quot;900 google.mail.com&quot;</span>, <span class="string">&quot;50 yahoo.com&quot;</span>, <span class="string">&quot;1 intel.mail.com&quot;</span>, <span class="string">&quot;5 wiki.org&quot;</span>]</span><br><span class="line">输出：[<span class="string">&quot;901 mail.com&quot;</span>,<span class="string">&quot;50 yahoo.com&quot;</span>,<span class="string">&quot;900 google.mail.com&quot;</span>,<span class="string">&quot;5 wiki.org&quot;</span>,<span class="string">&quot;5 org&quot;</span>,<span class="string">&quot;1 intel.mail.com&quot;</span>,<span class="string">&quot;951 com&quot;</span>]</span><br><span class="line">解释：按照前文描述，会访问 <span class="string">&quot;google.mail.com&quot;</span> <span class="number">900</span> 次，<span class="string">&quot;yahoo.com&quot;</span> <span class="number">50</span> 次，<span class="string">&quot;intel.mail.com&quot;</span> <span class="number">1</span> 次，<span class="string">&quot;wiki.org&quot;</span> <span class="number">5</span> 次。</span><br><span class="line">而对于父域名，会访问 <span class="string">&quot;mail.com&quot;</span> <span class="number">900</span> + <span class="number">1</span> = <span class="number">901</span> 次，<span class="string">&quot;com&quot;</span> <span class="number">900</span> + <span class="number">50</span> + <span class="number">1</span> = <span class="number">951</span> 次，和 <span class="string">&quot;org&quot;</span> <span class="number">5</span> 次。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>&#8195;&#8195;这道题求解的是不同层级的域名的次数汇总，很容易想到使用哈希表。我们可以使用哈希表来统计不同层级的域名访问次数。具体做如下：</p><ol><li>如果数组 <code>cpdomains</code> 为空，直接返回空数组。</li><li>使用哈希表 <code>times_dict</code> 存储不同层级的域名访问次数。</li><li>遍历数组 <code>cpdomains</code>。对于每一个计算机配对域名 <code>cpdomain</code>：<ol><li>先将计算机配对域名的访问次数 <code>times</code> 和域名 <code>domain</code> 进行分割。</li><li>然后将域名转为子域名数组 <code>domain_list</code>，逆序拼接不同等级的子域名 <code>sub_domain</code>。</li><li>如果子域名 <code>sub_domain</code> 没有出现在哈希表 <code>times_dict</code> 中，则在哈希表中存入 <code>sub_domain</code> 和访问次数 <code>times</code> 的键值对。</li><li>如果子域名 <code>sub_domain</code> 曾经出现在哈希表 <code>times_dict</code> 中，则在哈希表对应位置加上 <code>times</code>。</li></ol></li><li>遍历完之后，遍历哈希表 <code>times_dict</code>，将所有域名和访问次数拼接为字符串，存入答案数组中。</li><li>最后返回答案数组。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subdomainVisits</span>(<span class="params">self, cpdomains: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cpdomains:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        times_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> cpdomain <span class="keyword">in</span> cpdomains:</span><br><span class="line">            tiems, domain = cpdomain.split()</span><br><span class="line">            tiems = <span class="built_in">int</span>(tiems)</span><br><span class="line">            </span><br><span class="line">            domain_list = domain.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(domain_list) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                sub_domain = <span class="string">&#x27;.&#x27;</span>.join(domain_list[i:])</span><br><span class="line">                <span class="keyword">if</span> sub_domain <span class="keyword">not</span> <span class="keyword">in</span> times_dict:</span><br><span class="line">                    times_dict[sub_domain] = tiems</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    times_dict[sub_domain] += tiems</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> times_dict.keys():</span><br><span class="line">            res.append(<span class="built_in">str</span>(times_dict[key]) + <span class="string">&#x27; &#x27;</span> + key)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;@[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://algo.itcharge.cn/05.Hash-Table/01.Hash-Table/&quot;&gt;《算法通关手册》-哈希表篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;【博文】&lt;a href=&quot;https://time.geekbang.org/column/article/64233&quot;&gt;散列表（上）- 数据结构与算法之美 - 极客时间&lt;/a&gt;&lt;h2 id=&quot;一、哈希表&quot;&gt;&lt;a href=&quot;#一、哈希表&quot; class=&quot;headerlink&quot; title=&quot;一、哈希表&quot;&gt;&lt;/a&gt;一、哈希表&lt;/h2&gt;&lt;h3 id=&quot;1-1-哈希表简介&quot;&gt;&lt;a href=&quot;#1-1-哈希表简介&quot; class=&quot;headerlink&quot; title=&quot;1.1 哈希表简介&quot;&gt;&lt;/a&gt;1.1 哈希表简介&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;#8195;&amp;#8195; &lt;strong&gt;哈希表（Hash Table）&lt;/strong&gt;：也叫做散列表。是根据关键码值（Key Value）直接进行访问的数据结构。&lt;br&gt;&amp;#8195;&amp;#8195; 哈希表通过「键 &lt;code&gt;key&lt;/code&gt; 」和「映射函数 &lt;code&gt;Hash(key)&lt;/code&gt; 」计算出对应的「值 &lt;code&gt;value&lt;/code&gt;」，把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做「哈希函数（散列函数）」，存放记录的数组叫做「哈希表（散列表）」。&lt;/p&gt;
&lt;p&gt;哈希表的关键思想是使用哈希函数，将键 &lt;code&gt;key&lt;/code&gt; 映射到对应表的某个区块中。我们可以将算法思想分为两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;向哈希表中插入一个关键码值&lt;/strong&gt;：哈希函数决定该关键字的对应值应该存放到表中的哪个区块，并将对应值存放到该区块中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在哈希表中搜索一个关键码值&lt;/strong&gt;：使用相同的哈希函数从哈希表中查找对应的区块，并在特定的区块搜索该关键字对应的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;哈希表的原理示例图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/130e45ed6844703a636560c67a3bb15a.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;</summary>
    
    
    
    <category term="Data Structure and Algorithms" scheme="https://zhxnlp.github.io/categories/Data-Structure-and-Algorithms/"/>
    
    
    <category term="leetcode" scheme="https://zhxnlp.github.io/tags/leetcode/"/>
    
    <category term="Stack" scheme="https://zhxnlp.github.io/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习四：栈</title>
    <link href="https://zhxnlp.github.io/2023/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E5%9B%9B%EF%BC%9A%E6%A0%88/"/>
    <id>https://zhxnlp.github.io/2023/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E5%9B%9B%EF%BC%9A%E6%A0%88/</id>
    <published>2023-02-28T16:00:00.000Z</published>
    <updated>2023-04-08T00:40:53.872Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>本文主要参考<a href="https://algo.itcharge.cn/03.Stack/01.Stack-Basic/01.Stack-Basic/">《算法通关手册》堆栈篇</a></p><h2 id="一、-堆栈基础知识"><a href="#一、-堆栈基础知识" class="headerlink" title="一、 堆栈基础知识"></a>一、 堆栈基础知识</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3></blockquote><p> <strong>堆栈（Stack）</strong>：简称为栈。一种线性表数据结构，是一种只允许在表的一端进行插入和删除操作的线性表。</p><p>&#8195;&#8195;我们把栈中允许插入和删除的一端称为 <strong>「栈顶（top）」</strong>；另一端则称为 <strong>「栈底（bottom）」</strong>。当表中没有任何数据元素时，称之为 <strong>「空栈」</strong>。</p><p>堆栈有两种基本操作：<strong>「插入操作」</strong> 和 <strong>「删除操作」</strong>。</p><ul><li>栈的插入操作又称为「入栈」或者「进栈」。</li><li>栈的删除操作又称为「出栈」或者「退栈」。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/07774fbc4c85c01ef050267826da680e.png" alt=""><br><span id="more"></span><br>&#8195;&#8195;简单来说，栈是一种 <strong>「后进先出（Last In First Out）」</strong> 的线性表，简称为 <strong>「LIFO 结构」</strong>。我们可以从两个方面来解释一下栈的定义：</p><ul><li><p><strong>「线性表」</strong>：栈首先是一个线性表，栈中元素具有前驱后继的线性关系。栈中元素按照 $a_1, a_2, … , a_n$ 的次序依次进栈。栈顶元素为 $a_n$。</p></li><li><p><strong>「后进先出原则」</strong>：根据堆栈的定义，每次删除的总是堆栈中当前的栈顶元素，即最后进入堆栈的元素。而在进栈时，最先进入堆栈的元素一定在栈底，最后进入堆栈的元素一定在栈顶。也就是说，元素进入堆栈或者退出退栈是按照「后进先出（Last In First Out）」的原则进行的。</p></li></ul><p><strong>堆栈的基本操作</strong></p><p>&#8195;&#8195;栈作为一种线性表来说，理论上应该具备线性表所有的操作特性，但由于「后进先出」的特殊性，所以针对栈的操作进行了一些变化。尤其是插入操作和删除操作，改为了入栈（push）和出栈（pop）。</p><p>堆栈的基本操作如下：</p><ul><li><p><strong>初始化空栈</strong>：创建一个空栈，定义栈的大小 <code>size</code>，以及栈顶元素指针 <code>top</code>。</p></li><li><p><strong>判断栈是否为空</strong>：当堆栈为空时，返回 <code>True</code>。当堆栈不为空时，返回 <code>False</code>。一般只用于栈中删除操作和获取当前栈顶元素操作中。</p></li><li><p><strong>判断栈是否已满</strong>：当堆栈已满时，返回 <code>True</code>，当堆栈未满时，返回 <code>False</code>。一般只用于顺序栈中插入元素和获取当前栈顶元素操作中。</p></li><li><p><strong>插入元素（进栈、入栈）</strong>：相当于在线性表最后元素后面插入一个新的数据元素。并改变栈顶指针 <code>top</code> 的指向位置。</p></li><li><p><strong>删除元素（出栈、退栈）</strong>：相当于在线性表最后元素后面删除最后一个数据元素。并改变栈顶指针 <code>top</code> 的指向位置。</p></li><li><strong>获取栈顶元素</strong>：相当于获取线性表中最后一个数据元素。与插入元素、删除元素不同的是，该操作并不改变栈顶指针 <code>top</code> 的指向位置。</li></ul><p>接下来我们来看一下栈的顺序存储与链式存储两种不同的实现方式。</p><h3 id="1-2-堆栈的顺序存储"><a href="#1-2-堆栈的顺序存储" class="headerlink" title="1.2 堆栈的顺序存储"></a>1.2 堆栈的顺序存储</h3><p>和线性表类似，栈有两种存储表示方法：<strong>「顺序栈」</strong> 和 <strong>「链式栈」</strong>。</p><ul><li><strong>「顺序栈」</strong>：即堆栈的顺序存储结构。利用一组地址连续的存储单元依次存放自栈底到栈顶的元素，同时使用指针 <code>top</code> 指示栈顶元素在顺序栈中的位置。</li><li><strong>「链式栈」</strong>：即堆栈的链式存储结构。利用单链表的方式来实现堆栈。栈中元素按照插入顺序依次插入到链表的第一个节点之前，并使用栈顶指针 <code>top</code> 指示栈顶元素，<code>top</code> 永远指向链表的头节点位置。</li></ul><p>&#8195;&#8195;堆栈最简单的实现方式就是借助于一个数组来描述堆栈的顺序存储结构。在 <code>Python</code> 中我们可以借助列表 <code>list</code> 来实现。这种采用顺序存储结构的堆栈也被称为 <strong>「顺序栈」</strong>。</p><h4 id="1-2-1-堆栈顺序存储基本描述"><a href="#1-2-1-堆栈顺序存储基本描述" class="headerlink" title="1.2.1 堆栈顺序存储基本描述"></a>1.2.1 堆栈顺序存储基本描述</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/d0730e6b8c8fd338dcfdefafff1aa318.png" alt=""></p><p>我们约定 <code>self.top</code> 指向栈顶元素所在位置。</p><ul><li><strong>初始化空栈</strong>：使用列表创建一个空栈，定义栈的大小 <code>self.size</code>，并令栈顶元素指针 <code>self.top</code> 指向 <code>-1</code>，即 <code>self.top = -1</code>。</li><li><strong>判断栈是否为空</strong>：当 <code>self.top == -1</code> 时，说明堆栈为空，返回 <code>True</code>，否则返回 <code>False</code>。</li><li><strong>判断栈是否已满</strong>：当 <code>self.top == self.size - 1</code>，说明堆栈已满，返回 <code>True</code>，否则返回返回 <code>False</code>。</li><li><strong>插入元素（进栈、入栈）</strong>：先判断堆栈是否已满，已满直接抛出异常。如果堆栈未满，则在 <code>self.stack</code> 末尾插入新的数据元素，并令 <code>self.top</code> 向右移动 <code>1</code> 位。</li><li><strong>删除元素（出栈、退栈）</strong>：先判断堆栈是否为空，为空直接抛出异常。如果堆栈不为空，则删除 <code>self.stack</code> 末尾的数据元素，并令 <code>self.top</code> 向左移动 <code>1</code> 位。</li><li><strong>获取栈顶元素</strong>：先判断堆栈是否为空，为空直接抛出异常。不为空则返回 <code>self.top</code> 指向的栈顶元素，即 <code>self.stack[self.top]</code>。</li></ul><h4 id="1-2-2-堆栈顺序存储实现代码"><a href="#1-2-2-堆栈顺序存储实现代码" class="headerlink" title="1.2.2 堆栈顺序存储实现代码"></a>1.2.2 堆栈顺序存储实现代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="comment"># 初始化空栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size=<span class="number">100</span></span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.size = size</span><br><span class="line">        self.top = -<span class="number">1</span>    </span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.top == -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断栈是否已满</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_full</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.top + <span class="number">1</span> == self.size</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 入栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_full():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Stack is full&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.append(value)</span><br><span class="line">            self.top += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 出栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Stack is empty&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.pop()</span><br><span class="line">            self.top -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Stack is empty&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack[self.top]</span><br></pre></td></tr></table></figure><h3 id="1-3-堆栈的链式存储"><a href="#1-3-堆栈的链式存储" class="headerlink" title="1.3 堆栈的链式存储"></a>1.3 堆栈的链式存储</h3><p>&#8195;&#8195;堆栈的顺序存储结构保留着顺序存储分配空间的固有缺陷，即在栈满或者其他需要重新调整存储空间时需要移动大量元素。为此，堆栈可以采用链式存储方式来实现。在 <code>Python</code> 中我们通过构造链表节点 <code>Node</code> 的方式来实现。这种采用链式存储结构的堆栈也被称为 <strong>「链式栈」</strong>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2d396094962d5c19d93ed098778d89aa.png" alt=""></p><h4 id="1-3-1-堆栈的链式存储基本描述"><a href="#1-3-1-堆栈的链式存储基本描述" class="headerlink" title="1.3.1 堆栈的链式存储基本描述"></a>1.3.1 堆栈的链式存储基本描述</h4><p>我们约定 <code>self.top</code> 指向栈顶元素所在位置。</p><ul><li><strong>初始化空栈</strong>：使用列表创建一个空栈，并令栈顶元素指针 <code>self.top</code> 指向 <code>None</code>，即 <code>self.top = None</code>。</li><li><strong>判断栈是否为空</strong>：当 <code>self.top == None</code> 时，说明堆栈为空，返回 <code>True</code>，否则返回 <code>False</code>。</li><li><strong>插入元素（进栈、入栈）</strong>：创建值为 <code>value</code> 的链表节点，插入到链表头节点之前，并令栈顶指针 <code>self.top</code> 指向新的头节点。</li><li><strong>删除元素（出栈、退栈）</strong>：先判断堆栈是否为空，为空直接抛出异常。如果堆栈不为空，则先使用变量 <code>cur</code> 存储当前栈顶指针 <code>self.top</code> 指向的头节点，然后令 <code>self.top</code> 沿着链表移动 <code>1</code> 位，然后再删除之前保存的 <code>cur</code> 节点。</li><li><strong>获取栈顶元素</strong>：先判断堆栈是否为空，为空直接抛出异常。不为空则返回 <code>self.top</code> 指向的栈顶节点的值，即 <code>self.top.value</code>。</li></ul><h4 id="1-3-2-堆栈的链式存储实现代码"><a href="#1-3-2-堆栈的链式存储实现代码" class="headerlink" title="1.3.2 堆栈的链式存储实现代码"></a>1.3.2 堆栈的链式存储实现代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="comment"># 初始化空栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.top == <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 入栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        cur = Node(value)</span><br><span class="line">        cur.<span class="built_in">next</span> = self.top</span><br><span class="line">        self.top = cur</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 出栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Stack is empty&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.top</span><br><span class="line">            self.top = self.top.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">del</span> cur</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Stack is empty&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.top.value</span><br></pre></td></tr></table></figure><h2 id="二、-堆栈的基础应用"><a href="#二、-堆栈的基础应用" class="headerlink" title="二、 堆栈的基础应用"></a>二、 堆栈的基础应用</h2><p>堆栈是算法和程序中最常用的辅助结构，其的应用十分广泛。堆栈基本应用于两个方面：</p><ul><li>使用堆栈可以很方便的保存和取用信息，因此长被用作算法和程序中的辅助存储结构，临时保存信息，供后面操作中使用。<ul><li>例如：操作系统中的函数调用栈，浏览器中的前进、后退功能。</li></ul></li><li>堆栈的后进先出规则，可以保证特定的存取顺序。<ul><li>例如：翻转一组元素的顺序、铁路列车车辆调度。</li></ul></li></ul><h3 id="2-1-堆栈基础题列表"><a href="#2-1-堆栈基础题列表" class="headerlink" title="2.1 堆栈基础题列表"></a>2.1 堆栈基础题列表</h3><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">1047</td><td style="text-align:left"><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">删除字符串中的所有相邻重复项</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/1047.%20%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.md">Python</a></td><td style="text-align:left">字符串、栈</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0155</td><td style="text-align:left"><a href="https://leetcode.cn/problems/min-stack/">最小栈</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0155.%20%E6%9C%80%E5%B0%8F%E6%A0%88.md">Python</a></td><td style="text-align:left">栈、设计</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0020</td><td style="text-align:left"><a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0020.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.md">Python</a></td><td style="text-align:left">栈、字符串</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0227</td><td style="text-align:left"><a href="https://leetcode.cn/problems/basic-calculator-ii/">基本计算器 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0227.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%20II.md">Python</a></td><td style="text-align:left">栈、字符串</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0739</td><td style="text-align:left"><a href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0739.%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.md">Python</a></td><td style="text-align:left">栈、哈希表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0150</td><td style="text-align:left"><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">逆波兰表达式求值</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0150.%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.md">Python</a></td><td style="text-align:left">栈</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0232</td><td style="text-align:left"><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">用栈实现队列</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.md">Python</a></td><td style="text-align:left">栈、设计</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">剑指 Offer 09</td><td style="text-align:left"><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.md">Python</a></td><td style="text-align:left">栈、设计、队列</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0394</td><td style="text-align:left"><a href="https://leetcode.cn/problems/decode-string/">字符串解码</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0394.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81.md">Python</a></td><td style="text-align:left">栈、深度优先搜索</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0032</td><td style="text-align:left"><a href="https://leetcode.cn/problems/longest-valid-parentheses/">最长有效括号</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0032.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.md">Python</a></td><td style="text-align:left">栈、字符串、动态规划</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0946</td><td style="text-align:left"><a href="https://leetcode.cn/problems/validate-stack-sequences/">验证栈序列</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0946.%20%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97.md">Python</a></td><td style="text-align:left">栈、数组、模拟</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">剑指 Offer 06</td><td style="text-align:left"><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">栈、递归、链表、双指针</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0739</td><td style="text-align:left"><a href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0739.%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.md">Python</a></td><td style="text-align:left">栈、哈希表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0071</td><td style="text-align:left">简化路径</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></div><p>下面我们来讲解一下栈应用的典型例子。</p><h3 id="2-2-括号匹配问题"><a href="#2-2-括号匹配问题" class="headerlink" title="2.2 括号匹配问题"></a>2.2 括号匹配问题</h3><h4 id="2-2-1-有效的括号"><a href="#2-2-1-有效的括号" class="headerlink" title="2.2.1 有效的括号"></a>2.2.1 有效的括号</h4><blockquote><p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode）</a></p></blockquote><p>&#8195;&#8195;给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串 <code>s</code> 是否有效（即括号是否匹配）。</p><ul><li>左括号必须用相同类型的右括号闭合。<ul><li>左括号必须以正确的顺序闭合。</li></ul></li></ul><p><strong>示例</strong>：</p><ul><li>输入：s = “()[]{}”</li><li>输出：True</li></ul><p><strong>解题思路</strong>：括号匹配是「栈」的经典应用。我们可以用栈来解决这道题。</p><ol><li>先判断一下字符串的长度是否为偶数。因为括号是成对出现的，所以字符串的长度应为偶数，可以直接判断长度为奇数的字符串不匹配。如果字符串长度为奇数，则说明字符串 <code>s</code> 中的括号不匹配，直接返回 <code>False</code>。</li><li>使用栈 <code>stack</code> 来保存未匹配的左括号。然后依次遍历字符串 <code>s</code> 中的每一个字符。<ol><li>如果遍历到左括号时，将其入栈。</li><li>如果遍历到右括号时，先看栈顶元素是否是与当前右括号相同类型的左括号。<ol><li>如果是与当前右括号相同类型的左括号，则令其出栈，继续向前遍历。</li><li>如果不是与当前右括号相同类型的左括号，则说明字符串 <code>s</code> 中的括号不匹配，直接返回 <code>False</code>。</li></ol></li></ol></li><li>遍历完，还要再判断一下栈是否为空。<ol><li>如果栈为空，则说明字符串 <code>s</code> 中的括号匹配，返回 <code>True</code>。</li><li>如果栈不为空，则说明字符串 <code>s</code> 中的括号不匹配，返回 <code>False</code>。</li></ol></li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> ch == <span class="string">&#x27;[&#x27;</span> <span class="keyword">or</span> ch == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                stack.append(ch)</span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack) !=<span class="number">0</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack) !=<span class="number">0</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack) !=<span class="number">0</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n)$。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h4 id="2-2-2-最长有效括号"><a href="#2-2-2-最长有效括号" class="headerlink" title="2.2.2 最长有效括号"></a>2.2.2 最长有效括号</h4><blockquote><p><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32  最长有效括号 - 力扣（LeetCode）</a></p></blockquote><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。<br>示例：</p><ul><li>输入：s = “)()())”</li><li>输出：4</li><li>解释：最长有效括号子串是 “()()”</li></ul><p>参考官方题解，使用单调栈来解决。主要思路是我们始终保持<strong>栈底元素</strong>为当前已经遍历过的元素中，<strong>「最后一个没有被匹配的右括号的下标」</strong>。</p><ul><li>对于遇到的每个 ‘<code>(</code>’ ，直接入栈</li><li>对于遇到的每个 ‘<code>)</code>’ ，我们先弹出栈顶元素表示匹配了当前右括号：<ul><li>如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」</li></ul></li><li>如果栈不为空，当前右括号的下标减去栈顶元素即为，<strong>「以该右括号为结尾的最长有效括号的长度」</strong>。<br>我们从前往后遍历字符串并更新答案即可。</li></ul><blockquote><p>&#8195;&#8195;注意：如果一开始栈为空，第一个字符为左括号的时候，我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 <code>−1</code> 的元素。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        stack=[-<span class="number">1</span>] <span class="comment"># 初始赋值为-1，这样匹配到都一个右括号时，长度=1-（-1）=2，刚刚好。</span></span><br><span class="line">        ans=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i]==<span class="string">&quot;(&quot;</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack)==<span class="number">0</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans=<span class="built_in">max</span>(ans,i-stack[-<span class="number">1</span>])               </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n)$。</li><li><strong>空间复杂度</strong>：$O(n)$。        </li></ul><h3 id="2-3-前缀、中缀、后缀表达式"><a href="#2-3-前缀、中缀、后缀表达式" class="headerlink" title="2.3 前缀、中缀、后缀表达式"></a>2.3 前缀、中缀、后缀表达式</h3><h4 id="2-3-1-表达式简介"><a href="#2-3-1-表达式简介" class="headerlink" title="2.3.1 表达式简介"></a>2.3.1 表达式简介</h4><ul><li>中缀表达式<ul><li>中缀表达式：操作符介于操作数之间的表达式。</li><li>中缀(infix)表达式：A + B * C + D ，为了避免计算顺序混淆，引入全括号表达式；</li><li>全括号中缀表达式：((A + (B * C)) + D)，内层括号优先级更高。</li></ul></li><li>前缀和后缀表达式<ul><li>前缀(prefix)表达式：将操作符移到前面，形式变为：操作符、第一操作数、第二操作数。</li><li>后缀(postfix)表达式：将操作符移到后面，形式变为：第一操作数、第二操作数、操作符。</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/15200971498df17c98229b62960a34e0.png#pic_center =500x" alt="在这里插入图片描述"></p><h4 id="2-3-2-表达式转换原理"><a href="#2-3-2-表达式转换原理" class="headerlink" title="2.3.2 表达式转换原理"></a>2.3.2 表达式转换原理</h4><p>例：<code>(A + (B * C))</code></p><ol><li><strong>中缀转后缀表达式</strong>：把操作符移到相应的右括号替代之，并删掉左括号<ul><li>把操作符<code>*</code>移到子表达式<code>(B * C)</code>的右括号位置替代它，再删去左括号得到<code>BC*</code></li><li>把操作符<code>+</code>移到相应的右括号并删掉左括号，表达式就转为 <strong>后缀</strong> 形式，即：<code>ABC*+</code> 。</li></ul></li><li><strong>中缀转前缀表达式</strong>：同理，把操作符移到相应的左括号替代之，并删掉右括号，表达时就转换为 <strong>前缀</strong> 形式，即：<code>+A*BC</code> 。</li></ol><p>总结：</p><ul><li><strong>前后缀表达式中，操作符顺序完全决定了运算的次序，多数情况下计算机用此方法，特别是后缀法。</strong></li><li><strong>离操作数越近的越先做</strong></li><li>无论表达式多复杂，转换为前缀或后缀只需要两个步骤：  <ul><li>将中缀表达式转换为全括号形式；  </li><li><strong>将所有操作符移动到子表达式所在的左括号（前缀）或者右括号（后缀）处，替代之，再删除所有括号。</strong></li></ul></li></ul><h4 id="2-3-3-中缀转后缀算法"><a href="#2-3-3-中缀转后缀算法" class="headerlink" title="2.3.3 中缀转后缀算法"></a>2.3.3 中缀转后缀算法</h4><ul><li>在中缀表达式转换为后缀形式的处理过程中，操作符比操作数要晚输出，所以在扫描到对应的第二个操作数之前，需要把操作符先保存起来；</li><li>而这些暂存的操作符，由于优先级的规则还有可能要<strong>反转</strong>次序输出。<br>在<code>A+B*C</code>中，<code>+</code>虽然先出现，但优先级比后面这个<code>*</code>要低，所以它要等<code>*</code>处理完后，才能再处理。</li><li>这种<strong>反转</strong>特性，使得我们考虑用<code>栈</code>来保存暂时<strong>未处理</strong>的<strong>操作符</strong>。</li></ul><p>&#8195;&#8195;总结下，在从左到右扫描逐个字符扫描中缀表达式的过程中，采用一个<strong>栈</strong>来暂存未处理的操作符。这样，<strong>栈顶</strong>的操作符就是<strong>最近</strong>暂存进去的，当遇到一个新的操作符，就需要跟栈顶的操作符比较下优先级，再行处理。<br>&#8195;&#8195;所以遇到<strong>左括号</strong>，要标记下，其后出现的操作符<strong>优先级提升了</strong>，一旦扫描到对应的右括号，就可以马上输出这个操作符</p><p><strong>流程</strong>：</p><ul><li>从左到右扫描中缀表达式单词列表<ul><li>如果单词是操作数，则直接添加到后缀表达式列表的末尾；</li><li>如果单词是左括号，则压入opstack栈顶；</li><li>如果单词是右括号，则反复弹出opstack栈顶操作符，加入到输出列表末尾，直到碰到左括号；</li><li>如果单词是操作符，则压入opstack栈顶，但在压入栈顶之前，要比较其与栈顶操作符的优先级，如果栈顶的高于或等于它，就要反复弹出栈顶操作符，加入到输出列表末尾；直到栈顶的操作符优先级低于它。</li></ul></li><li>中缀表达式单词列表扫描结束后，把opstack栈中的所有剩余操作符  依次弹出，添加到输出列表末尾。</li><li>把输出列表再用join方法合并成后缀表达式字符串，算法结束。</li></ul><p><strong>代码实现</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infixToPostfix</span>(<span class="params">infixexpr</span>):</span></span><br><span class="line">    prec = &#123;&#125;</span><br><span class="line">    prec[<span class="string">&quot;*&quot;</span>] = <span class="number">3</span></span><br><span class="line">    prec[<span class="string">&quot;/&quot;</span>] = <span class="number">3</span></span><br><span class="line">    prec[<span class="string">&quot;+&quot;</span>] = <span class="number">2</span></span><br><span class="line">    prec[<span class="string">&quot;-&quot;</span>] = <span class="number">2</span></span><br><span class="line">    prec[<span class="string">&quot;(&quot;</span>] = <span class="number">1</span></span><br><span class="line">    opStack = Stack()</span><br><span class="line">    postfixList = []</span><br><span class="line">    tokenList = infixexpr.split()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokenList:</span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span> <span class="keyword">or</span> token <span class="keyword">in</span> <span class="string">&quot;0123456789&quot;</span>:</span><br><span class="line">            postfixList.append(token)</span><br><span class="line">        <span class="keyword">elif</span> token == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            opStack.push(token)</span><br><span class="line">        <span class="keyword">elif</span> token == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            topToken = opStack.pop()</span><br><span class="line">            <span class="keyword">while</span> topToken != <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                postfixList.append(topToken)</span><br><span class="line">                topToken = opStack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">not</span> opStack.isEmpty()) <span class="keyword">and</span> \</span><br><span class="line">                (prec[opStack.peek()] &gt;= prec[token]):</span><br><span class="line">                postfixList.append(opStack.pop())</span><br><span class="line">            opStack.push(token)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> opStack.isEmpty():</span><br><span class="line">        postfixList.append(opStack.pop())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(postfixList)</span><br></pre></td></tr></table></figure><h4 id="2-3-4-后缀表达式求值"><a href="#2-3-4-后缀表达式求值" class="headerlink" title="2.3.4 后缀表达式求值"></a>2.3.4 后缀表达式求值</h4><ul><li>创建空栈operandStack用于暂存操作数。</li><li>将后缀表达式用split方法解析为单词（token）的列表。</li><li>从左到右扫描单词列表，如果单词是一个操作数，将单词转换为整数int，压入operandStack栈顶；如果单词是一个操作符，就开始求值，从栈顶弹出两个操作数，先弹出的是右操作数，后弹出的是左操作数，计算后将值重新压入栈顶。</li><li>单词列表扫描结束后，表达式的值就在栈顶。</li><li>弹出栈顶的值，返回。<br><img src="https://img-blog.csdnimg.cn/ca6f3ddb73cb4aa8a46158447f30adaa.png" alt="在这里插入图片描述"><br><strong>代码实现</strong>：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postfixEval</span>(<span class="params">postfixExpr</span>):</span></span><br><span class="line">    operandStack = Stack()</span><br><span class="line">    tokenList = postfixExpr.split()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokenList:</span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">&quot;0123456789&quot;</span>:</span><br><span class="line">            operandStack.push(<span class="built_in">int</span>(token))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            operand2 = operandStack.pop()</span><br><span class="line">            operand1 = operandStack.pop()</span><br><span class="line">            result = doMath(token,operand1,operand2)</span><br><span class="line">            operandStack.push(result)</span><br><span class="line">    <span class="keyword">return</span> operandStack.pop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doMath</span>(<span class="params">op,op1,op2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> op == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1 * op2</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1 / op2</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1 + op2</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> op1 - op2</span><br></pre></td></tr></table></figure><h3 id="2-4-表达式求值问题"><a href="#2-4-表达式求值问题" class="headerlink" title="2.4 表达式求值问题"></a>2.4 表达式求值问题</h3><h4 id="2-4-1-基本计算器II"><a href="#2-4-1-基本计算器II" class="headerlink" title="2.4.1 基本计算器II"></a>2.4.1 基本计算器II</h4><blockquote><p><a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II - 力扣（LeetCode）</a></p></blockquote><p>&#8195;&#8195;给定一个字符串表达式 <code>s</code>，表达式中所有整数为非负整数，运算符只有 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>，没有括号。请实现一个基本计算器来计算并返回它的值。</p><ul><li>$1 \le s.length \le 3 * 10^5$。</li><li><code>s</code> 由整数和算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>）组成，中间由一些空格隔开。</li><li><code>s</code> 表示一个有效表达式。</li><li>表达式中的所有整数都是非负整数，且在范围 $[0, 2^{31} - 1]$ 内。</li><li>题目数据保证答案是一个 32-bit 整数。</li></ul><p><strong>示例</strong>：</p><ul><li>输入：s = “<code>3+2*2</code>“</li><li>输出：7</li></ul><p><strong>解题思路</strong></p><p>&#8195;&#8195;计算表达式中，乘除运算优先于加减运算。我们可以先做所有的乘除运算，将其结果放回表达式的原位置，这样整个表达式的值，就成了一系列加减的结果。</p><ul><li>遍历字符串，使用op记录每个数字之前的运算符。对于第一个数字，其之前的运算符视为‘+’。每次遍历到数字末尾时，根据op决定当前数字的计算方式：</li><li><code>+</code>：直接入栈</li><li><code>-</code>：将数字的负数入栈</li><li><code>*/</code>：将栈顶数字弹出，计算其与当前数字的结果，再将计算结果入栈</li><li>处理完当前数字后，更新操作符op，进行下一次计算</li><li>遍历完后，计算栈中所有数字的累加结果</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        s=<span class="built_in">list</span>(s)</span><br><span class="line">        stack=[]</span><br><span class="line">        op=<span class="string">&#x27;+&#x27;</span>    <span class="comment"># 记录操作符，默认为+</span></span><br><span class="line">        num=<span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                      </span><br><span class="line">            <span class="keyword">if</span> s[i].isdigit():</span><br><span class="line">                num+=s[i]</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> i==<span class="built_in">len</span>(s)-<span class="number">1</span> <span class="keyword">or</span> s[i] <span class="keyword">in</span> <span class="string">&#x27;+-*/&#x27;</span>:</span><br><span class="line">                num=<span class="built_in">int</span>(num)</span><br><span class="line">                <span class="keyword">if</span> op==<span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.append(num)</span><br><span class="line">                <span class="keyword">elif</span> op==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.append(-num)</span><br><span class="line">                <span class="keyword">elif</span> op==<span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stack.append(stack.pop()*num)</span><br><span class="line">                <span class="keyword">elif</span> op==<span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    stack.append(<span class="built_in">int</span>(stack.pop()/num))</span><br><span class="line">                op=s[i]</span><br><span class="line">                num=<span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure><h4 id="2-4-2-逆波兰表达式求值"><a href="#2-4-2-逆波兰表达式求值" class="headerlink" title="2.4.2  逆波兰表达式求值"></a>2.4.2  逆波兰表达式求值</h4><blockquote><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a>          </p></blockquote><p>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。</p><ul><li>两个整数之间的除法总是 向零截断</li><li>表达式中不含除零运算</li><li>输入是一个根据逆波兰表示法表示的算术表达式，有效的算符为 ‘+’、’-‘、’*’ 和 ‘/‘ 。</li><li>示例：<ul><li>输入：tokens = <code>[&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</code></li><li>输出：22</li><li>该算式转化为常见的中缀算术表达式为：  <code>((10 * (6 / ((9 + 3) * -11))) + 17) + 5</code></li></ul></li></ul><p>&#8195;&#8195;本题实际是后缀表达式求值问题。因为前缀或者后缀表达式中，靠近数字的操作符先运算，所以不存在中缀表达式那种需要先比较运算符优先级的情况，直接运算就行了。唯一注意的是，数字可以是负数，需要稍微处理一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        Stack = []       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="comment"># 数字直接入栈，负数将其乘以-1再入栈</span></span><br><span class="line">            <span class="keyword">if</span> token.isdigit():</span><br><span class="line">                Stack.append(<span class="built_in">int</span>(token))</span><br><span class="line">            <span class="keyword">elif</span> token[<span class="number">0</span>]==<span class="string">&quot;-&quot;</span> <span class="keyword">and</span> <span class="built_in">len</span>(token)&gt;<span class="number">1</span>:<span class="comment"># 此时表示的是负数</span></span><br><span class="line">                Stack.append(<span class="built_in">int</span>(token[<span class="number">1</span>:])*-<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 碰到操作符就开始运算，弹出的第一个栈顶元素是第二操作数            </span></span><br><span class="line">            <span class="keyword">else</span>:               </span><br><span class="line">                num2 = Stack.pop()</span><br><span class="line">                num1 = Stack.pop()</span><br><span class="line">                result = self.doMath(token,num1,num2)</span><br><span class="line">                Stack.append(result)</span><br><span class="line">        <span class="keyword">return</span> Stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doMath</span>(<span class="params">self,op,num1,num2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 * num2</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(num1 / num2)</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 + num2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 - num2</span><br></pre></td></tr></table></figure><h4 id="2-4-3-基本计算器I"><a href="#2-4-3-基本计算器I" class="headerlink" title="2.4.3 基本计算器I"></a>2.4.3 基本计算器I</h4><blockquote><p><a href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a></p></blockquote><p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。</p><ul><li>s 由数字、加减乘除和小括号 组成</li><li>‘+’ 不能用作一元运算，例如， “<code>+1</code>“ 和 “<code>+(2 + 3)</code>“ 无效</li><li>‘-‘ 可以用作一元运算，即 “<code>-1</code>“ 和 “<code>-(2 + 3)</code>“ 是有效的</li><li>输入中不存在两个连续的操作符</li><li>示例：<ul><li>输入： <code>s= &quot;(1+(4+5+2)-3)+(6+8)&quot;</code></li><li>输出：23</li></ul></li></ul><p>解题思路一：括号展开+栈<br><img src="https://img-blog.csdnimg.cn/43defdacf53247a3ad02a608541c085a.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/76e0c83809bc4c488b042bd752eba049.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ops = [<span class="number">1</span>]</span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                sign = ops[-<span class="number">1</span>]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                sign = -ops[-<span class="number">1</span>]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                ops.append(sign)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                ops.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> s[i].isdigit():</span><br><span class="line">                    num = num * <span class="number">10</span> + <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                ret += num * sign</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>解题思路2：构造nums和ops两个栈，分别存放操作数和操作符，然后遍历表达式：</p><blockquote><p>参考<a href="https://leetcode.cn/problems/basic-calculator-ii/solution/shi-yong-shuang-zhan-jie-jue-jiu-ji-biao-c65k/">《使用「双栈」解决「究极表达式计算」问题》</a></p><ul><li>遇到空格，跳过</li><li>遇到数字，将连续数字直接在nums中入栈（负数乘以-1）</li><li>遇到右括号时，优先级最大，反复弹出ops和nums中的元素进行计算，直到遇到左括号，将结果存入nums中。</li><li>因为我们是从前往后做的，假设我们当前已经扫描到 2 + 1 了（此时栈内的操作为 + ）。</li><li>遇到操作符，在ops中入栈。在放入之前先把栈内可以算的都算掉（<strong>只有「栈内运算符」比「当前运算符」优先级高/同等，才进行运算</strong>），使用现有的 nums 和 ops 进行计算，直到没有操作或者遇到左括号，计算结果放到 nums<ul><li>以<code>2 + 1</code>为例，如果后面出现的 + 2 或者 - 1 的话，满足「栈内运算符」比「当前运算符」优先级高/同等，可以将 2 + 1 算掉，把结果放到 nums 中；</li><li>如果后面出现的是 * 2 或者 / 1 的话，不满足「栈内运算符」比「当前运算符」优先级高/同等，这时候不能计算 2 + 1。</li><li>由于第一个数可能是负数，为了减少边界判断。一个小技巧是先往 nums 添加一个 0</li><li>为防止 () 内出现的首个字符为运算符，将所有的空格去掉，并将 (- 替换为 (0-，(+ 替换为 (0+（当然也可以不进行这样的预处理，将这个处理逻辑放到循环里去做）</li></ul></li></ul></blockquote><h3 id="2-5-验证栈序列"><a href="#2-5-验证栈序列" class="headerlink" title="2.5 验证栈序列"></a>2.5 验证栈序列</h3><blockquote><p><a href="https://leetcode.cn/problems/validate-stack-sequences/">946 验证栈序列</a></p></blockquote><p>&#8195;&#8195;给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。</p><ul><li>示例 1：<ul><li>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</li><li>输出：true</li><li>解释：我们可以按以下顺序执行：<ul><li>push(1), push(2), push(3), push(4), pop() -&gt; 4,</li><li>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</li></ul></li></ul></li><li>示例 2：<ul><li>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</li><li>输出：false</li><li>解释：1 不能在 2 之前弹出。</li></ul></li></ul><p>使用分离双指针<code>i</code>和<code>j</code>，分别遍历<code>pushed</code> 和 <code>popped</code>两个数组。再用空栈存储每次操作的元素。</p><ul><li><code>pushed[i]</code>入栈，<code>i</code>右移</li><li>当<code>popped[j]</code>在栈中时，开始弹出，弹出前进行比较<ul><li><code>popped[j]</code>等于栈顶元素时，栈顶元素出栈，<code>j</code>右移</li><li>否则弹出次序不对，返回<code>False</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span>(<span class="params">self, pushed: <span class="type">List</span>[<span class="built_in">int</span>], popped: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n=<span class="built_in">len</span>(popped)</span><br><span class="line">        stack=[]</span><br><span class="line">        i,j=<span class="number">0</span>,<span class="number">0</span><span class="comment"># 分离双指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i&lt;n <span class="keyword">and</span> j&lt;n:</span><br><span class="line">            stack.append(pushed[i])</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> popped[j] <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="keyword">if</span> popped[j]==stack[-<span class="number">1</span>]:</span><br><span class="line">                    j+=<span class="number">1</span></span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>也可以写成：（<code>popped[j]</code>等于栈顶元素就出栈，遍历完看栈是否为空）</li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span>(<span class="params">self, pushed: <span class="type">List</span>[<span class="built_in">int</span>], popped: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n=<span class="built_in">len</span>(popped)</span><br><span class="line">        stack=[]</span><br><span class="line">        i,j=<span class="number">0</span>,<span class="number">0</span><span class="comment"># 分离双指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i&lt;n <span class="keyword">and</span> j&lt;n:</span><br><span class="line">            stack.append(pushed[i])</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> popped[j]==stack[-<span class="number">1</span>]:</span><br><span class="line">                    j+=<span class="number">1</span></span><br><span class="line">                    stack.pop()                </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack)==<span class="number">0</span>             </span><br></pre></td></tr></table></figure><h2 id="三、单调栈"><a href="#三、单调栈" class="headerlink" title="三、单调栈"></a>三、单调栈</h2><ul><li><p><strong>单调栈（Monotone Stack）</strong>：一种特殊的栈。在栈的「先进后出」规则基础上，要求「从 <strong>栈顶</strong> 到 <strong>栈底</strong> 的元素是单调递增（或者单调递减）」。</p></li><li><p><strong>单调递增栈</strong>：从栈顶到栈底的元素是单调递增的栈</p></li><li><strong>单调递减栈</strong>：从栈顶到栈底的元素是单调递减的栈</li></ul><blockquote><p>注意：这里定义的顺序是从「栈顶」到「栈底」。有的文章里是反过来的。本文全文以「栈顶」到「栈底」的顺序为基准来描述单调栈。</p></blockquote><h3 id="3-1-单调递增栈"><a href="#3-1-单调递增栈" class="headerlink" title="3.1 单调递增栈"></a>3.1 单调递增栈</h3><p>&#8195;&#8195;只有比栈顶元素小的元素才能直接进栈，否则需要先将栈中比当前元素小的元素出栈，再将当前元素入栈。 下面我们以数组 <code>[2, 7, 5, 4, 6, 3, 4, 2]</code> 为例，从左到右遍历，模拟一下「单调递增栈」的进栈、出栈过程：</p><div class="table-container"><table><thead><tr><th style="text-align:center">第 i 步</th><th style="text-align:center">待插入元素</th><th>操 作</th><th>结 果（左侧为栈底）</th><th>作 用</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td>2 入栈</td><td>[2]</td><td>元素 2 的左侧无比 2 大的元素</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">7</td><td>2 出栈，7 入栈</td><td>[7]</td><td>元素 7 的左侧无比 7 大的元素</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">5</td><td>5 入栈</td><td>[7, 5]</td><td>元素 5 的左侧第一个比 5 大的元素为：7</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">4</td><td>4 入栈</td><td>[7, 5, 4]</td><td>元素 4 的左侧第一个比 4 大的元素为：5</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">6</td><td>4 出栈，5 出栈，6 入栈</td><td>[7, 6]</td><td>元素 6 的左侧第一个比 6 大的元素为：7</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">3</td><td>3 入栈</td><td>[7, 6, 3]</td><td>元素 3 的左侧第一个比 3 大的元素为：6</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">4</td><td>3 出栈，4 入栈</td><td>[7, 6, 4]</td><td>元素 4 的左侧第一个比 4 大的元素为：6</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">2</td><td>2 入栈</td><td>[7, 6, 4, 2]</td><td>元素 2 的左侧第一个比 2 大的元素为：4</td></tr></tbody></table></div><p>&#8195;&#8195;最终栈中元素为 <code>[7, 6, 4, 2]</code>。因为从栈顶（右端）到栈底（左侧）元素的顺序为 <code>2, 4, 6, 7</code>，满足递增关系，所以这是一个单调递增栈。</p><p>&#8195;&#8195;我们以上述过程第 5 步为例，所对应的图示过程为：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/abb6ae403797803c5b1c49bcda3235ef.png" alt=""><br>以从左到右遍历元素为例，单调递增栈伪代码为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">monotoneIncreasingStack</span>(<span class="params">nums</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> num &gt;= stack[-<span class="number">1</span>]:</span><br><span class="line">            stack.pop()</span><br><span class="line">        stack.append(num)</span><br></pre></td></tr></table></figure></p><h3 id="3-2-单调递减栈"><a href="#3-2-单调递减栈" class="headerlink" title="3.2 单调递减栈"></a>3.2 单调递减栈</h3><p>&#8195;&#8195;只有比栈顶元素大的元素才能直接进栈，否则需要先将栈中比当前元素大的元素出栈，再将当前元素入栈。下面我们以数组 <code>[4, 3, 2, 5, 7, 4, 6, 8]</code> 为例，模拟一下「单调递减栈」的进栈、出栈过程：</p><div class="table-container"><table><thead><tr><th style="text-align:center">第 i 步</th><th style="text-align:center">待插入元素</th><th>操 作</th><th>结 果（左侧为栈底）</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">4</td><td>4 入栈</td><td>[4]</td><td>元素 4 的左侧无比 4 小的元素</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td><td>4 出栈，3 入栈</td><td>[3]</td><td>元素 3 的左侧无比 3 小的元素</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">2</td><td>3 出栈，2 入栈</td><td>[2]</td><td>元素 2 的左侧无比 2 小的元素</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">5</td><td>5 入栈</td><td>[2, 5]</td><td>元素 5 的左侧第一个比 5 小的元素是：2</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">7</td><td>7 入栈</td><td>[2, 5, 7]</td><td>元素 7 的左侧第一个比 7 小的元素是：5</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">4</td><td>7 出栈，5 出栈，4 入栈</td><td>[2, 4]</td><td>元素 4 的左侧第一个比 4 小的元素是：2</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">6</td><td>6 入栈</td><td>[2, 4, 6]</td><td>元素 6 的左侧第一个比 6 小的元素是：4</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">8</td><td>8 入栈</td><td>[2, 4, 6, 8]</td><td>元素 8 的左侧第一个比 8 小的元素是：6</td></tr></tbody></table></div><p>&#8195;&#8195;最终栈中元素为 <code>[2, 4, 6, 8]</code>。因为从栈顶（右端）到栈底（左侧）元素的顺序为 <code>8, 6, 4, 2</code>，满足递减关系，所以这是一个单调递减栈。</p><p>&#8195;&#8195;我们以上述过程第 6 步为例，所对应的图示过程为： </p><p><img src="https://img-blog.csdnimg.cn/img_convert/a7c7cc8f491a3b62f72bfa4c9eaa228f.png" alt=""><br>以从左到右遍历元素为例，单调递减栈伪代码为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">monotoneDecreasingStack</span>(<span class="params">nums</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> num &lt;= stack[-<span class="number">1</span>]:</span><br><span class="line">            stack.pop()</span><br><span class="line">        stack.append(num)</span><br></pre></td></tr></table></figure></p><h3 id="3-3-单调栈适用场景"><a href="#3-3-单调栈适用场景" class="headerlink" title="3.3 单调栈适用场景"></a>3.3 单调栈适用场景</h3><p>单调栈可以在时间复杂度为 $O(n)$ 的情况下，求解出某个元素左边或者右边第一个比它大或者小的元素。</p><p>所以单调栈一般用于解决一下几种问题：</p><ul><li>寻找左侧第一个比当前元素大的元素。</li><li>寻找左侧第一个比当前元素小的元素。</li><li>寻找右侧第一个比当前元素大的元素。</li><li>寻找右侧第一个比当前元素小的元素。</li></ul><p>下面分别说一下这几种问题的求解方法。</p><h4 id="3-3-1-寻找左侧第一个比当前元素大的元素"><a href="#3-3-1-寻找左侧第一个比当前元素大的元素" class="headerlink" title="3.3.1 寻找左侧第一个比当前元素大的元素"></a>3.3.1 寻找左侧第一个比当前元素大的元素</h4><ul><li>从左到右遍历元素，构造单调递增栈（从栈顶到栈底递增）：<ul><li>一个元素左侧第一个比它大的元素就是将其「插入单调递增栈」时的栈顶元素。</li><li>如果插入时的栈为空，则说明左侧不存在比当前元素大的元素。</li></ul></li></ul><h4 id="3-3-2-寻找左侧第一个比当前元素小的元素"><a href="#3-3-2-寻找左侧第一个比当前元素小的元素" class="headerlink" title="3.3.2 寻找左侧第一个比当前元素小的元素"></a>3.3.2 寻找左侧第一个比当前元素小的元素</h4><ul><li>从左到右遍历元素，构造单调递减栈（从栈顶到栈底递减）：<ul><li>一个元素左侧第一个比它小的元素就是将其「插入单调递减栈」时的栈顶元素。</li><li>如果插入时的栈为空，则说明左侧不存在比当前元素小的元素。</li></ul></li></ul><h4 id="3-3-3-寻找右侧第一个比当前元素大的元素"><a href="#3-3-3-寻找右侧第一个比当前元素大的元素" class="headerlink" title="3.3.3 寻找右侧第一个比当前元素大的元素"></a>3.3.3 寻找右侧第一个比当前元素大的元素</h4><ul><li><p>从左到右遍历元素，构造单调递增栈（从栈顶到栈底递增）：</p><ul><li>一个元素右侧第一个比它大的元素就是将其「弹出单调递增栈」时即将插入的元素。</li><li>如果该元素没有被弹出栈，则说明右侧不存在比当前元素大的元素。</li></ul></li><li><p>从右到左遍历元素，构造单调递增栈（从栈顶到栈底递增）：</p><ul><li>一个元素右侧第一个比它大的元素就是将其「插入单调递增栈」时的栈顶元素。</li><li>如果插入时的栈为空，则说明右侧不存在比当前元素大的元素。</li></ul></li></ul><h4 id="3-3-4-寻找右侧第一个比当前元素小的元素"><a href="#3-3-4-寻找右侧第一个比当前元素小的元素" class="headerlink" title="3.3.4 寻找右侧第一个比当前元素小的元素"></a>3.3.4 寻找右侧第一个比当前元素小的元素</h4><ul><li><p>从左到右遍历元素，构造单调递减栈（从栈顶到栈底递减）：</p><ul><li>一个元素右侧第一个比它小的元素就是将其「弹出单调递减栈」时即将插入的元素。</li><li>如果该元素没有被弹出栈，则说明右侧不存在比当前元素小的元素。</li></ul></li><li><p>从右到左遍历元素，构造单调递减栈（从栈顶到栈底递减）：</p><ul><li>一个元素右侧第一个比它小的元素就是将其「插入单调递减栈」时的栈顶元素。</li><li>如果插入时的栈为空，则说明右侧不存在比当前元素小的元素。</li></ul></li></ul><p>上边的分类解法有点绕口，可以简单记为以下条规则：</p><ul><li><p>无论哪种题型，都建议从左到右遍历元素。</p></li><li><p>查找 <strong>「比当前元素大的元素」</strong> 就用 <strong>单调递增栈</strong>，查找 <strong>「比当前元素小的元素」</strong> 就用 <strong>单调递减栈</strong>。</p></li><li>从 <strong>「左侧」</strong> 查找就看 <strong>「插入栈」</strong> 时的栈顶元素，从 <strong>「右侧」</strong> 查找就看 <strong>「弹出栈」</strong> 时即将插入的元素。</li></ul><h2 id="四、-单调栈的应用"><a href="#四、-单调栈的应用" class="headerlink" title="四、 单调栈的应用"></a>四、 单调栈的应用</h2><h3 id="4-1-单调栈题目列表"><a href="#4-1-单调栈题目列表" class="headerlink" title="4.1 单调栈题目列表"></a>4.1 单调栈题目列表</h3><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0739</td><td style="text-align:left"><a href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0739.%20%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.md">Python</a></td><td style="text-align:left">栈、哈希表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0496</td><td style="text-align:left"><a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素 I</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0496.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I.md">Python</a></td><td style="text-align:left">栈、数组、哈希表、单调栈</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0503</td><td style="text-align:left"><a href="https://leetcode.cn/problems/next-greater-element-ii/">下一个更大元素 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0503.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20II.md">Python</a></td><td style="text-align:left">栈、数组、单调栈</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0901</td><td style="text-align:left"><a href="https://leetcode.cn/problems/online-stock-span/">股票价格跨度</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0901.%20%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6.md">Python</a></td><td style="text-align:left">栈、设计、数据流、单调栈</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0084</td><td style="text-align:left"><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0084.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.md">Python</a></td><td style="text-align:left">栈、数组、单调栈</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0316</td><td style="text-align:left"><a href="https://leetcode.cn/problems/remove-duplicate-letters/">去除重复字母</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0316.%20%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D.md">Python</a></td><td style="text-align:left">栈、贪心、字符串、单调栈</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">1081</td><td style="text-align:left"><a href="https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/">不同字符的最小子序列</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/1081.%20%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97.md">Python</a></td><td style="text-align:left">栈、贪心、字符串、单调栈</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0042</td><td style="text-align:left"><a href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0042.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4.md">Python</a></td><td style="text-align:left">栈、数组、双指针、动态规划、单调栈</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0085</td><td style="text-align:left">最大矩形</td><td style="text-align:left"></td><td style="text-align:left">单调栈</td><td style="text-align:left">困难</td></tr></tbody></table></div><p>下面介绍一下经典题目</p><h3 id="4-2-下一个更大元素-I-amp-II"><a href="#4-2-下一个更大元素-I-amp-II" class="headerlink" title="4.2 下一个更大元素 I &amp; II"></a>4.2 下一个更大元素 I &amp; II</h3><blockquote><ul><li><a href="https://leetcode.cn/problems/next-greater-element-i/">0496. 下一个更大元素 I</a></li><li><a href="https://leetcode.cn/problems/next-greater-element-ii/">0503. 下一个更大元素 II</a></li></ul></blockquote><p>&#8195;&#8195;给定两个没有重复元素的数组 <code>nums1</code> 和 <code>nums2</code> ，其中 <code>nums1</code> 是 <code>nums2</code> 的子集。要求找出 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值，如果不存在，对应位置输出 <code>-1</code>。<br><strong>示例</strong> ：</p><ul><li>输入：nums1 = [4,1,2], nums2 = [1,3,4,2].</li><li>输出：[-1,3,-1]</li><li>解释：nums1 中每个值的下一个更大元素如下所述：<ul><li>4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</li><li>1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。</li><li>2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</li></ul></li></ul><p><strong>解题思路</strong></p><ol><li><p>暴力求解：<br>根据题意直接暴力求解。遍历 <code>nums1</code> 中的每一个元素。对于 <code>nums1</code> 的每一个元素 <code>nums1[i]</code>，再遍历一遍 <code>nums2</code>，查找 <code>nums2</code> 中对应位置右边第一个比 <code>nums1[i]</code> 大的元素。这种解法的时间复杂度是 $O(n^2)$。</p></li><li><p>使用单调递增栈。因为 <code>nums1</code> 是 <code>nums2</code> 的子集，所以我们可以先遍历一遍 <code>nums2</code>，并构造单调递增栈，求出 <code>nums2</code> 中每个元素右侧下一个更大的元素。然后将其存储到哈希表中。然后再遍历一遍 <code>nums1</code>，从哈希表中取出对应结果，存放到答案数组中。这种解法的时间复杂度是 $O(n)$。</p></li></ol><p><strong>解题步骤</strong></p><ul><li>使用数组 <code>ans</code> 存放答案。使用 <code>stack</code> 表示单调递增栈。使用哈希表 <code>d</code> 用于存储 <code>nums2</code> 中下一个比当前元素大的数值，映射关系为 <code>当前元素值：下一个比当前元素大的数值</code>。</li><li><p>遍历数组 <code>nums2</code>，对于当前元素：</p><ul><li>如果当前元素值较小，则直接让当前元素值入栈。</li><li>如果当前元素值较大，则一直出栈，直到当前元素值小于栈顶元素。<ul><li>出栈时，出栈元素是第一个大于当前元素值的元素。则将其映射到 <code>d</code> 中。</li></ul></li></ul></li><li><p>遍历完数组 <code>nums2</code>，建立好所有元素下一个更大元素的映射关系之后，再遍历数组 <code>nums1</code>。</p></li><li>从 <code>d</code> 中取出对应的值，将其加入到答案数组中，最终输出答案数组 <code>ans</code>。</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        stack=[]</span><br><span class="line">        d=<span class="built_in">dict</span>()</span><br><span class="line">        ans=[]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> i&gt;stack[-<span class="number">1</span>]:                </span><br><span class="line">                d[stack[-<span class="number">1</span>]]=i</span><br><span class="line">                stack.pop()</span><br><span class="line">            stack.append(i)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> nums1:</span><br><span class="line">            ans.append(d.get(j,-<span class="number">1</span>))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;类似的题目还有下一个更大元素 I I，唯一不同的是数组是循环的。简单做法是将nums循环一次，即nums=nums+nums，再求解后，取结果的前m个数值作为答案：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        m=<span class="built_in">len</span>(nums)</span><br><span class="line">        nums=nums+nums        </span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        stack=[]</span><br><span class="line">        ans=[-<span class="number">1</span>]*n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums[i]&gt;nums[stack[-<span class="number">1</span>]]:</span><br><span class="line">                index=stack.pop()</span><br><span class="line">                ans[index]=nums[i]</span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans[:m]</span><br></pre></td></tr></table></figure><p>上面代码中 <code>index=stack.pop()</code>等同于</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index=stack[-<span class="number">1</span>]  </span><br><span class="line">stack.pop() </span><br></pre></td></tr></table></figure><h3 id="4-3-每日温度"><a href="#4-3-每日温度" class="headerlink" title="4.3 每日温度"></a>4.3 每日温度</h3><blockquote><p><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度 - 力扣（LeetCode）</a></p></blockquote><p>&#8195;&#8195;给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><ul><li>$1 \le temperatures.length \le 10^5$。</li><li>$30 \le temperatures[i] \le 100$。</li></ul><p><strong>示例</strong>：</p><ul><li>输入: temperatures = [73,74,75,71,69,72,76,73]</li><li>输出: [1,1,4,2,1,1,0,0]</li></ul><p><strong>解题思路</strong></p><p>&#8195;&#8195;本题就是寻找每个元素右侧第一个更大的元素，然后返回「该元素」与「右侧第一个比当前元素更大的元素」之间的距离，将所有距离保存为数组返回结果。考虑使用「单调递增栈」，栈中保存元素的下标。</p><p><strong>详细步骤</strong></p><ol><li>将答案数组 <code>ans</code> 全部赋值为 0。然后遍历数组每个位置元素。</li><li>如果栈为空，则将当前元素的下标入栈。</li><li>如果栈不为空，且当前数字大于栈顶元素对应数字，则栈顶元素出栈，并计算下标差。</li><li>此时当前元素就是栈顶元素的下一个更高值，将其下标差存入答案数组 <code>ans</code> 中保存起来，判断栈顶元素。</li><li>直到当前数字小于或等于栈顶元素，则停止出栈，将当前元素下标入栈。</li><li>最后输出答案数组 <code>ans</code>。</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        stack=[]</span><br><span class="line">        n=<span class="built_in">len</span>(temperatures)</span><br><span class="line">        ans=[<span class="number">0</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temperatures[i]&gt;temperatures[stack[-<span class="number">1</span>]]:</span><br><span class="line">                index=stack.pop()</span><br><span class="line">                ans[index]=i-index</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="4-4-股票价格跨度"><a href="#4-4-股票价格跨度" class="headerlink" title="4.4 股票价格跨度"></a>4.4 股票价格跨度</h3><blockquote><p><a href="https://leetcode.cn/problems/online-stock-span/">0901. 股票价格跨度</a></p></blockquote><p>&#8195;&#8195;设计一个算法收集某些股票的每日报价，并返回该股票当日价格的跨度 。当日股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。<br>&#8195;&#8195;实现 StockSpanner 类：</p><ul><li><code>StockSpanner()</code> ：初始化类对象。</li><li><code>int next(int price)</code> ：给出今天的股价 <code>price</code> ，返回该股票当日价格的 跨度 。</li></ul><p><strong>示例</strong></p><ul><li>输入： [100,80,60,70,60,75,85]</li><li>输出：那么股票跨度将是 [1,1,1,2,1,4,6] 。</li></ul><p><strong>解题思路</strong></p><p>「求解小于或等于今天价格的最大连续日」等价于「求出左侧第一个比当前股票价格大的股票，并计算距离」。求出左侧第一个比当前股票价格大的股票我们可以使用「单调递减栈」来做。</p><p><strong>详细步骤</strong></p><ul><li><p>初始化方法：初始化一个空栈，即 <code>self.stack = []</code></p></li><li><p>求解今天股票价格的跨度：</p><ul><li>初始化跨度 <code>span</code> 为 <code>1</code>。</li><li>如果今日股票价格 <code>price</code> 大于等于栈顶元素 <code>self.stack[-1][0]</code>，则：<ul><li>将其弹出，即 <code>top = self.stack.pop()</code>。</li><li>跨度累加上弹出栈顶元素的跨度，即 <code>span += top[1]</code>。</li><li>继续判断，直到遇到一个今日股票价格 <code>price</code> 小于栈顶元素的元素位置，再将 <code>[price, span]</code> 压入栈中。</li></ul></li><li><p>如果今日股票价格 <code>price</code> 小于栈顶元素 <code>self.stack[-1][0]</code>，则直接将 <code>[price, span]</code> 压入栈中。</p></li><li><p>最后输出今天股票价格的跨度 <code>span</code>。    </p></li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self, price: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        span = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> self.stack <span class="keyword">and</span> price &gt;= self.stack[-<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">            top = self.stack.pop()</span><br><span class="line">            span += top[<span class="number">1</span>]</span><br><span class="line">        self.stack.append([price, span])</span><br><span class="line">        <span class="keyword">return</span> span</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;也可以将遍历时每个元素的下标 <code>self.cur</code>存入栈中，然后计算入栈时，当前元素下标和入栈前栈顶元素的下标差就行：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment">#单调递增插入栈。左侧第一个更大的元素就是插入元素时的栈顶元素</span></span><br><span class="line">        self.stack = [(inf,-<span class="number">1</span>)]</span><br><span class="line">        self.cur=-<span class="number">1</span> <span class="comment"># 遍历时的当前元素下标，赋值为-1，第一次遍历时下标=0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self, price: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.cur+=<span class="number">1</span> <span class="comment"># 第一个元素下标为0</span></span><br><span class="line">                                </span><br><span class="line">        <span class="keyword">while</span> self.stack <span class="keyword">and</span> price&gt;=self.stack[-<span class="number">1</span>][<span class="number">0</span>]: </span><br><span class="line">            self.stack.pop()             </span><br><span class="line">        self.stack.append([price,self.cur])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当前元素已入栈，所以其插入前的栈顶元素是stack[-2]</span></span><br><span class="line">        <span class="keyword">return</span> self.cur-self.stack[-<span class="number">2</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="4-5-去除重复字母"><a href="#4-5-去除重复字母" class="headerlink" title="4.5 去除重复字母"></a>4.5 去除重复字母</h3><blockquote><p><a href="https://leetcode.cn/problems/remove-duplicate-letters/">0316. 去除重复字母</a>    ，这道题和<a href="https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/">1081. 不同字符的最小子序列</a>是一样的。</p></blockquote><p>&#8195;&#8195;给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p><p>示例：</p><ul><li>输入：s = “cbacdcbc”</li><li>输出：”acdb”</li></ul><p><strong>解题思路</strong></p><ol><li><strong>去重</strong>：可以通过 <strong>「使用哈希表存储字母出现次数」</strong> 的方式，将每个字母出现的次数统计起来，再遍历一遍，去除重复的字母。</li><li><strong>不能打乱其他字符顺序</strong>：按顺序遍历，将非重复的字母存储到答案数组或者栈中，最后再拼接起来，就能保证不打乱其他字符顺序。</li><li><strong>字典序最小</strong>：意味着字典序小的字母应该尽可能放在前面。<ol><li>对于第 <code>i</code> 个字符 <code>s[i]</code> 而言，如果第 <code>0</code> ~ <code>i - 1</code> 之间的某个字符 <code>s[j]</code> 在 <code>s[i]</code> 之后不再出现了，那么 <code>s[j]</code> 必须放到 <code>s[i]</code> 之前。</li><li>而如果 <code>s[j]</code> 在之后还会出现，并且 <code>s[j]</code> 的字典序大于 <code>s[i]</code>，我们则可以先舍弃 <code>s[j]</code>，把 <code>s[i]</code> 尽可能的放到前面。后边再考虑使用 <code>s[j]</code> 所对应的字符。</li></ol></li></ol><p>要满足第 3 条需求，我们可以使用 <strong>「单调递减栈」</strong> 来解决，即使用单调栈存储 <code>s[i]</code> 之前出现的非重复、并且字典序最小的字符序列。整个算法步骤如下：</p><ol><li>先遍历一遍字符串，用哈希表 <code>d</code> 统计出每个字母出现的次数。</li><li>然后使用单调递减栈保存当前字符之前出现的非重复、并且字典序最小的字符序列。</li><li>当遍历到 <code>s[i]</code> 时，如果 <code>s[i]</code> 没有在栈中出现过：<ol><li>比较 <code>s[i]</code> 和栈顶元素 <code>stack[-1]</code> 的字典序。如果 <code>s[i]</code> 的字典序小于栈顶元素 <code>stack[-1]</code>，并且栈顶元素次数 <code>&gt;1</code>，则将栈顶元素弹出，并从哈希表 <code>d</code> 中减去栈顶元素出现的次数，继续遍历。</li><li>直到栈顶元素出现次数为 <code>1</code> 时停止弹出。此时将 <code>s[i]</code> 添加到单调栈中。</li></ol></li><li>如果 遍历时，<code>s[i]</code> 在栈中出现过，就将其次数-1，因为我们只在<code>s[i]</code> 首次遍历时将其入栈，后续重复时不入栈，其统计次数应该-1。</li><li>最后将单调栈中的字符依次拼接为答案字符串，并返回。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        d=<span class="built_in">dict</span>(Counter(s))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用单调递减栈保证字典序最小</span></span><br><span class="line">        <span class="comment"># 如果遍历的当前元素小于栈顶元素，当其次数大于1时，将栈顶弹出，对应次数-1。直至=0时不再弹出</span></span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> ch&lt;stack[-<span class="number">1</span>] <span class="keyword">and</span> d[stack[-<span class="number">1</span>]]&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 注意，这里是先统计次数，再执行pop操作，并且是ch&lt;=stack[-1]</span></span><br><span class="line">                    d[stack[-<span class="number">1</span>]]-=<span class="number">1</span></span><br><span class="line">                    stack.pop()                     </span><br><span class="line">                stack.append(ch)</span><br><span class="line">            <span class="comment"># 如果ch已经在栈中，将其次数-1，等同于之前的相同元素会出栈，当前重复元素入栈。</span></span><br><span class="line">            <span class="comment"># 否则[bbcaac]这种会出错。</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                d[ch]-=<span class="number">1</span></span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-6-柱状图中最大的矩形"><a href="#4-6-柱状图中最大的矩形" class="headerlink" title="4.6 柱状图中最大的矩形"></a>4.6 柱状图中最大的矩形</h3><blockquote><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">0084. 柱状图中最大的矩形</a></p></blockquote><p>&#8195;&#8195;给定一个非负整数数组 <code>heights</code> ，<code>heights[i]</code> 用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。要求计算出在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例</strong></p><ul><li>输入：heights = [2,1,5,6,2,3]</li><li>输出：10</li><li>解释：最大的矩形为图中红色区域，面积为 10<br><img src="https://img-blog.csdnimg.cn/5374cad9e594404f97e4c44f65eb09a5.png" alt="在这里插入图片描述"></li></ul><p><strong>解题思路</strong></p><ol><li><p>暴力枚举「宽度」：<br>一重循环枚举所有柱子，第二重循环遍历柱子右侧的柱子，所得的宽度就是两根柱子形成区间的宽度，高度就是这段区间中的最小高度。然后计算出对应面积，记录并更新最大面积。这样下来，时间复杂度为 $O(n^2)$。</p></li><li><p>暴力枚举枚举「高度」。一重循环枚举所有柱子，以柱子高度为当前矩形高度，然后向两侧延伸，遇到小于当前矩形高度的情况就停止。然后计算当前矩形面积，记录并更新最大面积。这样下来，时间复杂度也是 $O(n^2)$。</p></li><li><p>单调栈遍历，求左右边界</p><ul><li>当前柱子<code>heights[i]</code>所能延伸到的最大面积<code>S[i]</code>，其实就是左右两侧高度不小于<code>heights[i]</code>的最远柱子之间的面积。也就是说，柱子<code>i</code>往左右延伸，直到碰到的柱子高度<code>&lt;heights[i]</code>时停止。所以本题关键是求数组<code>heights</code>中，每个元素左侧最近的更小值和右侧最近的更小值，考虑使用单调递减栈求解。</li><li>注意，面积延伸时，碰到更小的高度才停止，所以使用严格单调递减栈，遍历的元素严格大于栈顶元素才入栈，小于等于栈顶元素时，栈顶弹出。所以判断条件是<code>heights[i]&lt;=heights[stack[-1]]</code>，有等号。</li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        stack=[]</span><br><span class="line">        n=<span class="built_in">len</span>(heights)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 寻找左侧更小值，使用单调递减插入栈，栈中只存入栈元素的下标。</span></span><br><span class="line">        <span class="comment"># 当前元素≤栈顶元素时，栈顶弹出。</span></span><br><span class="line">        <span class="comment"># 直到当前元素入栈，此时栈顶元素就是当前元素的左侧第一个更小值。</span></span><br><span class="line">        <span class="comment"># 如果碰到空栈，说明左侧没有更小的元素，将其下标记为-1（哨兵，表示往左可以延伸到数组开头）</span></span><br><span class="line">        left=[-<span class="number">1</span>]*n        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i]&lt;=heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()               </span><br><span class="line">            left[i]=stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># print(left)</span></span><br><span class="line">        </span><br><span class="line">        right=[n]*n</span><br><span class="line">        stack=[] <span class="comment"># 没有重新设置stack初始化，坑</span></span><br><span class="line">        <span class="comment"># 寻找右侧更小值，使用单调递减弹出栈</span></span><br><span class="line">        <span class="comment"># 当前元素≤栈顶元素时，将栈顶弹出。此时，弹出前的栈顶元素的右侧第一个更小值就是当前元素</span></span><br><span class="line">        <span class="comment"># 如果为空栈，说明右侧没有更小元素，将其下标记为n（也就是往右遍历到数组结尾）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i]&lt;=heights[stack[-<span class="number">1</span>]]:               </span><br><span class="line">                right[stack[-<span class="number">1</span>]]=i <span class="keyword">if</span> stack <span class="keyword">else</span> n</span><br><span class="line">                stack.pop()               </span><br><span class="line">                </span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="comment"># print(right)                                           </span></span><br><span class="line">        </span><br><span class="line">        ans = [(right[i]-left[i]-<span class="number">1</span>) * heights[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans)</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;上面的代码中，我们用插入栈得到左侧更小的元素，使用弹出栈得到右侧更小的元素，但都使用了单调递减栈，判断条件也相同，所以其实可以一次遍历得到左右边界，优化后代码为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        stack=[]</span><br><span class="line">        n=<span class="built_in">len</span>(heights)</span><br><span class="line">        left=[-<span class="number">1</span>]*n </span><br><span class="line">        right=[n]*n  </span><br><span class="line">             </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i]&lt;=heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                right[stack[-<span class="number">1</span>]]=i </span><br><span class="line">                stack.pop()               </span><br><span class="line">            left[i]=stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">                                                      </span><br><span class="line">        ans = [(right[i]-left[i]-<span class="number">1</span>) * heights[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans)</span><br></pre></td></tr></table></figure><h3 id="4-7-接雨水"><a href="#4-7-接雨水" class="headerlink" title="4.7 接雨水"></a>4.7 接雨水</h3><blockquote><p><a href="https://leetcode.cn/problems/trapping-rain-water/">0042. 接雨水</a></p></blockquote><p>给定n个非负整数组成的数组 height ，其表示表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><ul><li>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</li><li>输出：6</li><li>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</li></ul><p><img src="https://img-blog.csdnimg.cn/31ea57f2e59c48ccb782068675cf0c3e.png" alt="在这里插入图片描述"></p><ul><li>$n == height.length$。</li><li>$1 \le n \le 2 * 10^4$。</li><li>$0 \le height[i] \le 10^5$。</li></ul><p><strong>解题思路</strong>    </p><ol><li><p>求出蓄水边界</p><ul><li>最明显的，某个柱子左右有更高的柱子时，这个柱子上才可以接雨水 ，这样需要首先求出数组中每个元素左侧和右侧最近的更高柱子，即蓄水的左右边界。</li><li>所以考虑使用单调递增栈求出左右边界的下标。比如<code>height = [0,1,0,2,1,0,1,3,2,1,2,1]</code>时，左边界<code>left=[-1, -1, 1, -1, 3, 4, 3, -1, 7, 8, 7, 10]</code>，右边界<code>right=[1, 3, 3, 7, 7, 6, 7, 12, 12, 10, 12, 12]</code></li><li>寻找左右边界时，因为是寻找两侧严格大的柱子，判断条件不一样，没办法一次遍历出来（可以自行测试）。</li></ul></li><li><p>求出蓄水面积</p><ul><li>蓄水宽度=左右边界下标差，蓄水高度=min（左右边界高度）- 当前柱子高度。这样可以算出每个柱子可以接的雨水。</li><li>还是以上面例子为例，此时得到的结果ans（柱子下标i，接水面积area）=<code>[(2,1),(4,3),(5,1),(6,3),(9,1)]</code>。可见计算的结果都是对的，唯一错误是下标4和6的这两个柱子，蓄水面积都计算了一次。观察可以发现，这两个柱子的左右边界完全相同，其结果只需要计算一次</li><li>考虑使用字典<code>d</code>，存储每个柱子的边界。对于相同的边界，蓄水面积只计算一次。</li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment">#寻找左边界</span></span><br><span class="line"></span><br><span class="line">        n=<span class="built_in">len</span>(height)</span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="comment"># 构造单调递增栈，更小的元素才入栈。例如[8,3,3,7.7,9]，当第一个3入栈时，7才是右侧更大的元素，所以是当前元素严格大于栈顶元素才入栈</span></span><br><span class="line">        left,right=[-<span class="number">1</span>]*n,[n]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[i]&gt;height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                right[stack[-<span class="number">1</span>]]=i </span><br><span class="line">                stack.pop()         </span><br><span class="line">            <span class="comment">#left[i]=stack[-1] if stack else -1</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        </span><br><span class="line">        stack=[]    </span><br><span class="line">        <span class="comment"># 构造单调递增栈，更小的元素才入栈。例如[8,3,3]，当第二个3入栈时，8才是左侧更大的元素</span></span><br><span class="line">        <span class="comment"># 所以判断条件中有等号，相同元素也要弹出。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[i]&gt;=height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            left[i]=stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;left:&quot;</span>,left)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;right:&quot;</span>,right)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果碰到左右边界完全一样，只计算一次</span></span><br><span class="line">        ans=[]</span><br><span class="line">        d=<span class="built_in">dict</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 遍历每个元素的左右边界</span></span><br><span class="line">            l,r=left[i],right[i]</span><br><span class="line">            <span class="keyword">if</span> l!=-<span class="number">1</span> <span class="keyword">and</span> r!=n:                              </span><br><span class="line">                <span class="keyword">if</span> (l,r) <span class="keyword">not</span> <span class="keyword">in</span> d: <span class="comment"># 相同边界的柱子蓄水量只计算一次</span></span><br><span class="line">                    area=(<span class="built_in">min</span>(height[l],height[r])-height[i])*(right[i]-left[i]-<span class="number">1</span>)</span><br><span class="line">                    ans.append(area)</span><br><span class="line">                    <span class="comment">#print(i,area)</span></span><br><span class="line">                d[(l,r)]=i</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(ans)</span><br></pre></td></tr></table></figure><p><strong>优化一：一次遍历出左右边界</strong><br>&#8195;&#8195;上面代码可以优化，其实无论是<code>height[i]&gt;=height[stack[-1]]</code>还是<code>height[i]&gt;height[stack[-1]]</code>，只用一个判断条件得到的结果，有一个边界是不完全准确的，但是不影响最终结果。比如：</p><ul><li><code>height[i]&gt;height[stack[-1]]</code>时，左边界不准，为<code>left= [-1, -1, 1, -1, 3, 4, 4(3), -1, 7, 8, 8(7), 10]</code>，右边界是准的，<code>right= [1, 3, 3, 7, 7, 6, 7, 12, 12, 10, 12, 12]</code>。</li><li>上面第6个柱子左边界应该是3，这里判断是4。结果就是计算时，左边界4和柱子6的高度一样，area=0。所以，虽然不是严格的左边界，但是不影响最终结果。以上面数组为例，<code>area=[(2,1),(4,3),(5,1),(6,0),(9,1)]</code></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment">#寻找左右边界</span></span><br><span class="line">        n=<span class="built_in">len</span>(height)</span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="comment"># 构造单调递增栈，更小的元素才入栈。例如[8,3,3,7.7,9]，当第一个3入栈时，7才是右侧更大的元素，所以是当前元素严格大于栈顶元素才入栈</span></span><br><span class="line">        <span class="comment"># 例如[8,3,3]，当第二个3入栈时，8才是左侧更大的元素</span></span><br><span class="line">        left,right=[-<span class="number">1</span>]*n,[n]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[i]&gt;height[stack[-<span class="number">1</span>]]: <span class="comment"># 这里可以是≥</span></span><br><span class="line">                right[stack[-<span class="number">1</span>]]=i </span><br><span class="line">                stack.pop()         </span><br><span class="line">            left[i]=stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(&quot;left:&quot;,left)</span></span><br><span class="line">        <span class="comment"># print(&quot;right:&quot;,right)</span></span><br><span class="line"></span><br><span class="line">        ans=[]        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 遍历每个元素的左右边界</span></span><br><span class="line">            l,r=left[i],right[i]</span><br><span class="line">            <span class="keyword">if</span> l!=-<span class="number">1</span> <span class="keyword">and</span> r!=n:                              </span><br><span class="line">                area=(<span class="built_in">min</span>(height[l],height[r])-height[i])*(right[i]-left[i]-<span class="number">1</span>)</span><br><span class="line">                ans.append(area)</span><br><span class="line">                <span class="comment"># print(i,area)</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(ans)</span><br></pre></td></tr></table></figure><p><strong>优化二：在一次遍历中求左右边界，并同时求出蓄水面积</strong><br>&#8195;&#8195;这里需要将判断条件左右边界不为数组头尾（<code>if l!=-1 and r!=n:</code>  ） ，改为<code>if stack</code>，因为只有遇到空栈，才说明左右侧没有更高的柱子。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        size = <span class="built_in">len</span>(height)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        <span class="comment"># 这里写成height[i] &gt;= height[stack[-1]]也是没有问题的</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[i] &gt; height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                cur = stack.pop(-<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 当前元素被弹出时，其上一个元素是左侧更大值，将要入栈的是右侧更大值</span></span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    left = stack[-<span class="number">1</span>] </span><br><span class="line">                    right = i </span><br><span class="line">                    high = <span class="built_in">min</span>(height[i], height[stack[-<span class="number">1</span>]]) - height[cur]</span><br><span class="line">                    ans += high * (right - left - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 遇到空栈，停止弹出，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans         </span><br></pre></td></tr></table></figure><h3 id="4-8-最大矩形"><a href="#4-8-最大矩形" class="headerlink" title="4.8 最大矩形"></a>4.8 最大矩形</h3><blockquote><p><a href="https://leetcode.cn/problems/maximal-rectangle/">0085：最大矩阵</a> ，参考题解<a href="https://leetcode.cn/problems/maximal-rectangle/solution/python3-qian-zhui-he-dan-diao-zhan-ji-su-vkpp/">《Python3 前缀和+单调栈计算最大矩形》</a>        </p></blockquote><p>&#8195;&#8195;给定一个仅包含 0 和 1 ，大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。<br>示例：</p><ul><li>输入：matrix = [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]</li><li>输出：6</li><li>解释：最大矩形如下图所示。</li></ul><p>  <img src="https://img-blog.csdnimg.cn/aea8adcd2c104630b34f7b60d2ba3574.png" alt="在这里插入图片描述"></p><p><strong>解题思路</strong> ： </p><ul><li><p>我们可以统计每一行中，每个元素上方“1”的个数，这样就等同于得到了每一行柱子的高度<code>height</code>。</p><ul><li>对于<code>height</code>的计算，根据最大前缀和思想，当前位置j为‘0’，则<code>height[j]=0</code>，当前位置为‘1’，则需要加上上一层连续1的个数，即<code>height[j]+=1</code>。</li><li>例如本题中，<code>height[2]=[3, 1, 3, 2, 2]</code> </li></ul></li><li><p>用<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">0084. 柱状图中最大的矩形</a>中同样的做法，求得柱状图的最大面积就行。例如示例中，第二行面积为<code>[3, 5, 3, 6, 2]</code></p></li><li>遍历每一行，得到各行的最大面积，取全局最大值就行。</li></ul><p><img src="https://img-blog.csdnimg.cn/71e7087118204c57897b293eea9d30c8.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        m,n=<span class="built_in">len</span>(matrix),<span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        height=[<span class="number">0</span>]*n <span class="comment"># 每行上方1的个数，可视作柱子的高度</span></span><br><span class="line">        ans=[] <span class="comment"># 存储每行的最大面积</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 第m行每个位置含1的高度</span></span><br><span class="line">                height[j]=height[j]+<span class="number">1</span> <span class="keyword">if</span> matrix[i][j]==<span class="string">&quot;1&quot;</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#根据柱子高度计算最大面积，等同于第84题</span></span><br><span class="line">            stack=[]</span><br><span class="line">            left,right=[-<span class="number">1</span>]*n,[n]*n</span><br><span class="line">            <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> height[h]&lt;height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                    right[stack[-<span class="number">1</span>]]=h</span><br><span class="line">                    stack.pop()</span><br><span class="line">                left[h]=stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">                stack.append(h)</span><br><span class="line">            res=[(right[h]-left[h]-<span class="number">1</span>)*height[h] <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n)] </span><br><span class="line">            </span><br><span class="line">            ans.append(<span class="built_in">max</span>(res))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;@[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要参考&lt;a href=&quot;https://algo.itcharge.cn/03.Stack/01.Stack-Basic/01.Stack-Basic/&quot;&gt;《算法通关手册》堆栈篇&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、-堆栈基础知识&quot;&gt;&lt;a href=&quot;#一、-堆栈基础知识&quot; class=&quot;headerlink&quot; title=&quot;一、 堆栈基础知识&quot;&gt;&lt;/a&gt;一、 堆栈基础知识&lt;/h2&gt;&lt;h3 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1-1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.1 简介&quot;&gt;&lt;/a&gt;1.1 简介&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt; &lt;strong&gt;堆栈（Stack）&lt;/strong&gt;：简称为栈。一种线性表数据结构，是一种只允许在表的一端进行插入和删除操作的线性表。&lt;/p&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;我们把栈中允许插入和删除的一端称为 &lt;strong&gt;「栈顶（top）」&lt;/strong&gt;；另一端则称为 &lt;strong&gt;「栈底（bottom）」&lt;/strong&gt;。当表中没有任何数据元素时，称之为 &lt;strong&gt;「空栈」&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;堆栈有两种基本操作：&lt;strong&gt;「插入操作」&lt;/strong&gt; 和 &lt;strong&gt;「删除操作」&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈的插入操作又称为「入栈」或者「进栈」。&lt;/li&gt;
&lt;li&gt;栈的删除操作又称为「出栈」或者「退栈」。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/07774fbc4c85c01ef050267826da680e.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;</summary>
    
    
    
    <category term="Data Structure and Algorithms" scheme="https://zhxnlp.github.io/categories/Data-Structure-and-Algorithms/"/>
    
    
    <category term="leetcode" scheme="https://zhxnlp.github.io/tags/leetcode/"/>
    
    <category term="Stack" scheme="https://zhxnlp.github.io/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习三：链表</title>
    <link href="https://zhxnlp.github.io/2023/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E4%B8%89%EF%BC%9A%E9%93%BE%E8%A1%A8/"/>
    <id>https://zhxnlp.github.io/2023/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode%E7%BB%83%E4%B9%A0%E4%B8%89%EF%BC%9A%E9%93%BE%E8%A1%A8/</id>
    <published>2023-02-23T16:00:00.000Z</published>
    <updated>2023-04-09T09:03:13.313Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>本文主要参考<a href="https://algo.itcharge.cn/">《算法通关手册》</a>链表篇</p><h2 id="一、链表基础"><a href="#一、链表基础" class="headerlink" title="一、链表基础"></a>一、链表基础</h2><h3 id="1-1-无序表（UnorderedList）"><a href="#1-1-无序表（UnorderedList）" class="headerlink" title="1.1 无序表（UnorderedList）"></a>1.1 无序表（UnorderedList）</h3></blockquote><p>&#8195;&#8195; <strong>链表（Linked List）</strong>：一种线性表数据结构。它使用一组任意的存储单元（可以是连续的，也可以是不连续的），来存储一组具有相同类型的数据。简单来说，<strong>「链表」</strong> 是实现线性表链式存储结构的基础。</p><p>&#8195;&#8195;虽然列表数据结构要求保持数据项的前后相对位置，但这种前后位置的保持，<strong>并不要求数据项依次存放在连续的存储空间</strong>。如下图，数据项存放位置并没有规则，但如果在数据项之间建立链接指向，就可以保持其前后相对位置。第一个和最后一个数据项需要显示标记出来，一个是队首，一个是队尾，后面再无数据了。</p><ul><li>插入删除元素时需要移动表中元素，而不是修改指针，顺序表也是随机存取数据。<br><img src="https://img-blog.csdnimg.cn/976032d0441941e890bb51d86205832a.png" alt="在这里插入图片描述"><span id="more"></span>如上图所示，链表通过将一组任意的存储单元串联在一起。其中，每个数据元素占用若干存储单元的组合称为一个<strong>链节点</strong>。每个节点包含两个部分：</li><li>元素值</li><li>后继指针 <code>next</code>：指出直接后继元素所在链节点的地址。</li></ul><p>在链表中，数据元素之间的逻辑关系是通过指针来间接反映的。逻辑上相邻的数据元素在物理地址上可能相邻，可也能不相邻。其在物理地址上的表现是随机的。</p><p>我们先来简单介绍一下链表结构的优缺点：</p><ul><li><p><strong>优点</strong>：存储空间不必事先分配，在需要存储空间的时候可以临时申请，不会造成空间的浪费；一些操作的时间效率远比数组高（插入、移动、删除元素等）。</p></li><li><p><strong>缺点</strong>：不仅数据元素本身的数据信息要占用存储空间，指针也需要占用存储空间，链表结构比数组结构的空间开销大。</p></li></ul><p>接下来先来介绍一下除了单链表之外，链表的其他几种类型。</p><h4 id="1-1-2-双向链表"><a href="#1-1-2-双向链表" class="headerlink" title="1.1.2 双向链表"></a>1.1.2 双向链表</h4><blockquote><p><strong>双向链表（Doubly Linked List）</strong>：链表的一种，也叫做双链表。它的每个链节点中有两个指针，分别指向直接后继和直接前驱。</p></blockquote><p>从双链表的任意一个节点开始，都可以很方便的访问它的前驱节点和后继节点。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/13e3e10cb7da9e3ae4abe40f5b297e7d.png" alt=""></p><h4 id="1-1-3-循环链表"><a href="#1-1-3-循环链表" class="headerlink" title="1.1.3 循环链表"></a>1.1.3 循环链表</h4><blockquote><p><strong>循环链表（Circular linked list）</strong>：链表的一种。它的最后一个链节点指向头节点，形成一个环。</p></blockquote><p>从循环链表的任何一个节点出发都能找到任何其他节点。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6f46916bdfd94f22511b68b01944ff60.png" alt=""></p><p>接下来我们以单链表为例，介绍一下链表的基本操作。</p><h3 id="1-2-链表的基本操作"><a href="#1-2-链表的基本操作" class="headerlink" title="1.2 链表的基本操作"></a>1.2 链表的基本操作</h3><p>&#8195;&#8195;数据结构的操作一般涉及到增、删、改、查 4 种情况，链表的操作也基本上是这 4 种情况。我们一起来看一下链表的基本操作。</p><h4 id="1-2-1-定义链表结构"><a href="#1-2-1-定义链表结构" class="headerlink" title="1.2.1 定义链表结构"></a>1.2.1 定义链表结构</h4><ul><li><code>ListNode</code> 类：链节点类。链表是由链节点通过 <code>next</code> 链接而构成的，所以<code>ListNode</code> 类可使用成员变量 <code>val</code> 表示数据元素的值，使用指针变量 <code>next</code> 表示后继指针。</li><li><code>LinkedList</code> 类：链表类 。<code>ListkedList</code> 类中只有一个链节点变量 <code>head</code> 用来表示链表的头节点。我们在创建空链表时，只需要把相应的链表头节点变量设置为空链接（None）即可。</li></ul><p>上述代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 链节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br></pre></td></tr></table></figure></p><h4 id="1-2-2-建立线性链表"><a href="#1-2-2-建立线性链表" class="headerlink" title="1.2.2  建立线性链表"></a>1.2.2  建立线性链表</h4><p>建立线性链表的过程是：据线性表的数据元素动态生成链节点，并依次将其连接到链表中。其做法如下：</p><ol><li>从所给线性表的第 <code>1</code> 个数据元素开始依次获取表中的数据元素。</li><li>每获取一个数据元素，就为该数据元素生成一个新节点，将新节点插入到链表的尾部。</li><li>插入完毕之后返回第 <code>1</code> 个链节点的地址。</li></ol><p>建立一个线性链表的时间复杂度为 $O(n)$，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据 data 初始化一个新链表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, data</span>):</span></span><br><span class="line">    self.head = ListNode(<span class="number">0</span>)</span><br><span class="line">    cur = self.head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        node = ListNode(data[i])</span><br><span class="line">        cur.<span class="built_in">next</span> = node</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3-求线性链表的长度"><a href="#1-2-3-求线性链表的长度" class="headerlink" title="1.2.3 求线性链表的长度"></a>1.2.3 求线性链表的长度</h4><p>&#8195;&#8195;使用一个可以顺着链表指针移动的指针变量 <code>cur</code> 和一个计数器 <code>count</code>， <code>cur</code> 从头开始遍历链表直至为空，此时计数器的数值就是链表的长度。此操作时间复杂度为 $O(n)$，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    cur = self.head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span> </span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h4 id="1-2-4-查找元素"><a href="#1-2-4-查找元素" class="headerlink" title="1.2.4 查找元素"></a>1.2.4 查找元素</h4><p>&#8195;&#8195;在链表中查找值为 <code>val</code> 的位置：链表不能像数组那样进行随机访问，只能从头节点 <code>head</code> 开始，沿着链表一个一个节点逐一进行查找。如果查找成功，返回被查找节点的地址。否则返回 <code>None</code>。所以查找元素操作的问时间复杂度也是 $O(n)$，其代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, val</span>):</span></span><br><span class="line">    cur = self.head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">if</span> val == cur.val:</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="1-2-5-插入元素"><a href="#1-2-5-插入元素" class="headerlink" title="1.2.5 插入元素"></a>1.2.5 插入元素</h4><p>链表中插入元素操作分为三种：</p><ul><li><strong>链表头部插入元素</strong>：在链表第 <code>1</code> 个链节点之前插入值为 <code>val</code> 的链节点。</li><li><strong>链表尾部插入元素</strong>：在链表最后 <code>1</code> 个链节点之后插入值为 <code>val</code> 的链节点。</li><li><strong>链表中间插入元素</strong>：在链表第 <code>i</code> 个链节点之前插入值为 <code>val</code> 的链节点。</li></ul><p>接下来我们分别讲解一下。</p><p><strong>1. 链表头部插入元素</strong></p><ol><li>先创建一个值为 <code>val</code> 的链节点 <code>node</code>。</li><li>然后将 <code>node</code> 的 <code>next</code> 指针指向链表的头节点 <code>head</code>。</li><li>再将链表的头节点 <code>head</code> 指向 <code>node</code>。</li></ol><p><font color='deeppink'>这里后面两步顺序不能反了，否则原先的链表就会丢失。&lt;/font &gt;<br><img src="https://img-blog.csdnimg.cn/img_convert/8e7a81c1f8bc5cbe63f7fc9a8a7b686f.png" alt=""></p><p>&#8195;&#8195;因为在链表头部插入链节点与链表的长度无关，所以该算法的时间复杂度为 $O(1)$。其代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 头部插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertFront</span>(<span class="params">self, val</span>):</span></span><br><span class="line">    node = ListNode(val)</span><br><span class="line">    node.<span class="built_in">next</span> = self.head</span><br><span class="line">    self.head = node</span><br></pre></td></tr></table></figure><p><strong>2. 尾部插入元素</strong></p><ol><li>先创建一个值为 <code>val</code> 的链节点 <code>node</code>。</li><li>使用指针 <code>cur</code> 指向链表的头节点 <code>head</code>。</li><li>通过链节点的 <code>next</code> 指针移动 <code>cur</code> 指针，从而遍历链表，直到 <code>cur.next == None</code>。</li><li>令 <code>cur.next</code> 指向将新的链节点 <code>node</code>。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/2c1e8fddf3954f3469da41876a48e087.png" alt=""></p><p>&#8195;&#8195;该算法的时间复杂度是 $O(n)$，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 尾部插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertRear</span>(<span class="params">self, val</span>):</span></span><br><span class="line">    node = ListNode(val)</span><br><span class="line">    cur = self.head</span><br><span class="line">    <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    cur.<span class="built_in">next</span> = node</span><br></pre></td></tr></table></figure><p><strong>3. 中间插入元素</strong></p><ol><li>使用指针变量 <code>cur</code> 和一个计数器 <code>count</code>。令 <code>cur</code> 指向链表的头节点，<code>count</code> 初始值赋值为 <code>0</code>。</li><li>沿着链节点的 <code>next</code> 指针遍历链表，指针变量 <code>cur</code> 每指向一个链节点，计数器就做一次计数。</li><li>当 <code>count == index - 1</code> 时，说明遍历到了第 <code>index - 1</code> 个链节点，此时停止遍历。</li><li>创建一个值为 <code>val</code> 的链节点 <code>node</code>。</li><li>将 <code>node.next</code> 指向 <code>cur.next</code>。</li><li>然后令 <code>cur.next</code> 指向 <code>node</code>。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/a3e86083642937438626e59ba8b4687a.png" alt=""></p><p>&#8195;&#8195;该算法的时间复杂度是 $O(n)$，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 中间插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertInside</span>(<span class="params">self, index, val</span>):</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    cur = self.head</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">and</span> count &lt; index - <span class="number">1</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Error&#x27;</span></span><br><span class="line">    </span><br><span class="line">    node = ListNode(val)</span><br><span class="line">    node.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">    cur.<span class="built_in">next</span> = node</span><br></pre></td></tr></table></figure><h4 id="1-2-6-改变元素"><a href="#1-2-6-改变元素" class="headerlink" title="1.2.6 改变元素"></a>1.2.6 改变元素</h4><p>&#8195;&#8195;将链表中第 <code>i</code> 个元素值改为 <code>val</code>：首先要先遍历到第 <code>i</code> 个链节点，然后直接更改第 <code>i</code> 个链节点的元素值。具体做法如下：</p><ol><li>使用指针变量 <code>cur</code> 和一个计数器 <code>count</code>。令 <code>cur</code> 指向链表的头节点，<code>count</code> 初始值赋值为 <code>0</code>。</li><li>沿着链节点的 <code>next</code> 指针遍历链表，指针变量 <code>cur</code> 每指向一个链节点，计数器就做一次计数。</li><li>当 <code>count == index</code> 时，说明遍历到了第 <code>index</code> 个链节点，此时停止遍历。</li><li>直接更改 <code>cur</code> 的值 <code>val</code>。</li></ol><p>&#8195;&#8195;该算法的时间复杂度是 $O(n)$， 代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改变元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, index, val</span>):</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    cur = self.head</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">and</span> count &lt; index:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Error&#x27;</span></span><br><span class="line">    </span><br><span class="line">    cur.val = val</span><br></pre></td></tr></table></figure><h4 id="1-2-7-删除元素"><a href="#1-2-7-删除元素" class="headerlink" title="1.2.7 删除元素"></a>1.2.7 删除元素</h4><p>链表的删除元素操作同样分为三种情况：</p><ul><li><strong>链表头部删除元素</strong>：删除链表的第 <code>1</code> 个链节点。</li><li><strong>链表尾部删除元素</strong>：删除链表末尾最后 <code>1</code> 个链节点。</li><li><strong>链表中间删除元素</strong>：删除链表第 <code>i</code> 个链节点。</li></ul><p>接下来我们分别讲解一下。</p><p><strong>1. 链表头部删除元素</strong><br>直接将 <code>self.head</code> 沿着 <code>next</code> 指针向右移动一步即可。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f8c787c8937540da43add1a34c3db692.png" alt=""></p><p>算法的时间复杂度为 $O(1)$，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 链表头部删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeFront</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> self.head:</span><br><span class="line">        self.head = self.head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><strong>2.  链表尾部删除元素</strong></p><ul><li>先使用指针变量 <code>cur</code> 沿着 <code>next</code> 指针移动到倒数第 <code>2</code> 个链节点。</li><li>然后将此节点的 <code>next</code> 指针指向 <code>None</code> 即可。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/9132f79ad7424e8a4ee0deb452ca1cb9.png" alt=""></p><p>该算法的时间复杂度为 $O(n)$，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 链表尾部删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeRear</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Error&#x27;</span></span><br><span class="line"></span><br><span class="line">    cur = self.head</span><br><span class="line">    <span class="keyword">while</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    cur.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><strong>3.  链表中间删除元素</strong></p><p>删除链表中第 <code>i</code> 个元素的算法具体步骤如下：</p><ol><li>先使用指针变量 <code>cur</code> 移动到第 <code>i - 1</code> 个位置的链节点。</li><li>然后将 <code>cur</code> 的 <code>next</code> 指针，指向要第 <code>i</code> 个元素的下一个节点即可。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/29761b5bd6dcdd9f6e75df61ab0905e4.png" alt=""></p><p>该算法的时间复杂度为 $O(n)$，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 链表中间删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeInside</span>(<span class="params">self, index</span>):</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    cur = self.head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> count &lt; index - <span class="number">1</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Error&#x27;</span></span><br><span class="line">        </span><br><span class="line">    del_node = cur.<span class="built_in">next</span></span><br><span class="line">    cur.<span class="built_in">next</span> = del_node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><hr><p>到这里，有关链表的基础知识就介绍完了。下面进行一下总结。</p><h3 id="1-3-有序表OrderedList"><a href="#1-3-有序表OrderedList" class="headerlink" title="1.3 有序表OrderedList"></a>1.3 有序表OrderedList</h3><p><img src="https://img-blog.csdnimg.cn/8a48dfc3376046b884a24f38aa167894.png" alt="在这里插入图片描述"></p><ul><li>在实现有序表时，需要记住数据项的相对位置，取决于他们之间的“大小”比较，Node定义相同，OrderedList也设置一个head来保存链表表头的引用。</li><li>对于isEmpty()，size()，remove()方法与节点次序无关，其实现与UnorderedList相同。</li><li>search和add方法需要修改。无序表中，需要search的数据项不存在，则需要搜索整个链表。而有序表中，可以利用链表有序排列的特点，节省搜索时间。</li></ul><p><strong>有序表实现：search方法</strong></p><ul><li>在无序表的search中，如果需要查找的数据项不存在，则会搜遍整个链表，直到表尾。</li><li>对于有序表来说，可以利用链表节点有序排列的特性，来为search节省不存在数据项的查找时间。一旦当前节点的数据项大于所要查找的数据项，则说明链表后面已经不可能再有要查找的数据项，可以直接返回False。</li></ul><p><strong>有序表实现：add方法</strong></p><ul><li>add方法必须保证加入的数据项添加在合适的位置，以维护整个链表的有序性。</li><li>从头找到第一个比添加项大的数据项，将添加项插到该数据项前面。</li><li>跟remove方法类似，引入一个previous，跟随当前节点current。</li></ul><p><strong>代码实现</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,initdata</span>):</span></span><br><span class="line">        self.data = initdata</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getData</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNext</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setData</span>(<span class="params">self,newdata</span>):</span></span><br><span class="line">        self.data = newdata</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setNext</span>(<span class="params">self,newnext</span>):</span></span><br><span class="line">        self.<span class="built_in">next</span> = newnext</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        current = self.head</span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        stop = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line">            <span class="keyword">if</span> current.getData() == item:</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> current.getData() &gt; item:</span><br><span class="line">                    stop = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    current = current.getNext()</span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        current = self.head</span><br><span class="line">        previous = <span class="literal">None</span></span><br><span class="line">        stop = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line">            <span class="keyword">if</span> current.getData() &gt; item: <span class="comment"># 发现插入位置</span></span><br><span class="line">                stop = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                previous = current</span><br><span class="line">                current = current.getNext()</span><br><span class="line">        temp = Node(item)</span><br><span class="line">        <span class="keyword">if</span> previous == <span class="literal">None</span>:     <span class="comment"># 表头插入</span></span><br><span class="line">            temp.setNext(self.head)</span><br><span class="line">            self.head = temp</span><br><span class="line">        <span class="keyword">else</span>:<span class="comment"># 表中插入</span></span><br><span class="line">            temp.setNext(current)</span><br><span class="line">            previous.setNext(temp)</span><br></pre></td></tr></table></figure><h3 id="1-4-链表总结"><a href="#1-4-链表总结" class="headerlink" title="1.4 链表总结"></a>1.4 链表总结</h3><p>&#8195;&#8195;<strong>「链表」</strong> 是实现线性表的链式存储结构的基础。它使用一组任意的存储单元（可以是连续的，也可以是不连续的），来存储一组具有相同类型的数据。</p><p>&#8195;&#8195;链表最大的优点在于可以灵活的添加和删除元素。链表进行访问元素、改变元素操作的时间复杂度为 $O(n)$，进行头部插入、头部删除元素操作的时间复杂度是 $O(1)$，进行尾部插入、尾部删除操作的时间复杂度是 $O(n)$。普通情况下进行插入、删除元素操作的时间复杂度为 $O(n)$。</p><p>&#8195;&#8195;Python内置的list数据类型，是基于顺序存储实现的，并进行了优化，其基本操作复杂度如下：<br><img src="https://img-blog.csdnimg.cn/0fde110f64fc4c8d96db86afd4f77be2.png##pic_center =500x" alt="在这里插入图片描述"></p><h2 id="二、-链表基础题目"><a href="#二、-链表基础题目" class="headerlink" title="二、 链表基础题目"></a>二、 链表基础题目</h2><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0707</td><td style="text-align:left"><a href="https://leetcode.cn/problems/design-linked-list/">设计链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0707.%20%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">链表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0083</td><td style="text-align:left"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0083.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.md">Python</a></td><td style="text-align:left">链表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0082</td><td style="text-align:left"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">删除排序链表中的重复元素 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0082.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II.md">Python</a></td><td style="text-align:left">链表、双指针</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0206</td><td style="text-align:left"><a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">链表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0092</td><td style="text-align:left"><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">反转链表 II </a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0092.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II%20.md">Python</a></td><td style="text-align:left">链表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0025</td><td style="text-align:left"><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0025.%20K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">递归、链表</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0203</td><td style="text-align:left"><a href="https://leetcode.cn/problems/remove-linked-list-elements/">移除链表元素</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0203.%20%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.md">Python</a></td><td style="text-align:left">链表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0328</td><td style="text-align:left"><a href="https://leetcode.cn/problems/odd-even-linked-list/">奇偶链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0328.%20%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">链表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0234</td><td style="text-align:left"><a href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">链表、双指针</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0430</td><td style="text-align:left"><a href="https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list/">扁平化多级双向链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0430.%20%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">链表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0138</td><td style="text-align:left"><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">复制带随机指针的链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">链表、哈希表</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0061</td><td style="text-align:left"><a href="https://leetcode.cn/problems/rotate-list/">旋转链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0061.%20%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">链表、双指针</td><td style="text-align:left">中等</td></tr></tbody></table></div><h3 id="2-1-设计链表-707"><a href="#2-1-设计链表-707" class="headerlink" title="2.1 设计链表(707)"></a>2.1 设计链表(707)</h3><p><strong>要求</strong>：设计实现一个链表，需要支持以下操作：</p><ul><li><code>get(index)</code>：获取链表中第 <code>index</code> 个节点的值。如果索引无效，则返回 <code>-1</code>。</li><li><code>addAtHead(val)</code>：在链表的第一个元素之前添加一个值为 <code>val</code> 的节点。插入后，新节点将成为链表的第一个节点。</li><li><code>addAtTail(val)</code>：将值为 <code>val</code> 的节点追加到链表的最后一个元素。</li><li><code>addAtIndex(index, val)</code>：在链表中的第 <code>index</code> 个节点之前添加值为 <code>val</code>  的节点。如果 <code>index</code> 等于链表的长度，则该节点将附加到链表的末尾。如果 <code>index</code> 大于链表长度，则不会插入节点。如果 <code>index</code> 小于 <code>0</code>，则在头部插入节点。</li><li><code>deleteAtIndex(index)</code>：如果索引 <code>index</code> 有效，则删除链表中的第 <code>index</code> 个节点。</li></ul><p><strong>说明</strong>：</p><ul><li>所有<code>val</code>值都在 $[1, 1000]$ 之内。</li><li>操作次数将在 $[1, 1000]$ 之内。</li><li>请不要使用内置的 <code>LinkedList</code> 库。</li></ul><p><strong>示例</strong>：</p><ul><li>示例 1：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MyLinkedList linkedList = new MyLinkedList();</span><br><span class="line">linkedList.addAtHead(<span class="number">1</span>);</span><br><span class="line">linkedList.addAtTail(<span class="number">3</span>);</span><br><span class="line">linkedList.addAtIndex(<span class="number">1</span>,<span class="number">2</span>);   // 链表变为 <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br><span class="line">linkedList.get(<span class="number">1</span>);            // 返回 <span class="number">2</span></span><br><span class="line">linkedList.deleteAtIndex(<span class="number">1</span>);  // 现在链表是 <span class="number">1</span>-&gt; <span class="number">3</span></span><br><span class="line">linkedList.get(<span class="number">1</span>);            // 返回 <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="2-1-1单链表"><a href="#2-1-1单链表" class="headerlink" title="2.1.1单链表"></a>2.1.1单链表</h4><p>新建一个带有 <code>val</code> 值 和 <code>next</code> 指针的链表节点类， 然后按照要求对节点进行操作。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        curr = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>):</span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> curr.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.addAtIndex(<span class="number">0</span>, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.addAtIndex(self.size, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        pre = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        add_node = ListNode(val)</span><br><span class="line">        add_node.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span> = add_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        pre = self.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>时间复杂度</strong>：</p><ul><li><code>addAtHead(val)</code>：$O(1)$。</li><li><code>get(index)</code>、<code>addAtTail(val)</code>、<code>del eteAtIndex(index)</code>：$O(k)$。$k$ 指的是元素的索引。</li><li><code>addAtIndex(index, val)</code>：$O(n)$。$n$ 指的是链表的元素个数。</li></ul></li><li><p><strong>空间复杂度</strong>：$O(1)$。</p></li></ul><h4 id="2-1-2-双链表"><a href="#2-1-2-双链表" class="headerlink" title="2.1.2 双链表"></a>2.1.2 双链表</h4><p>新建一个带有 <code>val</code> 值和 <code>next</code> 指针、<code>prev</code> 指针的链表节点类，然后按照要求对节点进行操作。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.head = ListNode(<span class="number">0</span>)</span><br><span class="line">        self.tail = ListNode(<span class="number">0</span>)</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index + <span class="number">1</span> &lt; self.size - index:</span><br><span class="line">            curr = self.head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>):</span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            curr = self.tail</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.size - index):</span><br><span class="line">                curr = curr.prev</span><br><span class="line">        <span class="keyword">return</span> curr.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.addAtIndex(<span class="number">0</span>, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.addAtIndex(self.size, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index &lt; self.size - index:</span><br><span class="line">            prev = self.head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">                prev = prev.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span> = prev.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">next</span> = self.tail</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.size - index):</span><br><span class="line">                <span class="built_in">next</span> = <span class="built_in">next</span>.prev</span><br><span class="line">            prev = <span class="built_in">next</span>.prev</span><br><span class="line"></span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        add_node = ListNode(val)</span><br><span class="line">        add_node.prev = prev</span><br><span class="line">        add_node.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = add_node</span><br><span class="line">        <span class="built_in">next</span>.prev = add_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.size:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index &lt; self.size - index:</span><br><span class="line">            prev = self.head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">                prev = prev.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span> = prev.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">next</span> = self.tail</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.size - index - <span class="number">1</span>):</span><br><span class="line">                <span class="built_in">next</span> = <span class="built_in">next</span>.prev</span><br><span class="line">            prev = <span class="built_in">next</span>.prev.prev</span><br><span class="line"></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        prev.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        <span class="built_in">next</span>.prev = prev</span><br></pre></td></tr></table></figure></p><ul><li><strong>时间复杂度</strong>：<ul><li><code>addAtHead(val)</code>、<code>addAtTail(val)</code>：$O(1)$。</li><li><code>get(index)</code>、<code>addAtIndex(index, val)</code>、<code>del eteAtIndex(index)</code>：$O(min(k, n - k))$。$n$ 指的是链表的元素个数，$k$ 指的是元素的索引。</li></ul></li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h3 id="2-2-移除链表元素（203）"><a href="#2-2-移除链表元素（203）" class="headerlink" title="2.2 移除链表元素（203）"></a>2.2 移除链表元素（203）</h3><p>&#8195;&#8195;给定一个链表的头节点 <code>head</code> 和一个值 <code>val</code>，删除链表中值为 <code>val</code> 的节点，并返回新的链表头节点。</p><ul><li>列表中的节点数目在范围 $[0, 10^4]$ 内</li></ul><p><strong>示例</strong>：</p><ul><li>输入：head = [1,2,6,3,4,5,6], val = 6</li><li>输出：[1,2,3,4,5]</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/fd74c96b1cd120e1eeb087d8383dab40.jpeg#pic_center =500x" alt=""><br><strong>解题思路：</strong></p><ul><li>使用两个指针 <code>pre</code> 和 <code>cur</code>。<code>pre</code> 指向前一节点，<code>cur</code> 指向当前节点。</li><li>从前向后遍历链表，遇到值为 <code>val</code> 的节点时，将 <code>pre</code> 的 <code>next</code> 指针指向当前节点的下一个节点，继续递归遍历。没有遇到则将 <code>pre</code> 指针向后移动一步。</li><li>向右移动 <code>cur</code>，继续遍历。</li></ul><p>&#8195;&#8195;需要注意的是：因为要删除的节点可能包含了头节点，我们可以考虑在遍历之前，新建一个头节点，让其指向原来的头节点。这样，最终如果删除的是头节点，则直接删除原头节点，然后最后返回新建头节点的下一个节点即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head: ListNode, val: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        newHead = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        newHead.<span class="built_in">next</span> = head</span><br><span class="line">        pre, cur = newHead, head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> newHead.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        newHead = ListNode(<span class="number">0</span>)</span><br><span class="line">        newHead.<span class="built_in">next</span> = head              </span><br><span class="line">        cur=newHead</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">        <span class="comment"># 如果cur下一个节点值为val，就将其跳过下一节点，否则cur右移</span></span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span>.val==val:</span><br><span class="line">                cur.<span class="built_in">next</span>=cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur=cur.<span class="built_in">next</span></span><br><span class="line">               </span><br><span class="line">            <span class="keyword">return</span> newHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="2-3-删除排序链表中的重复元素（83）"><a href="#2-3-删除排序链表中的重复元素（83）" class="headerlink" title="2.3  删除排序链表中的重复元素（83）"></a>2.3  删除排序链表中的重复元素（83）</h3><p>给定一个已排序的链表的头 <code>head</code>，要求删除所有重复的元素，使每个元素只出现一次。返回已排序的链表。</p><ul><li>链表中节点数目在范围 $[0, 300]$ 内。</li><li>$-100 \le Node.val \le 100$。</li><li>题目数据保证链表已经按升序排列。</li></ul><p><strong>示例</strong>：</p><ul><li>输入：head = [1,1,2,3,3]</li><li>输出：[1,2,3]</li></ul><p><strong>解题思路</strong></p><ul><li>使用指针 <code>cur</code> 遍历链表，如果cur节点和其下一个节点元素值相等，就跳过下一个节点（<code>cur.next = cur.next.next</code>）。否则，让 <code>cur</code> 继续向后遍历。</li><li>遍历完之后返回头节点 <code>head</code>。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h3 id="2-4-删除排序链表中的重复元素-82"><a href="#2-4-删除排序链表中的重复元素-82" class="headerlink" title="2.4 删除排序链表中的重复元素 (82)"></a>2.4 删除排序链表中的重复元素 (82)</h3>&#8195;&#8195;给定一个已排序的链表的头 <code>head</code>，要求删除原始链表中所有重复数字的节点，只留下不同的数字。返回已排序的链表。</li><li>链表中节点数目在范围 $[0, 300]$ 内。</li><li>$-100 \le Node.val \le 100$。</li><li>题目数据保证链表已经按升序排列。</li></ul><p><strong>示例</strong>：</p><ul><li>输入：head = [1,1,2,3,3,4,4,5]</li><li>输出：[2,5]</li></ul><p>解题思路：</p><ul><li>先使用哑节点 <code>dummy_head</code> 构造一个指向 <code>head</code> 的指针，使得可以防止从 <code>head</code> 开始就是重复元素。</li><li>然后使用指针 <code>cur</code> 表示链表中当前元素，从哑节点开始遍历。</li><li>当指针 <code>cur</code> 的下一个元素和下下一个元素存在时：<ul><li>如果下一个元素值和下下一个元素值相同，则我们使用指针 <code>temp</code> 保存下一个元素，并使用 <code>temp</code> 向后遍历，跳过所有重复元素，然后令 <code>cur</code> 的下一个元素指向 <code>temp</code> 的下一个元素，继续向后遍历。</li><li>如果下一个元素值和下下一个元素值不同，则令 <code>cur</code> 向右移动一位，继续向后遍历。</li></ul></li><li>当指针 <code>cur</code> 的下一个元素或者下下一个元素不存在时，说明已经遍历完，则返回哑节点 <code>dummy_head</code> 的下一个节点作为头节点。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy_head.<span class="built_in">next</span> = head</span><br><span class="line"></span><br><span class="line">        cur = dummy_head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span>.val == cur.<span class="built_in">next</span>.<span class="built_in">next</span>.val:</span><br><span class="line">                temp = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">while</span> temp <span class="keyword">and</span> temp.<span class="built_in">next</span> <span class="keyword">and</span> temp.val == temp.<span class="built_in">next</span>.val:</span><br><span class="line">                    temp = temp.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = temp.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="2-5-反转链表"><a href="#2-5-反转链表" class="headerlink" title="2.5 反转链表"></a>2.5 反转链表</h3>给定一个单链表的头节点 <code>head</code>。将该单链表进行反转。可以迭代或递归地反转链表。</li><li>链表中节点的数目范围是 $[0, 5000]$。</li><li>$-5000 \le Node.val \le 5000$。</li></ul><p><strong>示例</strong>：</p><ul><li>输入：head = [1,2,3,4,5]</li><li>输出：[5,4,3,2,1]</li><li>解释：翻转前    1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL，反转后    5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</li></ul><h4 id="2-5-1-迭代"><a href="#2-5-1-迭代" class="headerlink" title="2.5.1 迭代"></a>2.5.1 迭代</h4><ol><li><p>使用两个指针 <code>cur</code> 和 <code>pre</code> 进行迭代。<code>pre</code> 指向 <code>cur</code> 前一个节点位置。初始时，<code>pre</code> 指向 <code>None</code>，<code>cur</code> 指向 <code>head</code>。</p></li><li><p>将 <code>pre</code> 和 <code>cur</code> 的前后指针进行交换，指针更替顺序为：</p><ol><li>使用 <code>next</code> 指针保存当前节点 <code>cur</code> 的后一个节点，即 <code>next = cur.next</code>；</li><li>断开当前节点 <code>cur</code> 的后一节点链接，将 <code>cur</code> 的 <code>next</code> 指针指向前一节点 <code>pre</code>，即 <code>cur.next = pre</code>；</li><li><code>pre</code> 向前移动一步，移动到 <code>cur</code> 位置，即 <code>pre = cur</code>；</li><li><code>cur</code> 向前移动一步，移动到之前 <code>next</code> 指针保存的位置，即 <code>cur = next</code>。</li></ol></li><li>继续执行第 2 步中的 1、2、3、4。</li><li>最后等到 <code>cur</code> 遍历到链表末尾，即 <code>cur == None</code>，时，<code>pre</code> 所在位置就是反转后链表的头节点，返回新的头节点 <code>pre</code>。</li></ol><p>使用迭代法反转链表的示意图如下所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9e837f5fd0c48c8e79642189fbe957ae.png#pic_center =500x" alt=""><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></p><ul><li><strong>时间复杂度</strong>：$O(n)$。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h4 id="2-5-2-递归"><a href="#2-5-2-递归" class="headerlink" title="2.5.2 递归"></a>2.5.2 递归</h4><ol><li>首先定义递归函数含义为：将链表反转，并返回反转后的头节点。</li><li>然后从 <code>head.next</code> 的位置开始调用递归函数，即将 <code>head.next</code> 为头节点的链表进行反转，并返回该链表的头节点。</li><li>递归到链表的最后一个节点，将其作为最终的头节点，即为 <code>new_head</code>。</li><li>在每次递归函数返回的过程中，改变 <code>head</code> 和 <code>head.next</code> 的指向关系。也就是将 <code>head.next</code> 的<code>next</code> 指针先指向当前节点 <code>head</code>，即 <code>head.next.next = head</code>。</li><li>然后让当前节点 <code>head</code> 的 <code>next</code> 指针指向 <code>None</code>，从而实现从链表尾部开始的局部反转。</li><li>当递归从末尾开始顺着递归栈的退出，从而将整个链表进行反转。</li><li>最后返回反转后的链表头节点 <code>new_head</code>。</li></ol><p>使用递归法反转链表的示意图如下所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ea86eca320a6601c923f704ac6215547.png#pic_center =500x" alt=""><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        new_head = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure></p><ul><li><strong>时间复杂度</strong>：$O(n)$</li><li><strong>空间复杂度</strong>：$O(n)$。最多需要 $n$ 层栈空间。</li></ul><h3 id="2-6-反转链表二（92）"><a href="#2-6-反转链表二（92）" class="headerlink" title="2.6 反转链表二（92）"></a>2.6 反转链表二（92）</h3><p>&#8195;&#8195;给定单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code>。要求反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回反转后的链表 。</p><ul><li>链表中节点数目为 <code>n</code>，且$1 \le n \le 500$。</li><li>$-500 \le Node.val \le 500$。</li><li>$1 \le left \le right \le n$。</li></ul><p><strong>示例</strong>：</p><ul><li>输入：head = [1,2,3,4,5], left = 2, right = 4</li><li>输出：[1,4,3,2,5]</li></ul><h4 id="2-6-1-迭代"><a href="#2-6-1-迭代" class="headerlink" title="2.6.1 迭代"></a>2.6.1 迭代</h4><p>&#8195;&#8195;在「<a href="https://leetcode.cn/problems/reverse-linked-list/">0206. 反转链表</a>」中我们可以通过迭代、递归两种方法将整个链表反转。而这道题要求对链表的部分区间进行反转。我们可以先遍历到需要反转的链表区间的前一个节点，然后对需要反转的链表区间进行迭代反转。最后再返回头节点即可。</p><p>&#8195;&#8195;但是需要注意一点，如果需要反转的区间包含了链表的第一个节点，那么我们可以事先创建一个哑节点作为链表初始位置开始遍历，这样就能避免找不到需要反转的链表区间的前一个节点。具体解题步骤如下：</p><ol><li>先使用哑节点 <code>dummy_head</code> 构造一个指向 <code>head</code> 的指针，使得可以从 <code>head</code> 开始遍历。使用 <code>index</code> 记录当前元素的序号。</li><li>我们使用一个指针 <code>start</code>，初始赋值为 <code>dummy_head</code>。然后向右逐步移动到需要反转的区间的前一个节点。</li><li>然后再使用两个指针 <code>cur</code> 和 <code>pre</code> 进行迭代。<code>pre</code> 指向 <code>cur</code> 前一个节点位置，即 <code>pre</code> 指向需要反转节点的前一个节点，<code>cur</code> 指向需要反转的节点。初始时，<code>pre</code> 指向 <code>start</code>，<code>cur</code> 指向 <code>pre.next</code>。</li><li>当当前节点 <code>cur</code> 不为空，且 <code>index</code> 在反转区间内时，将 <code>pre</code> 和 <code>cur</code> 的前后指针进行交换，指针更替顺序为：<ol><li>使用 <code>next</code> 指针保存当前节点 <code>cur</code> 的后一个节点，即 <code>next = cur.next</code>；</li><li>断开当前节点 <code>cur</code> 的后一节点链接，将 <code>cur</code> 的 <code>next</code> 指针指向前一节点 <code>pre</code>，即 <code>cur.next = pre</code>；</li><li><code>pre</code> 向前移动一步，移动到 <code>cur</code> 位置，即 <code>pre = cur</code>；</li><li><code>cur</code> 向前移动一步，移动到之前 <code>next</code> 指针保存的位置，即 <code>cur = next</code>。</li><li>然后令 <code>index</code> 加 <code>1</code>。</li></ol></li><li>继续执行第 <code>4</code> 步中的 <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>、<code>5</code> 步。</li><li>最后等到 <code>cur</code> 遍历到链表末尾（即 <code>cur == None</code>）或者遍历到需要反转区间的末尾时（即 <code>index &gt; right</code>） 时，将反转区间的头尾节点分别与之前保存的需要反转的区间的前一个节点 <code>reverse_start</code> 相连，即 <code>start.next.next = cur</code>，<code>start.next = pre</code>。</li><li>最后返回新的头节点 <code>dummy_head.next</code>。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        dummy_head=ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy_head.<span class="built_in">next</span>=head</span><br><span class="line">        <span class="comment"># 使用一指针start，初始赋值为 dummy_head。向右遍历到left前一个节点</span></span><br><span class="line">        start=dummy_head</span><br><span class="line">        index=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start.<span class="built_in">next</span> <span class="keyword">and</span> index&lt;=left-<span class="number">2</span>:</span><br><span class="line">            start=start.<span class="built_in">next</span></span><br><span class="line">            index+=<span class="number">1</span></span><br><span class="line">        <span class="comment">#print(start.val)</span></span><br><span class="line">        <span class="comment">#使用两个指针 cur 和 pre分别指向left和left前一个节点，开始反转链表</span></span><br><span class="line">        pre,cur=start,start.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> index&lt;right:</span><br><span class="line">            <span class="built_in">next</span>=cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span>=pre</span><br><span class="line">            pre=cur</span><br><span class="line">            cur=<span class="built_in">next</span></span><br><span class="line">            index+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 此时pre是反转后的链表头结点，cur是right下一个节点</span></span><br><span class="line">        <span class="comment">#print(pre.val,cur.val) # 如果right是最后一个节点，cur指向None，其没有val属性，print报错</span></span><br><span class="line">        start.<span class="built_in">next</span>.<span class="built_in">next</span>=cur</span><br><span class="line">        start.<span class="built_in">next</span>=pre</span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h4 id="2-6-2-头插法，一次遍历（官方题解）"><a href="#2-6-2-头插法，一次遍历（官方题解）" class="headerlink" title="2.6.2 头插法，一次遍历（官方题解）"></a>2.6.2 头插法，一次遍历（官方题解）</h4><p>&#8195;&#8195;方法一的缺点是：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为 $O(n)$，但遍历了链表 2 次，可不可以只遍历一次呢？答案是可以的，如下图所示：<br><img src="https://img-blog.csdnimg.cn/3a86d71926a04ddbbad07ae949d2ac87.png" alt="在这里插入图片描述"><br>&#8195;&#8195;整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。下面的图展示了整个流程。<br><img src="https://img-blog.csdnimg.cn/948a8b25ef064a23b0e6872dadc3326a.png#pic_center =500x" alt="在这里插入图片描述"><br>具体来说，可以使用三个指针变量 pre、curr、next 来记录反转的过程中需要的变量，它们的意义如下：</p><ul><li>curr：指向待反转区域的第一个节点 left；</li><li>next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 next 会变化；</li><li>pre：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。</li></ul><ol><li>反转链表（同206题）<ul><li>先将 curr 的下一个节点记录为 next；</li><li>执行操作 ①：把 curr 的下一个节点指向 next 的下一个节点；</li><li>执行操作 ②：把 next 的下一个节点指向 pre 的下一个节点；</li><li>执行操作 ③：把 pre 的下一个节点指向 next。</li></ul></li></ol><p><img src="https://img-blog.csdnimg.cn/758ac8e638c34e0abf73444c2c62974a.png#pic_center =500x" alt="在这里插入图片描述"><br>反转后效果如下：<br><img src="https://img-blog.csdnimg.cn/d5372420233b45b285cbe7bd744c6de5.png#pic_center =500x" alt="在这里插入图片描述"></p><ol><li>继续穿针引线<br><img src="https://img-blog.csdnimg.cn/ac4972f5d09d4f7a954fc99a1cdfb463.png#pic_center =500x" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/52d80a5295c1420e818897d594780438.png#pic_center =500x" alt="在这里插入图片描述"><br>第三步同上：<br><img src="https://img-blog.csdnimg.cn/f739afba0f294c49883444925ef3e679.png#pic_center =500x" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d0e441b8657a45268559427504fd7df1.png#pic_center =500x" alt="在这里插入图片描述"></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: ListNode, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">        dummy_node = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy_node.<span class="built_in">next</span> = head</span><br><span class="line">        pre = dummy_node</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left - <span class="number">1</span>):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        cur = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right - left):</span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = <span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span>.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="2-7-回文链表"><a href="#2-7-回文链表" class="headerlink" title="2.7 回文链表"></a>2.7 回文链表</h3><p>给定一个链表的头节点 head，判断该链表是否为回文链表。<br><strong>示例：</strong></p><ul><li>输入：head = [1,2,2,1]</li><li>输出：True</li></ul><p>利用数组，将链表元素值依次存入，然后判断最终的数组是否是回文数。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        nodes = []</span><br><span class="line">        p1 = head</span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            nodes.append(p1.val)</span><br><span class="line">            p1 = p1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> nodes == nodes[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><h2 id="三、链表双指针"><a href="#三、链表双指针" class="headerlink" title="三、链表双指针"></a>三、链表双指针</h2><h3 id="3-1-双指针简介"><a href="#3-1-双指针简介" class="headerlink" title="3.1 双指针简介"></a>3.1 双指针简介</h3><p>在数组双指针中我们已经学习过了双指针的概念。这里再来复习一下。</p><p>&#8195;&#8195; <strong>双指针（Two Pointers）</strong>：指的是在遍历元素的过程中，使用两个指针进行访问，从而达到相应的目的。如果两个指针方向相反，则称为<font color='deeppink'>「对撞时针」&lt;/font &gt;。如果两个指针方向相同，则称为<font color='deeppink'>「快慢指针」&lt;/font &gt;。如果两个指针分别属于不同的数组 / 链表，则称为<font color='deeppink'>「分离双指针」&lt;/font &gt;。</p><p>&#8195;&#8195;而在单链表中，因为遍历节点只能顺着 <code>next</code> 指针方向进行，所以对于链表而言，一般只会用到「快慢指针」和「分离双指针」。其中链表的「快慢指针」又分为<font color='deeppink'>「起点不一致的快慢指针」&lt;/font &gt;和<font color='deeppink'>「步长不一致的快慢指针」&lt;/font &gt;。这几种类型的双指针所解决的问题也各不相同，下面我们一一进行讲解。</p><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0141</td><td style="text-align:left"><a href="https://leetcode.cn/problems/linked-list-cycle/">环形链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">链表、双指针</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0142</td><td style="text-align:left"><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II.md">Python</a></td><td style="text-align:left">链表、双指针</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0160</td><td style="text-align:left"><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">链表、双指针</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0019</td><td style="text-align:left"><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0019.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9.md">Python</a></td><td style="text-align:left">链表、双指针</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0876</td><td style="text-align:left"><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">链表的中间结点</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0876.%20%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9.md">Python</a></td><td style="text-align:left">链表、指针</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">剑指 Offer 22</td><td style="text-align:left"><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第k个节点</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.md">Python</a></td><td style="text-align:left">链表、双指针</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0143</td><td style="text-align:left"><a href="https://leetcode.cn/problems/reorder-list/">重排链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0143.%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">栈、递归、链表、双指针</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0002</td><td style="text-align:left"><a href="https://leetcode.cn/problems/add-two-numbers/">两数相加</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0002.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.md">Python</a></td><td style="text-align:left">递归、链表、数学</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0445</td><td style="text-align:left"><a href="https://leetcode.cn/problems/add-two-numbers-ii/">两数相加 II</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0445.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%20II.md">Python</a></td><td style="text-align:left">栈、链表、数学</td><td style="text-align:left">中等</td></tr></tbody></table></div><h3 id="3-2-起点不一致的快慢指针"><a href="#3-2-起点不一致的快慢指针" class="headerlink" title="3.2 起点不一致的快慢指针"></a>3.2 起点不一致的快慢指针</h3><h4 id="3-2-1-算法简介"><a href="#3-2-1-算法简介" class="headerlink" title="3.2.1 算法简介"></a>3.2.1 算法简介</h4><p>&#8195;&#8195;两个指针从同一侧开始遍历链表，但是两个指针的起点不一样。 快指针 <code>fast</code> 比慢指针 <code>slow</code> 先走 <code>n</code> 步，直到快指针移动到链表尾端时为止。</p><p><strong>求解步骤</strong></p><ol><li>使用两个指针 <code>slow</code>、<code>fast</code>。<code>slow</code>、<code>fast</code> 都指向链表的头节点，即：<code>slow = head</code>，<code>fast = head</code>。</li><li>先将快指针向右移动 <code>n</code> 步。然后再同时向右移动快、慢指针。</li><li>等到快指针移动到链表尾部（即 <code>fast == None</code>）时跳出循环体。</li></ol><p><strong>伪代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">slow，fast = head,head</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> n:</span><br><span class="line">    fast = fast.<span class="built_in">next</span></span><br><span class="line">    n -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> fast:</span><br><span class="line">    fast = fast.<span class="built_in">next</span></span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><strong>适用范围</strong>：主要用于<font color='deeppink'>找到链表中倒数第 k 个节点、删除链表倒数第 N 个节点等&lt;/font &gt;。</p><h4 id="3-2-2-删除链表的倒数第-N-个结点"><a href="#3-2-2-删除链表的倒数第-N-个结点" class="headerlink" title="3.2.2 删除链表的倒数第 N 个结点"></a>3.2.2 删除链表的倒数第 N 个结点</h4><blockquote><p>题目链接：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p></blockquote><p>给定一个链表的头节点 <code>head</code>，要求删除链表的倒数第 <code>n</code> 个节点，并且返回链表的头节点。</p><ul><li>要求使用一次遍历实现。</li><li>链表中结点的数目为 <code>sz</code>，其中 $1 \le sz \le 30$。</li><li>$0 \le Node.val \le 100$。</li><li>$1 \le n \le sz$。</li></ul><p><strong>示例</strong>：</p><ul><li>输入：head = [1,2,3,4,5], n = 2</li><li>输出：[1,2,3,5]<br><img src="https://img-blog.csdnimg.cn/img_convert/295f29407affc9a16eed067b9c15e4db.jpeg#pic_center =400x" alt=""></li></ul><p><strong>解题思路：快慢指针</strong></p><ul><li>常规思路是遍历一遍链表，求出链表长度，再遍历一遍到对应位置，删除该位置上的节点。</li><li>使用快慢指针可以实现一次遍历得到结果。思路就是让快指针先走 <code>n</code> 步，然后快慢指针同时右移，这样等快指针遍历到链表尾部的时候，慢指针就刚好遍历到了倒数第 <code>n</code> 个节点位置。将该位置上的节点删除即可。</li><li>要删除的节点可能包含了头节点。我们可以考虑在遍历之前，新建一个头节点，让其指向原来的头节点。这样，最终如果删除的是头节点，则删除原头节点即可。返回结果的时候，可以直接返回新建头节点的下一位节点。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        newHead = ListNode(<span class="number">0</span>, head) <span class="comment"># val=0,next=head</span></span><br><span class="line">        fast = head</span><br><span class="line">        slow = newHead</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> newHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n)$。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h3 id="3-3-步长不一致的快慢指针"><a href="#3-3-步长不一致的快慢指针" class="headerlink" title="3.3  步长不一致的快慢指针"></a>3.3  步长不一致的快慢指针</h3><h4 id="3-3-1-算法原理"><a href="#3-3-1-算法原理" class="headerlink" title="3.3.1 算法原理"></a>3.3.1 算法原理</h4><p>&#8195;&#8195;两个指针从同一侧开始遍历链表，两个指针的起点一样，但是步长不一致。例如，慢指针 <code>slow</code> 每次走 <code>1</code> 步，快指针 <code>fast</code> 每次走两步。直到快指针移动到链表尾端时为止。</p><p><strong>求解步骤</strong></p><ol><li>使用两个指针 <code>slow</code>、<code>fast</code>。<code>slow</code>、<code>fast</code> 都指向链表的头节点。</li><li>在循环体中将快、慢指针同时向右移动，但是快、慢指针的移动步长不一致。比如将慢指针每次移动 <code>1</code> 步，即 <code>slow = slow.next</code>。快指针每次移动 <code>2</code> 步，即 <code>fast = fast.next.next</code>。</li><li>等到快指针移动到链表尾部（即 <code>fast == None</code>）时跳出循环体。</li></ol><p><strong>伪代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fast = head</span><br><span class="line">slow = head</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p> <strong>适用范围</strong>：此算法适合<font color='deeppink'>寻找链表的中点、判断和检测链表是否有环、找到两个链表的交点等问题。&lt;/font &gt;</p><h4 id="3-3-2-求链表的中间结点"><a href="#3-3-2-求链表的中间结点" class="headerlink" title="3.3.2  求链表的中间结点"></a>3.3.2  求链表的中间结点</h4><blockquote><p>3.4.1 题目链接： <a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点 - 力扣（LeetCode）</a></p></blockquote><p>给定一个单链表的头节点 <code>head</code>，返回链表的中间节点。如果有两个中间节点，则返回第二个中间节点。</p><ul><li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li></ul><p><strong>示例1</strong>：</p><ul><li>输入：[1,2,3,4,5]</li><li>输出：此列表中的结点 3 (序列化形式：[3,4,5])</li><li>解释：返回的结点值为 3 。</li><li>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br><code>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL</code>.</li></ul><p><strong>示例2</strong>：</p><ul><li>输入：[1,2,3,4,5,6]</li><li>输出：此列表中的结点 4 (序列化形式：[4,5,6])</li><li>解释：由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</li></ul><h5 id="3-3-2-1-单指针"><a href="#3-3-2-1-单指针" class="headerlink" title="3.3.2.1 单指针"></a>3.3.2.1 单指针</h5><p>&#8195;&#8195;先遍历一遍链表，统计一下节点个数为 <code>n</code>，再遍历到 <code>n / 2</code> 的位置，返回中间节点。其代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> k &lt; n // <span class="number">2</span>:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n)$。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h5 id="3-3-2-2-快慢指针"><a href="#3-3-2-2-快慢指针" class="headerlink" title="3.3.2.2 快慢指针"></a>3.3.2.2 快慢指针</h5><p>使用步长不一致的快慢指针进行一次遍历找到链表的中间节点。具体做法如下：</p><ol><li>使用两个指针 <code>slow</code>、<code>fast</code>。<code>slow</code>、<code>fast</code> 都指向链表的头节点。</li><li>在循环体中将快、慢指针同时向右移动。其中慢指针每次移动 <code>1</code> 步，即 <code>slow = slow.next</code>。快指针每次移动 <code>2</code> 步，即 <code>fast = fast.next.next</code>。</li><li>等到快指针移动到链表尾部（即 <code>fast == Node</code>）时跳出循环体，此时 <code>slow</code> 指向链表中间位置。</li><li>返回 <code>slow</code> 指针。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n)$。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h4 id="3-3-3-判断链表中是否含有环"><a href="#3-3-3-判断链表中是否含有环" class="headerlink" title="3.3.3 判断链表中是否含有环"></a>3.3.3 判断链表中是否含有环</h4><blockquote><p>题目链接: <a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表 - 力扣（LeetCode）</a></p></blockquote><p>&#8195;&#8195;给定一个链表的头节点 <code>head</code>,判断链表中是否有环。如果有环则返回 <code>True</code>，否则返回 <code>False</code>。</p><ul><li>链表中节点的数目范围是 $[0, 10^4]$。</li><li>$-10^5 \le Node.val \le 10^5$。</li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个有效索引。</li></ul><p><strong>示例</strong>：</p><ul><li>输入：head = [3,2,0,-4], pos = 1</li><li>输出：True</li><li>解释：链表中有一个环，其尾部连接到第二个节点。<br><img src="https://img-blog.csdnimg.cn/img_convert/dbfb8d37f1e518946d12c3027e7d8b0d.png" alt=""><h5 id="3-3-3-1-哈希表"><a href="#3-3-3-1-哈希表" class="headerlink" title="3.3.3.1 哈希表"></a>3.3.3.1 哈希表</h5></li></ul><p>&#8195;&#8195;最简单的思路是遍历所有节点，每次遍历节点之前，使用哈希表判断该节点是否被访问过。如果过就说明存在环，如果没访问过则将该节点添加到哈希表中，继续遍历判断。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        nodeset = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> nodeset:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            nodeset.add(head)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n)$。</li><li><strong>空间复杂度</strong>：$O(n)$。</li></ul><h5 id="3-3-3-2-快慢指针（Floyd-判圈算法）"><a href="#3-3-3-2-快慢指针（Floyd-判圈算法）" class="headerlink" title="3.3.3.2 快慢指针（Floyd 判圈算法）"></a>3.3.3.2 快慢指针（Floyd 判圈算法）</h5><p>&#8195;&#8195;这种方法类似于在操场跑道跑步。两个人从同一位置同时出发，如果跑道有环（环形跑道），那么快的一方总能追上慢的一方。</p><p>&#8195;&#8195;基于上边的想法，Floyd 用两个指针，一个慢指针（龟）每次前进一步，快指针（兔）指针每次前进两步（两步或多步效果是等价的）。如果两个指针在链表头节点以外的某一节点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了某个没有后继指针的节点时，那么说明没环。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> fast == <span class="literal">None</span> <span class="keyword">or</span> fast.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n)$。</li><li><strong>空间复杂度</strong>：$O(1)$。   </li></ul><h4 id="3-3-4-求环形链表入环位置"><a href="#3-3-4-求环形链表入环位置" class="headerlink" title="3.3.4  求环形链表入环位置"></a>3.3.4  求环形链表入环位置</h4><blockquote><p>题目链接:：142  <a href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表 II</a></p></blockquote><p>&#8195;&#8195;给定一个链表的头节点 <code>head</code>，判断链表中是否有环，如果有环则返回入环的第一个节点，无环则返回 <code>None</code>。</p><ul><li>链表中节点的数目范围在范围 $[0, 10^4]$ 内。</li><li>$-10^5 \le Node.val \le 10^5$。</li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引。</li></ul><p><strong>示例</strong>：</p><ul><li>输入：head = [3,2,0,-4], pos = 1</li><li>输出：返回索引为 1 的链表节点</li><li>解释：链表中有一个环，其尾部连接到第二个节点。<br><img src="https://img-blog.csdnimg.cn/img_convert/ce72825fb3554578b0fb6a400054d2d8.png" alt=""></li></ul><h5 id="3-3-4-1-哈希表"><a href="#3-3-4-1-哈希表" class="headerlink" title="3.3.4.1 哈希表"></a>3.3.4.1 哈希表</h5><p>&#8195;&#8195;遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        se=<span class="built_in">set</span>()</span><br><span class="line">        cur=head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">not</span> <span class="keyword">in</span> se:</span><br><span class="line">                se.add(cur)</span><br><span class="line">                cur=cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h5 id="3-3-4-2-快慢指针（Floyd-判圈算法）"><a href="#3-3-4-2-快慢指针（Floyd-判圈算法）" class="headerlink" title="3.3.4.2 快慢指针（Floyd 判圈算法）"></a>3.3.4.2 快慢指针（Floyd 判圈算法）</h5><ol><li>利用两个指针，一个慢指针 <code>slow</code> 每次前进一步，快指针 <code>fast</code> 每次前进两步（两步或多步效果是等价的）。</li><li>如果两个指针在链表头节点以外的某一节点相遇（即相等）了，那么说明链表有环。</li><li>否则，如果（快指针）到达了某个没有后继指针的节点时，那么说明没环。</li><li>如果有环，则再定义一个指针 <code>ans</code>，和慢指针一起每次移动一步，两个指针相遇的位置即为入口节点。</li></ol><p>这是因为：</p><ul><li><p>假设入环位置为 <code>A</code>，快慢指针在 <code>B</code> 点相遇，则相遇时慢指针走了 $a + b$ 步，快指针走了 $a + n(b+c) + b$ 步。</p></li><li><p>因为快指针总共走的步数是慢指针走的步数的两倍，即 $2(a + b) = a + n(b + c) + b$，所以可以推出：$a = c + (n-1)(b + c)$。</p></li><li><p>我们可以发现：从相遇点到入环点的距离 $c$ 加上 $n-1$ 圈的环长 $b + c$ 刚好等于从链表头部到入环点的距离。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span>       </span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span>==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:            </span><br><span class="line">            slow,fast=head,head                       </span><br><span class="line">            <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:                                                                               </span><br><span class="line">                slow=slow.<span class="built_in">next</span></span><br><span class="line">                fast=fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> fast==slow: </span><br><span class="line">                    ans=head</span><br><span class="line">                    <span class="keyword">while</span> ans!=slow:</span><br><span class="line">                        ans,slow=ans.<span class="built_in">next</span>,slow.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">return</span> slow</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n)$。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h3 id="3-4-分离双指针"><a href="#3-4-分离双指针" class="headerlink" title="3.4 分离双指针"></a>3.4 分离双指针</h3><h4 id="3-4-1-算法原理"><a href="#3-4-1-算法原理" class="headerlink" title="3.4.1 算法原理"></a>3.4.1 算法原理</h4><p> <strong>分离双指针</strong>：两个指针分别属于不同的链表，两个指针分别在两个链表中移动。</p><p><strong>求解步骤</strong></p><ol><li>使用两个指针 <code>left_1</code>、<code>left_2</code>。分别指向两个链表的头节点，即：<code>left_1 = list1</code>，<code>left_2 = list2</code>。</li><li>当满足一定条件时，两个指针同时右移，即 <code>left_1 = left_1.next</code>、<code>left_2 = left_2.next</code>。</li><li>当满足另外一定条件时，将 <code>left_1</code> 指针右移，即 <code>left_1 = left_1.next</code>。</li><li>当满足其他一定条件时，将 <code>left_2</code> 指针右移，即 <code>left_2 = left_2.next</code>。</li><li>当其中一个链表遍历完时或者满足其他特殊条件时跳出循环体。</li></ol><p><strong>伪代码模板</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left_1 = list1</span><br><span class="line">left_2 = list2</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> left_1 <span class="keyword">and</span> left_2:</span><br><span class="line">    <span class="keyword">if</span> 一定条件 <span class="number">1</span>:</span><br><span class="line">        left_1 = left_1.<span class="built_in">next</span></span><br><span class="line">        left_2 = left_2.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">elif</span> 一定条件 <span class="number">2</span>:</span><br><span class="line">        left_1 = left_1.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">elif</span> 一定条件 <span class="number">3</span>:</span><br><span class="line">        left_2 = left_2.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><strong>适用范围</strong>：分离双指针一般用于有序链表合并等问题。</p><h4 id="3-4-2-合并两个有序链表"><a href="#3-4-2-合并两个有序链表" class="headerlink" title="3.4.2 合并两个有序链表"></a>3.4.2 合并两个有序链表</h4><blockquote><p>题目链接： <a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表 - 力扣（LeetCode）</a></p></blockquote><p>给定两个升序链表的头节点 <code>list1</code> 和 <code>list2</code>，要求将其合并为一个升序链表。</p><ul><li>两个链表的节点数目范围是 $[0, 50]$。</li><li>$-100 \le Node.val \le 100$。</li><li><code>list1</code> 和 <code>list2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><p><strong>示例</strong>：</p><ul><li>输入：list1 = [1,2,4], list2 = [1,3,4]</li><li>输出：[1,1,2,3,4,4]<br><img src="https://img-blog.csdnimg.cn/img_convert/c7b6783dbd37070bd65b715c00f4ad66.jpeg#pic_center =400x" alt=""></li></ul><p>利用分离双指针，具体步骤如下：</p><ol><li>使用哑节点 <code>dummy_head</code> 构造一个头节点，并使用 <code>cur</code> 指向 <code>dummy_head</code> 用于遍历。</li><li>然后判断 <code>list1</code> 和 <code>list2</code> 头节点的值，将较小的头节点加入到合并后的链表中。并向后移动该链表的头节点指针。</li><li>然后重复上一步操作，直到两个链表中出现链表为空的情况。</li><li>将剩余链表链接到合并后的链表中。</li><li>将哑节点 <code>dummy_dead</code> 的下一个链节点 <code>dummy_head.next</code> 作为合并后有序链表的头节点返回。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        cur = dummy_head</span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"><span class="comment"># 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        cur.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> list2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n)$。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h4 id="3-4-3-相交链表"><a href="#3-4-3-相交链表" class="headerlink" title="3.4.3 相交链表"></a>3.4.3 相交链表</h4><blockquote><p>题目链接： <a href="https://algo.itcharge.cn/Solutions/0100-0199/intersection-of-two-linked-lists/">160. 相交链表- 力扣（LeetCode）</a></p></blockquote><p>&#8195;&#8195;给定两个链表 <code>listA</code>、<code>listB</code>。判断两个链表是否相交，相交则返回起始点，不相交则返回 <code>None</code>。<br><strong>示例：</strong></p><ul><li>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</li><li>输出：Intersected at ‘8’</li><li>解释：<ul><li>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</li><li>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</li><li>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/b82865bb7dd242542f1bf2012302c4d3.png#pic_center =500x" alt=""></p><h5 id="3-4-3-1-哈希表"><a href="#3-4-3-1-哈希表" class="headerlink" title="3.4.3.1 哈希表"></a>3.4.3.1 哈希表</h5><p>判断两个链表是否相交，可以使用哈希集合存储链表节点。</p><ol><li>遍历链表 headA，并将其中的每个节点加入哈希集合中。</li><li><p>遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：</p><ul><li>如果当前节点不在哈希集合中，则继续遍历下一个节点；</li><li>如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。</li><li>如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 <code>null</code></li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        se=<span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        cur1=headA</span><br><span class="line">        cur2=headB</span><br><span class="line">        <span class="keyword">while</span> cur1:</span><br><span class="line">            se.add(cur1)</span><br><span class="line">            cur1=cur1.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> cur2:</span><br><span class="line">            <span class="keyword">if</span> cur2 <span class="keyword">in</span> se:</span><br><span class="line">                <span class="keyword">return</span> cur                          </span><br><span class="line">            cur2=cur2.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h5 id="3-4-3-2-分离双指针"><a href="#3-4-3-2-分离双指针" class="headerlink" title="3.4.3.2 分离双指针"></a>3.4.3.2 分离双指针</h5><p>使用双指针的方法，可以将空间复杂度降至 $O(1)$ ：           </p><ul><li>使用两个指针 <code>pA</code> 、<code>pB</code>，分别从链表 <code>listA</code>、链表 <code>listB</code> 的头节点开始遍历。</li><li>直到<code>pA</code> 为空，将其指向<code>listB</code>的头结点，继续遍历</li><li>直到<code>pB</code> 为空，将其指向<code>listA</code>的头结点，继续遍历</li><li>当指针 <code>pA</code>和 <code>pB</code> 指向同一个节点或者都为空时，返回它们指向的节点或者 <code>null</code>。</li></ul><p>当两个链表相交时：<br><img src="https://img-blog.csdnimg.cn/7b27f6af274a4e30b0cc976bb0fac56b.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> headA == <span class="literal">None</span> <span class="keyword">or</span> headB == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pA = headA</span><br><span class="line">        pB = headB</span><br><span class="line">        <span class="keyword">while</span> pA != pB :</span><br><span class="line">            pA = pA.<span class="built_in">next</span> <span class="keyword">if</span> pA != <span class="literal">None</span> <span class="keyword">else</span> headB</span><br><span class="line">            pB = pB.<span class="built_in">next</span> <span class="keyword">if</span> pB != <span class="literal">None</span> <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> pA    </span><br></pre></td></tr></table></figure><h2 id="四、链表排序"><a href="#四、链表排序" class="headerlink" title="四、链表排序"></a>四、链表排序</h2><p>&#8195;&#8195;此部分内容请参考<a href="https://algo.itcharge.cn/02.Linked-List/02.Linked-List-Sort/01.Linked-List-Sort/">《算法通关手册》</a>   链表排序篇。</p><h3 id="4-1-基础知识"><a href="#4-1-基础知识" class="headerlink" title="4.1 基础知识"></a>4.1 基础知识</h3><p>&#8195;&#8195;在数组排序中，常见的排序算法有：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序等。<br>&#8195;&#8195;而对于链表排序而言，因为链表不支持随机访问，访问链表后面的节点只能依靠 next 指针从头部顺序遍历，所以相对于数组排序问题来说，链表排序问题会更加复杂一点。</p><ul><li>适合链表的排序算法：<strong>冒泡排序</strong>、<strong>选择排序</strong>、<strong>插入排序</strong>、<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>计数排序</strong>、<strong>桶排序</strong>、<strong>基数排序</strong>。</li><li>重点掌握：<font color='deeppink'><strong>链表插入排序</strong>、<strong>链表归并排序</strong> &lt;/font &gt;。</li><li>不适合链表的排序算法：<strong>希尔排序</strong>。</li><li>可以用于链表排序但不建议使用的排序算法：<strong>堆排序</strong>。</li></ul><blockquote><p>希尔排序为什么不适合链表排序？<br>&#8195;&#8195;<strong>希尔排序</strong>：希尔排序中经常涉及到对序列中第 <code>i + gap</code> 的元素进行操作，其中 <code>gap</code> 是希尔排序中当前的步长。而链表不支持随机访问的特性，导致这种操作不适合链表，因而希尔排序算法不适合进行链表排序。</p><p>为什么不建议使用堆排序？<br>&#8195;&#8195;<strong>堆排序</strong>：堆排序所使用的最大堆 / 最小堆结构本质上是一棵完全二叉树。而完全二叉树适合采用顺序存储结构（数组）。因为数组存储的完全二叉树可以很方便的通过下标序号来确定父亲节点和孩子节点，并且可以极大限度的节省存储空间。<br>&#8195;&#8195;而链表用在存储完全二叉树的时候，因为不支持随机访问的特性，导致其寻找子节点和父亲节点会比较耗时，如果增加指向父亲节点的变量，又会浪费大量存储空间。所以堆排序算法不适合进行链表排序。<br>&#8195;&#8195;如果一定要对链表进行堆排序，则可以使用额外的数组空间表示堆结构。然后将链表中各个节点的值依次添加入堆结构中，对数组进行堆排序。排序后，再按照堆中元素顺序，依次建立链表节点，构建新的链表并返回新链表头节点。</p></blockquote><p>链表插入排序</p><h3 id="4-2-链表插入排序"><a href="#4-2-链表插入排序" class="headerlink" title="4.2 链表插入排序"></a>4.2 链表插入排序</h3><p><strong>1. 算法步骤</strong>：</p><ol><li>先使用哑节点 <code>dummy_head</code> 构造一个指向 <code>head</code> 的指针，使得可以从 <code>head</code> 开始遍历。</li><li>维护 <code>sorted_list</code> 为链表的已排序部分的最后一个节点，初始时，<code>sorted_list = head</code>。</li><li>维护 <code>prev</code> 为插入元素位置的前一个节点，维护 <code>cur</code> 为待插入元素。初始时，<code>prev = head</code>，<code>cur = head.next</code>。</li><li><p>比较 <code>sorted_list</code> 和 <code>cur</code> 的节点值。</p><ul><li>如果 <code>sorted_list.val &lt;= cur.val</code>，说明 <code>cur</code> 应该插入到 <code>sorted_list</code> 之后，则将 <code>sorted_list</code> 后移一位。</li><li>如果 <code>sorted_list.val &gt; cur.val</code>，说明 <code>cur</code> 应该插入到 <code>head</code> 与 <code>sorted_list</code> 之间。则使用 <code>prev</code> 从 <code>head</code> 开始遍历，直到找到插入 <code>cur</code> 的位置的前一个节点位置。然后将 <code>cur</code> 插入。</li></ul></li><li><p>令 <code>cur = sorted_list.next</code>，此时 <code>cur</code> 为下一个待插入元素。</p></li><li>重复 4、5 步骤，直到 <code>cur</code> 遍历结束为空。返回 <code>dummy_head</code> 的下一个节点。</li></ol><p><strong>2. 实现代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">self, head: ListNode</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy_head.<span class="built_in">next</span> = head</span><br><span class="line">        sorted_list = head</span><br><span class="line">        cur = head.<span class="built_in">next</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> sorted_list.val &lt;= cur.val:</span><br><span class="line">                <span class="comment"># 将 cur 插入到 sorted_list 之后</span></span><br><span class="line">                sorted_list = sorted_list.<span class="built_in">next</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = dummy_head</span><br><span class="line">                <span class="keyword">while</span> prev.<span class="built_in">next</span>.val &lt;= cur.val:</span><br><span class="line">                    prev = prev.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 将 cur 到链表中间</span></span><br><span class="line">                sorted_list.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = prev.<span class="built_in">next</span></span><br><span class="line">                prev.<span class="built_in">next</span> = cur</span><br><span class="line">            cur = sorted_list.<span class="built_in">next</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="keyword">return</span> self.insertionSort(head)</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n^2)$。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h3 id="4-3-链表归并排序"><a href="#4-3-链表归并排序" class="headerlink" title="4.3 链表归并排序"></a>4.3 链表归并排序</h3><p><strong>1. 算法步骤</strong></p><ol><li><strong>分割环节</strong>：找到链表中心链节点，从中心节点将链表断开，并递归进行分割。<ol><li>使用快慢指针 <code>fast = head.next</code>、<code>slow = head</code>，让 <code>fast</code> 每次移动 <code>2</code> 步，<code>slow</code> 移动 <code>1</code> 步，移动到链表末尾，从而找到链表中心链节点，即 <code>slow</code>。</li><li>从中心位置将链表从中心位置分为左右两个链表 <code>left_head</code> 和 <code>right_head</code>，并从中心位置将其断开，即 <code>slow.next = None</code>。</li><li>对左右两个链表分别进行递归分割，直到每个链表中只包含一个链节点。</li></ol></li><li><strong>归并环节</strong>：将递归后的链表进行两两归并，完成一遍后每个子链表长度加倍。重复进行归并操作，直到得到完整的链表。<ol><li>使用哑节点 <code>dummy_head</code> 构造一个头节点，并使用 <code>cur</code> 指向 <code>dummy_head</code> 用于遍历。</li><li>比较两个链表头节点 <code>left</code> 和 <code>right</code> 的值大小。将较小的头节点加入到合并后的链表中，并向后移动该链表的头节点指针。</li><li>然后重复上一步操作，直到两个链表中出现链表为空的情况。</li><li>将剩余链表插入到合并后的链表中。</li><li>将哑节点 <code>dummy_dead</code> 的下一个链节点 <code>dummy_head.next</code> 作为合并后的头节点返回。</li></ol></li></ol><p><strong>2. 实现代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        <span class="comment"># 归并环节</span></span><br><span class="line">        dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line">        cur = dummy_head</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt;= right.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = left</span><br><span class="line">                left = left.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = right</span><br><span class="line">                right = right.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            cur.<span class="built_in">next</span> = left</span><br><span class="line">        <span class="keyword">elif</span> right:</span><br><span class="line">            cur.<span class="built_in">next</span> = right</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">self, head: ListNode</span>):</span></span><br><span class="line">        <span class="comment"># 分割环节</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 快慢指针找到中心链节点</span></span><br><span class="line">        slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span> </span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span> </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 断开左右链节点</span></span><br><span class="line">        left_head, right_head = head, slow.<span class="built_in">next</span> </span><br><span class="line">        slow.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 归并操作</span></span><br><span class="line">        <span class="keyword">return</span> self.merge(self.mergeSort(left_head), self.mergeSort(right_head))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="keyword">return</span> self.mergeSort(head)</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n \times \log_2n)$。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h3 id="4-4-链表排序题目"><a href="#4-4-链表排序题目" class="headerlink" title="4.4 链表排序题目"></a>4.4 链表排序题目</h3><div class="table-container"><table><thead><tr><th style="text-align:left">题号</th><th style="text-align:left">标题</th><th style="text-align:left">题解</th><th style="text-align:left">标签</th><th style="text-align:left">难度</th></tr></thead><tbody><tr><td style="text-align:left">0148</td><td style="text-align:left"><a href="https://leetcode.cn/problems/sort-list/">排序链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">链表、双指针、分治、排序、归并排序</td><td style="text-align:left">中等</td></tr><tr><td style="text-align:left">0021</td><td style="text-align:left"><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0021.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">递归、链表</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">0023</td><td style="text-align:left"><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并K个升序链表</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0023.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.md">Python</a></td><td style="text-align:left">链表、分治、堆（优先队列）、归并排序</td><td style="text-align:left">困难</td></tr><tr><td style="text-align:left">0147</td><td style="text-align:left"><a href="https://leetcode.cn/problems/insertion-sort-list/">对链表进行插入排序</a></td><td style="text-align:left"><a href="https://github.com/itcharge/LeetCode-Py/blob/main/Solutions/0147.%20%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.md">Python</a></td><td style="text-align:left">链表、排序</td><td style="text-align:left">中等</td></tr></tbody></table></div><h4 id="4-4-1-排序链表"><a href="#4-4-1-排序链表" class="headerlink" title="4.4.1 排序链表"></a>4.4.1 排序链表</h4><blockquote><p>题目链接：<a href="https://leetcode.cn/problems/sort-list/">0148. 排序链表</a></p></blockquote><p>给定链表的头节点 <code>head</code>，请按照升序排列并返回排序后的链表。</p><ul><li>链表中节点的数目在范围 $[0, 5 * 10^4]$ 内。</li><li>$-10^5 \le Node.val \le 10^5$。</li></ul><p>&#8195;&#8195;本题使用链表的冒泡排序、选择排序、插入排序、快速排序都会超时。使用桶排序、归并排序、计数排序则可以通过，基数排序只适用于非负数的情况。归并排序代码上面已给出，其它排序算法请参考<a href="https://algo.itcharge.cn/02.Linked-List/02.Linked-List-Sort/01.Linked-List-Sort/">《算法通关手册》</a>    </p><h4 id="4-4-2-合并K个升序链表"><a href="#4-4-2-合并K个升序链表" class="headerlink" title="4.4.2 合并K个升序链表"></a>4.4.2 合并K个升序链表</h4><blockquote><p>题目链接：  <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">023 合并K个升序链表</a> </p></blockquote><p>&#8195;&#8195;给定一个链表数组，每个链表都已经按照升序排列。要求将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>&#8195;&#8195;首先，何在 $O(n)$ 的时间代价以及 $O(1)$ 的空间代价里完成两个有序链表的合并？为了达到空间代价是 $O(1)$，我们的宗旨是「原地调整链表元素的<code>next</code>指针完成合并」，具体参考本文的《3.4.2 合并两个有序链表》。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        cur = dummy_head</span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"><span class="comment"># 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        cur.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> list2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h5 id="4-4-2-1-顺序合并"><a href="#4-4-2-1-顺序合并" class="headerlink" title="4.4.2.1 顺序合并"></a>4.4.2.1 顺序合并</h5><p>&#8195;&#8195;我们可以想到一种最朴素的方法：用一个变量 <code>ans</code>来维护以及合并链表，第 <code>i</code> 次循环把第 <code>i</code> 个链表和 <code>ans</code>合并，答案保存到 <code>ans</code>中。</p><p><img src="https://img-blog.csdnimg.cn/eb3ca867418a4c9dba955cd56f86eb80.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lists)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>                </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans=lists[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> lists[<span class="number">1</span>:]:</span><br><span class="line">                ans=self.mergeTwoLists(ans,i)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        cur = dummy_head</span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"><span class="comment"># 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        cur.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> list2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span>    </span><br></pre></td></tr></table></figure><h5 id="4-4-2-2-分治合并"><a href="#4-4-2-2-分治合并" class="headerlink" title="4.4.2.2 分治合并"></a>4.4.2.2 分治合并</h5><p>&#8195;&#8195;分而治之的思想。将链表数组不断二分，转为规模为二分之一的子问题，然后再进行归并排序。<br><img src="https://img-blog.csdnimg.cn/0ca3685d8cff48c0971924a210850cd9.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">self, lists: <span class="type">List</span>[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> lists[left]</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        node_left = self.merge_sort(lists, left, mid)</span><br><span class="line">        node_right = self.merge_sort(lists, mid + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> self.merge(node_left, node_right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, a: ListNode, b: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        root = ListNode(-<span class="number">1</span>)</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> a <span class="keyword">and</span> b:</span><br><span class="line">            <span class="keyword">if</span> a.val &lt; b.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = a</span><br><span class="line">                a = a.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = b</span><br><span class="line">                b = b.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> a:</span><br><span class="line">            cur.<span class="built_in">next</span> = a</span><br><span class="line">        <span class="keyword">if</span> b:</span><br><span class="line">            cur.<span class="built_in">next</span> = b</span><br><span class="line">        <span class="keyword">return</span> root.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        size = <span class="built_in">len</span>(lists)</span><br><span class="line">        <span class="keyword">return</span> self.merge_sort(lists, <span class="number">0</span>, size - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/af35828c23c64ab184b9f7a191133d0f.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;@[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要参考&lt;a href=&quot;https://algo.itcharge.cn/&quot;&gt;《算法通关手册》&lt;/a&gt;链表篇&lt;/p&gt;
&lt;h2 id=&quot;一、链表基础&quot;&gt;&lt;a href=&quot;#一、链表基础&quot; class=&quot;headerlink&quot; title=&quot;一、链表基础&quot;&gt;&lt;/a&gt;一、链表基础&lt;/h2&gt;&lt;h3 id=&quot;1-1-无序表（UnorderedList）&quot;&gt;&lt;a href=&quot;#1-1-无序表（UnorderedList）&quot; class=&quot;headerlink&quot; title=&quot;1.1 无序表（UnorderedList）&quot;&gt;&lt;/a&gt;1.1 无序表（UnorderedList）&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;&amp;#8195;&amp;#8195; &lt;strong&gt;链表（Linked List）&lt;/strong&gt;：一种线性表数据结构。它使用一组任意的存储单元（可以是连续的，也可以是不连续的），来存储一组具有相同类型的数据。简单来说，&lt;strong&gt;「链表」&lt;/strong&gt; 是实现线性表链式存储结构的基础。&lt;/p&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;虽然列表数据结构要求保持数据项的前后相对位置，但这种前后位置的保持，&lt;strong&gt;并不要求数据项依次存放在连续的存储空间&lt;/strong&gt;。如下图，数据项存放位置并没有规则，但如果在数据项之间建立链接指向，就可以保持其前后相对位置。第一个和最后一个数据项需要显示标记出来，一个是队首，一个是队尾，后面再无数据了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入删除元素时需要移动表中元素，而不是修改指针，顺序表也是随机存取数据。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/976032d0441941e890bb51d86205832a.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;</summary>
    
    
    
    <category term="Data Structure and Algorithms" scheme="https://zhxnlp.github.io/categories/Data-Structure-and-Algorithms/"/>
    
    
    <category term="leetcode" scheme="https://zhxnlp.github.io/tags/leetcode/"/>
    
    <category term="Linked List" scheme="https://zhxnlp.github.io/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习二：排序</title>
    <link href="https://zhxnlp.github.io/2023/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode%E7%BB%83%E4%B9%A0%E4%BA%8C%EF%BC%9A%E6%8E%92%E5%BA%8F/"/>
    <id>https://zhxnlp.github.io/2023/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode%E7%BB%83%E4%B9%A0%E4%BA%8C%EF%BC%9A%E6%8E%92%E5%BA%8F/</id>
    <published>2023-02-12T16:00:00.000Z</published>
    <updated>2023-04-08T00:35:54.151Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>资源：<a href="https://leetcode.cn/problemset/all/">力扣题库</a>、<a href="https://algo.itcharge.cn/00.Introduction/05.Categories-List/">LeetCode 刷题列表</a>、<a href="https://programmercarl.com/">代码随想录</a></p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>参考<a href="https://algo.itcharge.cn/01.Array/02.Array-Sort/01.Array-Bubble-Sort/">《数组排序》</a>、<a href="https://blog.csdn.net/Dby_freedom/article/details/82154869">《排序算法总结（Python版）》</a></p></blockquote><h2 id="一、排序算法"><a href="#一、排序算法" class="headerlink" title="一、排序算法"></a>一、排序算法</h2><h3 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1  冒泡排序"></a>1.1  冒泡排序</h3><h4 id="1-1-1-算法步骤"><a href="#1-1-1-算法步骤" class="headerlink" title="1.1.1 算法步骤"></a>1.1.1 算法步骤</h4><p>&#8195;&#8195;<strong>冒泡排序（<code>Bubble Sort</code>）基本思想</strong>：通过相邻元素之间的比较与交换，使值较小的元素逐步从后面移到前面，值较大的元素从前面移到后面。这个过程就像水底的气泡一样向上冒，这也是冒泡排序法名字的由来。</p><p><strong>动画演示：</strong><br><img src="https://img-blog.csdnimg.cn/bf8b6bcf68ef4e23ade1157ba48fabd3.gif#pic_center" alt="在这里插入图片描述"></p><span id="more"></span><h4 id="1-1-2-算法分析"><a href="#1-1-2-算法分析" class="headerlink" title="1.1.2 算法分析"></a>1.1.2 算法分析</h4><ul><li>时间复杂度：$O(n)$到$O(n^2)$</li><li>冒泡排序适用情况：冒泡排序方法在排序过程中需要移动较多次数的元素，并且排序时间效率比较低。因此，冒泡排序方法比较适合于参加排序序列的数据量较小的情况，尤其是当序列的初始状态为基本有序的情况。</li><li>排序稳定性：由于元素交换是在相邻元素之间进行的，不会改变值相同元素的相对位置，因此，冒泡排序法是一种 稳定排序算法。</li></ul><h4 id="1-1-3-代码实现："><a href="#1-1-3-代码实现：" class="headerlink" title="1.1.3 代码实现："></a>1.1.3 代码实现：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 第 i 趟排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 大数排后，所以每次是从序列中前 n-i+1 个元素的第1个元素开始，相邻两个元素进行比较</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - i - <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 相邻两个元素进行比较，如果前者大于后者，则交换位置</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">                    nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortnumsay</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.bubbleSort(nums)</span><br></pre></td></tr></table></figure><h4 id="1-1-4-冒泡排序优化"><a href="#1-1-4-冒泡排序优化" class="headerlink" title="1.1.4 冒泡排序优化"></a>1.1.4 冒泡排序优化</h4><p>&#8195;&#8195;<strong>优化1：</strong> 某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort2</span>(<span class="params">nums</span>):</span></span><br><span class="line">n = <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">flag = <span class="literal">True</span>    <span class="comment"># 标记</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - i):</span><br><span class="line"><span class="keyword">if</span> nums[j] &lt; nums[j-<span class="number">1</span>]:</span><br><span class="line">nums[j], nums[j-<span class="number">1</span>] = nums[j-<span class="number">1</span>], nums[j]</span><br><span class="line">flag = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了</span></span><br><span class="line"><span class="keyword">if</span> flag:    </span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;<strong>优化2：</strong> 记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。            </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort3</span>(<span class="params">nums</span>):</span></span><br><span class="line">n = <span class="built_in">len</span>(nums)</span><br><span class="line">k = n    <span class="comment">#k为循环的范围，初始值n</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k):    <span class="comment">#只遍历到最后交换的位置即可</span></span><br><span class="line"><span class="keyword">if</span> nums[j-<span class="number">1</span>] &gt; nums[j]:</span><br><span class="line">nums[j-<span class="number">1</span>], nums[j] = nums[j], nums[j-<span class="number">1</span>]</span><br><span class="line">k = j     <span class="comment">#记录最后交换的位置</span></span><br><span class="line">flag = <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h3 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2  选择排序"></a>1.2  选择排序</h3><p>&#8195;&#8195;<strong>选择排序（<code>Selection Sort</code>）基本思想</strong>：每一趟排序中，从未排序部分中选出一个值最小的元素，与未排序部分第 1 个元素交换位置，从而将该元素划分到已排序部分。</p><h4 id="1-2-1-算法步骤"><a href="#1-2-1-算法步骤" class="headerlink" title="1.2.1 算法步骤"></a>1.2.1 算法步骤</h4><ol><li>第 <code>1</code> 趟排序：<ol><li>无已排序部分，把第 <code>1</code> ~ <code>n</code>个元素（总共 <code>n</code> 个元素）作为未排序部分。</li><li>遍历 <code>n</code> 个元素，使用变量 <code>min_i</code> 记录 <code>n</code> 个元素中值最小的元素位置。</li><li>将 <code>min_i</code> 与未排序部分第 <code>1</code> 个元素（也就是序列的第 <code>1</code> 个元素）交换位置。如果未排序部分第 <code>1</code> 个元素就是值最小的元素位置，则不用交换。</li><li>此时第 <code>1</code> 个元素为已排序部分，剩余第 <code>2</code> ~ <code>n</code> 个元素（总共 <code>n - 1</code> 个元素）为未排序部分。</li></ol></li><li>第 <code>2</code> 趟排序：<ol><li>遍历剩余 <code>n - 1</code> 个元素，使用变量 <code>min_i</code> 记录 <code>n - 1</code> 个元素中值最小的元素位置。</li><li>将 <code>min_i</code> 与未排序部分第 <code>1</code> 个元素（也就是序列的第 <code>2</code> 个元素）交换位置。如果未排序部分第 <code>1</code> 个元素就是值最小的元素位置，则不用交换。</li><li>此时第 <code>1</code> ~ <code>2</code> 个元素为已排序部分，剩余第 <code>3</code> ~ <code>n</code> 个元素（总共 <code>n - 2</code> 个元素）为未排序部分。</li></ol></li><li>依次类推，对剩余 <code>n - 2</code> 个元素重复上述排序过程，直到所有元素都变为已排序部分，则排序结束。</li></ol><p><strong>动画演示</strong><br><img src="https://img-blog.csdnimg.cn/d757b3aac927414fa515eb853c6f7a48.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="1-2-2-算法分析"><a href="#1-2-2-算法分析" class="headerlink" title="1.2.2 算法分析"></a>1.2.2 算法分析</h4><ul><li><strong>时间复杂度</strong>：$O(n^2)$。<br>排序法所进行的元素之间的比较次数与序列的原始状态无关，时间复杂度总是 $O(n^2)$。这是因为无论序列中元素的初始排列状态如何，第 i 趟排序要找出值最小元素都需要进行 n − i 次元素之间的比较。因此，整个排序过程需要进行的元素之间的比较次数都相同，为 $\sum_{i=2}^{n}(i-1)=\frac{n(n-1)}{2}$ 次。</li><li><strong>适用情况</strong>：选择排序方法在排序过程中需要移动较多次数的元素，并且排序时间效率比较低。因此，选择排序方法比较适合于参加排序序列的数据量较小的情况。选择排序的主要优点是仅需要原地操作无需占用其他空间就可以完成排序，因此在空间复杂度要求较高时，可以考虑选择排序。</li><li><strong>排序稳定性</strong>：由于值最小元素与未排序部分第 1 个元素的交换动作是在不相邻的元素之间进行的，因此很有可能会改变值相同元素的前后位置，因此，选择排序法是一种 不稳定排序算法。</li><li><strong>对比冒泡排序</strong>：<ul><li>选择排序对冒泡排序进行了改进，保留了其基本的多趟比对思路，每趟都使当前最大项就位。</li><li>但选择排序对交换进行了削减，相比起冒泡排序进行多次交换，每趟仅进行1次交换，即记录最大项的所在位置，最后再跟本趟最后一项交换。</li><li>选择排序的时间复杂度比冒泡排序潲优。比对次数不变，还是$O(n^2)$，交换次数则减少为$O(n)$。<h4 id="1-2-3-代码实现"><a href="#1-2-3-代码实现" class="headerlink" title="1.2.3 代码实现"></a>1.2.3 代码实现</h4></li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 记录未排序部分中最小值的位置</span></span><br><span class="line">            min_i = i</span><br><span class="line">            <span class="comment"># 序列分成两部分，前i个是已排序部分，i+1到le是未排序部分</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[min_i]:</span><br><span class="line">                    min_i = j</span><br><span class="line">            <span class="comment"># 如果找到最小值的位置，将 i 位置上元素与最小值位置上的元素进行交换</span></span><br><span class="line">            <span class="keyword">if</span> i != min_i:</span><br><span class="line">                nums[i], nums[min_i] = nums[min_i], nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortnumsay</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.selectionSort(nums)</span><br></pre></td></tr></table></figure><h3 id="1-3-插入排序"><a href="#1-3-插入排序" class="headerlink" title="1.3 插入排序"></a>1.3 插入排序</h3><p>&#8195;&#8195;<strong>插入排序（<code>Insertion Sort</code>）基本思想</strong>：将整个序列分为两部分：前面 <code>i</code> 个元素为有序序列，后面 <code>n - i</code> 个元素为无序序列。每一次排序，将无序序列的第 <code>1</code> 个元素，在有序序列中找到相应的位置并插入。</p><p><img src="https://img-blog.csdnimg.cn/1c5fea9a1fde4735b66e5173a9cf71c2.png#pic_center" alt="在这里插入图片描述"></p><h4 id="1-3-1-算法步骤"><a href="#1-3-1-算法步骤" class="headerlink" title="1.3.1 算法步骤"></a>1.3.1 算法步骤</h4><ol><li>第 <code>1</code> 趟排序：<ol><li>第 <code>1</code> 个元素为有序序列，后面第 <code>2</code> ~ <code>n</code>个元素（总共 <code>n - 1</code> 个元素）为无序序列。</li><li>从右至左遍历有序序列中的元素，如果遇到「有序序列的元素 &gt; 无序序列的第 <code>1</code> 个元素」的情况时，则将向有序序列的元素后移动一位。</li><li>如果遇到「有序序列的元素 &lt;= 无序序列的第 <code>1</code> 个元素」的情况或者「到达数组开始位置」时，则说明找到了插入位置。将「无序序列的第 <code>1</code> 个元素」插入该位置。</li></ol></li><li><p>第 <code>2</code> 趟排序：</p><ol><li>第 <code>1</code> ~ <code>2</code> 个元素为有序序列，后面第 <code>3</code> ~ <code>n</code> 个元素（总共 <code>n - 2</code> 个元素）为无序序列。</li><li>从右至左遍历有序序列中的元素，如果遇到「有序序列的元素 &gt; 无序序列的第 <code>1</code> 个元素」的情况时，则将向有序序列的元素后移动一位。</li><li>如果遇到「有序序列的元素 &lt;= 无序序列的第 <code>1</code> 个元素」的情况或者「到达数组开始位置」时，则说明找到了插入位置。将「无序序列的第 <code>1</code> 个元素」插入该位置。</li></ol></li><li><p>依次类推，对剩余 <code>n - 3</code> 个元素重复上述排序过程，直到所有元素都变为有序序列，则排序结束。</p></li></ol><p>简单来说，插入排序的算法步骤为：</p><ol><li>先将第 <code>1</code> 个元素作为一个有序序列，将第 <code>2</code> ~ <code>n</code> 个元素作为无序序列。</li><li>从左到右遍历一遍无序序列，对于无序序列中的每一个元素：<ol><li>遍历有序序列，找到适当的插入位置。</li><li>将有序序列中插入位置右侧的元素依次右移一位。</li><li>将该元素插入到适当位置</li></ol></li></ol><p><strong>动画演示：</strong></p><p><img src="https://img-blog.csdnimg.cn/9f57aa9917124290b62e30bbc5c08df6.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="1-3-2-算法分析"><a href="#1-3-2-算法分析" class="headerlink" title="1.3.2 算法分析"></a>1.3.2 算法分析</h4><p>&#8195;&#8195;插入排序比对操作主要是用来寻找新元素的待插入位置，而插入位置是靠倒序遍历前面有序数组来找到的。</p><ul><li><strong>最佳时间复杂度</strong>：$O(n)$。<br>最好的情况下，初始序列已经是升序排列，这样每个新元素只需要进行一次元素之间的比较， 总共只需要比对n − 1次，也完全并不需要移动有序数组的元素，此时时间复杂度是$O(n)$</li><li><strong>最差时间复杂度</strong>：$O(n^2)$。<br>最差的情况下，初始序列已经是降序排列，对应的每个 <code>i</code> 值都要进行 <code>i - 1</code> 次元素之间的比较，总的元素之间的比较次数达到最大值，为 $∑^n_{i=2}(i − 1) = \frac{n(n−1)}{2}$。</li><li><strong>平均时间复杂度</strong>：$O(n^2)$。如果序列的初始情况是随机的，即参加排序的序列中元素可能出现的各种排列的概率相同，则可取上述最小值和最大值的平均值作为插入排序时所进行的元素之间的比较次数，约为 $\frac{n^2}{4}$。由此得知，插入排序算法的时间复杂度 $O(n^2)$。</li><li><strong>排序稳定性</strong>：插入排序方法是一种 <strong>稳定排序算法</strong>。<h4 id="1-3-3-代码实现"><a href="#1-3-3-代码实现" class="headerlink" title="1.3.3 代码实现"></a>1.3.3 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 遍历无序序列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            temp = nums[i] <span class="comment"># 保存无序序列第一个元素的值，因为后面会有有序序列右移，覆盖此值</span></span><br><span class="line">            j = i <span class="comment"># 初始化插入位置</span></span><br><span class="line">            <span class="comment"># 从右至左遍历有序序列</span></span><br><span class="line">            <span class="comment"># 如果有序序列中的元素大于无序序列第一个元素，就将其右移一位</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> nums[j - <span class="number">1</span>] &gt; temp:</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 将该元素值插入到适当位置</span></span><br><span class="line">            nums[j] = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortnumsay</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.insertionSort(nums)</span><br></pre></td></tr></table></figure>也可以都改成for语句：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 遍历无序序列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            temp = nums[i] <span class="comment"># 保存当前元素值</span></span><br><span class="line">            <span class="comment"># 从右至左遍历有序序列</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> nums[j - <span class="number">1</span>] &gt; temp:</span><br><span class="line">                <span class="comment"># 将有序序列中插入位置右侧的元素依次右移一位</span></span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 将该元素插入到适当位置</span></span><br><span class="line">            nums[j] = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortnumsay</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.insertionSort(nums)</span><br></pre></td></tr></table></figure><h3 id="1-4-希尔排序"><a href="#1-4-希尔排序" class="headerlink" title="1.4 希尔排序"></a>1.4 希尔排序</h3>&#8195;&#8195;从上面分析可以知道，插入排序在初始序列升序排列时，时间复杂度最低。实际上，<font color='deeppink'>序列越是有序（升序），插入排序的比对次数就越少。</font></li></ul><p>&#8195;&#8195;希尔排序从此入手，对无序列表进行间隔划分，然后对每个子列表进行插入排序。随着子列表数越来越少，整个无序表也越来越有序，从而减少整体排序的比对次数。</p><p>&#8195;&#8195;<strong>希尔排序（<code>Shell Sort</code>）基本思想</strong>：将整个序列切按照一定的间隔值（<code>gap</code>）划分为若干个子序列，每个子序列分别排序。然后逐渐缩小<code>gap</code>值，进行下一次排序，直至<code>gap=1</code>。</p><h4 id="1-4-1-算法步骤"><a href="#1-4-1-算法步骤" class="headerlink" title="1.4.1 算法步骤"></a>1.4.1 算法步骤</h4><ol><li>确定一个元素间隔数 <code>gap</code>。</li><li>将参加排序的序列按此间隔数从第 <code>1</code> 个元素开始一次分成若干个子序列，即分别将所有位置相隔为 <code>gap</code> 的元素视为一个子序列。</li><li>在各个子序列中采用某种排序算法（例如插入排序算法）进行排序。</li><li>减少间隔数，并重新将整个序列按新的间隔数分成若干个子序列，再分别对各个子序列进行排序。依次类推，直到间隔数 <code>gap = 1</code>，排序结束。</li></ol><p><strong>图解演示：</strong><br><img src="https://img-blog.csdnimg.cn/3a831b253bf04786abe3879c0c473f07.png#pic_center" alt="在这里插入图片描述"></p><h4 id="1-4-2-算法分析"><a href="#1-4-2-算法分析" class="headerlink" title="1.4.2 算法分析"></a>1.4.2 算法分析</h4><ul><li><p><strong>时间复杂度</strong>：介于 $O(n \times \log_2 n)$ 与 $O(n^2)$ 之间。</p><ul><li>希尔排序方法的速度是一系列间隔数 $gap_i$ 的函数，而比较次数与 $gap_i$ 之间的依赖关系比较复杂，不太容易给出完整的数学分析。</li><li>由于采用 $gap<em>i = \lfloor gap</em>{i-1}/2 \rfloor$ 的方法缩小间隔数，对于具有 $n$ 个元素的序列，若 $gap_1 = \lfloor n/2 \rfloor$，则经过 $p = \lfloor \log_2 n \rfloor$ 趟排序后就有 $gap_p = 1$，因此，希尔排序方法的排序总躺数为 $\lfloor \log_2 n \rfloor$。</li><li>从算法中也可以看到，最外层的 <code>while</code> 循环为 $\log_2 n$ 数量级，中间层 <code>do-while</code> 循环为 <code>n</code> 数量级。当子序列分得越多时，子序列内的元素就越少，最内层的 <code>for</code> 循环的次数也就越少；反之，当所分的子序列个数减少时，子序列内的元素也随之增多，但整个序列也逐步接近有序，而循环次数却不会随之增加。因此，希尔排序算法的时间复杂度在 $O(n \times \log_2 n)$ 与 $O(n^2)$ 之间。</li></ul></li><li><p><strong>排序稳定性</strong>：希尔排序方法是一种 <strong>不稳定排序算法</strong>。</p></li></ul><h4 id="1-4-3-代码实现："><a href="#1-4-3-代码实现：" class="headerlink" title="1.4.3 代码实现："></a>1.4.3 代码实现：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shellSort</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        gap = size // <span class="number">2</span></span><br><span class="line"><span class="comment"># 按照 gap 分组</span></span><br><span class="line">        <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 对每组元素进行插入排序</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, size):</span><br><span class="line">                <span class="comment"># temp 为每组中无序序列第 1 个元素</span></span><br><span class="line">                temp = nums[i]</span><br><span class="line">                j = i</span><br><span class="line">                <span class="comment"># 从右至左遍历每组中的有序序列元素</span></span><br><span class="line">                <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> nums[j - gap] &gt; temp:</span><br><span class="line">                    <span class="comment"># 将每组有序序列中插入位置右侧的元素依次在组中右移一位</span></span><br><span class="line">                    nums[j] = nums[j - gap]</span><br><span class="line">                    j -= gap</span><br><span class="line">                <span class="comment"># 将该元素插入到适当位置</span></span><br><span class="line">                nums[j] = temp</span><br><span class="line">            <span class="comment"># 缩小 gap 间隔</span></span><br><span class="line">            gap = gap // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortnumsay</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.shellSort(nums)</span><br></pre></td></tr></table></figure><h3 id="1-5-归并排序"><a href="#1-5-归并排序" class="headerlink" title="1.5 归并排序"></a>1.5 归并排序</h3><p>&#8195;&#8195;<strong>归并排序（<code>Merge Sort</code>）基本思想</strong>：采用经典的分治策略，先递归地将当前序列平均分成两半。然后将有序序列两两合并，最终合并成一个有序序列。</p><h4 id="1-5-1-算法步骤"><a href="#1-5-1-算法步骤" class="headerlink" title="1.5.1 算法步骤"></a>1.5.1 算法步骤</h4><ul><li>分割过程：先递归地将当前序列平均分成两半，直到子序列长度为 1。<ul><li>找到序列中心位置 <code>mid</code>，从中心位置将序列分成左右两个子序列 <code>left_arr</code>、<code>right_arr</code>。</li><li>对左右两个子序列 <code>left_arr</code>、<code>right_arr</code> 分别进行递归分割。</li><li>最终将数组分割为 n 个长度均为 1 的有序子序列。</li></ul></li><li>归并过程：从长度为 1 的有序子序列开始，依次进行两两归并，直到合并成一个长度为 n 的有序序列。<ul><li>使用数组变量 <code>arr</code> 存放归并后的有序数组。</li><li>使用两个指针 <code>left</code>、<code>right</code>分别指向两个有序子序列 left_arr、right_arr 的开始位置。</li><li>比较两个指针指向的元素，将两个有序子序列中较小元素依次存入到结果数组 <code>arr</code> 中，并将指针移动到下一位置。</li><li>重复步骤 3，直到某一指针到达子序列末尾。</li><li>将另一个子序列中的剩余元素存入到结果数组 <code>arr</code> 中。</li><li>返回归并后的有序数组 <code>arr</code>。</li></ul></li></ul><p><strong>动画演示：</strong><br><img src="https://img-blog.csdnimg.cn/188fd7e2ca0047f1900c0265434f1574.gif#pic_center" alt="在这里插入图片描述"></p><ul><li>将序列分为为 [6]，[2]，[1]，[3]，[7]，[5]，[4]，[8]。</li><li>第 1 趟排序：将子序列中的有序子序列两两归并，归并后的子序列为：[2, 6]，[1, 3]，[5, 7]，[4, 8]。</li><li>第 2 趟排序：将子序列中的有序子序列两两归并，归并后的子序列为：[1, 2, 3, 6]，[4, 5, 7, 8]。</li><li>第 3 趟排序：将子序列中的有序子序列两两归并，归并后的子序列为：[1, 2, 3, 4, 5, 6, 7, 8]。得到长度为 n 的有序序列，排序结束。<h4 id="1-5-2-算法分析"><a href="#1-5-2-算法分析" class="headerlink" title="1.5.2 算法分析"></a>1.5.2 算法分析</h4></li><li><strong>时间复杂度</strong>：$O(n \times \log_2n)$。归并排序算法的时间复杂度等于归并趟数与每一趟归并的时间复杂度乘积。子算法 <code>merge(left_arr, right_arr):</code> 的时间复杂度是 $O(n)$，因此，归并排序算法总的时间复杂度为 $O(n \times \log_2 n)$。</li><li><strong>空间复杂度</strong>：$O(n)$。归并排序方法需要用到与参加排序的序列同样大小的辅助空间。因此算法的空间复杂度为 $O(n)$。</li><li><strong>排序稳定性</strong>：归并排序算法是一种 <strong>稳定排序算法</strong>。<ul><li>因为在两个有序子序列的归并过程中，如果两个有序序列中出现相同元素，<code>merge(left_arr, right_arr):</code> 算法能够使前一个序列中那个相同元素先被复制，从而确保这两个元素的相对次序不发生改变。<h4 id="1-5-3-代码实现："><a href="#1-5-3-代码实现：" class="headerlink" title="1.5.3 代码实现："></a>1.5.3 代码实现：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.merge(nums)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,arr</span>):</span><span class="comment"># 分割过程</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(arr)&lt;=<span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> arr    <span class="comment"># 数组元素个数小于等于 1 时，直接返回原数组</span></span><br><span class="line">        mid=<span class="built_in">len</span>(arr)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># 注意，这里是递归的写法</span></span><br><span class="line">        left_arr=self.merge(arr[:mid])</span><br><span class="line">        right_arr=self.merge(arr[mid:])</span><br><span class="line">        <span class="keyword">return</span> self.mergesort(left_arr,right_arr) </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergesort</span>(<span class="params">self,left_arr,right_arr</span>):</span> <span class="comment"># 归并过程</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        arr=[]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将两个有序子序列中较小元素依次插入到结果数组中</span></span><br><span class="line">        <span class="comment"># 注意，这里都是&lt;，不能取=,因为left_arr[len(left_arr)]是超出索引的        </span></span><br><span class="line">        <span class="keyword">while</span> left&lt;<span class="built_in">len</span>(left_arr) <span class="keyword">and</span> right&lt;<span class="built_in">len</span>(right_arr):</span><br><span class="line">            <span class="keyword">if</span> left_arr[left]&lt;right_arr[right]:</span><br><span class="line">                arr.append(left_arr[left])</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr.append(right_arr[right])</span><br><span class="line">                right+=<span class="number">1</span>  </span><br><span class="line">                </span><br><span class="line"><span class="comment"># 如果子序列有剩余元素，则将其插入到结果数组中</span></span><br><span class="line">        arr=arr+left_arr[left:]+right_arr[right:]             </span><br><span class="line">               </span><br><span class="line">        <span class="keyword">return</span> arr                            </span><br></pre></td></tr></table></figure><h3 id="1-6-快速排序"><a href="#1-6-快速排序" class="headerlink" title="1.6 快速排序"></a>1.6 快速排序</h3>&#8195;&#8195;<strong>快速排序（Quick Sort）基本思想：</strong> 根据序列的中值将序列分为两半，前一半都小于中值，后一半都大于中值，然后每部分再进行递归的快速排序。<h4 id="1-6-1-算法步骤"><a href="#1-6-1-算法步骤" class="headerlink" title="1.6.1 算法步骤"></a>1.6.1 算法步骤</h4>&#8195;&#8195;<strong>递归结束条件</strong>：序列只有一个元素，不需要再排序<br>&#8195;&#8195;<strong>中值选取</strong>：每次根据中值将序列分为规模相等的两半是最好的情况，此时中值就是序列的中位数，但是寻找中位数也需要开销，所以可以所以找一个数作为中值，比如序列的第一个数。</li></ul></li></ul><p><strong>分裂过程：</strong> 目标是找到“中值”的位置。</p><ul><li>设置左右标(left/right)</li><li>左标向右移动，右标向左移动</li><li>左标一直向右移动，碰到比中值大的就停止；右标一直向左移动，碰到比中值小的就停止。然后把左右标所指的数据项交换，</li><li>继续移动，直到左标移到右标的右侧，停止移动。这时右标所指位置就是“中值”应处的位置，将中值和这个位置交换，并记录此时中值的位置。这样就分裂完成，左半部分比中值小，右半部分比中值大。</li><li><strong>图解演示：</strong><br><img src="https://img-blog.csdnimg.cn/0e5c48609cdf4b7e8388170ad95df062.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e809a598098147e4ad76c11a68ea21c2.png" alt="在这里插入图片描述"><br>动画演示：<br><img src="https://img-blog.csdnimg.cn/d1b11ad705a04991809615b1f70e6b09.gif#pic_center" alt="在这里插入图片描述"><h4 id="1-6-2-算法分析"><a href="#1-6-2-算法分析" class="headerlink" title="1.6.2 算法分析"></a>1.6.2 算法分析</h4>&#8195;&#8195;快速排序算法的时间复杂度主要跟基准数的选择有关。本文中是将当前序列中第 <code>1</code> 个元素作为基准值。在这种选择下，如果参加排序的元素初始时已经有序的情况下，快速排序方法花费的时间最长。也就是会得到最坏时间复杂度。</li></ul><p>&#8195;&#8195;在这种情况下，第 <code>1</code> 趟排序经过 <code>n - 1</code> 次比较以后，将第 <code>1</code> 个元素仍然确定在原来的位置上，并得到 <code>1</code> 个长度为 <code>n - 1</code> 的子序列。第 <code>2</code> 趟排序进过 <code>n - 2</code> 次比较以后，将第 <code>2</code> 个元素确定在它原来的位置上，又得到 <code>1</code> 个长度为 <code>n - 2</code> 的子序列。</p><p>&#8195;&#8195;最终总的比较次数为 $(n − 1) + (n − 2) + … + 1 = \frac{n(n − 1)}{2}$。因此这种情况下的时间复杂度为 $O(n^2)$，也是最坏时间复杂度，这种情况一般不会发生。</p><p>&#8195;&#8195;而在平均情况下，我们可以从当前序列中随机选择一个元素作为基准数。这样，每一次选择的基准数可以看做是等概率随机的。其期望时间复杂度为 $O(n \times \log_2n)$，也就是平均时间复杂度。</p><p>下面来总结一下：</p><ul><li><strong>最佳时间复杂度</strong>：$O(n \times \log_2n)$。每一次选择的基准数都是当前序列的中位数，此时算法时间复杂度满足的递推式为 $T(n) = 2 \times T(\frac{n}{2}) + \Theta(n)$，由主定理可得 $T(n) = O(n \times \log_2n)$。</li><li><strong>最坏时间复杂度</strong>：$O(n^2)$。每一次选择的基准数都是序列的最终位置上的值，此时算法时间复杂度满足的递推式为 $T(n) = T(n - 1) + \Theta(n)$，累加可得 $T(n) = O(n^2)$。</li><li><strong>平均时间复杂度</strong>：$O(n \times \log_2n)$。在平均情况下，每一次选择的基准数可以看做是等概率随机的。其期望时间复杂度为 $O(n \times \log_2n)$。</li><li><strong>空间复杂度</strong>：$O(n)$。无论快速排序算法递归与否，排序过程中都需要用到堆栈或其他结构的辅助空间来存放当前待排序序列的首、尾位置。最坏的情况下，空间复杂度为 $O(n)$。如果对算法进行一些改写，在一趟排序之后比较被划分所得到的两个子序列的长度，并且首先对长度较短的子序列进行快速排序，这时候需要的空间复杂度可以达到 $O(log_2 n)$。</li><li><strong>排序稳定性</strong>：快速排序是一种 <strong>不稳定排序算法</strong>。<h4 id="1-6-3-代码实现："><a href="#1-6-3-代码实现：" class="headerlink" title="1.6.3 代码实现："></a>1.6.3 代码实现：</h4>&#8195;&#8195;从待排序列中找到一个基准数 <code>pivot</code>（这里取序列第一个元素），将比 <code>pivot</code>小的元素都移到序列左侧，比 <code>pivot</code>大的都移到序列右侧。这样就将待排序列分成了<code>[start,pivot-1]</code>、<code>pivot</code>和<code>[pivot+1,end]</code>三部分。再分别对前后两部分递归调用快速排序。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">nums</span>):</span>           </span><br><span class="line">    <span class="keyword">return</span> qSort(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qSort</span>(<span class="params">nums,start,end</span>):</span></span><br><span class="line">    <span class="keyword">if</span> start&lt;end:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        当分裂后的子序列有两个以上元素时，就进行排序。</span></span><br><span class="line"><span class="string">        使用左右指针分别指向子序列的开头和结尾</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pivot=nums[start]</span><br><span class="line">        left,right=start+<span class="number">1</span>,end</span><br><span class="line">        done=<span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        左指针一直右移，直到指向的元素大于中值；右指针一直左移，直到指向的元素小于中值。交换左右指针的元素值</span></span><br><span class="line"><span class="string">        继续下一次移动交换，直到左指针越过右指针。此时右指针位置就是中值应该在的位置，进行交换，排序完毕。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> done:</span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[left]&lt;=pivot:</span><br><span class="line">                left=left+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[right]&gt;=pivot:</span><br><span class="line">                right=right-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                done=<span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[left],nums[right] = nums[right],nums[left]</span><br><span class="line"></span><br><span class="line">        nums[start],nums[right]=nums[right],nums[start]</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        排完序后，中值前的部分[start,pivot-1]都是小于中值，中值后的部分[pivot+1,end]都是大于中值</span></span><br><span class="line"><span class="string">        对这两部分再次进行递归的快速排序</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        qSort(nums,start,right-<span class="number">1</span>)</span><br><span class="line">        qSort(nums,right+<span class="number">1</span>,end)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>也可以写成另一种方式：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>    </span><br><span class="line">        <span class="keyword">return</span> self.qsort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qsort</span>(<span class="params">self,ary, start, end</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start &lt; end:</span><br><span class="line">            left = start</span><br><span class="line">            right = end</span><br><span class="line">            pivot = ary[start]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ary</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> ary[right] &gt;= pivot:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:  <span class="comment"># 说明打破while循环的原因是ary[right] &lt;= key</span></span><br><span class="line">                ary[left] = ary[right]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> ary[left] &lt; pivot:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:  <span class="comment"># 说明打破while循环的原因是ary[left] &gt;= key</span></span><br><span class="line">                ary[right] = ary[left]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        ary[left] = pivot  <span class="comment"># 此时，left=right，用key来填坑</span></span><br><span class="line"></span><br><span class="line">        self.qsort(ary, start, left - <span class="number">1</span>)</span><br><span class="line">        self.qsort(ary, left + <span class="number">1</span>, end)</span><br><span class="line">        <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure><h3 id="1-7-桶排序"><a href="#1-7-桶排序" class="headerlink" title="1.7 桶排序"></a>1.7 桶排序</h3><p><strong>桶排序（Bucket Sort）基本思想</strong>：将未排序数组分到若干个「桶」中，每个桶的元素再进行单独排序。</p><h4 id="1-7-1-算法步骤"><a href="#1-7-1-算法步骤" class="headerlink" title="1.7.1  算法步骤"></a>1.7.1  算法步骤</h4><ol><li>根据原始数组的值域范围，将数组划分为 <code>k</code> 个相同大小的子区间，每个区间称为一个桶。</li><li>遍历原始数组元素，将每个元素装入对应区间的桶中。</li><li>对每个桶内的元素单独排序（使用插入排序、归并排序、快排排序等算法）。</li><li>最后按照区间顺序将桶内的元素合并起来，完成排序。</li></ol><p><strong>图解演示</strong></p><ol><li>划分子区间</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/268ad231558d117ac1915e2cdbe194c4.png" alt=""></p><ol><li>将数组元素装入桶中，并对桶内元素单独排序</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/0c05f4ed5dd7cdf918a784a27f8556a9.png" alt=""></p><ol><li>将桶内元素合并起来，完成排序</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/da068073da16aaf09ce1c8d63867a78a.png" alt=""></p><h4 id="1-7-2-算法分析"><a href="#1-7-2-算法分析" class="headerlink" title="1.7.2 算法分析"></a>1.7.2 算法分析</h4><ul><li><strong>时间复杂度</strong>：$O(n)$。当输入元素个数为 $n$，桶的个数是 $m$ 时，每个桶里的数据就是 $k = n / m$ 个。每个桶内排序的时间复杂度为 $O(k \times \log_2 k)$。$m$ 个桶就是 $m <em> O(k </em> log_2k) = m \times O((n / m) \times \log_2(n/m)) = O(n*log_2(n/m))$。当桶的个数 $m$ 接近于数据个数 $n$ 时，$log_2(n/m)$ 就是一个较小的常数，所以排序桶排序时间复杂度接近于 $O(n)$。</li><li><strong>空间复杂度</strong>：$O(n + m)$。由于桶排序使用了辅助空间，所以桶排序的空间复杂度是 $O(n + m)$。</li><li><strong>排序稳定性</strong>：如果桶内使用插入排序算法等稳定排序算法，则桶排序也是一种 <strong>稳定排序算法</strong>。</li></ul><h4 id="1-7-3-代码实现"><a href="#1-7-3-代码实现" class="headerlink" title="1.7.3 代码实现"></a>1.7.3 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">self, arr</span>):</span></span><br><span class="line">        <span class="comment"># 遍历无序序列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">            temp = arr[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 从右至左遍历有序序列</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> arr[j - <span class="number">1</span>] &gt; temp:</span><br><span class="line">                <span class="comment"># 将有序序列中插入位置右侧的元素依次右移一位</span></span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 将该元素插入到适当位置</span></span><br><span class="line">            arr[j] = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bucketSort</span>(<span class="params">self, arr, bucket_size=<span class="number">5</span></span>):</span></span><br><span class="line">        <span class="comment"># 计算待排序序列中最大值元素 arr_max 和最小值元素 arr_min</span></span><br><span class="line">        arr_min, arr_max = <span class="built_in">min</span>(arr), <span class="built_in">max</span>(arr)</span><br><span class="line">        <span class="comment"># 定义桶的个数为 (最大值元素 - 最小值元素) // 每个桶的大小 + 1</span></span><br><span class="line">        bucket_count = (arr_max - arr_min) // bucket_size + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 定义桶数组 buckets</span></span><br><span class="line">        buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(bucket_count)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历原始数组元素，将每个元素装入对应区间的桶中</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            buckets[(num - arr_min) // bucket_size].append(num)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对每个桶内的元素单独排序，并合并到 res 数组中</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">            self.insertionSort(bucket)</span><br><span class="line">            res.extend(bucket)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.bucketSort(nums)</span><br></pre></td></tr></table></figure><h3 id="1-8-堆排序"><a href="#1-8-堆排序" class="headerlink" title="1.8 堆排序"></a>1.8 堆排序</h3><h4 id="1-8-1-算法思想"><a href="#1-8-1-算法思想" class="headerlink" title="1.8.1 算法思想"></a>1.8.1 算法思想</h4><blockquote><p><strong>堆排序（Heap sort）基本思想</strong>：</p><p>借用「堆结构」所设计的排序算法。将数组转化为大顶堆，重复从大顶堆中取出数值最大的节点，并让剩余的堆结构继续维持大顶堆性质。</p></blockquote><p><strong>堆（Heap）</strong>：符合以下两个条件之一的完全二叉树：</p><ul><li><strong>大顶堆</strong>：根节点值 ≥ 子节点值。</li><li><strong>小顶堆</strong>：根节点值 ≤ 子节点值。</li></ul><h4 id="1-8-2-算法步骤"><a href="#1-8-2-算法步骤" class="headerlink" title="1.8.2 算法步骤"></a>1.8.2 算法步骤</h4><ol><li><strong>建立初始堆</strong>：将无序序列构造成第 <code>1</code> 个大顶堆（初始堆），使得 <code>n</code> 个元素的最大值处于序列的第 <code>1</code> 个位置。</li><li><strong>调整堆</strong>：交换序列的第 <code>1</code> 个元素（最大值元素）与第 <code>n</code> 个元素的位置。将序列前 <code>n - 1</code> 个元素组成的子序列调整成一个新的大顶堆，使得 <code>n - 1</code> 个元素的最大值处于序列第 <code>1</code> 个位置，从而得到第 <code>2</code> 个最大值元素。</li><li><strong>调整堆</strong>：交换子序列的第 <code>1</code> 个元素（最大值元素）与第 <code>n - 1</code> 个元素的位置。将序列前 <code>n - 2</code> 个元素组成的子序列调整成一个新的大顶堆，使得 <code>n - 2</code> 个元素的最大值处于序列第 <code>1</code> 个位置，从而得到第 <code>3</code> 个最大值元素。</li><li>依次类推，不断交换子序列的第 <code>1</code> 个元素（最大值元素）与当前子序列最后一个元素位置，并将其调整成新的大顶堆。直到子序列剩下一个元素时，排序结束。此时整个序列就变成了一个有序序列。</li></ol><p>从堆排序算法步骤中可以看出：堆排序算法主要涉及「调整堆」和「建立初始堆」两个步骤。</p><h4 id="1-8-3-调整堆"><a href="#1-8-3-调整堆" class="headerlink" title="1.8.3 调整堆"></a>1.8.3 调整堆</h4><p><strong>调整堆方法</strong>：把移走了最大值元素以后的剩余元素组成的序列再构造为一个新的堆积。具体步骤如下：</p><ol><li>从根节点开始，自上而下地调整节点的位置，使其成为堆积。<ol><li>判断序号为 <code>i</code> 的节点与其左子树节点（序号为 <code>2 * i</code>）、右子树节点（序号为 <code>2 * i + 1</code>）中值关系。</li><li>如果序号为 <code>i</code> 节点大于等于左右子节点值，则排序结束。</li><li>如果序号为 <code>i</code> 节点小于左右子节点值，则将序号为 <code>i</code> 节点与左右子节点中值最大的节点交换位置。</li></ol></li><li>因为交换了位置，使得当前节点的左右子树原有的堆积特性被破坏。于是，从当前节点的左右子树节点开始，自上而下继续进行类似的调整。</li><li>依次类推，直到整棵完全二叉树成为一个大顶堆。</li></ol><p><strong>调整堆方法演示</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/1289a25a64578c2780ec5cf6548e8bbb.gif" alt=""></p><ol><li>交换序列的第 <code>1</code> 个元素 <code>90</code> 与最后 <code>1</code> 个元素 <code>19</code> 的位置，此时当前节点为根节点 <code>19</code>。</li><li>判断根节点 <code>19</code>与其左右子节点值，因为 <code>17 &lt; 19 &lt; 36</code>，所以将根节点 <code>19</code> 与左子节点 <code>36</code> 互换位置，此时当前节点为根节点 <code>19</code>。</li><li>判断当前节点 <code>36</code> 与其左右子节点值，因为 <code>19 &lt; 25 &lt; 26</code>，所以将当前节点 <code>19</code> 与右节点 <code>26</code> 互换位置。调整堆结束。</li></ol><h4 id="1-8-4-建立初始堆"><a href="#1-8-4-建立初始堆" class="headerlink" title="1.8.4 建立初始堆"></a>1.8.4 建立初始堆</h4><ol><li>如果原始序列对应的完全二叉树（不一定是堆）的深度为 <code>d</code>，则从 <code>d - 1</code> 层最右侧分支节点（序号为 $\lfloor \frac{n}{2} \rfloor$）开始，初始时令 $i = \lfloor \frac{n}{2} \rfloor$，调用调整堆算法。</li><li>每调用一次调整堆算法，执行一次 <code>i = i - 1</code>，直到 <code>i == 1</code> 时，再调用一次，就把原始序列调整为了一个初始堆。</li></ol><p><strong>方法演示</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/143f7e1be004a10794cb28e08e1643e1.gif" alt=""></p><ol><li>原始序列为 <code>[2, 7, 26, 25, 19, 17, 1, 90, 3, 36]</code>，对应完全二叉树的深度为 <code>3</code>。</li><li>从第 <code>2</code> 层最右侧的分支节点，也就序号为 <code>5</code> 的节点开始，调用堆调整算法，使其与子树形成大顶堆。</li><li>节点序号减 <code>1</code>，对序号为 <code>4</code> 的节点，调用堆调整算法，使其与子树形成大顶堆。</li><li>节点序号减 <code>1</code>，对序号为 <code>3</code> 的节点，调用堆调整算法，使其与子树形成大顶堆。</li><li>节点序号减 <code>1</code>，对序号为 <code>2</code> 的节点，调用堆调整算法，使其与子树形成大顶堆。</li><li>节点序号减 <code>1</code>，对序号为 <code>1</code> 的节点，调用堆调整算法，使其与子树形成大顶堆。</li><li>此时整个原始序列对应的完全二叉树就成了一个大顶堆，建立初始堆完毕。</li></ol><h4 id="1-8-5-堆排序方法完整演示"><a href="#1-8-5-堆排序方法完整演示" class="headerlink" title="1.8.5 堆排序方法完整演示"></a>1.8.5 堆排序方法完整演示</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/4c9941c0790d2f6339bd9f97e5d97d46.gif" alt=""></p><ol><li>原始序列为 <code>[2, 7, 26, 25, 19, 17, 1, 90, 3, 36]</code>，先根据原始序列建立一个初始堆。</li><li>交换序列中第 <code>1</code> 个元素（<code>90</code>）与第 <code>10</code> 个元素（<code>2</code>）的位置。将序列前 <code>9</code> 个元素组成的子序列调整成一个大顶堆，此时堆顶变为 <code>36</code>。</li><li>交换序列中第 <code>1</code> 个元素（<code>36</code>）与第 <code>9</code> 个元素（<code>3</code>）的位置。将序列前 <code>8</code> 个元素组成的子序列调整成一个大顶堆，此时堆顶变为 <code>26</code>。</li><li>交换序列中第 <code>1</code> 个元素（<code>26</code>）与第 <code>8</code> 个元素（<code>2</code>）的位置。将序列前 <code>7</code> 个元素组成的子序列调整成一个大顶堆，此时堆顶变为 <code>25</code>。</li><li>以此类推，不断交换子序列的第 <code>1</code> 个元素（最大值元素）与当前子序列最后一个元素位置，并将其调整成新的大顶堆。直到子序列只剩下最后一个元素 <code>1</code> 时，排序结束。此时整个序列变成了一个有序序列，即 <code>[1, 2, 3, 7, 17, 19, 25, 26, 36, 90]</code>。</li></ol><h4 id="1-8-6-堆排序算法分析"><a href="#1-8-6-堆排序算法分析" class="headerlink" title="1.8.6 堆排序算法分析"></a>1.8.6 堆排序算法分析</h4><ul><li><strong>时间复杂度</strong>：$O(n \times \log_2 n)$。<ul><li>堆积排序的时间主要花费在两个方面：「建立初始堆」和「调整堆」。</li><li>设原始序列所对应的完全二叉树深度为 $d$，算法由两个独立的循环组成：<ol><li>在第 $1$ 个循环构造初始堆积时，从 $i = d - 1$ 层开始，到 $i = 1$ 层为止，对每个分支节点都要调用一次调整堆算法，而一次调整堆算法，对于第 $i$ 层一个节点到第 $d$ 层上建立的子堆积，所有节点可能移动的最大距离为该子堆积根节点移动到最后一层（第 $d$ 层） 的距离，即 $d - i$。而第 $i$ 层上节点最多有 $2^{i-1}$ 个，所以每一次调用调整堆算法的最大移动距离为 $2^{i-1} * (d-i)$。因此，堆积排序算法的第 $1$ 个循环所需时间应该是各层上的节点数与该层上节点可移动的最大距离之积的总和，即：$\sum<em>{i = d - 1}^1 2^{i-1} (d-i) = \sum</em>{j = 1}^{d-1} 2^{d-j-1} \times j = \sum<em>{j = 1}^{d-1} 2^{d-1} \times {j \over 2^j} \le n \sum</em>{j = 1}^{d-1} {j \over 2^j} &lt; 2n$。这一部分的时间花费为 $O(n)$。                                                                                                                                                                                                                                                                 </li><li>在第 $2$ 个循环中，每次调用调整堆算法一次，节点移动的最大距离为这棵完全二叉树的深度 $d = \lfloor \log_2(n) \rfloor + 1$，一共调用了 $n - 1$ 次调整堆算法，所以，第 $2$ 个循环的时间花费为 $(n-1)(\lfloor \log_2 (n)\rfloor + 1) = O(n \times \log_2 n)$。</li></ol></li><li>因此，堆积排序的时间复杂度为 $O(n \times \log_2 n)$。</li></ul></li><li><strong>空间复杂度</strong>：$O(1)$。由于在堆积排序中只需要一个记录大小的辅助空间，因此，堆积排序的空间复杂度为：$O(1)$。</li><li><strong>排序稳定性</strong>：堆排序是一种 <strong>不稳定排序算法</strong>。</li></ul><h4 id="1-8-7-代码实现"><a href="#1-8-7-代码实现" class="headerlink" title="1.8.7 代码实现"></a>1.8.7 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 调整为大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">self, arr: [<span class="built_in">int</span>], index: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="comment"># 根节点为 index，左节点为 2 * index + 1， 右节点为 2 * index + 2</span></span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        right = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= end:</span><br><span class="line">            <span class="comment"># 当前节点为非叶子结点</span></span><br><span class="line">            max_index = index</span><br><span class="line">            <span class="keyword">if</span> arr[left] &gt; arr[max_index]:</span><br><span class="line">                max_index = left</span><br><span class="line">            <span class="keyword">if</span> right &lt;= end <span class="keyword">and</span> arr[right] &gt; arr[max_index]:</span><br><span class="line">                max_index = right</span><br><span class="line">            <span class="keyword">if</span> index == max_index:</span><br><span class="line">                <span class="comment"># 如果不用交换，则说明已经交换结束</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            arr[index], arr[max_index] = arr[max_index], arr[index]</span><br><span class="line">            <span class="comment"># 继续调整子树</span></span><br><span class="line">            index = max_index</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            right = left + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildMaxHeap</span>(<span class="params">self, arr: [<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="comment"># (size - 2) // 2 是最后一个非叶节点，叶节点不用调整</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((size - <span class="number">2</span>) // <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            self.heapify(arr, i, size - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 升序堆排序，思路如下：</span></span><br><span class="line">    <span class="comment"># 1. 先建立大顶堆</span></span><br><span class="line">    <span class="comment"># 2. 让堆顶最大元素与最后一个交换，然后调整第一个元素到倒数第二个元素，这一步获取最大值</span></span><br><span class="line">    <span class="comment"># 3. 再交换堆顶元素与倒数第二个元素，然后调整第一个元素到倒数第三个元素，这一步获取第二大值</span></span><br><span class="line">    <span class="comment"># 4. 以此类推，直到最后一个元素交换之后完毕。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxHeapSort</span>(<span class="params">self, arr: [<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.buildMaxHeap(arr)</span><br><span class="line">        size = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            arr[<span class="number">0</span>], arr[size - i - <span class="number">1</span>] = arr[size - i - <span class="number">1</span>], arr[<span class="number">0</span>]</span><br><span class="line">            self.heapify(arr, <span class="number">0</span>, size - i - <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.maxHeapSort(nums)</span><br></pre></td></tr></table></figure><h3 id="1-9-计数排序"><a href="#1-9-计数排序" class="headerlink" title="1.9 计数排序"></a>1.9 计数排序</h3><p>&#8195;&#8195; <strong>计数排序（Counting Sort）基本思想</strong>：使用一个额外的数组 <code>counts</code>，其中 <code>counts[i]</code> 表示原数组 <code>arr</code> 中值等于 <code>i</code> 的元素个数。然后根据数组 <code>counts</code> 来将 <code>arr</code> 中的元素排到正确的位置。</p><h4 id="1-9-1-算法步骤"><a href="#1-9-1-算法步骤" class="headerlink" title="1.9.1 算法步骤"></a>1.9.1 算法步骤</h4><ol><li>找出待排序序列中最大值元素 <code>arr_max</code> 和最小值元素 <code>arr_min</code>。</li><li>定义大小为 <code>arr_max - arr_min + 1</code> 的数组 <code>counts</code>，初始时，<code>counts</code> 中元素值全为 <code>0</code>。</li><li>遍历数组 <code>arr</code>，统计值为 <code>num</code> 的元素出现的次数。将其次数存入 <code>counts</code> 数组的第 <code>num - arr_min</code> 项（<code>counts[num - arr_min]</code> 表示元素值 <code>num</code> 出现的次数）。</li><li>对所有的计数累加，从 <code>counts</code> 中的第一个元素开始，每一项和前一项相加。此时 <code>counts[i]</code> 表示值为 <code>i</code> 的元素排名。</li><li>反向填充目标数组：<ol><li>逆序遍历数组 <code>arr</code>。对于每个元素值 <code>arr[i]</code>，其对应排名为 <code>counts[arr[i] - arr_min]</code>。</li><li>根据排名，将 <code>arr[i]</code> 放在数组对应位置（因为数组下标是从 <code>0</code> 开始的，所以对应位置为排名减 <code>1</code>）。即 <code>res[counts[arr[i] - arr_min] - 1] = arr[i]</code>。</li><li>放入之后， 将 <code>arr[i]</code> 的对应排名减 <code>1</code>，即 <code>counts[arr[i] - arr_min] -= 1</code>。</li></ol></li></ol><p><strong>动画演示</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/eb1bcdad169668a0a80eaa7ff39df0ff.gif" alt="计数排序"></p><h4 id="1-9-2-算法分析"><a href="#1-9-2-算法分析" class="headerlink" title="1.9.2 算法分析"></a>1.9.2 算法分析</h4><ul><li><strong>时间复杂度</strong>：$O(n + k)$。其中 $k$ 代表待排序序列的值域。</li><li><strong>空间复杂度</strong>：$O(k)$。其中 $k$ 代表待排序序列的值域。由于用于计数的数组 <code>counts</code> 的长度取决于待排序数组中数据的范围（大小等于待排序数组最大值减去最小值再加 <code>1</code>）。所以计数排序算法对于数据范围很大的数组，需要大量的内存。</li><li><strong>计数排序适用情况</strong>：计数排序一般用于整数排序，不适用于按字母顺序、人名顺序排序。</li><li><strong>排序稳定性</strong>：计数排序是一种 <strong>稳定排序算法</strong>。</li></ul><h4 id="1-9-3-代码实现"><a href="#1-9-3-代码实现" class="headerlink" title="1.9.3. 代码实现"></a>1.9.3. 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countingSort</span>(<span class="params">self, arr</span>):</span></span><br><span class="line">        <span class="comment"># 计算待排序序列中最大值元素 arr_max 和最小值元素 arr_min</span></span><br><span class="line">        arr_min, arr_max = <span class="built_in">min</span>(arr), <span class="built_in">max</span>(arr)</span><br><span class="line">        <span class="comment"># 定义计数数组 counts，大小为 最大值元素 - 最小值元素 + 1</span></span><br><span class="line">        size = arr_max - arr_min + <span class="number">1</span></span><br><span class="line">        counts = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 统计值为 num 的元素出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            counts[num - arr_min] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算元素排名</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            counts[j] += counts[j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反向填充目标数组</span></span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 根据排名，将 arr[i] 放在数组对应位置</span></span><br><span class="line">            res[counts[arr[i] - arr_min] - <span class="number">1</span>] = arr[i]</span><br><span class="line">            <span class="comment"># 将 arr[i] 的对应排名减 1</span></span><br><span class="line">            counts[arr[i] - arr_min] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.countingSort(nums)</span><br></pre></td></tr></table></figure><h3 id="1-10-基数排序"><a href="#1-10-基数排序" class="headerlink" title="1.10 基数排序"></a>1.10 基数排序</h3><p>&#8195;&#8195;假设要对 10 万个手机号码进行排序，显然桶排序和计数排序都不太适合，那怎样才能做到时间复杂度为 O(n) 呢?  此时可以考虑基数排序。<br>&#8195;&#8195;手机号码有这样的规律，<font color='deeppink'>假设要比较两个手机号码 a, b 的大小，如果在前面几位中，a 手机号码已经比 b大了，那后面几位就不用看了</font>。所以借助 稳定排序算法，我们可以这么实现：从手机号码的最后一位开始，分别按照每一位的数字对手机号码进行排序，依次往前进行，经过 11 次排序之后，手机号码就都有序了。</p><p>&#8195;&#8195; <strong>基数排序（Radix Sort）基本思想</strong>：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后后，从最低位开始，依次进行排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p><h4 id="1-10-1-算法步骤"><a href="#1-10-1-算法步骤" class="headerlink" title="1.10.1 算法步骤"></a>1.10.1 算法步骤</h4><p>&#8195;&#8195;基数排序算法可以采用「最低位优先法（Least Significant Digit First）」或者「最高位优先法（Most Significant Digit first）」。最常用的是「最低位优先法」。</p><p>下面我们以最低位优先法为例，讲解一下算法步骤。</p><ol><li>遍历数组元素，获取数组最大值元素，并取得位数。</li><li>定义一个长度为 <code>10</code> 的桶 <code>buckets</code>，分别代表 <code>0 ~ 9</code> 这 <code>10</code> 位数字。</li><li>以个位元素为索引，根据数组元素个位上的值，将数组元素存入对应数字的桶中。</li><li>清空原始数组，并从桶中依次取出对应元素，重新加入到原始数组中。</li><li>之后分别以十位，百位，…，最大值元素的最高位为索引，根据元素对应位上的数字，存入对应数字的桶中。并合并数组，完成排序。</li></ol><p><strong>动画演示</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4a37ada8ea48d1f9c9a023bc8c8d6f6d.gif" alt=""></p><ol><li>初始序列为 <code>[32, 1, 10, 96, 57, 7, 62, 47, 82, 25, 79, 5]</code>，序列所有元素的最大位数为 <code>2</code>。</li><li>以个位为索引，根据元素个位上的数字，将其分别存入到 <code>0</code> ~ <code>9</code> 这 <code>10</code> 个桶中。</li><li>清空原始数组，并从桶中依次取出对应元素，重新加入到原始数组中。此时序列变为 <code>[10, 1, 32, 62, 82, 25, 5, 96, 57, 7, 47, 79]</code>。</li><li>以十位为索引，根据元素十位上的数字，将其分别存入到 <code>0</code> ~ <code>9</code> 这 <code>10</code> 个桶中。</li><li>清空原始数组，并从桶中依次取出对应元素，重新加入到原始数组中。此时序列变为 <code>[1, 5, 7, 10, 25, 32, 47, 57, 62, 79, 82, 96]</code>，完成排序。</li></ol><h4 id="1-10-2-算法分析"><a href="#1-10-2-算法分析" class="headerlink" title="1.10.2 算法分析"></a>1.10.2 算法分析</h4><p>&#8195;&#8195;基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><ul><li><strong>时间复杂度</strong>：$O(n \times k)$。<ul><li>根据每一位的排序，可以用桶排序或者计数排序来实现，它们的时间复杂度可以做到 O(n)。如果排序的数据有 K位，则总的时间复杂度为 O(K * n)，当 K 不大时，基数排序的时间复杂度就近似为 O(n)</li><li>$k$ 的大小取决于数字位的选择（十进制位、二进制位）和待排序元素所属数据类型全集的大小。</li></ul></li><li><strong>空间复杂度</strong>：$O(n + k)$。</li><li><strong>排序稳定性</strong>：基数排序是一种 <strong>稳定排序算法</strong>。</li><li>有时候，要排序的数据并不都是等长的，比如我们要对英文单词进行排序。这时候，我们可以把所有单词都补足到相同长度，位数不够的在后面补 ’0‘，所有字母的 ASCII 码都大于 ‘0’，因此不会影响原有的大小顺序。</li></ul><h4 id="1-10-3-代码实现"><a href="#1-10-3-代码实现" class="headerlink" title="1.10.3 代码实现"></a>1.10.3 代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">radixSort</span>(<span class="params">self, arr</span>):</span></span><br><span class="line">        <span class="comment"># 桶的大小为所有元素的最大位数</span></span><br><span class="line">        size = <span class="built_in">len</span>(<span class="built_in">str</span>(<span class="built_in">max</span>(arr)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从低位到高位依次遍历每一位，以各个数位值为索引，对数组进行按数位排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="comment"># 使用一个长度为 10 的桶来存放各个位上的元素</span></span><br><span class="line">            buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">            <span class="comment"># 遍历数组元素，根据元素对应位上的值，将其存入对应位的桶中</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">                buckets[num // (<span class="number">10</span> ** i) % <span class="number">10</span>].append(num)</span><br><span class="line">            <span class="comment"># 清空原始数组</span></span><br><span class="line">            arr.clear()</span><br><span class="line">            <span class="comment"># 从桶中依次取出对应元素，并重新加入到原始数组</span></span><br><span class="line">            <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">                <span class="keyword">for</span> num <span class="keyword">in</span> bucket:</span><br><span class="line">                    arr.append(num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.radixSort(nums)</span><br></pre></td></tr></table></figure><h3 id="1-11-排序算法总结"><a href="#1-11-排序算法总结" class="headerlink" title="1.11 排序算法总结"></a>1.11 排序算法总结</h3><p>下面为七种经典排序算法指标对比情况：<br><img src="https://img-blog.csdnimg.cn/13128565aa0043ada3fa108e6ecf8115.png" alt="在这里插入图片描述"></p><ul><li><p>冒泡排序,简单选择排序,堆排序,直接插入排序,希尔排序的空间复杂度为O(1),因为需要一个临时变量来交换元素位置,(另外遍历序列时自然少不了用一个变量来做索引)</p></li><li><p>快速排序空间复杂度为logn(因为递归调用了) </p></li><li>归并排序空间复杂是O(n),需要一个大小为n的临时数组.。基数排序的空间复杂是O(n),桶排序的空间复杂度不确定。</li><li>所有排序算法中最快的应该是<strong>桶排序</strong>(很多人误以为是快速排序,实际上不是.不过实际应用中快速排序用的多)。但桶排序一般用的不多,因为有几个比较大的缺陷.<ul><li>待排序的元素不能是负数,小数.</li><li>空间复杂度不确定,要看待排序元素中最大值是多少.。所需要的辅助数组大小即为最大元素的值.</li></ul></li></ul><h2 id="二、-练习题"><a href="#二、-练习题" class="headerlink" title="二、 练习题"></a>二、 练习题</h2><h3 id="2-1-移动零（题283）"><a href="#2-1-移动零（题283）" class="headerlink" title="2.1 移动零（题283）"></a>2.1 移动零（题283）</h3><p>&#8195;&#8195;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><ul><li>示例 1:<ul><li>输入: nums = [0,1,0,3,12]</li><li>输出: [1,3,12,0,0]</li></ul></li><li>示例 2:<ul><li>输入: nums = [0]</li><li>输出: [0]</li></ul></li></ul><p>思路 1：冒泡排序（超时）<br>&#8195;&#8195;冒泡排序的思想，就是通过相邻元素的比较与交换，使得较大元素从前面移到后面。我们可以借用冒泡排序的思想，将值为 0 的元素移动到数组末尾。因为冒泡排序的时间复杂度为$O(n^2)$ 。所以这种做法会导致超时。</p><p>思路 2：双指针</p><ol><li>使用两个指针 slow，fast。slow 指向处理好的非 0 数字数组的尾部，fast 指针指向当前待处理元素。</li><li>不断向右移动 fast 指针，每次移动到非零数，则将左右指针对应的数交换，交换同时将 slow 右移。</li><li>此时，slow 指针左侧均为处理好的非零数，而从 slow 指针指向的位置开始， fast 指针左边为止都为 0。</li><li>遍历结束之后，则所有 0 都移动到了右侧，且保持了非零数的相对位置。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):            </span><br><span class="line">            <span class="keyword">if</span> nums[i]!=<span class="number">0</span>:</span><br><span class="line">                nums[i],nums[slow]=nums[slow],nums[i]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h3 id="2-2-颜色分类（题75）"><a href="#2-2-颜色分类（题75）" class="headerlink" title="2.2 颜色分类（题75）"></a>2.2 颜色分类（题75）</h3><p><strong>方法一：单指针</strong><br>&#8195;&#8195;这道题和上一题很类似，最简单的方法是遍历两次，先将0排到最前面，再接着将1排到前面：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 两次遍历，先排0再排1</span></span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">0</span>:</span><br><span class="line">                nums[left],nums[i]=nums[i],nums[left]</span><br><span class="line">                left+=<span class="number">1</span>  </span><br><span class="line">                              </span><br><span class="line">        right=left  <span class="comment"># 前面left个位置已经排好了0     </span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j]==<span class="number">1</span>:</span><br><span class="line">                nums[right],nums[j]=nums[j],nums[right]</span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><strong>方法二：双指针（官方题解）</strong><br>&#8195;&#8195;我们可以额外使用一个指针，即使用两个指针分别用来交换 0 和1。具体地，我们用指针 $p_0$来交换 0，$p_1$来交换 1，初始值都为 0。当我们从左向右遍历整个数组时：</p><ul><li>如果找到了 1，那么将其与 $nums[p_1]$ 进行交换，并将 $p_1$向后移动一个位置，这与方法一是相同的；</li><li>如果找到了 0，那么将其与 $nums[p_0]$ 进行交换，并将 $p_0$向后移动一个位置。这样做是正确的吗？<br>&#8195;&#8195;我们可以注意到，因为连续的 0 之后是连续的 1，因此如果我们将 0 与$nums[p_0]$ 进行交换，那么我们可能会把一个 1 交换出去。当 $p_0 &lt; p_1$时，我们已经将一些 1 连续地放在头部，此时一定会把一个 1 交换出去，导致答案错误。因此，如果$p_0 &lt; p_1$，那么我们需要再将 $nums[i]$ 与$nums[p_1]$进行交换，其中 i 是当前遍历到的位置。<br>&#8195;&#8195;在进行了第一次交换后，$nums[i]$的值为 1，我们需要将这个 1 放到「头部」的末端。在最后，无论是否有 $p_0 &lt; p_1$，我们需要将 $p_0$ 和 $p_1$均向后移动一个位置，而不是仅将 $p_0$向后移动一个位置。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 两个指针分别用于交换0和1</span></span><br><span class="line">        p0=p1=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">1</span>:</span><br><span class="line">                nums[i],nums[p1]=nums[p1],nums[i]</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i]==<span class="number">0</span>:</span><br><span class="line">                nums[i],nums[p0]=nums[p0],nums[i]</span><br><span class="line">                <span class="keyword">if</span> p0&lt;p1:</span><br><span class="line">                    nums[i],nums[p1]=nums[p1],nums[i]</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">                p0+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><strong>方法三：快速排序</strong><br>我们也可以借鉴快速排序算法中的 <code>partition</code> 过程，将 1 作为基准数 <code>pivot</code>，然后将序列分为三部分：0（即比 1 小的部分）、等于 1 的部分、2（即比 1 大的部分）。具体步骤如下：</p><ol><li>使用两个指针 left、right，分别指向数组的头尾。left 表示当前处理好红色元素的尾部，right 表示当前处理好蓝色的头部。</li><li>再使用一个下标 index 遍历数组，如果遇到 <code>nums[index] == 0</code>，就交换 nums[index] 和 nums[left]，同时将 left 右移。如果遇到 <code>nums[index] == 2</code>，就交换 nums[index] 和 nums[right]，同时将 right 左移。</li><li>直到 index 移动到 right 位置之后，停止遍历。遍历结束之后，此时 left 左侧都是红色，right 右侧都是蓝色。</li><li>注意：移动的时候需要判断 index 和 left 的位置，因为 left 左侧是已经处理好的数组，所以需要判断 index 的位置是否小于 left，小于的话，需要更新 index 位置。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> index &lt; left:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[index] == <span class="number">0</span>:</span><br><span class="line">                nums[index], nums[left] = nums[left], nums[index]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[index] == <span class="number">2</span>:</span><br><span class="line">                nums[index], nums[right] = nums[right], nums[index]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-3-数组中的第K个最大元素（题215）"><a href="#2-3-数组中的第K个最大元素（题215）" class="headerlink" title="2.3    数组中的第K个最大元素（题215）"></a>2.3    数组中的第K个最大元素（题215）</h3><p>&#8195;&#8195;给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。示例：</p><ul><li>输入: [3,2,1,5,6,4], k = 2</li><li>输出: 5          </li></ul><p>&#8195;&#8195;这道题使用改进的冒泡排序、选择排序、插入排序都会超时。希尔排序（1440ms）、归并排序（1016ms）、堆排序（640ms），这些都是可以通过的。也可以考虑使用快速排序。</p><h4 id="2-3-1-快速排序"><a href="#2-3-1-快速排序" class="headerlink" title="2.3.1 快速排序"></a>2.3.1 快速排序</h4><p><strong>快速排序思路：</strong><br>&#8195;&#8195;使用快速排序在每次调整时，都会确定一个元素的最终位置，且以该元素为界限，将数组分成了左右两个子数组，左子数组中的元素都比该元素小，右子树组中的元素都比该元素大。</p><p>&#8195;&#8195;这样，只要某次划分的元素位置q恰好是第 k 个下标就找到了答案。至于<code>nums[left,q-1]</code>和<code>nums[q+1,right]</code>是否有序，我们并不关心。具体来说，在分解的过程当中，我们会对子数组进行划分，如果划分得到的 <code>q</code> 正好就是我们需要的下标，就直接返回 <code>nums[q]</code>；否则，如果 <code>q</code> 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>       </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> self.qSort(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>,k)  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qSort</span>(<span class="params">self,nums,start,end,k</span>):</span></span><br><span class="line">        <span class="comment"># if start&lt;end:这个是完全排序的结束条件，如果是topk排序，结束条件是pivot_idx=len(nums)-k</span></span><br><span class="line">        pivot_idx=self.partition(nums,start,end)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        如果pivot_idx==len(nums)-k,说明中值正好就是第k大的值，直接返回nums[pivot_idx]；</span></span><br><span class="line"><span class="string">        否则，如果pivot_idx&gt;len(nums)-k，就递归左子区间，否则递归右子区间。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pivot_idx==<span class="built_in">len</span>(nums)-k:</span><br><span class="line">            <span class="keyword">return</span> nums[pivot_idx]</span><br><span class="line">        <span class="keyword">elif</span> pivot_idx&gt;<span class="built_in">len</span>(nums)-k:</span><br><span class="line">            <span class="keyword">return</span> self.qSort(nums,start,pivot_idx-<span class="number">1</span>,k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.qSort(nums,pivot_idx+<span class="number">1</span>,end,k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self,nums,start,end</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        左指针一直右移，直到指向的元素大于中值；右指针一直左移，直到指向的元素小于中值。交换左右指针的元素值</span></span><br><span class="line"><span class="string">        继续下一次移动交换，直到左指针越过右指针。此时右指针位置就是中值应该在的位置，进行交换，排序完毕。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 改进中值，选取序列中随机一个位置的元素，将其和序列开头元素交换位置，作为中值</span></span><br><span class="line">        idx=random.randint(start,end)</span><br><span class="line">        nums[start],nums[idx]=nums[idx],nums[start]</span><br><span class="line">        pivot=nums[start]</span><br><span class="line"></span><br><span class="line">        left=start+<span class="number">1</span></span><br><span class="line">        right=end</span><br><span class="line">        done=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[left]&lt;=pivot:</span><br><span class="line">                left=left+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[right]&gt;=pivot:</span><br><span class="line">                right=right-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                done=<span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[left],nums[right] = nums[right],nums[left]                        </span><br><span class="line"></span><br><span class="line">        nums[start],nums[right]=nums[right],nums[start]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;使用完整的快速排序再取第k大的元素，是2672ms。只排到第k大的元素是640ms。加上随机选取中值之后，是80ms到90ms。<br>堆排序、优先队列等方法可参考<a href="https://algo.itcharge.cn/Solutions/0200-0299/kth-largest-element-in-an-array/#%E6%80%9D%E8%B7%AF-4%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97">算法通关手册</a>或<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/">官方题解</a>。</p><p>&#8195;&#8195;与这道题类似的还有<a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数（剑指 Offer 40）</a>，使用随机快速排序：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span>(<span class="params">self, arr, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>     </span><br><span class="line">        <span class="keyword">if</span> k&gt;<span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> self.qSort(arr,<span class="number">0</span>,<span class="built_in">len</span>(arr)-<span class="number">1</span>,k)  </span><br><span class="line">        <span class="keyword">elif</span> k==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qSort</span>(<span class="params">self,nums,start,end,k</span>):</span></span><br><span class="line">        <span class="comment"># if start&lt;end:这个是完全排序的结束条件，如果是topk排序，结束条件是pivot_idx=k-1</span></span><br><span class="line">        pivot_idx=self.partition(nums,start,end)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        注意，第k大的数其下标是k-1</span></span><br><span class="line"><span class="string">        如果pivot_idx==k-1,说明中值正好就是第k大的值，直接返回nums[pivot_idx]；</span></span><br><span class="line"><span class="string">        否则，如果pivot_idx&gt;k-1，就递归左子区间，否则递归右子区间。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 第k小的数位于序列的第k-1个位置（快排默认是升序）</span></span><br><span class="line">        <span class="keyword">if</span> pivot_idx==k-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[:pivot_idx+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> pivot_idx&gt;k-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.qSort(nums,start,pivot_idx-<span class="number">1</span>,k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.qSort(nums,pivot_idx+<span class="number">1</span>,end,k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self,nums,start,end</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        左指针一直右移，直到指向的元素大于中值；右指针一直左移，直到指向的元素小于中值。交换左右指针的元素值</span></span><br><span class="line"><span class="string">        继续下一次移动交换，直到左指针越过右指针。此时右指针位置就是中值应该在的位置，进行交换，排序完毕。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 改进中值，选取序列中随机一个位置的元素，将其和序列开头元素交换位置，作为中值</span></span><br><span class="line">        idx=random.randint(start,end)</span><br><span class="line">        nums[start],nums[idx]=nums[idx],nums[start]</span><br><span class="line">        pivot=nums[start]</span><br><span class="line"></span><br><span class="line">        left=start+<span class="number">1</span></span><br><span class="line">        right=end</span><br><span class="line">        done=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[left]&lt;=pivot:</span><br><span class="line">                left=left+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[right]&gt;=pivot:</span><br><span class="line">                right=right-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                done=<span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[left],nums[right] = nums[right],nums[left]                        </span><br><span class="line"></span><br><span class="line">        nums[start],nums[right]=nums[right],nums[start]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n)$。证明过程可参考「算法导论 9.2：期望为线性的选择算法」。</li><li><strong>空间复杂度</strong>：$O(\log_2 n)$。递归使用栈空间的空间代价期望为 $O(\log_2n)$。<h4 id="2-3-2-堆排序"><a href="#2-3-2-堆排序" class="headerlink" title="2.3.2 堆排序"></a>2.3.2 堆排序</h4>升序堆排序的思路如下：</li></ul><ol><li><p>将无序序列构造成第 <code>1</code> 个大顶堆（初始堆），使得 <code>n</code> 个元素的最大值处于序列的第 <code>1</code> 个位置。</p></li><li><p><strong>调整堆</strong>：交换序列的第 <code>1</code> 个元素（最大值元素）与第 <code>n</code> 个元素的位置。将序列前 <code>n - 1</code> 个元素组成的子序列调整成一个新的大顶堆，使得 <code>n - 1</code> 个元素的最大值处于序列第 <code>1</code> 个位置，从而得到第 <code>2</code> 个最大值元素。</p></li><li><p><strong>调整堆</strong>：交换子序列的第 <code>1</code> 个元素（最大值元素）与第 <code>n - 1</code> 个元素的位置。将序列前 <code>n - 2</code> 个元素组成的子序列调整成一个新的大顶堆，使得 <code>n - 2</code> 个元素的最大值处于序列第 <code>1</code> 个位置，从而得到第 <code>3</code> 个最大值元素。</p></li><li><p>依次类推，不断交换子序列的第 <code>1</code> 个元素（最大值元素）与当前子序列最后一个元素位置，并将其调整成新的大顶堆。直到获取第 <code>k</code> 个最大值元素为止。</p></li></ol><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 调整为大顶堆</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">heapify</span>(<span class="params">nums, index, end</span>):</span></span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            right = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= end:</span><br><span class="line">                <span class="comment"># 当前节点为非叶子节点</span></span><br><span class="line">                max_index = index</span><br><span class="line">                <span class="keyword">if</span> nums[left] &gt; nums[max_index]:</span><br><span class="line">                    max_index = left</span><br><span class="line">                <span class="keyword">if</span> right &lt;= end <span class="keyword">and</span> nums[right] &gt; nums[max_index]:</span><br><span class="line">                    max_index = right</span><br><span class="line">                <span class="keyword">if</span> index == max_index:</span><br><span class="line">                    <span class="comment"># 如果不用交换，则说明已经交换结束</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                nums[index], nums[max_index] = nums[max_index], nums[index]</span><br><span class="line">                <span class="comment"># 继续调整子树</span></span><br><span class="line">                index = max_index</span><br><span class="line">                left = index * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                right = left + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 初始化大顶堆</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buildMaxHeap</span>(<span class="params">nums</span>):</span></span><br><span class="line">            size = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="comment"># (size-2) // 2 是最后一个非叶节点，叶节点不用调整</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((size - <span class="number">2</span>) // <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                heapify(nums, i, size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">        buildMaxHeap(nums)</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            nums[<span class="number">0</span>], nums[size-i-<span class="number">1</span>] = nums[size-i-<span class="number">1</span>], nums[<span class="number">0</span>]</span><br><span class="line">            heapify(nums, <span class="number">0</span>, size-i-<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：$O(n \times \log_2n)$。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h4 id="2-3-3-优先队列"><a href="#2-3-3-优先队列" class="headerlink" title="2.3.3 优先队列"></a>2.3.3 优先队列</h4><ol><li>遍历数组元素，对于挡圈元素 <code>num</code>：<ol><li>如果优先队列中的元素个数小于 <code>k</code> 个，则将当前元素 <code>num</code> 放入优先队列中。</li><li>如果优先队列中的元素个数大于等于 <code>k</code> 个，并且当前元素 <code>num</code> 大于优先队列的队头元素，则弹出队头元素，并将当前元素 <code>num</code> 插入到优先队列中。</li></ol></li><li>遍历完，此时优先队列的队头元素就是第K个最大元素，将其弹出并返回即可。</li></ol><p>&#8195;&#8195;这里我们借助了 Python 中的 <code>heapq</code> 模块实现优先队列算法，这一步也可以通过手写堆的方式实现优先队列。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; k:</span><br><span class="line">                heapq.heappush(res, num)</span><br><span class="line">            <span class="keyword">elif</span> num &gt; res[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(res)</span><br><span class="line">                heapq.heappush(res, num)</span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(res)</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：$O(n \times \log_2k)$。</li><li><strong>空间复杂度</strong>：$O(k)$。</li></ul><h3 id="2-4-排序数组（题912）"><a href="#2-4-排序数组（题912）" class="headerlink" title="2.4 排序数组（题912）"></a>2.4 排序数组（题912）</h3><p>给你一个整数数组 nums，请你将该数组升序排列。</p><p>&#8195;&#8195;本题冒泡排序（改进）是过不了的，估计选择排序、插入排序也不行。可行的有希尔排序（1172ms）、归并排序（1036ms）、快速排序（816ms）。其中，验证的nums列表中有一个是nums全部为2的极端情况，直接快速排序是超时的。所以可以设置归并+快排，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(nums))&lt;<span class="number">5</span>: <span class="comment"># 随便选的一个值，排除一些极端情况下快排会超时</span></span><br><span class="line">            <span class="keyword">return</span> self.merge(nums) <span class="comment"># 归并排序</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.qSort(nums,<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>) <span class="comment"># 快速排序</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,arr</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(arr)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        mid=<span class="built_in">len</span>(arr)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># 注意，这里是递归的写法</span></span><br><span class="line">        left_arr=self.merge(arr[:mid])</span><br><span class="line">        right_arr=self.merge(arr[mid:])</span><br><span class="line">        <span class="keyword">return</span> self.mergesort(left_arr,right_arr)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergesort</span>(<span class="params">self,left_arr,right_arr</span>):</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        arr=[]</span><br><span class="line">        <span class="comment"># 注意，这里都是&lt;，不能取=,因为left_arr[len(left_arr)]是超出索引的</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;<span class="built_in">len</span>(left_arr) <span class="keyword">and</span> right&lt;<span class="built_in">len</span>(right_arr):</span><br><span class="line">            <span class="keyword">if</span> left_arr[left]&lt;right_arr[right]:</span><br><span class="line">                arr.append(left_arr[left])</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr.append(right_arr[right])</span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">while</span> left&lt;<span class="built_in">len</span>(left_arr):</span><br><span class="line">            arr.append(left_arr[left])</span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right&lt;<span class="built_in">len</span>(right_arr):</span><br><span class="line">            arr.append(right_arr[right])</span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">        <span class="comment">#print(left_arr,right_arr,arr)</span></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qSort</span>(<span class="params">self,nums,start,end</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start&lt;end:</span><br><span class="line">            pivot_idx=self.partition(nums,start,end)</span><br><span class="line">            self.qSort(nums,start,pivot_idx-<span class="number">1</span>)</span><br><span class="line">            self.qSort(nums,pivot_idx+<span class="number">1</span>,end)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self,nums,start,end</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        左指针一直右移，直到指向的元素大于中值；右指针一直左移，直到指向的元素小于中值。交换左右指针的元素值</span></span><br><span class="line"><span class="string">        继续下一次移动交换，直到左指针越过右指针。此时右指针位置就是中值应该在的位置，进行交换，排序完毕。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 改进中值，选取序列中随机一个位置的元素，将其和序列开头元素交换位置，作为中值</span></span><br><span class="line">        idx=random.randint(start,end)</span><br><span class="line">        nums[start],nums[idx]=nums[idx],nums[start]</span><br><span class="line">        pivot=nums[start]</span><br><span class="line"></span><br><span class="line">        left=start+<span class="number">1</span></span><br><span class="line">        right=end</span><br><span class="line">        done=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[left]&lt;=pivot:</span><br><span class="line">                left=left+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;=right <span class="keyword">and</span> nums[right]&gt;=pivot:</span><br><span class="line">                right=right-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                done=<span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[left],nums[right] = nums[right],nums[left]                        </span><br><span class="line"></span><br><span class="line">        nums[start],nums[right]=nums[right],nums[start]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right        </span><br></pre></td></tr></table></figure><p>其它排序方法详见<a href="https://algo.itcharge.cn/Solutions/0900-0999/sort-an-array/">算法通关手册</a>。</p><h3 id="2-5-数组中的逆序对（剑指-Offer-51）"><a href="#2-5-数组中的逆序对（剑指-Offer-51）" class="headerlink" title="2.5 数组中的逆序对（剑指 Offer 51）"></a>2.5 数组中的逆序对（剑指 Offer 51）</h3><p>&#8195;&#8195;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。示例：</p><ul><li>输入: [7,5,6,4]</li><li>输出: 5                </li></ul><p><strong>思路 1：归并排序</strong><br>&#8195;&#8195;归并排序主要分为：「分解过程」和「合并过程」。其中「合并过程」实质上是两个有序数组的合并过程。<br><img src="https://img-blog.csdnimg.cn/9676155cdd1f4c94adf1f0763753d21e.png" alt="在这里插入图片描述"><br>&#8195;&#8195;每当遇到<font color='deeppink'> 左子数组当前元素 &gt; 右子树组当前元素时</font>，意味着<font color='deeppink'>「左子数组从当前元素开始，一直到左子数组末尾元素」与「右子树组当前元素」构成了若干个逆序对</font>。</p><p>&#8195;&#8195;比如上图中的左子数组 <code>[0, 3, 5, 7]</code> 与右子树组 <code>[1, 4, 6, 8]</code>，遇到左子数组中元素 3 大于右子树组中元素 1。则左子数组从 3 开始，经过 5 一直到 7，与右子数组当前元素 1 都构成了逆序对。即 <code>[3, 1]、[5, 1]、[7, 1]</code> 都构成了逆序对。</p><p>&#8195;&#8195;因此，我们可以在合并两个有序数组的时候计算逆序对。具体做法如下：</p><ol><li>使用全局变量 <code>count</code> 来存储逆序对的个数。然后进行归并排序。</li><li>归并过程中：<ul><li>使用数组变量 arr 存放归并后的有序数组</li><li>使用两个指针 left、right 分别指向两个有序子序列 left_arr、right_arr 的开始位置。</li><li>如果 <code>left_arr[left] &lt;= right_arr[right]</code>，则将 <code>left_arr[left]</code> 存入到结果数组 <code>arr</code> 中，并将指针移动到下一位置。</li><li>如果 <code>left_arr[left] &gt; right_arr[right]</code>，则 记录当前左子序列中元素与当前右子序列元素所形成的逆序对的个数，并累加到 <code>count</code> 中，即 <code>self.count += len(left_arr) - left</code>，然后将 <code>right_arr[right]</code> 存入到结果数组 <code>arr</code> 中，并将指针移动到下一位置。</li><li>重复以上，直到某一指针到达子序列末尾，将另一个子序列中的剩余元素存入到结果数组 arr 中。</li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums=self.mergeSort(nums)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">self, arr</span>):</span>                       <span class="comment"># 分割过程</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:                           <span class="comment"># 数组元素个数小于等于 1 时，直接返回原数组</span></span><br><span class="line">                <span class="keyword">return</span> arr</span><br><span class="line">            </span><br><span class="line">            mid = <span class="built_in">len</span>(arr) // <span class="number">2</span>                         <span class="comment"># 将数组从中间位置分为左右两个数组。</span></span><br><span class="line">            <span class="comment"># 注意这里是递归的写法</span></span><br><span class="line">            left_arr = self.mergeSort(arr[<span class="number">0</span>: mid])      <span class="comment"># 递归将左子序列进行分割和排序</span></span><br><span class="line">            right_arr =  self.mergeSort(arr[mid:])      <span class="comment"># 递归将右子序列进行分割和排序</span></span><br><span class="line">            <span class="keyword">return</span> self.merge(left_arr, right_arr)      <span class="comment"># 把当前序列组中有序子序列逐层向上，进行两两合并。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, left_arr, right_arr</span>):</span>           <span class="comment"># 归并过程</span></span><br><span class="line">        arr = []</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 这里不能取等于，否则超出索引，下同</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(left_arr) <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(right_arr):</span><br><span class="line">            <span class="comment"># 将两个有序子序列中较小元素依次插入到结果数组中</span></span><br><span class="line">            <span class="keyword">if</span> left_arr[left] &lt;= right_arr[right]:</span><br><span class="line">                arr.append(left_arr[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.count+=<span class="built_in">len</span>(left_arr)-left</span><br><span class="line">                arr.append(right_arr[right])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        arr=arr+left_arr[left:]+right_arr[right:]            </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> arr                                  <span class="comment"># 返回排好序的结果数组</span></span><br></pre></td></tr></table></figure><p><strong>思路 2 树状数组：</strong> 见<a href="https://algo.itcharge.cn/Solutions/Offer/shu-zu-zhong-de-ni-xu-dui-lcof/">算法通关手册</a></p><h3 id="2-6-计算右侧小于当前元素的个数（题315）"><a href="#2-6-计算右侧小于当前元素的个数（题315）" class="headerlink" title="2.6 计算右侧小于当前元素的个数（题315）"></a>2.6 计算右侧小于当前元素的个数（题315）</h3><blockquote><p>参考<a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/4chong-jie-fa-yi-wang-da-jin-pai-xu-shu-5vvds/">《『 4种解法一网打尽 』 有序数组、归并排序、树状数组和线段树的实现及注释》</a></p></blockquote><p>&#8195;&#8195;给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p><ul><li>示例 1：<ul><li>输入：nums = [5,2,6,1]</li><li>输出：[2,1,1,0] </li><li>解释：<ul><li>5 的右侧有 2 个更小的元素 (2 和 1)</li><li>2 的右侧仅有 1 个更小的元素 (1)</li><li>6 的右侧有 1 个更小的元素 (1)</li><li>1 的右侧有 0 个更小的元素</li></ul></li></ul></li><li>示例 2：<ul><li>输入：nums = [-1]</li><li>输出：[0]<h4 id="2-6-1-归并排序"><a href="#2-6-1-归并排序" class="headerlink" title="2.6.1 归并排序"></a>2.6.1 归并排序</h4>&#8195;&#8195;这题类似上一题求逆序对。但是本题我们要求解的是 <code>nums[i]</code>右侧小于 <code>nums[i]</code> 的元素的数量，即以 <code>nums[i]</code>为左端点的「逆序对」的数目。注意到，在常规的归并排序过程中，数组中的元素其位置会发生变化，所以在本题中我们则需要记录下每个元素的初始位置，以便将每个元素贡献的逆序对数目归功到对应的位置上。<br>&#8195;&#8195;由于数组中的元素会重复，不能使用哈希表，所以考虑为每个数值添加其对应的下标，即对于第 <code>i</code> 个元素 <code>nums[i]</code>，可将其扩充为<code>(nums[i], i)</code>。这样在nums排序过程中，即便 nums 中元素的位置发生了变化，也可将每个元素贡献的逆序对数目准确定位到对应的位置上，原理如下图所示：<br><img src="https://img-blog.csdnimg.cn/11625172912b49e58456e7dedc4f9537.png" alt="在这里插入图片描述"></li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;根据nums[*][0]进行排序，对应的index随之移动&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">nums, low, high</span>):</span></span><br><span class="line">            <span class="keyword">if</span> low &gt;= high:     <span class="comment"># 递归终止</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;递归排序&#x27;&#x27;&#x27;</span></span><br><span class="line">            mid = low + (high-low)//<span class="number">2</span>     </span><br><span class="line">            mergeSort(nums, low, mid)           <span class="comment"># 左半部分逆序对数目</span></span><br><span class="line">            mergeSort(nums, mid+<span class="number">1</span>, high)        <span class="comment"># 右半部分逆序对数目</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;nums[low, mid] 和 nums[mid+1, high] 已排序好&#x27;&#x27;&#x27;</span></span><br><span class="line">            tmp = []                            <span class="comment"># 记录nums[low, high]排序结果</span></span><br><span class="line">            left, right = low, mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;=mid <span class="keyword">and</span> right&lt;=high:</span><br><span class="line">                <span class="keyword">if</span> nums[left][<span class="number">0</span>] &lt;= nums[right][<span class="number">0</span>]:         <span class="comment"># 根据nums[*][0]进行排序</span></span><br><span class="line">                    tmp.append(nums[left])</span><br><span class="line">                    res[nums[left][<span class="number">1</span>]] += right-(mid+<span class="number">1</span>)     <span class="comment"># 记录逆序对数目【对应坐标nums[*][1]处】</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp.append(nums[right])</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;左或右数组需遍历完（最多只有一个未遍历完）&#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;=mid:</span><br><span class="line">                tmp.append(nums[left])</span><br><span class="line">                res[nums[left][<span class="number">1</span>]] += right -(mid+<span class="number">1</span>)    <span class="comment"># 记录逆序对数目【对应坐标nums[*][1]处】</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> right&lt;=high:</span><br><span class="line">                tmp.append(nums[right])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            nums[low:high+<span class="number">1</span>] = tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;主程序&#x27;&#x27;&#x27;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">0</span>] * n               <span class="comment"># 存储结果</span></span><br><span class="line">        nums = [(num, idx) <span class="keyword">for</span> idx, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums)] </span><br><span class="line">        <span class="comment"># 每个数值附上其对应的索引：</span></span><br><span class="line">        <span class="comment"># 此时，nums[i][0]表示原来的数值，而nums[i][1]则表示原数值对应的索引（方便定位）</span></span><br><span class="line"></span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, n-<span class="number">1</span>)     <span class="comment"># 归并排序</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="2-6-2-有序数组-（Sorted-List）-二分搜索"><a href="#2-6-2-有序数组-（Sorted-List）-二分搜索" class="headerlink" title="2.6.2 有序数组 （Sorted List）+ 二分搜索"></a>2.6.2 有序数组 （Sorted List）+ 二分搜索</h4><p>&#8195;&#8195;<strong>基本思路</strong>： 维护一个有序数组 sl，从右往左依次往里添加 nums 中的元素，每次添加 nums[i] 前基于「二分搜索」判断出当前 sl 中比 nums[i] 小的元素个数（即 nums[i] 右侧比 nums[i] 还要小的元素个数），并计入答案即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">0</span>] * n</span><br><span class="line">        sl = []         <span class="comment"># 有序数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bisect_left</span>(<span class="params">arr, x, low, high</span>):</span></span><br><span class="line">            left, right = low, high</span><br><span class="line">            <span class="keyword">while</span> left&lt;right:</span><br><span class="line">                mid = (left+right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> arr[mid] &lt; x:</span><br><span class="line">                    left = mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="comment"># arr.insert(left, x)</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):         <span class="comment"># 反向遍历</span></span><br><span class="line">            <span class="comment"># pos = bisect.bisect_left(sl, nums[i])      # 找到右边比当前值小的元素个数</span></span><br><span class="line">            pos = bisect_left(sl, nums[i], <span class="number">0</span>, <span class="built_in">len</span>(sl))   <span class="comment"># 找到右边比当前值小的元素个数</span></span><br><span class="line">            res[i] = pos                     <span class="comment"># 记入答案</span></span><br><span class="line">            sl.insert(pos, nums[i])          <span class="comment"># 将当前值加入有序数组中</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>可简写为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedList</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">0</span>] * n</span><br><span class="line">        sl = SortedList()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):        <span class="comment"># 反向遍历</span></span><br><span class="line">            cnt = sl.bisect_left(nums[i])   <span class="comment"># 找到右边比当前值小的元素个数</span></span><br><span class="line">            res[i] = cnt                    <span class="comment"># 记入答案</span></span><br><span class="line">            sl.add(nums[i])                 <span class="comment"># 将当前值加入有序数组中</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;树状数组、线段树方法，请参考<a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/4chong-jie-fa-yi-wang-da-jin-pai-xu-shu-5vvds/">《『 4种解法一网打尽 』 有序数组、归并排序、树状数组和线段树的实现及注释》</a>。</p><h3 id="2-7-最大间距-（题164）"><a href="#2-7-最大间距-（题164）" class="headerlink" title="2.7 最大间距  （题164）"></a>2.7 最大间距  （题164）</h3><p>&#8195;&#8195;给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。</p><blockquote><p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。</p></blockquote><p>示例 :</p><ul><li>输入: nums = [3,6,9,1]</li><li>输出: 3</li><li>解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</li><li>提示：$1 &lt;= nums.length &lt;= 10^5$，$0 &lt;= nums[i] &lt;= 10^9$<h4 id="2-7-1-基数排序"><a href="#2-7-1-基数排序" class="headerlink" title="2.7.1 基数排序"></a>2.7.1 基数排序</h4>根据题意可知所有元素都是非负整数，且数值在 32 位有符号整数范围内。所以我们可以选择基数排序。基数排序的步骤如下：</li></ul><ol><li>遍历数组元素，获取数组最大值元素，并取得位数。</li><li>以个位元素为索引，对数组元素排序。</li><li>合并数组。</li><li>之后依次以十位，百位，…，直到最大值元素的最高位处值为索引，进行排序，并合并数组，最终完成排序。</li><li>最后，还要注意数组元素个数小于 2 的情况需要特别判断一下。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">radixSort</span>(<span class="params">self, arr</span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(<span class="built_in">str</span>(<span class="built_in">max</span>(arr)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">                buckets[num // (<span class="number">10</span> ** i) % <span class="number">10</span>].append(num)</span><br><span class="line">            arr.clear()</span><br><span class="line">            <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">                <span class="keyword">for</span> num <span class="keyword">in</span> bucket:</span><br><span class="line">                    arr.append(num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        arr = self.radixSort(nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(arr[i] - arr[i - <span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)))</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(N)。</li></ul><h4 id="2-7-2-桶排序"><a href="#2-7-2-桶排序" class="headerlink" title="2.7.2 桶排序"></a>2.7.2 桶排序</h4><p><img src="https://img-blog.csdnimg.cn/e060550fd85f49bb89d4ded2b014e57b.png" alt="在这里插入图片描述"><br>例如：nums = [1,3,4,5,6,10,11,12,17]<br>则：每个桶的长度 = （17 - 1） / (9-1) = 2。桶的个数 = （17-1）/ 2 + 1 = 9<br>所以我们的桶为（左闭右开）：<br><img src="https://img-blog.csdnimg.cn/5e98342b3bf14c149589a5f23467448d.png" alt="在这里插入图片描述"><br>答案 = max（差值） = 5。</p><blockquote><p>&#8195;&#8195;注意：在桶长度这里我们进行了和1取max的操作，这是为了一些边界条件的情况，比如数组是<code>[1,1,1,1]</code>。当然我们也可以不取max，把向下取整改为向上取整。<br>&#8195;&#8195;在所有排序算法里，我们一般认为快速排序是速度相对较快的，然而桶排序在大多数情况下比快速排序还要快，但是它付出的代价就是牺牲<code>O(n)</code>空间的复杂度，且比归并排序的空间占用要多一点点，多出来的一点点就是可能出现的空桶。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 一些初始化</span></span><br><span class="line">        max_ = <span class="built_in">max</span>(nums)</span><br><span class="line">        min_ = <span class="built_in">min</span>(nums)</span><br><span class="line">        max_gap = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        each_bucket_len = <span class="built_in">max</span>(<span class="number">1</span>,(max_-min_) // (<span class="built_in">len</span>(nums)-<span class="number">1</span>))</span><br><span class="line">        buckets =[[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>((max_-min_) // each_bucket_len + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 把数字放入桶中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            loc = (nums[i] - min_) // each_bucket_len</span><br><span class="line">            buckets[loc].append(nums[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历桶更新答案</span></span><br><span class="line">        prev_max = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(buckets)):</span><br><span class="line">            <span class="keyword">if</span> buckets[i] <span class="keyword">and</span> prev_max != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">                max_gap = <span class="built_in">max</span>(max_gap, <span class="built_in">min</span>(buckets[i])-prev_max)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> buckets[i]:</span><br><span class="line">                prev_max = <span class="built_in">max</span>(buckets[i])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> max_gap</span><br></pre></td></tr></table></figure><h4 id="2-7-3-你的代码真是无敌了"><a href="#2-7-3-你的代码真是无敌了" class="headerlink" title="2.7.3 你的代码真是无敌了"></a>2.7.3 你的代码真是无敌了</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums=<span class="built_in">sorted</span>(nums)</span><br><span class="line">            res=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i+<span class="number">1</span>]-nums[i]&gt;res:</span><br><span class="line">                    res= nums[i+<span class="number">1</span>]-nums[i]</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/a2fa801f1214400d9194fc0595bc8eb7.png" alt="在这里插入图片描述"><br>之前最快的是224ms。</p><h3 id="2-8-数组的相对顺序（题1122）"><a href="#2-8-数组的相对顺序（题1122）" class="headerlink" title="2.8 数组的相对顺序（题1122）"></a>2.8 数组的相对顺序（题1122）</h3><p>&#8195;&#8195;给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。<br>&#8195;&#8195;对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p><ul><li>示例 1：<ul><li>输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]</li><li>输出：[2,2,2,1,4,3,3,9,6,7,19]</li></ul></li><li>示例  2:<ul><li>输入：arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]</li><li>输出：[22,28,8,6,17,44]</li></ul></li></ul><p>提示：1 &lt;= arr1.length, arr2.length &lt;= 1000；0 &lt;= arr1[i], arr2[i] &lt;= 1000</p><p>因为元素值范围在 [0, 1000]，所以可以使用计数排序的思路来解题。</p><ol><li>使用数组 count 统计 arr1 各个元素个数。</li><li>遍历 arr2 数组，将对应元素num2 按照个数 count[num2] 添加到答案数组 ans 中，同时在 count 数组中减去对应个数。</li><li>然后在处理 count 中剩余元素，将 count 中大于 0 的元素下标依次添加到答案数组 ans 中。最后返回答案数组 ans</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">relativeSortArray</span>(<span class="params">self, arr1: <span class="type">List</span>[<span class="built_in">int</span>], arr2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># 计算待排序序列中最大值元素 arr_max 和最小值元素 arr_min</span></span><br><span class="line">        arr1_min, arr1_max = <span class="built_in">min</span>(arr1), <span class="built_in">max</span>(arr1)</span><br><span class="line">        <span class="comment"># 定义计数数组 counts，大小为 最大值元素 - 最小值元素 + 1</span></span><br><span class="line">        size = arr1_max - arr1_min + <span class="number">1</span></span><br><span class="line">        counts = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 统计值为 num 的元素出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr1:</span><br><span class="line">            counts[num - arr1_min] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr2:</span><br><span class="line">            <span class="keyword">while</span> counts[num - arr1_min] &gt; <span class="number">0</span>:</span><br><span class="line">                res.append(num)</span><br><span class="line">                counts[num - arr1_min] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">while</span> counts[i] &gt; <span class="number">0</span>:</span><br><span class="line">                num = i + arr1_min</span><br><span class="line">                res.append(num)</span><br><span class="line">                counts[i] -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="2-9-存在重复元素-III（题220）"><a href="#2-9-存在重复元素-III（题220）" class="headerlink" title="2.9 存在重复元素 III（题220）"></a>2.9 存在重复元素 III（题220）</h3><p>&#8195;&#8195;给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>t</code> 。请你判断是否存在 两个不同下标 i 和 j，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code> 。如果存在则返回 true，不存在返回 false。 </p><ul><li>示例 1：<ul><li>输入：nums = [1,2,3,1], k = 3, t = 0</li><li>输出：true</li></ul></li><li>示例2：<ul><li>输入：nums = [1,5,9,1,5,9], k = 2, t = 3</li><li>输出：false</li></ul></li></ul><p>&#8195;&#8195;题目中需要满足两个要求，一个是元素值的要求（abs(nums[i] - nums[j]) &lt;= t） ，一个是下标范围的要求（abs(i - j) &lt;= k）。所以对于任意一个位置 i 来说，合适的 j 应该在区间 <code>[i - k, i + k]</code> 内，同时 nums[j] 值应该在区间 <code>[nums[i] - t, nums[i] + t]</code> 内。<br>&#8195;&#8195;检测相邻 2 * k 个元素是否满足 <code>abs(nums[i] - nums[j]) &lt;= t</code> 的方法。有两种思路：「桶排序」和「滑动窗口（固定长度）」。</p><h4 id="2-9-1-桶排序"><a href="#2-9-1-桶排序" class="headerlink" title="2.9.1 桶排序"></a>2.9.1 桶排序</h4><blockquote><p>参考【题解】<a href="https://leetcode.cn/problems/contains-duplicate-iii/solution/li-yong-tong-de-yuan-li-onpython3-by-zhou-pen-chen/">利用桶的原理O(n)，Python3 - 存在重复元素 III - 力扣</a></p></blockquote><ol><li>利用桶排序的思想，将桶的大小设置为 <code>t + 1</code>。只需要使用一重循环遍历位置 <code>i</code>，然后根据 <code>nums[i] // (t + 1)</code>，从而决定将 <code>nums[i]</code> 放入哪个桶中。</li><li>这样在同一个桶内各个元素之间的差值绝对值都小于等于 <code>t</code>。而相邻桶之间的元素，只需要校验一下两个桶之间的差值是否不超过 <code>t</code>。这样就可以以 $O(1)$ 的时间复杂度检测相邻 <code>2 * k</code> 个元素是否满足 <code>abs(nums[i] - nums[j]) &lt;= t</code>。</li><li>而 <code>abs(i - j) &lt;= k</code> 条件则可以通过在一重循环遍历时，将超出范围的 <code>nums[i - k]</code> 从对应桶中删除，从而保证桶中元素一定满足 <code>abs(i - j) &lt;= k</code>。</li></ol><p>具体步骤如下：</p><ol><li>将每个桶的大小设置为 <code>t + 1</code>。我们将元素按照大小依次放入不同的桶中。</li><li>遍历数组 <code>nums</code> 中的元素，对于元素<code>nums[i]</code> ：<ol><li>如果 <code>nums[i]</code> 放入桶之前桶里已经有元素了，那么这两个元素必然满足 <code>abs(nums[i] - nums[j]) &lt;= t</code>，</li><li>如果之前桶里没有元素，那么就将 <code>nums[i]</code> 放入对应桶中。</li><li>再判断左右桶的左右两侧桶中是否有元素满足 <code>abs(nums[i] - nums[j]) &lt;= t</code>。</li><li>然后将 <code>nums[i - k]</code> 之前的桶清空，因为这些桶中的元素与 <code>nums[i]</code> 已经不满足 <code>abs(i - j) &lt;= k</code> 了。</li></ol></li><li>最后上述满足条件的情况就返回 <code>True</code>，最终遍历完仍不满足条件就返回 <code>False</code>。</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        bucket_dict = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 将 nums[i] 划分到大小为 t + 1 的不同桶中</span></span><br><span class="line">            num = nums[i] // (t + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 桶中已经有元素了</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> bucket_dict:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 把 nums[i] 放入桶中</span></span><br><span class="line">            bucket_dict[num] = nums[i]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断左侧桶是否满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (num - <span class="number">1</span>) <span class="keyword">in</span> bucket_dict <span class="keyword">and</span> <span class="built_in">abs</span>(bucket_dict[num - <span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 判断右侧桶是否满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (num + <span class="number">1</span>) <span class="keyword">in</span> bucket_dict <span class="keyword">and</span> <span class="built_in">abs</span>(bucket_dict[num + <span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 将 i - k 之前的旧桶清除，因为之前的桶已经不满足条件了</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">                bucket_dict.pop(nums[i - k] // (t + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：$O(n)$。$n$ 是给定数组长度。</li><li><strong>空间复杂度</strong>：$O(min(n, k))$。桶中最多包含 $min(n, k + 1)$ 个元素。</li></ul><h4 id="2-9-2滑动窗口（固定长度）"><a href="#2-9-2滑动窗口（固定长度）" class="headerlink" title="2.9.2滑动窗口（固定长度）"></a>2.9.2滑动窗口（固定长度）</h4><ol><li>使用一个长度为 <code>k</code> 的滑动窗口，每次遍历到 <code>nums[right]</code> 时，滑动窗口内最多包含 <code>nums[right]</code> 之前最多 <code>k</code> 个元素。只需要检查前 <code>k</code> 个元素是否在 <code>[nums[right] - t, nums[right] + t]</code> 区间内即可。</li><li>检查 <code>k</code> 个元素是否在 <code>[nums[right] - t, nums[right] + t]</code> 区间，可以借助保证有序的数据结构（比如 <code>SortedList</code>）+ 二分查找来解决，从而减少时间复杂度。</li></ol><p>具体步骤如下：</p><ol><li>使用有序数组类 <code>window</code> 维护一个长度为 <code>k</code> 的窗口，满足数组内元素有序，且支持增加和删除操作。</li><li><code>left</code>、<code>right</code> 都指向序列的第一个元素。即：<code>left = 0</code>，<code>right = 0</code>。</li><li>将当前元素填入窗口中，即 <code>window.add(nums[right])</code>。</li><li>当窗口元素大于 <code>k</code> 个时，即 <code>right - left &gt; k</code>，移除窗口最左侧元素，并向右移动 <code>left</code>。</li><li>当窗口元素小于等于 <code>k</code> 个时：<ol><li>使用二分查找算法，查找 <code>nums[right]</code> 在 <code>window</code> 中的位置 <code>idx</code>。</li><li>判断 <code>window[idx]</code> 与相邻位置上元素差值绝对值，若果满足 <code>abs(window[idx] - window[idx - 1]) &lt;= t</code> 或者 <code>abs(window[idx + 1] - window[idx]) &lt;= t</code> 时返回 <code>True</code>。</li></ol></li><li>向右移动 <code>right</code>。</li><li>重复 <code>3</code> ~ <code>6</code> 步，直到 <code>right</code> 到达数组末尾，如果还没找到满足条件的情况，则返回 <code>False</code>。</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedList</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        window = SortedList()</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; size:</span><br><span class="line">            window.add(nums[right])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> right - left &gt; k:</span><br><span class="line">                window.remove(nums[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            idx = bisect.bisect_left(window, nums[right])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> idx &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">abs</span>(window[idx] - window[idx - <span class="number">1</span>]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> idx &lt; <span class="built_in">len</span>(window) - <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">abs</span>(window[idx + <span class="number">1</span>] - window[idx]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>：$O(n \times \log_2(min(n, k)))$。</li><li><strong>空间复杂度</strong>：$O(min(n, k))$。</li></ul><h3 id="2-10-合并区间（题56）"><a href="#2-10-合并区间（题56）" class="headerlink" title="2.10 合并区间（题56）"></a>2.10 合并区间（题56）</h3><p>&#8195;&#8195;给定数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><ul><li><p>示例 1：</p><ul><li>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</li><li>输出：[[1,6],[8,10],[15,18]]</li><li>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li></ul></li><li><p>示例 2：</p><ul><li>输入：intervals = [[1,4],[4,5]]</li><li>输出：[[1,5]]</li><li>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</li></ul></li><li><p>说明：</p><ul><li>$1 \le intervals.length \le 10^4$。</li><li>$intervals[i].length == 2$。</li><li>$0 \le starti \le endi \le 10^4$。</li></ul></li></ul><p>此题可以考虑对区间进行排序：</p><ol><li>设定一个数组 <code>ans</code> 用于表示最终不重叠的区间数组</li><li>对原始区间先按照区间左端点大小从小到大进行排序。</li><li>遍历所有区间，先将第一个区间加入 <code>ans</code> 数组中。然后依次考虑后边的区间：<ol><li>如果第 <code>i</code> 个区间左端点在前一个区间右端点右侧，则这两个区间不会重合，直接将该区间加入 <code>ans</code> 数组中。</li><li>否则的话，这两个区间重合，判断一下两个区间的右区间值，更新前一个区间的右区间值为较大值，然后继续考虑下一个区间，以此类推。</li></ol></li><li>最后返回数组 <code>ans</code>。</li></ol><p><strong>代码</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    </span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="comment"># not ans表示初始ans为空。ans[-1][1]是最后一个加入的区间的右端点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ans <span class="keyword">or</span> ans[-<span class="number">1</span>][<span class="number">1</span>] &lt; interval[<span class="number">0</span>]:</span><br><span class="line">                ans.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(ans[-<span class="number">1</span>][<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p><ul><li><strong>时间复杂度</strong>：$O(n \times \log_2 n)$。其中 $n$ 为区间数量。</li><li><strong>空间复杂度</strong>：$O(n)$。</li></ul><h3 id="2-11-最大数（题179）"><a href="#2-11-最大数（题179）" class="headerlink" title="2.11 最大数（题179）"></a>2.11 最大数（题179）</h3><h4 id="2-11-1-自定义排序（内置函数）"><a href="#2-11-1-自定义排序（内置函数）" class="headerlink" title="2.11.1 自定义排序（内置函数）"></a>2.11.1 自定义排序（内置函数）</h4><p>&#8195;&#8195;本质上是给数组进行排序。假设 x、y 是数组 nums 中的两个元素，规定 排序判断规则 为：如果拼接字符串 x + y &lt; y + x，则 y &gt; x 。y 应该排在 x 前面。反之，则 y &lt; x。<br>&#8195;&#8195;按照上述规则，对原数组套用任何方法进行排序即可。这里我们使用了 functools.cmp_to_key 自定义排序函数。<br><img src="https://img-blog.csdnimg.cn/e93c592b588f4c2896d1a54db9cad4de.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cmp</span>(<span class="params">a, b</span>):</span></span><br><span class="line">            <span class="keyword">if</span> a + b == b + a:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> a + b &gt; b + a:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        nums_s = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, nums))</span><br><span class="line">        nums_s.sort(key=functools.cmp_to_key(cmp), reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(nums_s)))</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：$O(n^2)$。其中 $n$ 为区间数量。</li><li><strong>空间复杂度</strong>：$O(n)$。</li></ul><p>类似的还有<a href="https://algo.itcharge.cn/Solutions/Offer/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cmp</span>(<span class="params">a, b</span>):</span></span><br><span class="line">            <span class="keyword">if</span> a + b == b + a:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> a + b &gt; b + a:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        nums_s = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, nums))</span><br><span class="line">        nums_s.sort(key=functools.cmp_to_key(cmp))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(nums_s)</span><br></pre></td></tr></table></figure><h4 id="2-11-2-自定义排序（快速排序）"><a href="#2-11-2-自定义排序（快速排序）" class="headerlink" title="2.11.2 自定义排序（快速排序）"></a>2.11.2 自定义排序（快速排序）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">l , r</span>):</span></span><br><span class="line">            <span class="keyword">if</span> l &gt;= r: <span class="keyword">return</span></span><br><span class="line">            i, j = l, r</span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                <span class="keyword">while</span> strs[j] + strs[l] &gt;= strs[l] + strs[j] <span class="keyword">and</span> i &lt; j: j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> strs[i] + strs[l] &lt;= strs[l] + strs[i] <span class="keyword">and</span> i &lt; j: i += <span class="number">1</span></span><br><span class="line">                strs[i], strs[j] = strs[j], strs[i]</span><br><span class="line">            strs[i], strs[l] = strs[l], strs[i]</span><br><span class="line">            quick_sort(l, i - <span class="number">1</span>)</span><br><span class="line">            quick_sort(i + <span class="number">1</span>, r)</span><br><span class="line">        </span><br><span class="line">        strs = [<span class="built_in">str</span>(num) <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">        quick_sort(<span class="number">0</span>, <span class="built_in">len</span>(strs) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(strs)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;@[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;资源：&lt;a href=&quot;https://leetcode.cn/problemset/all/&quot;&gt;力扣题库&lt;/a&gt;、&lt;a href=&quot;https://algo.itcharge.cn/00.Introduction/05.Categories-List/&quot;&gt;LeetCode 刷题列表&lt;/a&gt;、&lt;a href=&quot;https://programmercarl.com/&quot;&gt;代码随想录&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;p&gt;参考&lt;a href=&quot;https://algo.itcharge.cn/01.Array/02.Array-Sort/01.Array-Bubble-Sort/&quot;&gt;《数组排序》&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/Dby_freedom/article/details/82154869&quot;&gt;《排序算法总结（Python版）》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、排序算法&quot;&gt;&lt;a href=&quot;#一、排序算法&quot; class=&quot;headerlink&quot; title=&quot;一、排序算法&quot;&gt;&lt;/a&gt;一、排序算法&lt;/h2&gt;&lt;h3 id=&quot;1-1-冒泡排序&quot;&gt;&lt;a href=&quot;#1-1-冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1.1  冒泡排序&quot;&gt;&lt;/a&gt;1.1  冒泡排序&lt;/h3&gt;&lt;h4 id=&quot;1-1-1-算法步骤&quot;&gt;&lt;a href=&quot;#1-1-1-算法步骤&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 算法步骤&quot;&gt;&lt;/a&gt;1.1.1 算法步骤&lt;/h4&gt;&lt;p&gt;&amp;#8195;&amp;#8195;&lt;strong&gt;冒泡排序（&lt;code&gt;Bubble Sort&lt;/code&gt;）基本思想&lt;/strong&gt;：通过相邻元素之间的比较与交换，使值较小的元素逐步从后面移到前面，值较大的元素从前面移到后面。这个过程就像水底的气泡一样向上冒，这也是冒泡排序法名字的由来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动画演示：&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/bf8b6bcf68ef4e23ade1157ba48fabd3.gif#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Data Structure and Algorithms" scheme="https://zhxnlp.github.io/categories/Data-Structure-and-Algorithms/"/>
    
    
    <category term="leetcode" scheme="https://zhxnlp.github.io/tags/leetcode/"/>
    
    <category term="Sort" scheme="https://zhxnlp.github.io/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习一：数组（二分查找、双指针、滑动窗口）</title>
    <link href="https://zhxnlp.github.io/2023/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode%E7%BB%83%E4%B9%A0%E4%B8%80%EF%BC%9A%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/"/>
    <id>https://zhxnlp.github.io/2023/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode%E7%BB%83%E4%B9%A0%E4%B8%80%EF%BC%9A%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/</id>
    <published>2023-02-11T16:31:59.000Z</published>
    <updated>2023-04-08T00:36:00.525Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>资源：<a href="https://leetcode.cn/problemset/all/">力扣题库</a>、<a href="https://algo.itcharge.cn/00.Introduction/05.Categories-List/">LeetCode 刷题列表</a>、<a href="https://programmercarl.com/">代码随想录</a></p></blockquote><h2 id="一、-数组理论基础"><a href="#一、-数组理论基础" class="headerlink" title="一、 数组理论基础"></a>一、 数组理论基础</h2><blockquote><p>参考代码随想录<a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">《数组理论基础》</a></p><p>数组是存放在连续内存空间上的相同类型数据的集合，数组可以方便的通过下标索引的方式获取到下标下对应的数据，例如：<br><img src="https://img-blog.csdnimg.cn/ba939ff642cb4170a7052f4ac65d3563.png" alt="在这里插入图片描述"><br>有两点需要注意：</p><ul><li>数组下标都是从0开始的。</li><li>数组内存空间的地址是连续的<span id="more"></span>正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：<br><img src="https://img-blog.csdnimg.cn/7b5a3e0d29074bdc9a88e17d60576e9f.png" alt="在这里插入图片描述"><br>那么二维数组在内存的空间地址是连续的么？不同编程语言的内存管理是不一样的。在C++中二维数组是连续分布的，Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。</li></ul></blockquote><h2 id="二、-二分查找"><a href="#二、-二分查找" class="headerlink" title="二、 二分查找"></a>二、 二分查找</h2><h3 id="2-1-解题思路"><a href="#2-1-解题思路" class="headerlink" title="2.1 解题思路"></a>2.1 解题思路</h3><p>&#8195;&#8195;<strong>二分法的前提条件</strong>：数组为有序数组<br>&#8195;&#8195;<strong>循环不变量规则</strong>：在二分查找的过程中，区间的定义是不变量，所以在while寻找中每一次边界的处理都要坚持根据区间的定义来操作。<br>&#8195;&#8195;区间的定义决定了二分法的代码应该如何写。区间的定义一般为两种，左闭右闭即<code>[left, right]</code>，或者左闭右开即<code>[left, right)</code>。</p><p>具体思路：</p><p><img src="https://img-blog.csdnimg.cn/e59ac11b1c504d989811dd0aad8e01b0.png" alt="在这里插入图片描述"></p><p><strong>1. 左闭右闭写法</strong><br>因为定义target在<code>[left, right]</code>区间，所以有如下两点：</p><ul><li><code>while (left &lt;= right)</code> 要使用 <code>&lt;=</code> ，因为<code>left == right</code>是有意义的，所以使用 &lt;=</li><li><code>if (nums[middle] &gt; target)</code> ，right 要赋值为 <code>middle - 1</code>，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><p><strong>2. 左闭右开写法</strong><br>因为定义target在<code>[left, right)</code>区间，所以有如下两点：</p><ul><li><code>while (left &lt; right)</code>，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li><code>if (nums[middle] &gt; target)</code> right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><h3 id="2-2-练习题"><a href="#2-2-练习题" class="headerlink" title="2.2 练习题"></a>2.2 练习题</h3><h4 id="2-2-1-二分查找-题704"><a href="#2-2-1-二分查找-题704" class="headerlink" title="2.2.1  二分查找(题704)"></a>2.2.1  二分查找(题704)</h4><p>解法一：左闭右闭:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = left + (right - left) // <span class="number">2</span> <span class="comment"># 防止溢出 等同于(left + right)/2            </span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &gt; target:</span><br><span class="line">                right = middle - <span class="number">1</span>  <span class="comment"># target在左区间，所以[left, middle - 1]</span></span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &lt; target:</span><br><span class="line">                left = middle + <span class="number">1</span>  <span class="comment"># target在右区间，所以[middle + 1, right]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle  <span class="comment"># 数组中找到目标值，直接返回下标</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 未找到目标值</span></span><br></pre></td></tr></table></figure><br>解法二：左闭右开<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)  <span class="comment"># 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:  <span class="comment"># 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            middle = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &gt; target:</span><br><span class="line">                right = middle  <span class="comment"># target 在左区间，在[left, middle)中</span></span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &lt; target:</span><br><span class="line">                left = middle + <span class="number">1</span>  <span class="comment"># target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle  <span class="comment"># 数组中找到目标值，直接返回下标</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 未找到目标值</span></span><br></pre></td></tr></table></figure></p><h4 id="2-2-2-搜索插入位置（题35）"><a href="#2-2-2-搜索插入位置（题35）" class="headerlink" title="2.2.2  搜索插入位置（题35）"></a>2.2.2  搜索插入位置（题35）</h4><p>要在数组中插入目标值，无非是这四种情况：</p><ul><li>目标值在数组所有元素之前</li><li>目标值等于数组中某一个元素（就是上一题）</li><li>目标值插入数组中的位置<code>nums[pos−1]&lt;target≤nums[pos]</code></li><li>目标值在数组所有元素之后</li></ul><p>对于数组中没有目标值的情况，其实就是寻找升序数组中第一个大于等于$\textit{target}$ 的下标。经过测试可知，这个下标是<code>right+1（left）</code>，所以本题答案为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span> </span><br><span class="line">        ans=<span class="built_in">len</span>(nums)     </span><br><span class="line">        <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">            mid=(left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;target:</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid]&gt;target:</span><br><span class="line">                right=mid-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> right+<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-查找排序数组元素起止位置（题34）"><a href="#2-2-3-查找排序数组元素起止位置（题34）" class="headerlink" title="2.2.3  查找排序数组元素起止位置（题34）"></a>2.2.3  查找排序数组元素起止位置（题34）</h4><p>&#8195;&#8195;直观的思路肯定是从前往后遍历一遍。用两个变量记录第一次和最后一次遇见 $\textit{target}$ 的下标，但这个方法的时间复杂度为 $O(n)$，没有利用到数组升序排列的条件。由于数组已经排序，因此整个数组是单调递增的，我们可以利用二分法来加速查找的过程。</p><p>&#8195;&#8195;考虑<code>target</code>开始和结束位置，其实就是查找数组中<strong>第一个等于target 的位置</strong>（记为<code>start</code>）和<strong>第一个大于target 的位置减1</strong>（记为 <code>end</code>）。为了代码的复用，我们定义 <code>lower_bound(nums,target)</code>函数，表示在 $nums$ 数组中二分查找 $target$的位置。</p><p>&#8195;&#8195;最后，因为 $target$可能不存在数组中，因此我们需要重新校验我们得到的两个下标，看是否符合条件，如果符合条件就返回<code>[start,end]</code>，不符合就返回<code>[−1,−1]</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">nums,target</span>):</span></span><br><span class="line">            <span class="comment"># lower_bound返回最小的满足nums[i]&gt;=targrt的i</span></span><br><span class="line">            left,right=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>   </span><br><span class="line">            <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">                mid=(left+right)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid]&lt;target:</span><br><span class="line">                    left=mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right=mid-<span class="number">1</span>           </span><br><span class="line">            <span class="keyword">return</span> right+<span class="number">1</span> <span class="comment"># 或left</span></span><br><span class="line">        start=lower_bound(nums,target) <span class="comment"># 第一个大于等于target的下标</span></span><br><span class="line">        <span class="keyword">if</span> start==<span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start]!=target:</span><br><span class="line">        <span class="comment"># 分别对应target大于整个数组和target不在数组中</span></span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end=lower_bound(nums,target+<span class="number">1</span>)-<span class="number">1</span> <span class="comment"># 第一个大于target 的下标</span></span><br><span class="line">        <span class="keyword">return</span> [start,end]</span><br></pre></td></tr></table></figure><h4 id="2-2-4-有效的完全平方数（题367）"><a href="#2-2-4-有效的完全平方数（题367）" class="headerlink" title="2.2.4 有效的完全平方数（题367）"></a>2.2.4 有效的完全平方数（题367）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPerfectSquare</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        left,right=<span class="number">1</span>,num</span><br><span class="line">        <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">            mid=(left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid*mid&gt;num:</span><br><span class="line">                right=mid-<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mid*mid&lt;num:</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="2-2-5-x-的平方根（题69）"><a href="#2-2-5-x-的平方根（题69）" class="headerlink" title="2.2.5 x 的平方根（题69）"></a>2.2.5 x 的平方根（题69）</h4><p>&#8195;&#8195;由于 x 平方根的整数部分ans 是满足 $k^2 \leq x$的最大 k 值，因此我们可以对 k进行二分查找，从而得到答案。<br>&#8195;&#8195;二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 <code>mid</code> 的平方与 <code>x</code> 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 <code>ans</code> 后，也就不需要再去尝试 <code>ans+1</code> 了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left,right=<span class="number">0</span>,x</span><br><span class="line">        <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">            mid=(left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid*mid&lt;=x: <span class="comment"># 根据牛顿迭代法，可以写mid**2&lt;=x</span></span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><h4 id="2-2-6-寻找峰值（题162）"><a href="#2-2-6-寻找峰值（题162）" class="headerlink" title="2.2.6 寻找峰值（题162）"></a>2.2.6 寻找峰值（题162）</h4><p>&#8195;&#8195;使用两个指针 left、right 。left 指向数组第一个元素，right 指向数组最后一个元素。取区间中间节点 mid，并比较 nums[mid] 和 nums[mid + 1] 的值大小。</p><ul><li>如果 nums[mid] 小于 nums[mid + 1]，则右侧存在峰值，令 left = mid + 1。</li><li>如果 nums[mid] 大于等于 nums[mid + 1]，则左侧存在峰值，令 right = mid。</li></ul><p>&#8195;&#8195;最后，当 left == right 时，跳出循环，返回 left。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        left,right=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left </span><br></pre></td></tr></table></figure><h4 id="2-2-7-寻找旋转排序数组中的最小值（题153）"><a href="#2-2-7-寻找旋转排序数组中的最小值（题153）" class="headerlink" title="2.2.7 寻找旋转排序数组中的最小值（题153）"></a>2.2.7 寻找旋转排序数组中的最小值（题153）</h4><p>&#8195;&#8195;二分查找的前提条件是数组有序，本题数组经过旋转之后，前半部分和后半部分也都是有序的，所以也可以使用二分查找。<br>&#8195;&#8195;数组经过「旋转」之后，会有两种情况，第一种就是原先的升序序列，另一种是两段升序的序列。第一种的最小值在最左边。第二种最小值在第二段升序序列的第一个元素。</p><blockquote><p>解说视频见<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solution/jian-dan-yi-dong-javac-pythonjspei-yang-zvoif/">官方题解</a><br><img src="https://img-blog.csdnimg.cn/680d06470b2b446f8d106166d16ea391.png" alt="在这里插入图片描述"></p></blockquote><ul><li>如果 <code>nums[mid] &gt; nums[right]</code>，则最小值一定在 mid 右侧，则令<code>left= mid + 1</code> ，继续查找右侧区间。</li><li>如果 <code>nums[mid] ≤ nums[right]</code>，则最小值一定在 mid 左侧，或者 mid 位置，令 <code>right = mid</code> ，继续查找左侧区间。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left,right=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:         <span class="comment"># 不能取等号，保证查找区间至少有一个元素</span></span><br><span class="line">            mid=(left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;nums[right]:</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right=mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;类似题目还有<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a> ，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment"># 无法判断在 mid 的哪一侧，可以采用 right = right - 1 逐步缩小区域</span></span><br><span class="line">                right = right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><h4 id="2-2-8-搜索旋转排序数组-（题33）"><a href="#2-2-8-搜索旋转排序数组-（题33）" class="headerlink" title="2.2.8 搜索旋转排序数组  （题33）"></a>2.2.8 搜索旋转排序数组  （题33）</h4><p>&#8195;&#8195;原本为升序排列的数组 nums 经过「旋转」之后，会有两种情况，第一种就是原先的升序序列，另一种是两段升序的序列。其实我们可以把第一种情况中的整个数组看做是左半部分，然后右半部分为空数组。所以将旋转后的数组看成左右两个升序部分：左半部分和右半部分。<br>&#8195;&#8195;创建两个指针 left、right，分别指向数组首尾。让后计算出两个指针中间值 mid。将 mid 与两个指针做比较，并考虑与 target 的关系。</p><ul><li>如果 <code>mid[mid] == target</code>，说明找到了 <code>target</code>，直接返回下标。</li><li><p>如果 <code>nums[mid] ≥ nums[left]</code>，则 <code>mid</code> 在左半部分（因为右半部分值都比 <code>nums[left]</code> 小）。</p><ul><li>如果 <code>nums[mid] ≥ target</code>，并且 <code>target ≥ nums[left]</code>，则 <code>target</code> 在左半部分，并且在 <code>mid</code> 左侧，此时应将 <code>right</code> 左移到 <code>mid - 1</code> 位置。</li><li>如果 <code>nums[mid] ≤ target</code>，则 <code>target</code> 在左半部分，并且在 <code>mid</code> 右侧，此时应将 <code>left</code> 右移到 <code>mid + 1</code> 位置。</li><li>如果 <code>nums[left] &gt; target</code>，则 <code>target</code> 在右半部分，应将 <code>left</code> 移动到 <code>mid + 1</code> 位置。</li></ul></li><li><p>如果 <code>nums[mid] &lt; nums[left]</code>，则 <code>mid</code> 在右半部分（因为右半部分值都比 <code>nums[left]</code> 小）。</p><ul><li>如果 <code>nums[mid] &lt; target</code>，并且 <code>target ≤ nums[right]</code>，则 <code>target</code> 在右半部分，并且在 <code>mid</code> 右侧，此时应将 <code>left</code> 右移到 <code>mid + 1</code> 位置。</li><li>如果 <code>nums[mid] ≥ target</code>，则 <code>target</code> 在右半部分，并且在 <code>mid</code> 左侧，此时应将 <code>right</code> 左移到 <code>mid - 1</code> 位置。</li><li>如果 <code>nums[right] &lt; target</code>，则 <code>target</code> 在左半部分，应将 <code>right</code> 左移到 <code>mid - 1</code> 位置</li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= nums[left]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; target <span class="keyword">and</span> target &gt;= nums[left]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>与之类似的还有搜索旋转排序数组 II，区别是数组元素会重复。</p><ul><li><p>如果 nums[mid] &gt; nums[left]，则 mid 在左半部分（因为右半部分值都比 nums[left] 小）。</p><ul><li>如果 nums[mid] ≥ target，并且 target ≥ nums[left]，则 target 在左半部分，并且在 mid 左侧，此时应将 right 左移到 mid - 1 位置。</li><li>否则如果 nums[mid] &lt; target，则 target 在左半部分，并且在 mid 右侧，此时应将 left 右移到 mid + 1。</li><li>否则如果 nums[left] &gt; target，则 target 在右半部分，应将 left 移动到 mid + 1 位置。</li></ul></li><li><p>如果 nums[mid] &lt; nums[left]，则 mid 在右半部分（因为右半部分值都比 nums[left] 小）。</p><ul><li>如果 nums[mid] &lt; target，并且 target ≤ nums[right]，则 target 在右半部分，并且在 mid 右侧，此时应将 left 右移到 mid + 1 位置。</li><li>否则如果 nums[mid] ≥ target，则 target 在右半部分，并且在 mid 左侧，此时应将 right 左移到 mid - 1 位置。</li><li>否则如果 nums[right] &lt; target，则 target 在左半部分，应将 right 左移到 mid - 1 位置。</li></ul></li><li>最终判断 <code>nums[left]</code> 是否等于 <code>target</code>，如果等于，则返回 <code>True</code>，否则返回 <code>False</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[left]:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target <span class="keyword">and</span> target &lt;= nums[mid]:</span><br><span class="line">                    right = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[left]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = left + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left] == target</span><br></pre></td></tr></table></figure><h2 id="三-双指针法"><a href="#三-双指针法" class="headerlink" title="三 双指针法"></a>三 双指针法</h2><h3 id="3-1-解题思路"><a href="#3-1-解题思路" class="headerlink" title="3.1 解题思路"></a>3.1 解题思路</h3><p>以 <a href="https://leetcode.cn/problems/remove-element/">移除元素（27）</a>举例，介绍双指针法。</p><ul><li>暴力解法：这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。删除过程如下：<br><img src="https://img-blog.csdnimg.cn/0b48363fc58d4b4e9ce57f829a9e4d26.gif#pic_center" alt="在这里插入图片描述"></li></ul><p>很明显暴力解法的时间复杂度是$O(n^2)$，空间复杂度：$O(1)$。</p><ul><li>双指针法（快慢指针法）： 右指针 <code>right</code> 指向当前将要处理的元素，左指针<code>left</code> 指向下一个将要赋值的位置。通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。<ul><li>如果右指针指向的元素不等于 <code>val</code>，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</li><li>如果右指针指向的元素等于 <code>val</code>，它不能在输出数组里，此时左指针不动，右指针右移一位。<br><img src="https://img-blog.csdnimg.cn/8fa2b816816c4b008382a2fc76c19abb.gif#pic_center" alt="在这里插入图片描述"><br>&#8195;&#8195;整个过程保持不变的性质是：区间<code>[0,left)</code> 中的元素都不等于 <code>val</code>。当左右指针遍历完输入数组以后，<code>left</code> 的值就是输出数组的长度。这样的算法在最坏情况下（输入数组中没有元素等于<code>val</code>），左右指针各遍历了数组一次。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        fast = <span class="number">0</span>  <span class="comment"># 快指针</span></span><br><span class="line">        slow = <span class="number">0</span>  <span class="comment"># 慢指针</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> fast &lt; size:  <span class="comment"># a = size 时，nums[a] 会越界</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            slow 用来收集不等于 val 的值，如果 fast 对应值不等于 val，</span></span><br><span class="line"><span class="string">            则把它与 slow 替换，同时slow+1。fast不管是否等于val，始终都有fast+1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><ul><li>双指针优化：<ul><li>思路：如果要移除的元素恰好在数组的开头，例如序列 <strong>[1,2,3,4,5]</strong>，当 <code>val</code> 为 1时，我们需要把每一个元素都左移一位。注意到题目中说：<strong>「元素的顺序可以改变」</strong>。实际上我们可以直接将最后一个元素 5 移动到序列开头，取代元素 1，得到序列 [5,2,3,4]，同样满足题目要求。这个优化在序列中<code>val</code> 元素的数量较少时非常有效。</li><li>算法：实现方面，我们依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。<br>&#8195;&#8195;如果左指针 <code>left</code> 指向的元素等于 <code>val</code>，此时将右指针<code>right</code> 指向的元素复制到左指针 <code>left</code> 的位置，然后右指针 <code>right</code> 左移一位。如果赋值过来的元素恰好也等于<code>val</code>，可以继续把右指针 <code>right</code> 指向的元素的值赋值过来（左指针<code>left</code> 指向的等于<code>val</code> 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 <code>val</code> 为止。<br>&#8195;&#8195;当左指针<code>left</code> 和右指针<code>right</code> 重合的时候，左右指针遍历完数组中所有的元素。<br>&#8195;&#8195;<font color='deeppink'>这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作</font>。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow,fast=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> slow &lt;=fast:</span><br><span class="line">            <span class="keyword">if</span> nums[slow] ==val:</span><br><span class="line">                nums[slow]=nums[fast]</span><br><span class="line">                fast-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                slow+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-2-练习题"><a href="#3-2-练习题" class="headerlink" title="3.2 练习题"></a>3.2 练习题</h3><h4 id="3-2-1-删除排序数组中的重复项（题26）"><a href="#3-2-1-删除排序数组中的重复项（题26）" class="headerlink" title="3.2.1 删除排序数组中的重复项（题26）"></a>3.2.1 删除排序数组中的重复项（题26）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        fast = <span class="number">1</span> <span class="comment"># 快指针,因为后面会用到fast-1，所以fast赋值从1开始</span></span><br><span class="line">        slow = <span class="number">1</span> <span class="comment"># 慢指针</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> fast &lt; size:  <span class="comment"># a = size 时，nums[a] 会越界</span></span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[fast-<span class="number">1</span>]: <span class="comment"># 判断很前一个数是否重复</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h4 id="3-2-2-移动零（题283）"><a href="#3-2-2-移动零（题283）" class="headerlink" title="3.2.2 移动零（题283）"></a>3.2.2 移动零（题283）</h4><p><strong>思路：使非0元素左移，等同于使0往右移。</strong><br>算法：使用双指针，右指针不断向右移动。每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移，否则只有右指针右移，左指针不动。<br>&#8195;&#8195;每次交换，都是将左指针的零与右指针的非零数交换，结果就是左右指针之间都是0。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left,right = <span class="number">0</span>,<span class="number">0</span>  </span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):  <span class="comment"># a = size 时，nums[a] 会越界</span></span><br><span class="line">            <span class="keyword">if</span> nums[right] != <span class="number">0</span>: </span><br><span class="line">                nums[left],nums[right] = nums[right], nums[left]       </span><br><span class="line">                left+= <span class="number">1</span></span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">               </span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;也可以看做是参考了快速排序的思想，用0当做这个中间点，把不等于0(注意题目没说不能有负数)的放到中间点的左边，等于0的放到其右边。使用两个指针left和right，只要nums[right]!=0，我们就交换nums[left]和nums[right]：<br><img src="https://img-blog.csdnimg.cn/2a42cabfcf6d48c78589c4082f62cdeb.gif#pic_center =500x" alt="在这里插入图片描述"><br>用for循环写出来就是：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type nums: List[int]</span></span><br><span class="line"><span class="string">:rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">left = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line"><span class="comment"># 当前元素!=0，就把其交换到左边，等于0的交换到右边</span></span><br><span class="line"><span class="keyword">if</span> nums[right]:</span><br><span class="line">nums[left],nums[right] = nums[right],nums[left]</span><br><span class="line">left += <span class="number">1</span></span><br></pre></td></tr></table></figure><br>如果right指针指向末尾来进行交换，会改变非0元素顺序。</p><h4 id="3-2-3-比较含退格的字符串（题844）"><a href="#3-2-3-比较含退格的字符串（题844）" class="headerlink" title="3.2.3 比较含退格的字符串（题844）"></a>3.2.3 比较含退格的字符串（题844）</h4><p>&#8195;&#8195;栈有后进先出的特性，比如网页的后退、文本编辑中的撤销操作等，这些操作的特性都契合这个特性，本题也是一样，所以可以考虑用栈来处理。<br><strong>方法一：重构字符串</strong>：用栈处理遍历过程，每次我们遍历到一个字符：</p><ul><li>如果它是退格符，那么我们将栈顶弹出；</li><li>如果它是普通字符，那么我们将其压入栈中。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       :type s: str</span></span><br><span class="line"><span class="string">       :type t: str</span></span><br><span class="line"><span class="string">       :rtype: bool</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">s</span>):</span></span><br><span class="line">           ls = <span class="built_in">list</span>()</span><br><span class="line">           <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">               <span class="keyword">if</span> ch != <span class="string">&quot;#&quot;</span>:</span><br><span class="line">                   ls.append(ch)</span><br><span class="line">               <span class="keyword">elif</span> ls:</span><br><span class="line">                   ls.pop()</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ls)</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> build(s) == build(t)</span><br></pre></td></tr></table></figure>复杂度分析</li><li>时间复杂度：$O(N+M)$，其中 N 和 M分别为字符串 S 和 T 的长度。我们需要遍历两字符串各一次。</li><li>空间复杂度：$O(N+M)$，其中 N 和 M 分别为字符串 S 和 T 的长度。主要为还原出的字符串的开销。</li></ul><p><strong>方法二：双指针</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back</span>(<span class="params">s</span>):</span></span><br><span class="line">            s=<span class="built_in">list</span>(s)</span><br><span class="line">            slow,fast=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> fast&lt;<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="comment"># 只要快指针不是指向&#x27;#&#x27;就将其赋值给慢指针，同时慢指针右移</span></span><br><span class="line">                <span class="keyword">if</span> s[fast]!=<span class="string">&quot;#&quot;</span>: </span><br><span class="line">                    s[slow]=s[fast]</span><br><span class="line">                    slow+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 当快指针指向&#x27;#&#x27;时慢指针后退一格</span></span><br><span class="line">                    <span class="keyword">if</span> slow&gt;<span class="number">0</span>: <span class="comment"># 慢指针指向空不再退格</span></span><br><span class="line">                        slow-=<span class="number">1</span></span><br><span class="line">                fast+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s[:slow]</span><br><span class="line">        <span class="keyword">return</span> back(s)==back(t)</span><br></pre></td></tr></table></figure><p><strong>方法三：双指针（官方）</strong></p><p>&#8195;&#8195;一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。<br>&#8195;&#8195;具体地，我们定义<code>skip</code> 表示当前待删除的字符的数量。每次我们遍历到一个字符：</p><ul><li>若该字符为退格符，则我们需要多删除一个普通字符，我们让<code>skip + 1</code>；</li><li>若该字符为普通字符：<ul><li>若<code>skip</code> 为 0，则说明当前字符不需要删去；</li><li>若 <code>skip</code> 不为 0，则说明当前字符需要删去，我们让<code>skip - 1</code>。</li></ul></li></ul><p>&#8195;&#8195;所以可以定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。<br><img src="https://img-blog.csdnimg.cn/img_convert/3a7cbd6ec5903c4662a4fd993983dbc1.gif#pic_center =500x" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        up,down=<span class="built_in">len</span>(s)-<span class="number">1</span>,<span class="built_in">len</span>(t)-<span class="number">1</span></span><br><span class="line">        skip_s,skip_t=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> up&gt;=<span class="number">0</span> <span class="keyword">or</span> down&gt;=<span class="number">0</span>: <span class="comment">#同时遍历两个字符串</span></span><br><span class="line">            <span class="keyword">while</span> up&gt;=<span class="number">0</span>:     <span class="comment"># 先逆序遍历s中字符串，找到不需要删除的普通字符</span></span><br><span class="line">                <span class="keyword">if</span> s[up]==<span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    skip_s+=<span class="number">1</span></span><br><span class="line">                    up-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> skip_s&gt;<span class="number">0</span>:</span><br><span class="line">                        up-=<span class="number">1</span></span><br><span class="line">                        skip_s-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">while</span> down&gt;=<span class="number">0</span>:           <span class="comment"># 先逆序遍历s中字符串，找到不需要删除的普通字符</span></span><br><span class="line">                <span class="keyword">if</span> t[down]==<span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    skip_t+=<span class="number">1</span></span><br><span class="line">                    down-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> skip_t&gt;<span class="number">0</span>:</span><br><span class="line">                        down-=<span class="number">1</span></span><br><span class="line">                        skip_t-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 开始进行字符对比</span></span><br><span class="line">            <span class="keyword">if</span> up&gt;=<span class="number">0</span> <span class="keyword">and</span> down&gt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> s[up]!=t[down]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 存在一个字符串遍历完而另一个还没遍历完的情况，此时也是返回False</span></span><br><span class="line">            <span class="keyword">elif</span> up&gt;=<span class="number">0</span> <span class="keyword">or</span> down&gt;=<span class="number">0</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 无论何种情况都要开始遍历到下一个位置</span></span><br><span class="line">            up-=<span class="number">1</span></span><br><span class="line">            down-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="3-2-4-有序数组的平方（题977）"><a href="#3-2-4-有序数组的平方（题977）" class="headerlink" title="3.2.4 有序数组的平方（题977）"></a>3.2.4 有序数组的平方（题977）</h4><p>&#8195;&#8195;本题主要思路是原数组nuns本身是有序的，只不过负数的平方反过来成了降序。比如[-3,-2,-1]是升序的，其平方[9,4,1]成了降序。这样造成数组每个元素平方之后，是一个两边大中间小的结构：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入：nums = [-<span class="number">4</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line">平方：nums =[<span class="number">16</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;此时可以考虑使用一个额外的列表ls，初始化为与nums等长。然后使用指针<code>idx</code>从后往前遍历ls，则每次最大的元素一定是从nums的两端往中间取，至于具体是左端还是右端，比较这两个元素就行。故考虑使用左右指针<code>left</code>和<code>right</code>，分别从0和-1的位置开始遍历。具体的：</p><ul><li>若 <code>nums[left]**2&lt;=nums[right]**2</code>，则<code>ls[idx]=nums[right]**2</code>，同时左指针往右一格遍历nums左侧的下一个元素</li><li>若 <code>nums[left]**2&gt;nums[right]**2</code>，则<code>ls[idx]=nums[left]**2</code>，同时右指针往左一格遍历nums右侧的下一个元素</li><li>每次ls赋值完，指针<code>idx</code>都左移一格，即<code>idx-=1</code>。</li></ul><p>参考别人图解则是：</p><p><img src="https://img-blog.csdnimg.cn/59899153594b461c9d428284918610bf.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始化额外数组ls，初始赋值nums左右指针和数组ls的末端指针idx       </span></span><br><span class="line">        ls=[-<span class="number">1</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        left,right,idx=<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 开始从末端遍历ls，最大值只会来自nums的两端，故遍历左右指针，更大的数赋值给ls[idx]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;=right:</span><br><span class="line">            <span class="keyword">if</span> nums[left]**<span class="number">2</span>&lt;=nums[right]**<span class="number">2</span>:</span><br><span class="line">                ls[idx]=nums[right]**<span class="number">2</span></span><br><span class="line">                <span class="comment"># 右侧更大则赋值给ls[idx]，同时right和idx都右移一位</span></span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">                idx-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ls[idx]=nums[left]**<span class="number">2</span></span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                idx-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ls</span><br></pre></td></tr></table></figure><h4 id="3-2-5-合并两个有序数组（题88）"><a href="#3-2-5-合并两个有序数组（题88）" class="headerlink" title="3.2.5 合并两个有序数组（题88）"></a>3.2.5 合并两个有序数组（题88）</h4><p>&#8195;&#8195;给你两个按 非递减顺序 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，其元素个数分别是 <code>m</code> 和 <code>n</code> 。请你 合并 <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 非递减顺序 排列。</p><p>&#8195;&#8195;注意：最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p>示例 ：</p><ul><li>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</li><li>输出：[1,2,2,3,5,6]</li><li>解释：需要合并 [1,2,3] 和 [2,5,6] 。</li><li>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</li><li>nums1.length == m + n，0 &lt;= m, n &lt;= 200</li></ul><p>&#8195;&#8195;这道题和上一题很相似，两个数组都是有序的，为了利用这一性质，我们可以使用双指针方法，每次将两个数组中更大的元素放在<code>nums1</code>末尾。这样做是为了不使用额外的存储空间，所以需要倒序遍历。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># p1和p2分别指向两个数组的末尾，倒序遍历</span></span><br><span class="line">        p1,p2=m-<span class="number">1</span>,n-<span class="number">1</span></span><br><span class="line">        idx=m+n-<span class="number">1</span></span><br><span class="line">        <span class="comment"># p1、p2如果不限制可以为负值，也能表示下标，所以不能单纯设置idx》0</span></span><br><span class="line">        <span class="keyword">while</span> p1&gt;=<span class="number">0</span> <span class="keyword">and</span> p2&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="comment"># print(p1,p2,idx)</span></span><br><span class="line">            <span class="keyword">if</span> nums1[p1]&gt;nums2[p2]:</span><br><span class="line">            <span class="comment"># 这里写nums1[idx]=nums1[p1]结果也正确，下同</span></span><br><span class="line">                nums1[idx],nums1[p1]=nums1[p1],nums1[idx]</span><br><span class="line">                p1-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[idx],nums2[p2]=nums2[p2],nums1[idx]</span><br><span class="line">                p2-=<span class="number">1</span></span><br><span class="line">            idx-=<span class="number">1</span> </span><br><span class="line">        <span class="comment"># 当nums1序列中大数排完后，p1=0,循环终止，此时p2可能还有剩下的数，这些数都是最小的一部分，直接接到nums1前面</span></span><br><span class="line">        <span class="comment"># print(nums2[:p2+1] )</span></span><br><span class="line">        nums1[:p2+<span class="number">1</span>]=nums2[:p2+<span class="number">1</span>]         </span><br><span class="line">        <span class="keyword">return</span> nums1</span><br></pre></td></tr></table></figure></p><h4 id="3-2-6-两数之和-II-输入有序数组（题167）"><a href="#3-2-6-两数之和-II-输入有序数组（题167）" class="headerlink" title="3.2.6 两数之和 II - 输入有序数组（题167）"></a>3.2.6 两数之和 II - 输入有序数组（题167）</h4><p>&#8195;&#8195;这道题和两数之和（题3）的区别是，数组是有序的。所以可以考虑使用两个指针分别遍历数组，如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。重复上述操作，直到找到答案。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            total = numbers[low] + numbers[high]</span><br><span class="line">            <span class="keyword">if</span> total == target:</span><br><span class="line">                <span class="keyword">return</span> [low + <span class="number">1</span>, high + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="3-2-7-移动零（题283）"><a href="#3-2-7-移动零（题283）" class="headerlink" title="3.2.7 移动零（题283）"></a>3.2.7 移动零（题283）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type nums: List[int]</span></span><br><span class="line"><span class="string">:rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">left = <span class="number">0</span> <span class="comment"># 两个指针l和r</span></span><br><span class="line"><span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line"><span class="comment"># 当前元素!=0，就把其交换到左边，等于0的交换到右边</span></span><br><span class="line"><span class="keyword">if</span> nums[right]:</span><br><span class="line">nums[left],nums[right] = nums[right],nums[left]</span><br><span class="line">left += <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="3-2-8-颜色分类（题75）"><a href="#3-2-8-颜色分类（题75）" class="headerlink" title="3.2.8 颜色分类（题75）"></a>3.2.8 颜色分类（题75）</h4><p><strong>方法一：单指针</strong><br>&#8195;&#8195;这道题和上一题很类似，最简单的方法是遍历两次，先将0排到最前面，再接着将1排到前面：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 两次遍历，先排0再排1</span></span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">0</span>:</span><br><span class="line">                nums[left],nums[i]=nums[i],nums[left]</span><br><span class="line">                left+=<span class="number">1</span>  </span><br><span class="line">                              </span><br><span class="line">        right=left  <span class="comment"># 前面left个位置已经排好了0     </span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j]==<span class="number">1</span>:</span><br><span class="line">                nums[right],nums[j]=nums[j],nums[right]</span><br><span class="line">                right+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><strong>方法二：双指针（官方题解）</strong><br>&#8195;&#8195;我们可以额外使用一个指针，即使用两个指针分别用来交换 0 和1。具体地，我们用指针 $p_0$来交换 0，$p_1$来交换 1，初始值都为 0。当我们从左向右遍历整个数组时：</p><ul><li>如果找到了 1，那么将其与 $nums[p_1]$ 进行交换，并将 $p_1$向后移动一个位置，这与方法一是相同的；</li><li>如果找到了 0，那么将其与 $nums[p_0]$ 进行交换，并将 $p_0$向后移动一个位置。这样做是正确的吗？<br>&#8195;&#8195;我们可以注意到，因为连续的 0 之后是连续的 1，因此如果我们将 0 与$nums[p_0]$ 进行交换，那么我们可能会把一个 1 交换出去。当 $p_0 &lt; p_1$时，我们已经将一些 1 连续地放在头部，此时一定会把一个 1 交换出去，导致答案错误。因此，如果$p_0 &lt; p_1$，那么我们需要再将 $nums[i]$ 与$nums[p_1]$进行交换，其中 i 是当前遍历到的位置。<br>&#8195;&#8195;在进行了第一次交换后，$nums[i]$的值为 1，我们需要将这个 1 放到「头部」的末端。在最后，无论是否有 $p_0 &lt; p_1$，我们需要将 $p_0$ 和 $p_1$均向后移动一个位置，而不是仅将 $p_0$向后移动一个位置。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 两个指针分别用于交换0和1</span></span><br><span class="line">        p0=p1=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">1</span>:</span><br><span class="line">                nums[i],nums[p1]=nums[p1],nums[i]</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i]==<span class="number">0</span>:</span><br><span class="line">                nums[i],nums[p0]=nums[p0],nums[i]</span><br><span class="line">                <span class="keyword">if</span> p0&lt;p1:</span><br><span class="line">                    nums[i],nums[p1]=nums[p1],nums[i]</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">                p0+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><strong>方法三：快速排序</strong><br>&#8195;&#8195;我们也可以借鉴快速排序算法中的 <code>partition</code> 过程，将 1 作为基准数 <code>pivot</code>，然后将序列分为三部分：0（即比 1 小的部分）、等于 1 的部分、2（即比 1 大的部分）。具体步骤如下：</p><ol><li>使用两个指针 left、right，分别指向数组的头尾。left 表示当前处理好红色元素的尾部，right 表示当前处理好蓝色的头部。</li><li>再使用一个下标 index 遍历数组，如果遇到 <code>nums[index] == 0</code>，就交换 nums[index] 和 nums[left]，同时将 left 右移。如果遇到 <code>nums[index] == 2</code>，就交换 nums[index] 和 nums[right]，同时将 right 左移。</li><li>直到 index 移动到 right 位置之后，停止遍历。遍历结束之后，此时 left 左侧都是红色，right 右侧都是蓝色。</li><li>注意：移动的时候需要判断 index 和 left 的位置，因为 left 左侧是已经处理好的数组，所以需要判断 index 的位置是否小于 left，小于的话，需要更新 index 位置。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> index &lt; left:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[index] == <span class="number">0</span>:</span><br><span class="line">                nums[index], nums[left] = nums[left], nums[index]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[index] == <span class="number">2</span>:</span><br><span class="line">                nums[index], nums[right] = nums[right], nums[index]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="四、滑动窗口"><a href="#四、滑动窗口" class="headerlink" title="四、滑动窗口"></a>四、滑动窗口</h2><h3 id="4-1-解题思路"><a href="#4-1-解题思路" class="headerlink" title="4.1 解题思路"></a>4.1 解题思路</h3><p>下面以<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组（题209）</a>这一题讲解滑动窗口的思路。</p><p>&#8195;&#8195;给定一个含有 n 个正整数的数组<code>nums</code>和一个正整数 <code>target</code> 。找出该数组中满足其和 <code>≥ target</code> 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><ul><li>示例1：<ul><li>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li><li>输出：2</li><li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li></ul></li><li>示例2：<ul><li>输入：target = 11, nums = [1,1,1,1,1,1,1,1]</li><li>输出：0</li></ul></li></ul><hr><p><strong>解法一：暴力解法</strong><br>&#8195;&#8195;使用两个for循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是$O(n^2)$。<br>&#8195;&#8195;具体的，先初始化子数组的最小长度为无穷大，枚举数组<code>nums</code> 中的每个下标作为子数组的开始下标，对于每个开始下标 <code>i</code>，需要找到大于或等于 <code>i</code> 的最小下标 <code>j</code>，使得从 <code>[nums[i] , nums[j] ]</code>的元素和大于或等于 <code>s</code>，并更新子数组的最小长度（此时子数组的长度是 <code>j−i+1</code>）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, s: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = n + <span class="number">1</span> <span class="comment"># 存储最小数组长度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n): <span class="comment"># 计算位置i到位置j的元素和</span></span><br><span class="line">                total += nums[j]</span><br><span class="line">                <span class="keyword">if</span> total &gt;= s:</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, j - i + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure><p><strong>解法二：滑动窗口</strong><br><img src="https://img-blog.csdnimg.cn/59a05f1ae642403094f95e0a98bbc03e.png" alt="在这里插入图片描述"><br>&#8195;&#8195;思路：使用一个动态区间，维护整个区间的和都是大于等于target，从左往右遍历并不断更新动态区间的长度。以题目中的示例来举例，target = 7, nums = [2,3,1,2,4,3]来看一下查找的过程：</p><p><img src="https://img-blog.csdnimg.cn/385cf314302446e8819771dd3d143bd8.gif#pic_center" alt="在这里插入图片描述"><br>&#8195;&#8195;其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做<strong>滑动窗口</strong>更适合一些。<br>&#8195;&#8195;在本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？：满足其和 ≥ s 的长度最小的 连续 子数组。</li><li>如何移动窗口的起始位置？：如果当前窗口的值大于s了，窗口就要向前移动了</li><li>如何移动窗口的结束位置？：窗口的结束位置就是遍历数组的指针</li></ul><p>&#8195;&#8195;具体的，将右指针<code>right</code>遍历到数组的最右端，遍历过程中，求出当前子数组的和（使用一个变量<code>total</code>来维护）。在<code>total &gt;= target</code>时，我们就缩小区间，即左指针移右移，此时需要<code>total-nums[left]</code>更新区间和，并更新区间长度<code>ans</code>。然后 右指针继续右移，这样我们总是保证了<code>total &gt;= target</code>。 最终右指针右移到数组末尾依旧没找到<code>total &gt;= target</code>，或者找到最短子数组长度<code>ans</code>。</p><blockquote><p>&#8195;&#8195;注意，只有<code>total &gt;= target</code>时，左指针才会移动。因此，当右指针移动到下一个位置时，总是有前缀和<code>total &gt;= s</code>。可以看作是，每次左指针移动都是在找到一个新的更短的符合条件的连续子数组，因此维护的总和total一定是<code>&gt;=s</code>的，而答案一定是更新的。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span>(<span class="params">self, target, nums</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="comment">#  初始化左右指针、区间和以及区间长度</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            ans = n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#  移动右指针，计算当前子数组的和</span></span><br><span class="line">            <span class="keyword">while</span> right &lt; n:</span><br><span class="line">                total += nums[right]</span><br><span class="line">                <span class="comment"># 只要和大于目标值，左指针就一直右移</span></span><br><span class="line">                <span class="keyword">while</span> total &gt;= target:       </span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, right - left + <span class="number">1</span>) <span class="comment"># 先更新区间长度再移动指针        </span></span><br><span class="line">                    total -= nums[left]  <span class="comment"># 区间和减去刚刚舍去的左指针的值</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将$O(n^2)$暴力解法降为$O(n)$。</p><h3 id="4-2-练习题"><a href="#4-2-练习题" class="headerlink" title="4.2 练习题"></a>4.2 练习题</h3><h4 id="4-2-1-无重复字符的最长子串（题3）"><a href="#4-2-1-无重复字符的最长子串（题3）" class="headerlink" title="4.2.1 无重复字符的最长子串（题3）"></a>4.2.1 无重复字符的最长子串（题3）</h4><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><ul><li>输入: s = “abcabcbb”</li><li>输出: 3 </li><li>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</li></ul><hr><p><strong>方法一：官方解法</strong></p><p>&#8195;&#8195;使用两个指针表示最长子串的左右边界，依次递增地枚举子串的起始位置<code>left</code>。假设<code>left=k</code>，我们得到了不含重复字符的最长子串的结束位置为<code>right</code>。那么下一次遍历到<code>left=k+1</code>时，k+1到right这个区间字符串仍是不重复的。由于left左移，区间缩小，故right应该右移遍历，直到右侧出现了重复字符为止。<br>&#8195;&#8195;在上面的流程中，我们还需要使用一种数据结构来判断是否有重复的字符，可以直接使用集合。在左指针右移动的时候，我们从集合中移除一个字符；在右指针向右移动的时候，我们往集合中添加一个字符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        se = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        right, ans = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>: <span class="comment"># 从第二个字符开始删除</span></span><br><span class="line">                <span class="comment"># 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                se.remove(s[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> right + <span class="number">1</span> &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> s[right + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> se:</span><br><span class="line">                <span class="comment"># 不断地移动右指针</span></span><br><span class="line">                se.add(s[right + <span class="number">1</span>])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>方法二：滑动窗口</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">        left,right=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="comment"># 因为重复的元素会出现在任何位置，比如&#x27;abccd&#x27;，不能简单的用列表pop(0)</span></span><br><span class="line">        <span class="comment"># 和位置无关的位置结构，可以选用集合</span></span><br><span class="line">        se=<span class="built_in">set</span>() </span><br><span class="line">        ans=<span class="number">0</span> <span class="comment"># 子串长度初始化为0，当s为空时，不会进入for循环，此时长度依旧为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 指针右移，首先添加第一个元素 </span></span><br><span class="line">            <span class="keyword">while</span> s[right] <span class="keyword">in</span> se:</span><br><span class="line">            <span class="comment"># 当右指针遇到重复元素时，左指针右移，当前长度减一</span></span><br><span class="line">            <span class="comment"># 直到右指针不再和集合中元素重复                                        </span></span><br><span class="line">                se.remove(s[left])</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                      </span><br><span class="line">            ans=<span class="built_in">max</span>(ans,right-left+<span class="number">1</span>)     </span><br><span class="line">            se.add(s[right])            </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：应该将<code>se.add(s[right])</code> 放在 <code>while</code> 循环之后，否则每次集合先添加，就肯定可以进while循环了。</p></blockquote><p>方法三：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 定义当前最长不重复子串的长度</span></span><br><span class="line">    le = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 定义字典，用于记录每个字符最后一次出现的位置</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="comment"># 定义left指针，用于维护当前子串</span></span><br><span class="line">    left = -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):           </span><br><span class="line">        <span class="keyword">if</span> s[r] <span class="keyword">in</span> d:            <span class="comment"># 如果当前字符已经在字典中出现过           </span></span><br><span class="line">            left = <span class="built_in">max</span>(left, d[s[r]])    <span class="comment"># 更新left指针位置</span></span><br><span class="line">        d[s[r]] = r     <span class="comment"># 更新当前字符最后一次出现的位置</span></span><br><span class="line">        <span class="comment"># 更新最长不重复子串的长度</span></span><br><span class="line">        le = <span class="built_in">max</span>(le, r - left)</span><br><span class="line">    <span class="keyword">return</span> le</span><br></pre></td></tr></table></figure></p><p>&#8195;&#8195;上面代码中，首先定义了当前最长不重复子串的长度 <code>le</code>，用于记录结果；字典 <code>d</code>，用于记录每个字符最后一次出现的位置；<code>left</code>指针，用于维护当前子串。</p><p>&#8195;&#8195;接下来使用for循环遍历字符串<code>s</code>，对于每个字符，如果当前字符已经在字典中出现过，那么<code>left</code>指针应该跳到该字符上一次出现的位置的后面一个位置，这样才能保证当前子串中没有重复字符。然后更新当前字符最后一次出现的位置，遍历right指针并更新答案即可。<br>&#8195;&#8195;需要注意的是，重复字符上一次出现的位置可能会更小（比如’abbac’），故需要设置为<code>max(left, d[s[r]])</code>。</p><h4 id="4-2-2-字符串的排列（题567）"><a href="#4-2-2-字符串的排列（题567）" class="headerlink" title="4.2.2 字符串的排列（题567）"></a>4.2.2 字符串的排列（题567）</h4><p>&#8195;&#8195;给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。换句话说，s1 的排列之一是 s2 的 子串 。</p><ul><li>输入：s1 = “ab” s2 = “eidbaooo”</li><li>输出：true</li><li>解释：s2 包含 s1 的排列之一 (“ba”).</li></ul><hr><p>这道题是 <a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a> 的简单版本。解题思路：<strong>滑动窗口 + 字典</strong></p><ul><li><p>分析一： 题目要求 s1 的排列之一是 s2 的一个子串。而子串必须是连续的，所以要求的 s2 子串的长度跟 s1 长度必须相等。</p></li><li><p>分析二： 那么我们有必要把 s1 的每个排列都求出来吗？当然不用。如果字符串 a 是 b 的一个排列，那么当且仅当它们两者中的每个字符的个数都必须完全相等。</p></li></ul><p>&#8195;&#8195;所以，根据上面两点分析，我们已经能确定这个题目可以使用 滑动窗口 + 字典 来解决。</p><p>&#8195;&#8195;我们使用一个长度和 s1 长度相等的固定窗口大小的滑动窗口，在 s2 上面从左向右滑动，判断 s2 在滑动窗口内的每个字符出现的个数是否跟 s1 每个字符出现次数完全相等。</p><p>&#8195;&#8195;我们定义 <code>counter1</code> 是对 s1 内字符出现的个数的统计，定义 <code>counter2</code> 是对 s2 内字符出现的个数的统计。在窗口每次右移的时候，需要把右边新加入窗口的字符个数在 counter2 中加 1，把左边移出窗口的字符的个数减 1。 <code>if counter1 == counter2</code> ，那么说明窗口内的子串是 s1  的一个排列，返回 <code>True</code>；如果窗口已经把 s2 遍历完了仍然没有找到满足条件的排列，返回 <code>False</code>。</p><p>&#8195;&#8195;对于题目给的示例一：s1 = “ab” s2 = “eidbaooo”，我制作了滑动窗口过程的动画帮助理解：</p><p><img src="https://img-blog.csdnimg.cn/5f7643a7e62149a3874d15f309fbdb6b.gif#pic_center" alt="在这里插入图片描述"></p><blockquote><p><a href="https://www.gif.cn/tools/compress">gif动图裁剪压缩网站</a></p></blockquote><p><strong>躲坑指南：</strong></p><ul><li>本题中的 <code>counter</code> 可以用字典，也可以用数组来实现。用字典的时候，需要注意：如果移除 <code>left</code> 元素后，若 <code>counter2[s2[left]] == 0</code> 那么需要从字典中删除 <code>s2[left]</code> 这个key。因为 <code>&#123;&quot;a&quot;:0, &quot;b&quot;:1&#125;</code> 和 <code>&#123;&quot;b&quot;:1&#125;</code> 是不等的。</li><li>窗口的定义一定要搞清楚是否包含两边的端点，比如我定义的窗口是 <code>[left, right]</code> 两个端点都包含，那么就需要把两个端点的元素也放入 <code>counter2</code> 中。</li><li><code>counter2</code> 初始化的时候只放了 <code>[0, right - 1]</code> 个元素，因为在 while 循环中的第一行就是把 <code>right</code> 元素放到 <code>counter2</code> 中。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span>(<span class="params">self, s1, s2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s1: str</span></span><br><span class="line"><span class="string">        :type s2: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 统计 s1 中每个字符出现的次数</span></span><br><span class="line">        counter1 = collections.Counter(s1)</span><br><span class="line">        N = <span class="built_in">len</span>(s2)</span><br><span class="line">        <span class="comment"># 定义滑动窗口的范围是 [left, right]，闭区间，长度与s1相等</span></span><br><span class="line">        left ,right = <span class="number">0</span>,<span class="built_in">len</span>(s1) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 统计窗口s2[left, right - 1]内的元素出现的次数</span></span><br><span class="line">        counter2 = collections.Counter(s2[<span class="number">0</span>:right])</span><br><span class="line">        <span class="keyword">while</span> right &lt; N:</span><br><span class="line">            <span class="comment"># 把 right 位置的元素放到 counter2 中</span></span><br><span class="line">            counter2[s2[right]] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果滑动窗口内各个元素出现的次数跟 s1 的元素出现次数完全一致，返回 True</span></span><br><span class="line">            <span class="keyword">if</span> counter1 == counter2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 窗口向右移动前，把当前 left 位置的元素出现次数 - 1</span></span><br><span class="line">            counter2[s2[left]] -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果当前 left 位置的元素出现次数为 0， 需要从字典中删除，否则这个出现次数为 0 的元素会影响两 counter 之间的比较</span></span><br><span class="line">            <span class="keyword">if</span> counter2[s2[left]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> counter2[s2[left]]</span><br><span class="line">            <span class="comment"># 窗口向右移动</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>写法二：（<a href="https://leetcode.cn/problems/permutation-in-string/solution/by-flix-ix7f/">『 一招吃遍七道 』滑动窗口的应用</a>）<br>&#8195;&#8195;在窗口滑动的过程中，我们维持一个长度为 len(s1) 的滑动窗口，当窗口中待匹配的字符数目为 0，我们就找到了一个满足要求的子串。此题更进一步的思路可以看下一题最小覆盖子串（题76）的解答。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s1)&gt;<span class="built_in">len</span>(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">            count1=<span class="built_in">dict</span>(Counter(s1))</span><br><span class="line">            need=<span class="built_in">len</span>(s1) <span class="comment">#所需字符的总次数</span></span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s2)):</span><br><span class="line">                ch=s2[right]</span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                如果ch是所需的字符，就将ch需要的次数减一，</span></span><br><span class="line"><span class="string">                但是ch次数&gt;0时，才表示这个字符还需要，此时才有need+1</span></span><br><span class="line"><span class="string">                而且要先计算need次数，因为ch次数先操作会导致need统计错误，类似于计算窗口的值再移动窗口</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> count1:</span><br><span class="line">                    <span class="keyword">if</span> count1[ch]&gt;<span class="number">0</span>:                     </span><br><span class="line">                        need-=<span class="number">1</span></span><br><span class="line">                    count1[ch]-=<span class="number">1</span></span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                窗口是固定大小，左指针跟随右指针移动，同时维护需求字典               </span></span><br><span class="line"><span class="string">                一开始窗口还不到s1长度，此时left会小于0。left=0是窗口第一次右移</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">                left=right-<span class="built_in">len</span>(s1)</span><br><span class="line">                <span class="keyword">if</span> left&gt;=<span class="number">0</span>:</span><br><span class="line">                    ch=s2[left]</span><br><span class="line">                    <span class="keyword">if</span> ch <span class="keyword">in</span> count1:</span><br><span class="line">                        <span class="keyword">if</span> count1[ch]&gt;=<span class="number">0</span>:</span><br><span class="line">                            </span><br><span class="line">                            need+=<span class="number">1</span></span><br><span class="line">                        count1[ch]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> need==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-最小覆盖子串（题76）"><a href="#4-2-3-最小覆盖子串（题76）" class="headerlink" title="4.2.3 最小覆盖子串（题76）"></a>4.2.3 最小覆盖子串（题76）</h4><p>&#8195;&#8195;这道题和<a href="https://leetcode.cn/problems/M1oyTv/">剑指 Offer II 017. 含有所有字符的最短字符串</a>几乎是一样的，区别仅仅在于本题的最短子串只有唯一一个，而后者可能出现多个，只要求取其中任意一个就行。所以二者的代码可以是完全一样的。</p><p>&#8195;&#8195;我们以<strong>哈希表<code>cnt</code>记录目标字符串 <code>t</code> 中待匹配的各字符的数目</strong>，并在 <code>s</code> 中维护一个变长的滑动窗口，期望使得窗口中的字符能够覆盖 <code>t</code>。具体地，设定一个非负变量 <code>need</code> 表示当前窗口还需要匹配到的字符总数：</p><ul><li>当窗口新增一位字符 <code>ch</code> 时：<ul><li>若<code>cnt[ch]&gt;0</code>，说明 待加入的字符<code>ch</code> 是当前窗口还需要的，此时新加入的 <code>ch</code> 能够使得 <code>need-1</code></li><li>若<code>cnt[ch]≤0</code>，说明 当前窗口不需要这个字符，need不变</li><li>无论<code>cnt[ch]</code>是否大于0，由于窗口一直右移，<code>cnt[ch]</code>本身的次数是要减一的。所以<code>cnt[ch]</code> 可以为负值，这表示表示当前窗口中字符 <code>ch</code> 过多。</li></ul></li><li><p>当窗口滑出一位字符 <code>ch</code> 时：</p><ul><li>若<code>cnt[ch]≥0</code>，说明 待加入的字符<code>ch</code> 是当前窗口还需要的（滑出去需求更大了），此时滑出的 <code>ch</code> 能够使得 <code>need+1</code></li><li>若<code>cnt[ch]＜0</code>，说明 当前窗口不需要这个字符，need不变</li><li>无论<code>cnt[ch]</code>是否大于0，由于窗口一直右移，<code>cnt[ch]</code>本身的次数是要加一的。</li></ul></li><li><p>当 <code>need=0</code> 时，说明找到了覆盖子串 ，在记录下答案的同时，我们还需要尝试收缩窗口左边界（参照上一步）。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(t)&gt;<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> s==t:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">            cnt=<span class="built_in">dict</span>(Counter(t)) <span class="comment"># 哈希表：记录需要匹配到的各个字符的数目</span></span><br><span class="line">            left=<span class="number">0</span> </span><br><span class="line">            need=<span class="built_in">len</span>(t) <span class="comment"># 需匹配的字符总数。每次右指针匹配到所需字符，need-=1，所以need=0表示匹配到了完整的覆盖子串</span></span><br><span class="line">            le=<span class="built_in">len</span>(s)+<span class="number">1</span> <span class="comment"># 最短长度</span></span><br><span class="line">            result=<span class="string">&quot;&quot;</span>   <span class="comment"># 覆盖子串，即返回的结果</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                ch=s[right]          </span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> cnt:<span class="comment"># 窗口右端新加入的字符ch若位于s1中，就将其次数-1。可以是负数，表示ch有多余的</span></span><br><span class="line">                    <span class="keyword">if</span> cnt[ch]&gt;<span class="number">0</span>:<span class="comment"># 但是只有字符ch大于0，才表示这个字符还需要，need-=1</span></span><br><span class="line">                        need-=<span class="number">1</span></span><br><span class="line">                    cnt[ch]-=<span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">while</span> need==<span class="number">0</span>:     <span class="comment"># 只要所需字符为0，就一直移动左指针</span></span><br><span class="line">                    ch=s[left]</span><br><span class="line">                    <span class="keyword">if</span> ch <span class="keyword">in</span> cnt:  <span class="comment"># 刚滑出的字符位于s1中，操作同上</span></span><br><span class="line">                        <span class="keyword">if</span> cnt[ch]&gt;=<span class="number">0</span>:</span><br><span class="line">                            need+=<span class="number">1</span></span><br><span class="line">                        cnt[ch]+=<span class="number">1</span></span><br><span class="line">                    <span class="comment"># 下面这一段写在while语句之前也可以，只要left+=1在最后一行</span></span><br><span class="line">                    <span class="keyword">if</span> right-left&lt;le:</span><br><span class="line">                        le=right-left</span><br><span class="line">                        result=s[left:right+<span class="number">1</span>]</span><br><span class="line">                        </span><br><span class="line">                    left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> <span class="keyword">if</span> le==<span class="built_in">len</span>(s)+<span class="number">1</span> <span class="keyword">else</span> result</span><br></pre></td></tr></table></figure><h4 id="4-2-4-最短超串"><a href="#4-2-4-最短超串" class="headerlink" title="4.2.4 最短超串"></a>4.2.4 最短超串</h4><blockquote><p><a href="https://leetcode.cn/problems/shortest-supersequence-lcci/">题目链接</a></p></blockquote><p>这题和上一题差不多，改一下输出结果的格式就行。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestSeq</span>(<span class="params">self, big, small</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type big: List[int]</span></span><br><span class="line"><span class="string">        :type small: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        cnt=<span class="built_in">dict</span>(Counter(small)) <span class="comment"># 哈希表：记录需要匹配到的各个字符的数目</span></span><br><span class="line">        left=<span class="number">0</span> </span><br><span class="line">        need=<span class="built_in">len</span>(small) <span class="comment"># 需匹配的字符总数。每次右指针匹配到所需字符，need-=1，所以need=0表示匹配到了完整的覆盖子串</span></span><br><span class="line">        le=<span class="built_in">len</span>(big)+<span class="number">1</span>   <span class="comment"># 记录最短子串长度          </span></span><br><span class="line">        result=[]       <span class="comment"># 返回的结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(big)):</span><br><span class="line">            ch=big[right]          </span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> cnt:<span class="comment"># 窗口右端新加入的字符ch若位于s1中，就将其次数-1。可以是负数，表示ch有多余的</span></span><br><span class="line">                <span class="keyword">if</span> cnt[ch]&gt;<span class="number">0</span>:<span class="comment"># 但是只有字符ch大于0，才表示这个字符还需要，need-=1</span></span><br><span class="line">                    need-=<span class="number">1</span></span><br><span class="line">                cnt[ch]-=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">while</span> need==<span class="number">0</span>:     <span class="comment"># 只要所需字符为0，就一直移动左指针</span></span><br><span class="line">                ch=big[left]</span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> cnt:  <span class="comment"># 刚滑出的字符位于s1中，操作同上</span></span><br><span class="line">                    <span class="keyword">if</span> cnt[ch]&gt;=<span class="number">0</span>:</span><br><span class="line">                        need+=<span class="number">1</span></span><br><span class="line">                    cnt[ch]+=<span class="number">1</span></span><br><span class="line">                <span class="comment"># 下面这一段写在while语句之前也可以，只要left+=1在最后一行</span></span><br><span class="line">                <span class="comment"># 只要子串更短就覆盖结果，所以即使最短子串有多个，也只会返回第一个</span></span><br><span class="line">                <span class="keyword">if</span> right-left&lt;le: <span class="comment">#</span></span><br><span class="line">                    le=right-left</span><br><span class="line">                    result=[left,right]</span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [] <span class="keyword">if</span> le==<span class="built_in">len</span>(big)+<span class="number">1</span> <span class="keyword">else</span> result</span><br></pre></td></tr></table></figure></p><h4 id="4-2-5-找到字符串中所有字母异位词（题438）"><a href="#4-2-5-找到字符串中所有字母异位词（题438）" class="headerlink" title="4.2.5 找到字符串中所有字母异位词（题438）"></a>4.2.5 找到字符串中所有字母异位词（题438）</h4><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<br>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><ul><li>输入: s = “cbaebabacd”, p = “abc”</li><li>输出: [0,6]</li><li>解释:<ul><li>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。</li><li>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</li></ul></li></ul><p>&#8195;&#8195;这道题和题567几乎一样，只是需要返回每个子串的起始位置，答案就不写了，同样的题还有<a href="https://leetcode.cn/problems/VabMRr/">《剑指 Offer II 015. 字符串中的所有变位词》</a>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span>(<span class="params">self, s, p</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(p)&gt;<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">            count1=<span class="built_in">dict</span>(Counter(p))</span><br><span class="line">            need=<span class="built_in">len</span>(p) <span class="comment">#所需字符的总次数</span></span><br><span class="line">            result=[]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                ch=s[right]</span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                如果ch是所需的字符，就将ch需要的次数减一，</span></span><br><span class="line"><span class="string">                但是ch次数&gt;0时，才表示这个字符还需要，此时才有need+1</span></span><br><span class="line"><span class="string">                而且要先计算need次数，因为ch次数先操作会导致need统计错误，类似于计算窗口的值再移动窗口</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> count1:</span><br><span class="line">                    <span class="keyword">if</span> count1[ch]&gt;<span class="number">0</span>:                     </span><br><span class="line">                        need-=<span class="number">1</span></span><br><span class="line">                    count1[ch]-=<span class="number">1</span></span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                窗口是固定大小，左指针跟随右指针移动，同时维护需求字典               </span></span><br><span class="line"><span class="string">                一开始窗口还不到s1长度，此时left会小于0。left=0是窗口第一次右移</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">                left=right-<span class="built_in">len</span>(p)</span><br><span class="line">                <span class="keyword">if</span> left&gt;=<span class="number">0</span>:</span><br><span class="line">                    ch=s[left]</span><br><span class="line">                    <span class="keyword">if</span> ch <span class="keyword">in</span> count1:</span><br><span class="line">                        <span class="keyword">if</span> count1[ch]&gt;=<span class="number">0</span>:</span><br><span class="line">                            </span><br><span class="line">                            need+=<span class="number">1</span></span><br><span class="line">                        count1[ch]+=<span class="number">1</span></span><br><span class="line">  </span><br><span class="line">                <span class="keyword">if</span> need==<span class="number">0</span>:</span><br><span class="line">                    result.append(left+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="4-2-6-串联所有单词的子串（题30）"><a href="#4-2-6-串联所有单词的子串（题30）" class="headerlink" title="4.2.6 串联所有单词的子串（题30）"></a>4.2.6 串联所有单词的子串（题30）</h4><blockquote><p><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">题目链接</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span>          </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># word的所有排列组合和元素顺序无关，可以考虑使用字典，不看具体单词只看元素</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        <span class="comment"># 将words中每个元素统计其次数存入字典</span></span><br><span class="line">        cnw=<span class="built_in">dict</span>(Counter(words))</span><br><span class="line">        le1=<span class="built_in">len</span>(<span class="string">&quot;&quot;</span>.join(words)) <span class="comment"># 匹配子串总长度，也等于滑动窗口长度</span></span><br><span class="line">        le2=<span class="built_in">len</span>(words[<span class="number">0</span>]) <span class="comment"># 每个word等长</span></span><br><span class="line">        need=<span class="built_in">len</span>(words)   <span class="comment"># need表示总共需要的元素数,不等于cnw长度，因为有键是多个，坑死我了</span></span><br><span class="line">        </span><br><span class="line">        res=[] <span class="comment"># 记录匹配子串的起始位置</span></span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,le2): <span class="comment"># s的分词方式有多种，都需要遍历到</span></span><br><span class="line">            <span class="comment">#print(&quot;start:&quot;,start)</span></span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(start+le2,<span class="built_in">len</span>(s)+<span class="number">1</span>,le2):<span class="comment">#还是要分割成若干个单词，间隔le2</span></span><br><span class="line">            <span class="comment"># 遍历右指针，如果碰到需要的单词，就将其需要次数减1，如果次数大于0，就将总次数减1</span></span><br><span class="line">            <span class="comment"># 假如word长为3，即le2=3，右指针就从3开始遍历，每次加入的字符长度都是3</span></span><br><span class="line">           </span><br><span class="line">                ch=s[right-le2:right]</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> cnw:</span><br><span class="line">                    <span class="keyword">if</span> cnw[ch]&gt;<span class="number">0</span>:</span><br><span class="line">                        need-=<span class="number">1</span></span><br><span class="line">                    cnw[ch]-=<span class="number">1</span></span><br><span class="line">                <span class="comment">#print(&quot;r:&quot;,ch,cnw,need)</span></span><br><span class="line">                left=right-le1 <span class="comment"># 窗口是固定大小，长为le。left=0时刚好是要第一次滑动窗口</span></span><br><span class="line">                <span class="keyword">if</span> left&gt;=le2:</span><br><span class="line">                    ch=s[left-le2:left]</span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">if</span> ch <span class="keyword">in</span> cnw:</span><br><span class="line">                        <span class="keyword">if</span> cnw[ch]&gt;=<span class="number">0</span>:</span><br><span class="line">                            need+=<span class="number">1</span></span><br><span class="line">                        cnw[ch]+=<span class="number">1</span></span><br><span class="line">                    <span class="comment">#print(ch,cnw,need)</span></span><br><span class="line">                                    </span><br><span class="line">                <span class="keyword">if</span> need==<span class="number">0</span>:</span><br><span class="line">                    res.append(left)</span><br><span class="line">                <span class="comment"># 每次起点位置遍历完，need 和cnw上一次被改了，需要重置</span></span><br><span class="line">            need=<span class="built_in">len</span>(words)</span><br><span class="line">            cnw=<span class="built_in">dict</span>(Counter(words))</span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><br>后续有空再补。</p><hr><p>904-水果成篮(opens new window)<br>159-至多包含两个不同字符的最长子串<br>340-至多包含 K 个不同字符的最长子串<br>30-串联所有单词的子串<br>239- 滑动窗口最大值<br>632-最小区间<br>727.-最小窗口子序列</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;@[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;资源：&lt;a href=&quot;https://leetcode.cn/problemset/all/&quot;&gt;力扣题库&lt;/a&gt;、&lt;a href=&quot;https://algo.itcharge.cn/00.Introduction/05.Categories-List/&quot;&gt;LeetCode 刷题列表&lt;/a&gt;、&lt;a href=&quot;https://programmercarl.com/&quot;&gt;代码随想录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、-数组理论基础&quot;&gt;&lt;a href=&quot;#一、-数组理论基础&quot; class=&quot;headerlink&quot; title=&quot;一、 数组理论基础&quot;&gt;&lt;/a&gt;一、 数组理论基础&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;参考代码随想录&lt;a href=&quot;https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80&quot;&gt;《数组理论基础》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数组是存放在连续内存空间上的相同类型数据的集合，数组可以方便的通过下标索引的方式获取到下标下对应的数据，例如：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/ba939ff642cb4170a7052f4ac65d3563.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;有两点需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组下标都是从0开始的。&lt;/li&gt;
&lt;li&gt;数组内存空间的地址是连续的</summary>
    
    
    
    <category term="Data Structure and Algorithms" scheme="https://zhxnlp.github.io/categories/Data-Structure-and-Algorithms/"/>
    
    
    <category term="leetcode" scheme="https://zhxnlp.github.io/tags/leetcode/"/>
    
    <category term="Array" scheme="https://zhxnlp.github.io/tags/Array/"/>
    
    <category term="Binary Search" scheme="https://zhxnlp.github.io/tags/Binary-Search/"/>
    
    <category term="Two Pointers" scheme="https://zhxnlp.github.io/tags/Two-Pointers/"/>
    
    <category term="Sliding Window" scheme="https://zhxnlp.github.io/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>集成学习5： LightGBM实战</title>
    <link href="https://zhxnlp.github.io/2022/01/15/datawhale%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/lightGBM/"/>
    <id>https://zhxnlp.github.io/2022/01/15/datawhale%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/lightGBM/</id>
    <published>2022-01-14T19:33:27.000Z</published>
    <updated>2022-01-14T19:43:23.720Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://lightgbm.readthedocs.io/en/latest/Python-Intro.html" title="官方文档">LightGBM 官方文档</a></li><li>阿水知乎贴：<a href="https://zhuanlan.zhihu.com/p/266865429" title="《你应该知道的LightGBM各种操作》">《你应该知道的LightGBM各种操作》</a></li><li><a href="https://lightgbm.readthedocs.io/en/latest/Python-API.html" title="Python API">Python API（包括Scikit-learn API）</a></li><li><a href="https://coggle.club/blog/30days-of-ml-202201" title="《Coggle 30 Days of ML（22年1&amp;2月）》">《Coggle 30 Days of ML（22年1&amp;2月）》</a></li></ul><p>学习内容：</p><p>LightGBM（Light Gradient Boosting Machine）是微软开源的一个实现 GBDT 算法的框架，支持高效率的并行训练。LightGBM 提出的主要原因是为了解决 GBDT 在海量数据遇到的问题。本次学习内容包括使用LightGBM完成各种操作，包括竞赛和数据挖掘中的模型训练、验证和调参过程。</p><p>打卡汇总：</p><div class="table-container"><table><thead><tr><th>任务名称</th><th>难度、分数</th><th>所需技能</th></tr></thead><tbody><tr><td>任务1模型训练与预测</td><td>低、1</td><td>LightGBM</td></tr><tr><td>任务2：模型保存与加载</td><td>低、1</td><td>LightGBM</td></tr><tr><td>任务3：分类、回归和排序任务</td><td>高、3</td><td>LightGBM</td></tr><tr><td>任务4：模型可视化</td><td>低、1</td><td>graphviz</td></tr><tr><td>任务5：模型调参（网格、随机、贝叶斯）</td><td>中、2</td><td>模型调参</td></tr><tr><td>任务6：模型微调与参数衰减</td><td>中、2</td><td>LightGBM</td></tr><tr><td>任务7：特征筛选方法</td><td>高、3</td><td>特征筛选方法</td></tr><tr><td>任务8：自定义损失函数</td><td>中、2</td><td>损失函数&amp;评价函数</td></tr><tr><td>任务9：模型部署与加速</td><td>高、3</td><td>Treelite</td></tr></tbody></table></div><span id="more"></span><h2 id="一、使用LGBMClassifier对iris进行训练"><a href="#一、使用LGBMClassifier对iris进行训练" class="headerlink" title="一、使用LGBMClassifier对iris进行训练"></a>一、使用LGBMClassifier对iris进行训练</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">from</span> lightgbm <span class="keyword">import</span> LGBMClassifier</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">iris = load_iris()</span><br><span class="line">X,y = iris.data,iris.target</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">2022</span>) <span class="comment"># 数据集分割</span></span><br></pre></td></tr></table></figure><h3 id="1-1-使用lgb-LGBMClassifier"><a href="#1-1-使用lgb-LGBMClassifier" class="headerlink" title="1.1 使用lgb.LGBMClassifier"></a>1.1 使用lgb.LGBMClassifier</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gbm = lgb.LGBMClassifier(max_depth=<span class="number">10</span>,</span><br><span class="line">            learning_rate=<span class="number">0.01</span>,</span><br><span class="line">            n_estimators=<span class="number">2000</span>,<span class="comment">#提升迭代次数</span></span><br><span class="line">            objective=<span class="string">&#x27;multi:softmax&#x27;</span>,<span class="comment">#默认regression，用于设置损失函数</span></span><br><span class="line">            num_class=<span class="number">3</span> ,          </span><br><span class="line">            nthread=-<span class="number">1</span>,<span class="comment">#LightGBM 的线程数</span></span><br><span class="line">            min_child_weight=<span class="number">1</span>,</span><br><span class="line">            max_delta_step=<span class="number">0</span>,</span><br><span class="line">            subsample=<span class="number">0.85</span>,</span><br><span class="line">            colsample_bytree=<span class="number">0.7</span>,</span><br><span class="line">            reg_alpha=<span class="number">0</span>,<span class="comment">#L1正则化系数</span></span><br><span class="line">            reg_lambda=<span class="number">1</span>,<span class="comment">#L2正则化系数</span></span><br><span class="line">            scale_pos_weight=<span class="number">1</span>,</span><br><span class="line">            seed=<span class="number">0</span>,</span><br><span class="line">            missing=<span class="literal">None</span>)</span><br><span class="line">gbm.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = gbm.predict(X_test)</span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>[LightGBM] [Warning] num_threads is set with n_jobs=-1, nthread=-1 will be ignored. Current value: num_threads=-1accuarcy: 93.33%</code></pre><h4 id="1-1-2使用pickle进行保存模型，然后加载预测"><a href="#1-1-2使用pickle进行保存模型，然后加载预测" class="headerlink" title="1.1.2使用pickle进行保存模型，然后加载预测"></a>1.1.2使用pickle进行保存模型，然后加载预测</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;model.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fout:</span><br><span class="line">    pickle.dump(gbm, fout)</span><br><span class="line"><span class="comment"># load model with pickle to predict</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;model.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fin:</span><br><span class="line">    pkl_bst = pickle.load(fin)</span><br><span class="line"><span class="comment"># can predict with any iteration when loaded in pickle way</span></span><br><span class="line">y_pred = pkl_bst.predict(X_test)</span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>accuarcy: 93.33%</code></pre><h4 id="1-1-3-使用txt和json保存模型并加载"><a href="#1-1-3-使用txt和json保存模型并加载" class="headerlink" title="1.1.3 使用txt和json保存模型并加载"></a>1.1.3 使用txt和json保存模型并加载</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># txt格式</span></span><br><span class="line">gbm.booster_.save_model(<span class="string">&quot;skmodel.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">clf_loads = lgb.Booster(model_file=<span class="string">&#x27;skmodel.txt&#x27;</span>)</span><br><span class="line">y_pred = clf_loads.predict(X_test)</span><br><span class="line">y_pred=np.argmax(y_pred,axis=-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>accuarcy: 93.33%</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#json格式</span></span><br><span class="line">gbm.booster_.save_model(<span class="string">&quot;skmodel.json&quot;</span>)</span><br><span class="line"></span><br><span class="line">clf_loads = lgb.Booster(model_file=<span class="string">&#x27;skmodel.json&#x27;</span>)</span><br><span class="line">y_pred = clf_loads.predict(X_test)</span><br><span class="line">y_pred=np.argmax(y_pred,axis=-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>accuarcy: 93.33%</code></pre><h2 id="二、使用原生的API进行模型训练和预测"><a href="#二、使用原生的API进行模型训练和预测" class="headerlink" title="二、使用原生的API进行模型训练和预测"></a>二、使用原生的API进行模型训练和预测</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lgb_train = lgb.Dataset(X_train, y_train)</span><br><span class="line"><span class="comment">#reference:如果这是用于验证的数据集，则应使用训练数据作为参考</span></span><br><span class="line"><span class="comment">#weight : list每个实例的权重</span></span><br><span class="line"><span class="comment">#free_raw_data：default=True，构建内部 Dataset 后释放原始数据，节省内存。</span></span><br><span class="line"><span class="comment">#silent:布尔类型，default=False。是否在构建过程中打印消息。</span></span><br><span class="line"><span class="comment">#init_score：数据集初始分数</span></span><br><span class="line"><span class="comment">#feature_name：设为 &#x27;auto&#x27; 时，如果 data 是 pandas DataFrame，则使用数据列名称。</span></span><br><span class="line">lgb_eval = lgb.Dataset(X_test, y_test, reference=lgb_train)</span><br><span class="line"><span class="comment">#设置参数</span></span><br><span class="line"><span class="comment">#多分类的objective为multiclass或者别名softmax</span></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;softmax&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;num_class&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">&#x27;lambda_l2&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;subsample&#x27;</span>: <span class="number">0.85</span>,</span><br><span class="line">    <span class="string">&#x27;colsample_bytree&#x27;</span>: <span class="number">0.7</span>,</span><br><span class="line">    <span class="string">&#x27;min_child_weight&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;learning_rate&#x27;</span>:<span class="number">0.01</span>,</span><br><span class="line">    <span class="string">&quot;verbosity&quot;</span>:-<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">gbm = lgb.train(params,</span><br><span class="line">                lgb_train,</span><br><span class="line">                num_boost_round=<span class="number">10</span>,</span><br><span class="line">                valid_sets=lgb_eval,</span><br><span class="line">                callbacks=[lgb.early_stopping(stopping_rounds=<span class="number">5</span>)])</span><br><span class="line"></span><br><span class="line">y_pred = gbm.predict(X_test,num_iteration=gbm.best_iteration)</span><br><span class="line">y_pred=np.argmax(y_pred,axis=-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>Training until validation scores don&#39;t improve for 5 roundsDid not meet early stopping. Best iteration is:[10]    valid_0&#39;s multi_logloss: 0.96537accuarcy: 93.33%</code></pre><h4 id="2-2-2-使用txt-json格式保存模型"><a href="#2-2-2-使用txt-json格式保存模型" class="headerlink" title="2.2.2 使用txt/json格式保存模型"></a>2.2.2 使用txt/json格式保存模型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用txt保存模型</span></span><br><span class="line">gbm.save_model(<span class="string">&#x27;model.txt&#x27;</span>)</span><br><span class="line">bst = lgb.Booster(model_file=<span class="string">&#x27;model.txt&#x27;</span>)</span><br><span class="line">y_pred = bst.predict(X_test, num_iteration=gbm.best_iteration)</span><br><span class="line">y_pred=np.argmax(y_pred,axis=-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用json格式保存模型</span></span><br><span class="line">    </span><br><span class="line">gbm.save_model(<span class="string">&#x27;model.json&#x27;</span>)</span><br><span class="line">bst = lgb.Booster(model_file=<span class="string">&#x27;model.json&#x27;</span>)</span><br><span class="line">y_pred = bst.predict(X_test, num_iteration=gbm.best_iteration)</span><br><span class="line">y_pred=np.argmax(y_pred,axis=-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>accuarcy: 93.33%accuarcy: 93.33%</code></pre><h4 id="2-2-3-使用pickle进行保存模型"><a href="#2-2-3-使用pickle进行保存模型" class="headerlink" title="2.2.3 使用pickle进行保存模型"></a>2.2.3 使用pickle进行保存模型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;model.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fout:</span><br><span class="line">    pickle.dump(gbm, fout)</span><br><span class="line"><span class="comment"># load model with pickle to predict</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;model.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fin:</span><br><span class="line">    pkl_bst = pickle.load(fin)</span><br><span class="line"><span class="comment"># can predict with any iteration when loaded in pickle way</span></span><br><span class="line">y_pred = pkl_bst.predict(X_test)</span><br><span class="line">y_pred=np.argmax(y_pred,axis=-<span class="number">1</span>)</span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>accuarcy: 93.33%</code></pre><h2 id="三、任务3-分类、回归和排序任务"><a href="#三、任务3-分类、回归和排序任务" class="headerlink" title="三、任务3 分类、回归和排序任务"></a>三、任务3 分类、回归和排序任务</h2><h3 id="3-1使用-make-classification生成二分类数据进行训练"><a href="#3-1使用-make-classification生成二分类数据进行训练" class="headerlink" title="3.1使用 make_classification生成二分类数据进行训练"></a>3.1使用 make_classification生成二分类数据进行训练</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#n_samples:样本数量，默认100</span></span><br><span class="line"><span class="comment">#n_features:特征数，默认20</span></span><br><span class="line"><span class="comment">#n_informative：有效特征数量，默认2</span></span><br><span class="line"><span class="comment">#n_redundant:冗余特征，默认2</span></span><br><span class="line"><span class="comment">#n_repeated :重复的特征个数，默认0</span></span><br><span class="line"><span class="comment">#n_clusters_per_class：每个类别中cluster数量，默认2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#weight：各个类的占比</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#n_classes* n_clusters_per_class 必须≤ 2**有效特征数</span></span><br><span class="line">data, target = make_classification(n_samples=<span class="number">1000</span>,n_features=<span class="number">3</span>,n_informative=<span class="number">3</span>,n_redundant=<span class="number">0</span>,n_classes=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">df[<span class="string">&#x27;target&#x27;</span>] = target</span><br><span class="line"></span><br><span class="line">df1 = df[df[<span class="string">&#x27;target&#x27;</span>]==<span class="number">0</span>]</span><br><span class="line">df2 = df[df[<span class="string">&#x27;target&#x27;</span>]==<span class="number">1</span>]</span><br><span class="line">df1.index = <span class="built_in">range</span>(<span class="built_in">len</span>(df1))</span><br><span class="line">df2.index = <span class="built_in">range</span>(<span class="built_in">len</span>(df2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出数据集的数据分布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">plt.scatter(df1[<span class="number">0</span>],df1[<span class="number">1</span>],color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">plt.scatter(df2[<span class="number">0</span>],df2[<span class="number">1</span>],color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>,<span class="number">2</span>))</span><br><span class="line">df1[<span class="number">0</span>].hist()</span><br><span class="line">df1[<span class="number">0</span>].plot(kind = <span class="string">&#x27;kde&#x27;</span>, secondary_y=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">mean_ = df1[<span class="number">0</span>].mean()</span><br><span class="line">std_ = df1[<span class="number">0</span>].std()</span><br><span class="line"></span><br><span class="line">stats.kstest(df1[<span class="number">0</span>], <span class="string">&#x27;norm&#x27;</span>, (mean_, std_))</span><br></pre></td></tr></table></figure><pre><code>KstestResult(statistic=0.03723785150172143, pvalue=0.4930944895472954)</code></pre><p><img src="lightGBM_files/lightGBM_17_1.png" alt="png"></p><p><img src="lightGBM_files/lightGBM_17_2.png" alt="png"></p><h4 id="3-1-1-sklearn接口"><a href="#3-1-1-sklearn接口" class="headerlink" title="3.1.1 sklearn接口"></a>3.1.1 sklearn接口</h4><blockquote><p><a href="https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.LGBMClassifier.html#lightgbm.LGBMClassifier" title="sklearn接口lgb分类器参考文档">sklearn接口lgb分类器参考文档</a><br>注意：每次产生的数据都不一样，所以</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">from</span> lightgbm <span class="keyword">import</span> LGBMClassifier</span><br><span class="line"></span><br><span class="line">X,y = data,target</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">2022</span>) <span class="comment"># 数据集分割</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gbm = lgb.LGBMClassifier()</span><br><span class="line"></span><br><span class="line">gbm.fit(X_train, y_train,</span><br><span class="line">        eval_set=[(X_test, y_test)],</span><br><span class="line">        eval_metric=<span class="string">&#x27;binary_logloss&#x27;</span>,</span><br><span class="line">        callbacks=[lgb.early_stopping(<span class="number">5</span>)])</span><br><span class="line"><span class="comment">#eval_metric默认值：LGBMRegressor 为“l2”，LGBMClassifier 为“logloss”，LGBMRanker 为“ndcg”。</span></span><br><span class="line"><span class="comment">#使用binary_logloss或者logloss准确率都是一样的。默认logloss</span></span><br><span class="line">y_pred = gbm.predict(X_test)</span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[39]    valid_0&#39;s binary_logloss: 0.255538accuarcy: 88.50%</code></pre><h4 id="3-1-2-原生train接口"><a href="#3-1-2-原生train接口" class="headerlink" title="3.1.2 原生train接口"></a>3.1.2 原生train接口</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lgb_train = lgb.Dataset(X_train, y_train)</span><br><span class="line">lgb_eval = lgb.Dataset(X_test, y_test, reference=lgb_train)</span><br><span class="line"><span class="comment">#设置参数</span></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">&#x27;metric&#x27;</span>: <span class="string">&#x27;binary_logloss&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;verbosity&quot;</span>:-<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">gbm2 = lgb.train(params,</span><br><span class="line">                lgb_train,</span><br><span class="line">                num_boost_round=<span class="number">10</span>,</span><br><span class="line">                valid_sets=lgb_eval,</span><br><span class="line">                callbacks=[lgb.early_stopping(stopping_rounds=<span class="number">5</span>)])</span><br><span class="line"></span><br><span class="line">y_pred = gbm2.predict(X_test,num_iteration=gbm2.best_iteration)<span class="comment">#结果是0-1之间的概率值，是一维数组</span></span><br><span class="line">y_pred =[<span class="number">1</span> <span class="keyword">if</span> x &gt;<span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> y_pred]</span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>Training until validation scores don&#39;t improve for 5 roundsDid not meet early stopping. Best iteration is:[10]    valid_0&#39;s binary_logloss: 0.371903accuarcy: 88.00%</code></pre><h3 id="3-2使用-make-classification生成多分类数据进行训练"><a href="#3-2使用-make-classification生成多分类数据进行训练" class="headerlink" title="3.2使用 make_classification生成多分类数据进行训练"></a>3.2使用 make_classification生成多分类数据进行训练</h3><h4 id="3-2-1-sklearn接口"><a href="#3-2-1-sklearn接口" class="headerlink" title="3.2.1 sklearn接口"></a>3.2.1 sklearn接口</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">data, target = make_classification(n_samples=<span class="number">1000</span>,n_features=<span class="number">3</span>,n_informative=<span class="number">3</span>,n_redundant=<span class="number">0</span>,n_classes=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">from</span> lightgbm <span class="keyword">import</span> LGBMClassifier</span><br><span class="line"></span><br><span class="line">X,y = data,target</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">2022</span>) <span class="comment"># 数据集分割</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gbm = lgb.LGBMClassifier()</span><br><span class="line"></span><br><span class="line">gbm.fit(X_train, y_train,</span><br><span class="line">        eval_set=[(X_test, y_test)],</span><br><span class="line">        eval_metric=<span class="string">&#x27;logloss&#x27;</span>,</span><br><span class="line">        callbacks=[lgb.early_stopping(<span class="number">5</span>)])</span><br><span class="line"><span class="comment">#eval_metric默认值：LGBMRegressor 为“l2”，LGBMClassifier 为“logloss”，LGBMRanker 为“ndcg”。</span></span><br><span class="line"><span class="comment">#使用binary_logloss或者logloss准确率都是一样的。默认logloss</span></span><br><span class="line">y_pred = gbm.predict(X_test)</span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[39]    valid_0&#39;s binary_logloss: 0.255538accuarcy: 88.50%</code></pre><h4 id="3-2-2-原生train接口"><a href="#3-2-2-原生train接口" class="headerlink" title="3.2.2 原生train接口"></a>3.2.2 原生train接口</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lgb_train = lgb.Dataset(X_train, y_train)</span><br><span class="line">lgb_eval = lgb.Dataset(X_test, y_test, reference=lgb_train)</span><br><span class="line"><span class="comment">#设置参数</span></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;softmax&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;num_class&#x27;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">&#x27;metric&#x27;</span>: <span class="string">&#x27;softmax&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;verbosity&quot;</span>:-<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">gbm2 = lgb.train(params,</span><br><span class="line">                lgb_train,</span><br><span class="line">                num_boost_round=<span class="number">10</span>,</span><br><span class="line">                valid_sets=lgb_eval,</span><br><span class="line">                callbacks=[lgb.early_stopping(stopping_rounds=<span class="number">5</span>)])</span><br><span class="line"></span><br><span class="line">y_pred = gbm2.predict(X_test,num_iteration=gbm2.best_iteration)<span class="comment">#结果是0-1之间的概率值，是一维数组</span></span><br><span class="line">y_pred=np.argmax(y_pred,axis=-<span class="number">1</span>)</span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>Training until validation scores don&#39;t improve for 5 roundsDid not meet early stopping. Best iteration is:[10]    valid_0&#39;s multi_logloss: 0.322024accuarcy: 87.50%</code></pre><h3 id="3-3使用-make-regression生成回归数据"><a href="#3-3使用-make-regression生成回归数据" class="headerlink" title="3.3使用 make_regression生成回归数据"></a>3.3使用 make_regression生成回归数据</h3><h4 id="3-3-1-sklearn接口"><a href="#3-3-1-sklearn接口" class="headerlink" title="3.3.1 sklearn接口"></a>3.3.1 sklearn接口</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">make_regression(n_samples=<span class="number">100</span>, n_features=<span class="number">100</span>, n_informative=<span class="number">10</span>, n_targets=<span class="number">1</span>, bias=<span class="number">0.0</span>, </span><br><span class="line">                effective_rank=<span class="literal">None</span>, tail_strength=<span class="number">0.5</span>, noise=<span class="number">0.0</span>, shuffle=<span class="literal">True</span>, coef=<span class="literal">False</span>, random_state=<span class="literal">None</span>)</span><br><span class="line">```                </span><br><span class="line">- n_samples：样本数</span><br><span class="line">- n_features：特征数(自变量个数)</span><br><span class="line">- n_informative：参与建模特征数</span><br><span class="line">- n_targets：因变量个数</span><br><span class="line">- noise：噪音</span><br><span class="line">- bias：偏差(截距)</span><br><span class="line">- coef：是否输出coef标识</span><br><span class="line">- random_state：随机状态若为固定值则每次产生的数据都一样</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_regression</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">data, target = make_regression(n_samples=<span class="number">1000</span>, n_features=<span class="number">5</span>,n_targets=<span class="number">1</span>,noise=<span class="number">1.5</span>,random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">from</span> lightgbm <span class="keyword">import</span> LGBMClassifier</span><br><span class="line"></span><br><span class="line">X,y = data,target</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">2022</span>) <span class="comment"># 数据集分割</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gbm = lgb.LGBMRegressor()<span class="comment">#直接使用默认参数，mse较小。</span></span><br><span class="line"></span><br><span class="line">gbm.fit(X_train, y_train,</span><br><span class="line">        eval_set=[(X_test, y_test)],</span><br><span class="line">        eval_metric=<span class="string">&#x27;l1&#x27;</span>,</span><br><span class="line">        callbacks=[lgb.early_stopping(<span class="number">5</span>)])</span><br><span class="line"><span class="comment">#eval_metric默认值：LGBMRegressor 为“l2”，LGBMClassifier 为“logloss”，LGBMRanker 为“ndcg”。</span></span><br><span class="line"><span class="comment">#使用binary_logloss或者logloss准确率都是一样的。默认logloss</span></span><br><span class="line">y_pred = gbm.predict(X_test)</span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">mse= mean_squared_error(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mse: %.2f&quot;</span> % (mse))</span><br></pre></td></tr></table></figure><pre><code>Training until validation scores don&#39;t improve for 5 roundsDid not meet early stopping. Best iteration is:[99]    valid_0&#39;s l1: 8.13036    valid_0&#39;s l2: 119.246mse: 119.25</code></pre><h4 id="3-3-2-原生train接口"><a href="#3-3-2-原生train接口" class="headerlink" title="3.3.2 原生train接口"></a>3.3.2 原生train接口</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lgb_train = lgb.Dataset(X_train, y_train)</span><br><span class="line">lgb_eval = lgb.Dataset(X_test, y_test, reference=lgb_train)</span><br><span class="line"><span class="comment">#设置参数为lgb.LGBMRegressor的默认参数。</span></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;regression&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;num_leaves&quot;</span>:<span class="number">31</span>,</span><br><span class="line">    <span class="string">&quot;learning_rate&quot;</span>: <span class="number">0.1</span>, </span><br><span class="line">    <span class="string">&quot;n_estimators&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">&quot;min_child_samples&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;verbosity&quot;</span>:-<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">gbm2 = lgb.train(params,</span><br><span class="line">                lgb_train,</span><br><span class="line">                num_boost_round=<span class="number">5</span>,</span><br><span class="line">                valid_sets=lgb_eval,</span><br><span class="line">                callbacks=[lgb.early_stopping(stopping_rounds=<span class="number">5</span>)])</span><br><span class="line"></span><br><span class="line">y_pred = gbm2.predict(X_test,num_iteration=gbm2.best_iteration)<span class="comment">#结果是0-1之间的概率值，是一维数组</span></span><br><span class="line">mse= mean_squared_error(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mse: %.2f&quot;</span> % (mse))</span><br></pre></td></tr></table></figure><pre><code>Training until validation scores don&#39;t improve for 5 roundsDid not meet early stopping. Best iteration is:[99]    valid_0&#39;s l2: 119.246mse: 119.25</code></pre><h2 id="四、graphviz可视化"><a href="#四、graphviz可视化" class="headerlink" title="四、graphviz可视化"></a>四、graphviz可视化</h2><blockquote><p>参考文档：<a href="https://blog.csdn.net/kyle1314608/article/details/111245782">《lightgbm 决策树 可视化 graphviz》</a>、<a href="https://graphviz.readthedocs.io/en/stable/manual.html"> graphviz参考文档</a> 、<a href="https://xgboost.readthedocs.io/en/latest/python/python_api.html#module-xgboost.plotting">《xgboost 可视化API文档》</a>、<a href="https://lightgbm.readthedocs.io/en/latest/Python-API.html#plotting">《lightgbm可视化API》</a></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">from</span> lightgbm <span class="keyword">import</span> LGBMClassifier</span><br><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">X,y = iris.data,iris.target</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">2022</span>) <span class="comment"># 数据集分割</span></span><br><span class="line"></span><br><span class="line">lgb_clf = lgb.LGBMClassifier()</span><br><span class="line">lgb_clf.fit(X_train, y_train)</span><br><span class="line">lgb.create_tree_digraph(lgb_clf, tree_index=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#设置参数</span></span><br><span class="line"><span class="comment">#多分类的objective为multiclass或者别名softmax</span></span><br></pre></td></tr></table></figure><p><img src="lightGBM_files/lightGBM_33_0.svg" alt="svg"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#lgb没有to_graphviz，无法这样保存图片通</span></span><br><span class="line">digraph = lgb.to_graphviz(lgb_clf , num_trees=<span class="number">1</span>)<span class="comment">#报错module &#x27;lightgbm&#x27; has no attribute &#x27;to_graphviz&#x27;</span></span><br><span class="line">digraph.<span class="built_in">format</span> = <span class="string">&#x27;png&#x27;</span></span><br><span class="line">digraph.view(<span class="string">&#x27;./iris_lgb&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-20-c0cca38d5eee&gt; in &lt;module&gt;      1 #lgb没有to_graphviz，无法这样保存图片通----&gt; 2 digraph = lgb.to_graphviz(lgb_clf , num_trees=1)#报错module &#39;lightgbm&#39; has no attribute &#39;to_graphviz&#39;      3 digraph.format = &#39;png&#39;      4 digraph.view(&#39;./iris_lgb&#39;)AttributeError: module &#39;lightgbm&#39; has no attribute &#39;to_graphviz&#39;</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line">iris = load_iris()</span><br><span class="line"></span><br><span class="line">xgb_clf = xgb.XGBClassifier()</span><br><span class="line">xgb_clf.fit(iris.data, iris.target)</span><br><span class="line">xgb.to_graphviz(xgb_clf, num_trees=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>[02:55:18] WARNING: C:/Users/Administrator/workspace/xgboost-win64_release_1.5.1/src/learner.cc:1115: Starting in XGBoost 1.3.0, the default evaluation metric used with the objective &#39;multi:softprob&#39; was changed from &#39;merror&#39; to &#39;mlogloss&#39;. Explicitly set eval_metric if you&#39;d like to restore the old behavior.</code></pre><p><img src="lightGBM_files/lightGBM_35_1.svg" alt="svg"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过Digraph对象可以将保存文件并查看</span></span><br><span class="line">digraph = xgb.to_graphviz(xgb_clf, num_trees=<span class="number">1</span>)</span><br><span class="line">digraph.<span class="built_in">format</span> = <span class="string">&#x27;png&#x27;</span><span class="comment">#将图像保存为png图片</span></span><br><span class="line">digraph.view(<span class="string">&#x27;./iris_xgb&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>&#39;iris_xgb.png&#39;</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 步骤3：读取任务2的json格式模型文件</span></span><br><span class="line">bst = lgb.Booster(model_file=<span class="string">&#x27;model.json&#x27;</span>)</span><br><span class="line">lgb.create_tree_digraph(bst, tree_index=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="lightGBM_files/lightGBM_37_0.svg" alt="svg"></p><h2 id="五、模型调参（网格、随机、贝叶斯）"><a href="#五、模型调参（网格、随机、贝叶斯）" class="headerlink" title="五、模型调参（网格、随机、贝叶斯）"></a>五、模型调参（网格、随机、贝叶斯）</h2><h3 id="5-1-加载数据集"><a href="#5-1-加载数据集" class="headerlink" title="5.1 加载数据集"></a>5.1 加载数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd, numpy <span class="keyword">as</span> np, time</span><br><span class="line">data= pd.read_csv(<span class="string">&quot;https://cdn.coggle.club/kaggle-flight-delays/flights_10k.csv.zip&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取有用的列</span></span><br><span class="line">data= data[[<span class="string">&quot;MONTH&quot;</span>,<span class="string">&quot;DAY&quot;</span>,<span class="string">&quot;DAY_OF_WEEK&quot;</span>,<span class="string">&quot;AIRLINE&quot;</span>,<span class="string">&quot;FLIGHT_NUMBER&quot;</span>,<span class="string">&quot;DESTINATION_AIRPORT&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;ORIGIN_AIRPORT&quot;</span>,<span class="string">&quot;AIR_TIME&quot;</span>, <span class="string">&quot;DEPARTURE_TIME&quot;</span>,<span class="string">&quot;DISTANCE&quot;</span>,<span class="string">&quot;ARRIVAL_DELAY&quot;</span>]]</span><br><span class="line">data.dropna(inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># 筛选出部分数据</span></span><br><span class="line">data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>] = (data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>]&gt;<span class="number">10</span>)*<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下四列数据转换为类别</span></span><br><span class="line">cols = [<span class="string">&quot;AIRLINE&quot;</span>,<span class="string">&quot;FLIGHT_NUMBER&quot;</span>,<span class="string">&quot;DESTINATION_AIRPORT&quot;</span>,<span class="string">&quot;ORIGIN_AIRPORT&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cols:</span><br><span class="line">    data[item] = data[item].astype(<span class="string">&quot;category&quot;</span>).cat.codes +<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">train, test, y_train, y_test = train_test_split(data.drop([<span class="string">&quot;ARRIVAL_DELAY&quot;</span>], axis=<span class="number">1</span>), data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>], random_state=<span class="number">10</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line">data</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>MONTH</th>      <th>DAY</th>      <th>DAY_OF_WEEK</th>      <th>AIRLINE</th>      <th>FLIGHT_NUMBER</th>      <th>DESTINATION_AIRPORT</th>      <th>ORIGIN_AIRPORT</th>      <th>AIR_TIME</th>      <th>DEPARTURE_TIME</th>      <th>DISTANCE</th>      <th>ARRIVAL_DELAY</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>1</td>      <td>4</td>      <td>2</td>      <td>88</td>      <td>253</td>      <td>13</td>      <td>169.0</td>      <td>2354.0</td>      <td>1448</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>1</td>      <td>4</td>      <td>1</td>      <td>2120</td>      <td>213</td>      <td>164</td>      <td>263.0</td>      <td>2.0</td>      <td>2330</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>1</td>      <td>1</td>      <td>4</td>      <td>12</td>      <td>803</td>      <td>60</td>      <td>262</td>      <td>266.0</td>      <td>18.0</td>      <td>2296</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>1</td>      <td>4</td>      <td>1</td>      <td>238</td>      <td>185</td>      <td>164</td>      <td>258.0</td>      <td>15.0</td>      <td>2342</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>1</td>      <td>1</td>      <td>4</td>      <td>2</td>      <td>122</td>      <td>14</td>      <td>261</td>      <td>199.0</td>      <td>24.0</td>      <td>1448</td>      <td>0</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>9994</th>      <td>1</td>      <td>1</td>      <td>4</td>      <td>8</td>      <td>2399</td>      <td>44</td>      <td>215</td>      <td>62.0</td>      <td>1710.0</td>      <td>473</td>      <td>0</td>    </tr>    <tr>      <th>9995</th>      <td>1</td>      <td>1</td>      <td>4</td>      <td>7</td>      <td>149</td>      <td>128</td>      <td>210</td>      <td>28.0</td>      <td>1716.0</td>      <td>100</td>      <td>1</td>    </tr>    <tr>      <th>9996</th>      <td>1</td>      <td>1</td>      <td>4</td>      <td>8</td>      <td>2510</td>      <td>208</td>      <td>76</td>      <td>29.0</td>      <td>1653.0</td>      <td>147</td>      <td>0</td>    </tr>    <tr>      <th>9997</th>      <td>1</td>      <td>1</td>      <td>4</td>      <td>8</td>      <td>2512</td>      <td>62</td>      <td>215</td>      <td>28.0</td>      <td>1721.0</td>      <td>135</td>      <td>1</td>    </tr>    <tr>      <th>9998</th>      <td>1</td>      <td>1</td>      <td>4</td>      <td>8</td>      <td>2541</td>      <td>208</td>      <td>182</td>      <td>103.0</td>      <td>2000.0</td>      <td>594</td>      <td>1</td>    </tr>  </tbody></table><p>9592 rows × 11 columns</p></div><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">from</span> lightgbm <span class="keyword">import</span> LGBMClassifier</span><br></pre></td></tr></table></figure><h3 id="5-2-步骤2-设置树模型深度分别为-3-5-6-9-，记录下验证集AUC精度。"><a href="#5-2-步骤2-设置树模型深度分别为-3-5-6-9-，记录下验证集AUC精度。" class="headerlink" title="5.2:步骤2 设置树模型深度分别为[3,5,6,9]，记录下验证集AUC精度。"></a>5.2:步骤2 设置树模型深度分别为[3,5,6,9]，记录下验证集AUC精度。</h3><ul><li>predict：lgb.LGBMClassifier()等sklearn接口中是返回预测的类别</li><li>predict_proba：klearn接口中是返回预测的概率。重点是求auc时，我们必须用predict_proba。因为roc曲线的阀值是根据其正样本的概率求的。</li></ul><p>参考<a href="https://blog.csdn.net/weixin_43827767/article/details/120586336">《数据挖掘竞赛lightgbm通过求最大auc调参》</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sklearn接口</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_depth</span>(<span class="params">max_depth</span>):</span>    </span><br><span class="line">    gbm = lgb.LGBMClassifier(max_depth=max_depth)</span><br><span class="line">    gbm.fit(train, y_train,</span><br><span class="line">            eval_set=[(test, y_test)],</span><br><span class="line">            eval_metric=<span class="string">&#x27;binary_logloss&#x27;</span>,</span><br><span class="line">            callbacks=[lgb.early_stopping(<span class="number">5</span>)])</span><br><span class="line">    <span class="comment">#eval_metric默认值：LGBMRegressor 为“l2”，LGBMClassifier 为“logloss”，LGBMRanker 为“ndcg”。</span></span><br><span class="line">    <span class="comment">#使用binary_logloss或者logloss准确率都是一样的。默认logloss</span></span><br><span class="line">    y_pred = gbm.predict(test)</span><br><span class="line">    <span class="comment"># 计算准确率</span></span><br><span class="line">    accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line">    auc_score=metrics.roc_auc_score(y_test,gbm.predict_proba(test)[:,<span class="number">1</span>])<span class="comment">#predict_proba输出正负样本概率值，取第二列为正样本概率值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;max_depth=&quot;</span>,max_depth,<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>),<span class="string">&quot;auc_score: %.2f%%&quot;</span> % (auc_score*<span class="number">100.0</span>))</span><br><span class="line"></span><br><span class="line">test_depth(<span class="number">3</span>)</span><br><span class="line">test_depth(<span class="number">5</span>)</span><br><span class="line">test_depth(<span class="number">6</span>)</span><br><span class="line">test_depth(<span class="number">9</span>)</span><br></pre></td></tr></table></figure><pre><code>Training until validation scores don&#39;t improve for 5 roundsDid not meet early stopping. Best iteration is:[98]    valid_0&#39;s binary_logloss: 0.429334max_depth= 3 accuarcy: 81.90% auc_score: 76.32%Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[60]    valid_0&#39;s binary_logloss: 0.430826max_depth= 5 accuarcy: 81.98% auc_score: 75.54%Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[65]    valid_0&#39;s binary_logloss: 0.429341max_depth= 6 accuarcy: 81.69% auc_score: 75.63%Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[52]    valid_0&#39;s binary_logloss: 0.429146max_depth= 9 accuarcy: 81.94% auc_score: 76.07%</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#原生train接口</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">lgb_train = lgb.Dataset(train, y_train)</span><br><span class="line">lgb_eval = lgb.Dataset(test, y_test, reference=lgb_train)</span><br><span class="line"><span class="comment">#设置参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_depth</span>(<span class="params">max_depth</span>):</span> </span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">&#x27;metric&#x27;</span>: <span class="string">&#x27;binary_logloss&#x27;</span>,</span><br><span class="line">        <span class="string">&quot;learning_rate&quot;</span>:<span class="number">0.1</span>, </span><br><span class="line">        <span class="string">&quot;min_child_samples&quot;</span>:<span class="number">20</span>,</span><br><span class="line">         <span class="string">&quot;num_leaves&quot;</span>:<span class="number">31</span>,</span><br><span class="line">         <span class="string">&quot;max_depth&quot;</span>:max_depth&#125;</span><br><span class="line"></span><br><span class="line">    gbm2 = lgb.train(params,</span><br><span class="line">                    lgb_train,</span><br><span class="line">                    num_boost_round=<span class="number">10</span>,</span><br><span class="line">                    valid_sets=lgb_eval,</span><br><span class="line">                    callbacks=[lgb.early_stopping(stopping_rounds=<span class="number">5</span>)])</span><br><span class="line"></span><br><span class="line">    y_pred = gbm2.predict(test,num_iteration=gbm2.best_iteration)<span class="comment">#结果是0-1之间的概率值，是一维数组</span></span><br><span class="line">    pred =[<span class="number">1</span> <span class="keyword">if</span> x &gt;<span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> y_pred]</span><br><span class="line">    accuracy = accuracy_score(y_test,pred)</span><br><span class="line">    auc_score=metrics.roc_auc_score(y_test,y_pred)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;max_depth=&quot;</span>,max_depth,<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>),<span class="string">&quot;auc_score: %.2f%%&quot;</span> % (auc_score*<span class="number">100.0</span>))</span><br><span class="line">test_depth(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-------------------------------------------------------------------------&#x27;</span>)</span><br><span class="line">test_depth(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-------------------------------------------------------------------------&#x27;</span>)</span><br><span class="line">test_depth(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-------------------------------------------------------------------------&#x27;</span>)</span><br><span class="line">test_depth(<span class="number">9</span>)</span><br></pre></td></tr></table></figure><h3 id="5-3-步骤3：category变量设置为categorical-feature"><a href="#5-3-步骤3：category变量设置为categorical-feature" class="headerlink" title="5.3  步骤3：category变量设置为categorical_feature"></a>5.3  步骤3：category变量设置为categorical_feature</h3><blockquote><p>参考<a href="https://blog.csdn.net/anshuai_aw1/article/details/83275299">《Lightgbm如何处理类别特征？》</a><br>参考kaggle教程<a href="https://www.kaggle.com/ogrellier/feature-selection-with-null-importances">《Feature Selection with Null Importances》</a>中的代码。</p></blockquote><p>lightGBM比XGBoost的1个改进之处在于对类别特征的处理, 不再需要将类别特征转为one-hot形式。这一步通过设置categorical_feature来实现。</p><p>唯一疑惑的是真正的object特征只有’AIRLINE’, ‘DESTINATION_AIRPORT’, ‘ORIGIN_AIRPORT’，但是’FLIGHT_NUMBER’也设置成类别特征效果更好。</p><ul><li>‘FLIGHT_NUMBER’也为类别特征：accuarcy: 81.82% auc_score: 77.52%</li><li>‘FLIGHT_NUMBER’不是类别特征：accuarcy: 81.69% auc_score: 76.48%</li></ul><p>估计跟数据集有关系，没有仔细研究数据集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd, numpy <span class="keyword">as</span> np, time</span><br><span class="line">data= pd.read_csv(<span class="string">&quot;https://cdn.coggle.club/kaggle-flight-delays/flights_10k.csv.zip&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取有用的列</span></span><br><span class="line">data= data[[<span class="string">&quot;MONTH&quot;</span>,<span class="string">&quot;DAY&quot;</span>,<span class="string">&quot;DAY_OF_WEEK&quot;</span>,<span class="string">&quot;AIRLINE&quot;</span>,<span class="string">&quot;FLIGHT_NUMBER&quot;</span>,<span class="string">&quot;DESTINATION_AIRPORT&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;ORIGIN_AIRPORT&quot;</span>,<span class="string">&quot;AIR_TIME&quot;</span>, <span class="string">&quot;DEPARTURE_TIME&quot;</span>,<span class="string">&quot;DISTANCE&quot;</span>,<span class="string">&quot;ARRIVAL_DELAY&quot;</span>]]</span><br><span class="line">data.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># 筛选出部分数据</span></span><br><span class="line">data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>] = (data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>]&gt;<span class="number">10</span>)*<span class="number">1</span></span><br><span class="line">categorical_feats  = [<span class="string">&quot;AIRLINE&quot;</span>,<span class="string">&quot;FLIGHT_NUMBER&quot;</span>,<span class="string">&quot;DESTINATION_AIRPORT&quot;</span>,<span class="string">&quot;ORIGIN_AIRPORT&quot;</span>]</span><br><span class="line"><span class="comment">#categorical_feats = [f for f in data.columns if data[f].dtype == &#x27;object&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将上面四列特征转为类别特征，但不是one-hot编码</span></span><br><span class="line"><span class="keyword">for</span> f_ <span class="keyword">in</span> categorical_feats:</span><br><span class="line">    data[f_], _ = pd.factorize(data[f_])</span><br><span class="line">    <span class="comment"># Set feature type as categorical</span></span><br><span class="line">    data[f_] = data[f_].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(data.drop([<span class="string">&quot;ARRIVAL_DELAY&quot;</span>], axis=<span class="number">1</span>), data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>], random_state=<span class="number">10</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line">categorical_feats</span><br></pre></td></tr></table></figure><pre><code>[&#39;AIRLINE&#39;, &#39;FLIGHT_NUMBER&#39;, &#39;DESTINATION_AIRPORT&#39;, &#39;ORIGIN_AIRPORT&#39;]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"></span><br><span class="line">lgb_train = lgb.Dataset(X_train, y_train,free_raw_data=<span class="literal">False</span>)</span><br><span class="line">lgb_eval = lgb.Dataset(X_test, y_test, reference=lgb_train,free_raw_data=<span class="literal">False</span>)</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;metric&#x27;</span>: <span class="string">&#x27;binary_logloss&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.3</span>,</span><br><span class="line">    <span class="string">&#x27;feature_fraction&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">    <span class="string">&#x27;lambda_l1&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line">    <span class="string">&#x27;lambda_l2&#x27;</span>: <span class="number">2.9</span>,</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">15</span>,</span><br><span class="line">    <span class="string">&#x27;min_data_in_leaf&#x27;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="string">&#x27;min_gain_to_split&#x27;</span>: <span class="number">1.0</span>,</span><br><span class="line">    <span class="string">&#x27;min_sum_hessian_in_leaf&#x27;</span>: <span class="number">0.0038</span>,</span><br><span class="line">    <span class="string">&quot;verbosity&quot;</span>:-<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征命名</span></span><br><span class="line"><span class="comment">#num_train, num_feature = X_train.shape#X_train是7194行10列的数据集，num_feature=10表示特征数量</span></span><br><span class="line"><span class="comment">#feature_name = [&#x27;feature_&#x27; + str(col) for col in range(num_feature)]#feature_0到9</span></span><br><span class="line"></span><br><span class="line">gbm = lgb.train(params,</span><br><span class="line">                lgb_train,</span><br><span class="line">                num_boost_round=<span class="number">10</span>,</span><br><span class="line">                valid_sets=lgb_eval,  <span class="comment">#验证集设置</span></span><br><span class="line">                <span class="comment">#feature_name=feature_name,  #特征命名</span></span><br><span class="line">                categorical_feature=categorical_feats,</span><br><span class="line">                callbacks=[lgb.early_stopping(stopping_rounds=<span class="number">5</span>)]) <span class="comment">#设置分类变量</span></span><br><span class="line"></span><br><span class="line">y_pred = gbm.predict(X_test,num_iteration=gbm.best_iteration)<span class="comment">#结果是0-1之间的概率值，是一维数组</span></span><br><span class="line">pred =[<span class="number">1</span> <span class="keyword">if</span> x &gt;<span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> y_pred]</span><br><span class="line">accuracy = accuracy_score(y_test,pred)</span><br><span class="line">auc_score=metrics.roc_auc_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>),<span class="string">&quot;auc_score: %.2f%%&quot;</span> % (auc_score*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>Training until validation scores don&#39;t improve for 5 roundsDid not meet early stopping. Best iteration is:[10]    valid_0&#39;s binary_logloss: 0.424384accuarcy: 81.82% auc_score: 77.52%</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不设置categorical_feature结果一样啊，不知道为何？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行one-hot编码</span></span><br><span class="line">cols = [<span class="string">&quot;AIRLINE&quot;</span>,<span class="string">&quot;FLIGHT_NUMBER&quot;</span>,<span class="string">&quot;DESTINATION_AIRPORT&quot;</span>,<span class="string">&quot;ORIGIN_AIRPORT&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cols:</span><br><span class="line">    data[item] = data[item].astype(<span class="string">&quot;category&quot;</span>).cat.codes +<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">train, test, y_train, y_test = train_test_split(data.drop([<span class="string">&quot;ARRIVAL_DELAY&quot;</span>], axis=<span class="number">1</span>), data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>], random_state=<span class="number">10</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line">gbm2 = lgb.train(params,</span><br><span class="line">                lgb_train,</span><br><span class="line">                num_boost_round=<span class="number">10</span>,</span><br><span class="line">                valid_sets=lgb_eval,</span><br><span class="line">                 callbacks=[lgb.early_stopping(stopping_rounds=<span class="number">5</span>)]) </span><br><span class="line"></span><br><span class="line">y_pred2 = gbm2.predict(X_test,num_iteration=gbm2.best_iteration)<span class="comment">#结果是0-1之间的概率值，是一维数组</span></span><br><span class="line">pred2 =[<span class="number">1</span> <span class="keyword">if</span> x &gt;<span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> y_pred2]</span><br><span class="line">accuracy2 = accuracy_score(y_test,pred2)</span><br><span class="line">auc_score2=metrics.roc_auc_score(y_test,y_pred2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy2*<span class="number">100.0</span>),<span class="string">&quot;auc_score: %.2f%%&quot;</span> % (auc_score2*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>Training until validation scores don&#39;t improve for 5 roundsDid not meet early stopping. Best iteration is:[10]    valid_0&#39;s binary_logloss: 0.424384accuarcy: 81.82% auc_score: 77.52%</code></pre><h3 id="5-4-步骤4：超参搜索"><a href="#5-4-步骤4：超参搜索" class="headerlink" title="5.4  步骤4：超参搜索"></a>5.4  步骤4：超参搜索</h3><h4 id="5-4-1-GridSearchCV"><a href="#5-4-1-GridSearchCV" class="headerlink" title="5.4.1 GridSearchCV"></a>5.4.1 GridSearchCV</h4><blockquote><p><a href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.model_selection">GridSearchCV参考文档</a></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sklearn.model_selection.GridSearchCV(estimator, param_grid, *, scoring=<span class="literal">None</span>, n_jobs=<span class="literal">None</span>, refit=<span class="literal">True</span>, cv=<span class="literal">None</span>, verbose=<span class="number">0</span>, pre_dispatch=<span class="string">&#x27;2*n_jobs&#x27;</span>, error_score=nan, return_train_score=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>其中 scoring是字符串格式或者str列表、字典。具体的参数列表参考文档<a href="https://scikit-learn.org/stable/modules/model_evaluation.html#scoring-parameter">scoring-parameter</a></p><p>网格搜索——尝试所有可能的组合：<br><img src="https://img-blog.csdnimg.cn/fc0dcfd497d04ab38597dc9a4b02afe7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">from</span> lightgbm <span class="keyword">import</span> LGBMClassifier</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd, numpy <span class="keyword">as</span> np, time</span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">&quot;https://cdn.coggle.club/kaggle-flight-delays/flights_10k.csv.zip&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取有用的列</span></span><br><span class="line">data = data[[<span class="string">&quot;MONTH&quot;</span>,<span class="string">&quot;DAY&quot;</span>,<span class="string">&quot;DAY_OF_WEEK&quot;</span>,<span class="string">&quot;AIRLINE&quot;</span>,<span class="string">&quot;FLIGHT_NUMBER&quot;</span>,<span class="string">&quot;DESTINATION_AIRPORT&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;ORIGIN_AIRPORT&quot;</span>,<span class="string">&quot;AIR_TIME&quot;</span>, <span class="string">&quot;DEPARTURE_TIME&quot;</span>,<span class="string">&quot;DISTANCE&quot;</span>,<span class="string">&quot;ARRIVAL_DELAY&quot;</span>]]</span><br><span class="line">data.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出部分数据</span></span><br><span class="line">data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>] = (data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>]&gt;<span class="number">10</span>)*<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行编码</span></span><br><span class="line">cols = [<span class="string">&quot;AIRLINE&quot;</span>,<span class="string">&quot;FLIGHT_NUMBER&quot;</span>,<span class="string">&quot;DESTINATION_AIRPORT&quot;</span>,<span class="string">&quot;ORIGIN_AIRPORT&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cols:</span><br><span class="line">    data[item] = data[item].astype(<span class="string">&quot;category&quot;</span>).cat.codes +<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(data.drop([<span class="string">&quot;ARRIVAL_DELAY&quot;</span>], axis=<span class="number">1</span>), data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>], random_state=<span class="number">10</span>, test_size=<span class="number">0.25</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parameters = &#123;</span><br><span class="line">              <span class="string">&#x27;max_depth&#x27;</span>: [<span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>],</span><br><span class="line">              <span class="string">&#x27;learning_rate&#x27;</span>: [<span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.15</span>],</span><br><span class="line">              <span class="string">&#x27;n_estimators&#x27;</span>: [<span class="number">100</span>, <span class="number">200</span>,<span class="number">500</span>],</span><br><span class="line">              <span class="string">&quot;num_leaves&quot;</span>:[<span class="number">25</span>,<span class="number">31</span>,<span class="number">36</span>]&#125;</span><br><span class="line"></span><br><span class="line">gbm = lgb.LGBMClassifier(max_depth=<span class="number">10</span>,<span class="comment">#构建树的深度，越大越容易过拟合</span></span><br><span class="line">            learning_rate=<span class="number">0.01</span>,</span><br><span class="line">            n_estimators=<span class="number">100</span>,         </span><br><span class="line">            seed=<span class="number">0</span>,</span><br><span class="line">            missing=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">gs = GridSearchCV(gbm, param_grid=parameters, scoring=<span class="string">&#x27;accuracy&#x27;</span>, cv=<span class="number">3</span>)</span><br><span class="line">gs.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Best score: %0.3f&quot;</span> % gs.best_score_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Best parameters set: %s&quot;</span> % gs.best_params_ )</span><br></pre></td></tr></table></figure><pre><code>Best score: 0.805Best parameters set: &#123;&#39;learning_rate&#39;: 0.05, &#39;max_depth&#39;: 8, &#39;n_estimators&#39;: 100, &#39;num_leaves&#39;: 36&#125;</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用最优参数预测验证集</span></span><br><span class="line">y_pred = gs.predict(X_test)</span><br><span class="line"><span class="comment"># 计算准确率和auc</span></span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line">auc_score=metrics.roc_auc_score(y_test,gs.predict_proba(X_test)[:,<span class="number">1</span>])<span class="comment">#predict_proba输出正负样本概率值，取第二列为正样本概率值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>),<span class="string">&quot;auc_score: %.2f%%&quot;</span> % (auc_score*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>accuarcy: 82.07% auc_score: 75.92%</code></pre><h3 id="5-4-3-随机搜索"><a href="#5-4-3-随机搜索" class="headerlink" title="5.4.3 随机搜索"></a>5.4.3 随机搜索</h3><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.RandomizedSearchCV.html#sklearn.model_selection.RandomizedSearchCV">参考文档</a></p></blockquote><p>网格搜索尝试超参数的所有组合，因此增加了计算的时间复杂度，在数据量较大，或者模型较为复杂等等情况下，可能导致不可行的计算成本，这样网格搜索调参方法就不适用了。然而，随机搜索提供更便利的替代方案，该方法只测试你选择的超参数组成的元组，并且超参数值的选择是完全随机的，如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/424f79626ce841ae95ee8bd3247808e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> RandomizedSearchCV</span><br><span class="line"></span><br><span class="line">param = <span class="built_in">dict</span>(n_estimators=[<span class="number">80</span>,<span class="number">100</span>, <span class="number">200</span>],</span><br><span class="line">             max_depth=[<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>],</span><br><span class="line">            learning_rate= [<span class="number">0.02</span>,<span class="number">0.05</span>, <span class="number">0.1</span>],</span><br><span class="line">            num_leaves=[<span class="number">25</span>,<span class="number">31</span>,<span class="number">36</span>])</span><br><span class="line"></span><br><span class="line">grid = RandomizedSearchCV(estimator=lgb.LGBMClassifier(),</span><br><span class="line">                          param_distributions=param,scoring=<span class="string">&#x27;accuracy&#x27;</span>,cv=<span class="number">3</span>)</span><br><span class="line">grid.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Best score: %0.3f&quot;</span> % grid.best_score_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Best parameters set: %s&quot;</span> % grid.best_params_ )</span><br><span class="line"><span class="comment"># 找到最好的模型</span></span><br><span class="line">grid.best_estimator_</span><br></pre></td></tr></table></figure><pre><code>Best score: 0.806Best parameters set: &#123;&#39;num_leaves&#39;: 36, &#39;n_estimators&#39;: 80, &#39;max_depth&#39;: 6, &#39;learning_rate&#39;: 0.1&#125;LGBMClassifier(max_depth=6, n_estimators=80, num_leaves=36)</code></pre><p>最优模型直接用grid或者rid.best<em>estimator</em>都行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用最优参数预测验证集</span></span><br><span class="line">y_pred = grid .predict(X_test)</span><br><span class="line"><span class="comment"># 计算准确率和auc</span></span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line">auc_score=metrics.roc_auc_score(y_test,grid .predict_proba(X_test)[:,<span class="number">1</span>])<span class="comment">#predict_proba输出正负样本概率值，取第二列为正样本概率值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>),<span class="string">&quot;auc_score: %.2f%%&quot;</span> % (auc_score*<span class="number">100.0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到最好的模型</span></span><br><span class="line">gd=grid.best_estimator_</span><br><span class="line">y_pred = gd .predict(X_test)</span><br><span class="line"><span class="comment"># 计算准确率和auc</span></span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line">auc_score=metrics.roc_auc_score(y_test,gd .predict_proba(X_test)[:,<span class="number">1</span>])<span class="comment">#predict_proba输出正负样本概率值，取第二列为正样本概率值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>),<span class="string">&quot;auc_score: %.2f%%&quot;</span> % (auc_score*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>accuarcy: 81.69% auc_score: 75.62%accuarcy: 81.69% auc_score: 75.62%</code></pre><h3 id="5-4-4-贝叶斯搜索"><a href="#5-4-4-贝叶斯搜索" class="headerlink" title="5.4.4 贝叶斯搜索"></a>5.4.4 贝叶斯搜索</h3><blockquote><p>参考<a href="https://blog.csdn.net/qq_42283960/article/details/88317003">《贝叶斯全局优化（LightGBM调参）》</a></p></blockquote><p>贝叶斯搜索使用贝叶斯优化技术对搜索空间进行建模，以尽快获得优化的参数值。它使用搜索空间的结构来优化搜索时间。贝叶斯搜索方法使用过去的评估结果来采样最有可能提供更好结果的新候选参数（如下图所示）:</p><p><img src="https://img-blog.csdnimg.cn/02eaae7e2d104f418e5d0331ca9cd870.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设定贝叶斯优化的黑盒函数LGB_bayesian</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LGB_bayesian</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    num_leaves,  <span class="comment"># int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    min_data_in_leaf,  <span class="comment"># int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    learning_rate,</span></span></span><br><span class="line"><span class="params"><span class="function">    min_sum_hessian_in_leaf,    <span class="comment"># int  </span></span></span></span><br><span class="line"><span class="params"><span class="function">    feature_fraction,</span></span></span><br><span class="line"><span class="params"><span class="function">    lambda_l1,</span></span></span><br><span class="line"><span class="params"><span class="function">    lambda_l2,</span></span></span><br><span class="line"><span class="params"><span class="function">    min_gain_to_split,</span></span></span><br><span class="line"><span class="params"><span class="function">    max_depth</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># LightGBM expects next three parameters need to be integer. So we make them integer</span></span><br><span class="line">    num_leaves = <span class="built_in">int</span>(num_leaves)</span><br><span class="line">    min_data_in_leaf = <span class="built_in">int</span>(min_data_in_leaf)</span><br><span class="line">    max_depth = <span class="built_in">int</span>(max_depth)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">type</span>(num_leaves) == <span class="built_in">int</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">type</span>(min_data_in_leaf) == <span class="built_in">int</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">type</span>(max_depth) == <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">    param = &#123;</span><br><span class="line">        <span class="string">&#x27;num_leaves&#x27;</span>: num_leaves,</span><br><span class="line">        <span class="string">&#x27;max_bin&#x27;</span>: <span class="number">63</span>,</span><br><span class="line">        <span class="string">&#x27;min_data_in_leaf&#x27;</span>: min_data_in_leaf,</span><br><span class="line">        <span class="string">&#x27;learning_rate&#x27;</span>: learning_rate,</span><br><span class="line">        <span class="string">&#x27;min_sum_hessian_in_leaf&#x27;</span>: min_sum_hessian_in_leaf,</span><br><span class="line">        <span class="string">&#x27;bagging_fraction&#x27;</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="string">&#x27;bagging_freq&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&#x27;feature_fraction&#x27;</span>: feature_fraction,</span><br><span class="line">        <span class="string">&#x27;lambda_l1&#x27;</span>: lambda_l1,</span><br><span class="line">        <span class="string">&#x27;lambda_l2&#x27;</span>: lambda_l2,</span><br><span class="line">        <span class="string">&#x27;min_gain_to_split&#x27;</span>: min_gain_to_split,</span><br><span class="line">        <span class="string">&#x27;max_depth&#x27;</span>: max_depth,</span><br><span class="line">        <span class="string">&#x27;save_binary&#x27;</span>: <span class="literal">True</span>, </span><br><span class="line">        <span class="string">&#x27;seed&#x27;</span>: <span class="number">1337</span>,</span><br><span class="line">        <span class="string">&#x27;feature_fraction_seed&#x27;</span>: <span class="number">1337</span>,</span><br><span class="line">        <span class="string">&#x27;bagging_seed&#x27;</span>: <span class="number">1337</span>,</span><br><span class="line">        <span class="string">&#x27;drop_seed&#x27;</span>: <span class="number">1337</span>,</span><br><span class="line">        <span class="string">&#x27;data_random_seed&#x27;</span>: <span class="number">1337</span>,</span><br><span class="line">        <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;verbose&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;metric&#x27;</span>: <span class="string">&#x27;auc&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;is_unbalance&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&#x27;boost_from_average&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;verbosity&quot;</span>:-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    lgb_train = lgb.Dataset(X_train,</span><br><span class="line">                           label=y_train)</span><br><span class="line">    lgb_valid = lgb.Dataset(X_test,label=y_test,reference=lgb_train)   </span><br><span class="line"></span><br><span class="line">    num_round = <span class="number">500</span></span><br><span class="line">    gbm= lgb.train(param, lgb_train, num_round, valid_sets = [lgb_valid],callbacks=[lgb.early_stopping(stopping_rounds=<span class="number">5</span>)])   </span><br><span class="line">    predictions = gbm.predict(X_test,num_iteration=gbm.best_iteration)</span><br><span class="line">    score = metrics.roc_auc_score(y_test, predictions)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> score</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LGB_bayesian函数从贝叶斯优化框架获取num_leaves，min_data_in_leaf，learning_rate，min_sum_hessian_in_leaf，feature_fraction，lambda_l1，lambda_l2，min_gain_to_split，max_depth的值。 请记住，对于LightGBM，num_leaves，min_data_in_leaf和max_depth应该是整数。 但贝叶斯优化会发送连续的函数。 所以我强制它们是整数。 我只会找到它们的最佳参数值。 读者可以增加或减少要优化的参数数量。<br>现在需要为这些参数提供边界，以便贝叶斯优化仅在边界内搜索</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bounds_LGB = &#123;</span><br><span class="line">    <span class="string">&#x27;num_leaves&#x27;</span>: (<span class="number">5</span>, <span class="number">20</span>), </span><br><span class="line">    <span class="string">&#x27;min_data_in_leaf&#x27;</span>: (<span class="number">5</span>, <span class="number">20</span>),  </span><br><span class="line">    <span class="string">&#x27;learning_rate&#x27;</span>: (<span class="number">0.01</span>, <span class="number">0.3</span>),</span><br><span class="line">    <span class="string">&#x27;min_sum_hessian_in_leaf&#x27;</span>: (<span class="number">0.00001</span>, <span class="number">0.01</span>),    </span><br><span class="line">    <span class="string">&#x27;feature_fraction&#x27;</span>: (<span class="number">0.05</span>, <span class="number">0.5</span>),</span><br><span class="line">    <span class="string">&#x27;lambda_l1&#x27;</span>: (<span class="number">0</span>, <span class="number">5.0</span>), </span><br><span class="line">    <span class="string">&#x27;lambda_l2&#x27;</span>: (<span class="number">0</span>, <span class="number">5.0</span>), </span><br><span class="line">    <span class="string">&#x27;min_gain_to_split&#x27;</span>: (<span class="number">0</span>, <span class="number">1.0</span>),</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>:(<span class="number">3</span>,<span class="number">15</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#将它们全部放在BayesianOptimization对象中</span></span><br><span class="line"><span class="keyword">from</span> bayes_opt <span class="keyword">import</span> BayesianOptimization</span><br><span class="line">LGB_BO = BayesianOptimization(LGB_bayesian, bounds_LGB, random_state=<span class="number">13</span>)</span><br><span class="line"><span class="built_in">print</span>(LGB_BO.space.keys)<span class="comment">#显示要优化的参数</span></span><br></pre></td></tr></table></figure><pre><code>[&#39;feature_fraction&#39;, &#39;lambda_l1&#39;, &#39;lambda_l2&#39;, &#39;learning_rate&#39;, &#39;max_depth&#39;, &#39;min_data_in_leaf&#39;, &#39;min_gain_to_split&#39;, &#39;min_sum_hessian_in_leaf&#39;, &#39;num_leaves&#39;]</code></pre><p>调用maximize方法LGB_BO才会开始搜索。</p><ul><li>init_points：我们想要执行的随机探索的初始随机运行次数。 在我们的例子中，LGB_bayesian将被运行n_iter次。</li><li>n_iter：运行init_points数后，我们要执行多少次贝叶斯优化运行。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">pd.set_option(<span class="string">&#x27;display.max_columns&#x27;</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">init_points = <span class="number">5</span></span><br><span class="line">n_iter = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">130</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> warnings.catch_warnings():</span><br><span class="line">    warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    LGB_BO.maximize(init_points=init_points, n_iter=n_iter, acq=<span class="string">&#x27;ucb&#x27;</span>, xi=<span class="number">0.0</span>, alpha=<span class="number">1e-6</span>)</span><br></pre></td></tr></table></figure><pre><code>----------------------------------------------------------------------------------------------------------------------------------|   iter    |  target   | featur... | lambda_l1 | lambda_l2 | learni... | max_depth | min_da... | min_ga... | min_su... | num_le... |-------------------------------------------------------------------------------------------------------------------------------------[LightGBM] [Warning] verbosity is set=-1, verbose=1 will be ignored. Current value: verbosity=-1Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[22]    valid_0&#39;s auc: 0.770384| [0m 1       [0m | [0m 0.7704  [0m | [0m 0.4     [0m | [0m 1.188   [0m | [0m 4.121   [0m | [0m 0.2901  [0m | [0m 14.67   [0m | [0m 11.8    [0m | [0m 0.609   [0m | [0m 0.007758[0m | [0m 14.62   [0m |[LightGBM] [Warning] verbosity is set=-1, verbose=1 will be ignored. Current value: verbosity=-1Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[5]    valid_0&#39;s auc: 0.737399| [0m 2       [0m | [0m 0.7374  [0m | [0m 0.3749  [0m | [0m 0.1752  [0m | [0m 1.492   [0m | [0m 0.02697 [0m | [0m 13.28   [0m | [0m 10.59   [0m | [0m 0.6798  [0m | [0m 0.00257 [0m | [0m 10.21   [0m |[LightGBM] [Warning] verbosity is set=-1, verbose=1 will be ignored. Current value: verbosity=-1Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[8]    valid_0&#39;s auc: 0.719501| [0m 3       [0m | [0m 0.7195  [0m | [0m 0.05424 [0m | [0m 1.792   [0m | [0m 4.745   [0m | [0m 0.07319 [0m | [0m 6.833   [0m | [0m 18.77   [0m | [0m 0.0319  [0m | [0m 0.000660[0m | [0m 14.45   [0m |[LightGBM] [Warning] verbosity is set=-1, verbose=1 will be ignored. Current value: verbosity=-1Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[19]    valid_0&#39;s auc: 0.760323| [0m 4       [0m | [0m 0.7603  [0m | [0m 0.4432  [0m | [0m 0.04358 [0m | [0m 3.733   [0m | [0m 0.2457  [0m | [0m 3.909   [0m | [0m 14.85   [0m | [0m 0.5093  [0m | [0m 0.004804[0m | [0m 19.33   [0m |[LightGBM] [Warning] verbosity is set=-1, verbose=1 will be ignored. Current value: verbosity=-1Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[8]    valid_0&#39;s auc: 0.719412| [0m 5       [0m | [0m 0.7194  [0m | [0m 0.05001 [0m | [0m 1.235   [0m | [0m 3.561   [0m | [0m 0.1041  [0m | [0m 6.324   [0m | [0m 15.43   [0m | [0m 0.9186  [0m | [0m 0.002452[0m | [0m 11.87   [0m |[LightGBM] [Warning] verbosity is set=-1, verbose=1 will be ignored. Current value: verbosity=-1Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[11]    valid_0&#39;s auc: 0.761779| [0m 6       [0m | [0m 0.7618  [0m | [0m 0.5     [0m | [0m 1.457   [0m | [0m 5.0     [0m | [0m 0.3     [0m | [0m 15.0    [0m | [0m 11.16   [0m | [0m 0.5786  [0m | [0m 0.01    [0m | [0m 17.3    [0m |[LightGBM] [Warning] verbosity is set=-1, verbose=1 will be ignored. Current value: verbosity=-1Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[8]    valid_0&#39;s auc: 0.723696| [0m 7       [0m | [0m 0.7237  [0m | [0m 0.05    [0m | [0m 5.0     [0m | [0m 5.0     [0m | [0m 0.3     [0m | [0m 15.0    [0m | [0m 12.07   [0m | [0m 0.0     [0m | [0m 0.01    [0m | [0m 14.22   [0m |[LightGBM] [Warning] verbosity is set=-1, verbose=1 will be ignored. Current value: verbosity=-1Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[17]    valid_0&#39;s auc: 0.770585| [95m 8       [0m | [95m 0.7706  [0m | [95m 0.5     [0m | [95m 0.0     [0m | [95m 2.9     [0m | [95m 0.3     [0m | [95m 14.75   [0m | [95m 11.78   [0m | [95m 1.0     [0m | [95m 0.003764[0m | [95m 16.12   [0m |[LightGBM] [Warning] verbosity is set=-1, verbose=1 will be ignored. Current value: verbosity=-1Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[19]    valid_0&#39;s auc: 0.769728| [0m 9       [0m | [0m 0.7697  [0m | [0m 0.5     [0m | [0m 0.0     [0m | [0m 4.272   [0m | [0m 0.3     [0m | [0m 15.0    [0m | [0m 8.6     [0m | [0m 1.0     [0m | [0m 0.009985[0m | [0m 15.0    [0m |[LightGBM] [Warning] verbosity is set=-1, verbose=1 will be ignored. Current value: verbosity=-1Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[28]    valid_0&#39;s auc: 0.770488| [0m 10      [0m | [0m 0.7705  [0m | [0m 0.5     [0m | [0m 0.0     [0m | [0m 4.457   [0m | [0m 0.3     [0m | [0m 10.79   [0m | [0m 9.347   [0m | [0m 1.0     [0m | [0m 0.01    [0m | [0m 16.83   [0m |=====================================================================================================================================</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(LGB_BO.<span class="built_in">max</span>[<span class="string">&#x27;target&#x27;</span>])<span class="comment">#最佳的auc值</span></span><br><span class="line">LGB_BO.<span class="built_in">max</span>[<span class="string">&#x27;params&#x27;</span>]<span class="comment">#最佳模型参数</span></span><br></pre></td></tr></table></figure><pre><code>0.7705848546741305&#123;&#39;feature_fraction&#39;: 0.5, &#39;lambda_l1&#39;: 0.0, &#39;lambda_l2&#39;: 2.899605369776912, &#39;learning_rate&#39;: 0.3, &#39;max_depth&#39;: 14.752822601781512, &#39;min_data_in_leaf&#39;: 11.782200828907708, &#39;min_gain_to_split&#39;: 1.0, &#39;min_sum_hessian_in_leaf&#39;: 0.0037639771497955552, &#39;num_leaves&#39;: 16.11909067874899&#125;</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将这些参数用于我们的最终模型</span></span><br><span class="line">LGB_BO.probe(</span><br><span class="line">    params=&#123;<span class="string">&#x27;feature_fraction&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">            <span class="string">&#x27;lambda_l1&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line">            <span class="string">&#x27;lambda_l2&#x27;</span>: <span class="number">2.9</span>,</span><br><span class="line">            <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.3</span>,</span><br><span class="line">            <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">15</span>,</span><br><span class="line">            <span class="string">&#x27;min_data_in_leaf&#x27;</span>: <span class="number">12</span>,</span><br><span class="line">            <span class="string">&#x27;min_gain_to_split&#x27;</span>: <span class="number">1.0</span>,</span><br><span class="line">            <span class="string">&#x27;min_sum_hessian_in_leaf&#x27;</span>: <span class="number">0.0038</span>,</span><br><span class="line">            <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">16</span>&#125;,</span><br><span class="line">            lazy=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对LGB_BO对象进行最大化调用。</span></span><br><span class="line">LGB_BO.maximize(init_points=<span class="number">0</span>, n_iter=<span class="number">0</span>) </span><br></pre></td></tr></table></figure><pre><code>|   iter    |  target   | featur... | lambda_l1 | lambda_l2 | learni... | max_depth | min_da... | min_ga... | min_su... | num_le... |-------------------------------------------------------------------------------------------------------------------------------------[LightGBM] [Warning] verbosity is set=-1, verbose=1 will be ignored. Current value: verbosity=-1Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[17]    valid_0&#39;s auc: 0.770586| [95m 11      [0m | [95m 0.7706  [0m | [95m 0.5     [0m | [95m 0.0     [0m | [95m 2.9     [0m | [95m 0.3     [0m | [95m 15.0    [0m | [95m 12.0    [0m | [95m 1.0     [0m | [95m 0.0038  [0m | [95m 16.0    [0m |=====================================================================================================================================</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过属性LGB_BO.res可以获得探测的所有参数列表及其相应的目标值。</span></span><br><span class="line"><span class="keyword">for</span> i, res <span class="keyword">in</span> <span class="built_in">enumerate</span>(LGB_BO.res):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Iteration &#123;&#125;: \n\t&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, res))</span><br></pre></td></tr></table></figure><p>将LGB_BO的最佳参数保存到param_lgb字典中，然后进行5折交叉训练</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> rankdata</span><br><span class="line">param_lgb = &#123;</span><br><span class="line">        <span class="string">&#x27;num_leaves&#x27;</span>: <span class="built_in">int</span>(LGB_BO.<span class="built_in">max</span>[<span class="string">&#x27;params&#x27;</span>][<span class="string">&#x27;num_leaves&#x27;</span>]), <span class="comment"># remember to int here</span></span><br><span class="line">        <span class="string">&#x27;max_bin&#x27;</span>: <span class="number">63</span>,</span><br><span class="line">        <span class="string">&#x27;min_data_in_leaf&#x27;</span>: <span class="built_in">int</span>(LGB_BO.<span class="built_in">max</span>[<span class="string">&#x27;params&#x27;</span>][<span class="string">&#x27;min_data_in_leaf&#x27;</span>]), <span class="comment"># remember to int here</span></span><br><span class="line">        <span class="string">&#x27;learning_rate&#x27;</span>: LGB_BO.<span class="built_in">max</span>[<span class="string">&#x27;params&#x27;</span>][<span class="string">&#x27;learning_rate&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;min_sum_hessian_in_leaf&#x27;</span>: LGB_BO.<span class="built_in">max</span>[<span class="string">&#x27;params&#x27;</span>][<span class="string">&#x27;min_sum_hessian_in_leaf&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;bagging_fraction&#x27;</span>: <span class="number">1.0</span>, </span><br><span class="line">        <span class="string">&#x27;bagging_freq&#x27;</span>: <span class="number">5</span>, </span><br><span class="line">        <span class="string">&#x27;feature_fraction&#x27;</span>: LGB_BO.<span class="built_in">max</span>[<span class="string">&#x27;params&#x27;</span>][<span class="string">&#x27;feature_fraction&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;lambda_l1&#x27;</span>: LGB_BO.<span class="built_in">max</span>[<span class="string">&#x27;params&#x27;</span>][<span class="string">&#x27;lambda_l1&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;lambda_l2&#x27;</span>: LGB_BO.<span class="built_in">max</span>[<span class="string">&#x27;params&#x27;</span>][<span class="string">&#x27;lambda_l2&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;min_gain_to_split&#x27;</span>: LGB_BO.<span class="built_in">max</span>[<span class="string">&#x27;params&#x27;</span>][<span class="string">&#x27;min_gain_to_split&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;max_depth&#x27;</span>: <span class="built_in">int</span>(LGB_BO.<span class="built_in">max</span>[<span class="string">&#x27;params&#x27;</span>][<span class="string">&#x27;max_depth&#x27;</span>]), <span class="comment"># remember to int here</span></span><br><span class="line">        <span class="string">&#x27;save_binary&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&#x27;seed&#x27;</span>: <span class="number">1337</span>,</span><br><span class="line">        <span class="string">&#x27;feature_fraction_seed&#x27;</span>: <span class="number">1337</span>,</span><br><span class="line">        <span class="string">&#x27;bagging_seed&#x27;</span>: <span class="number">1337</span>,</span><br><span class="line">        <span class="string">&#x27;drop_seed&#x27;</span>: <span class="number">1337</span>,</span><br><span class="line">        <span class="string">&#x27;data_random_seed&#x27;</span>: <span class="number">1337</span>,</span><br><span class="line">        <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;verbose&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;metric&#x27;</span>: <span class="string">&#x27;auc&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;is_unbalance&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&#x27;boost_from_average&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">nfold = <span class="number">5</span></span><br><span class="line">gc.collect()</span><br><span class="line">skf = StratifiedKFold(n_splits=nfold, shuffle=<span class="literal">True</span>, random_state=<span class="number">2019</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">oof = np.zeros(<span class="built_in">len</span>(y_train))</span><br><span class="line">predictions = np.zeros((<span class="built_in">len</span>(X_test),nfold))</span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> train_index, valid_index <span class="keyword">in</span> skf.split(X_train, y_train):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nfold &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    lgb_train = lgb.Dataset(X_train,label=y_train)</span><br><span class="line">    lgb_valid = lgb.Dataset(X_test,label=y_test,reference=lgb_train)  </span><br><span class="line">   </span><br><span class="line">    clf = lgb.train(param_lgb, lgb_train,<span class="number">500</span>, valid_sets = [lgb_valid ], verbose_eval=<span class="number">250</span>, callbacks=[lgb.early_stopping(stopping_rounds=<span class="number">5</span>)])</span><br><span class="line">    <span class="built_in">print</span>(clf.predict(X_train, num_iteration=clf.best_iteration) )</span><br><span class="line">    oof[valid_index] = clf.predict(X_train.iloc[valid_index].values, num_iteration=clf.best_iteration) </span><br><span class="line">    </span><br><span class="line">    predictions[:,i-<span class="number">1</span>] += clf.predict(X_test, num_iteration=clf.best_iteration)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n\nCV AUC: &#123;:&lt;0.2f&#125;&quot;</span>.<span class="built_in">format</span>(metrics.roc_auc_score(y_train, oof)))</span><br></pre></td></tr></table></figure><pre><code>fold 1[LightGBM] [Info] Number of positive: 1600, number of negative: 5594[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000288 seconds.You can set `force_col_wise=true` to remove the overhead.[LightGBM] [Info] Total Bins 393[LightGBM] [Info] Number of data points in the train set: 7194, number of used features: 7Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[17]    valid_0&#39;s auc: 0.770586[0.52559221 0.40000825 0.43907974 ... 0.40122056 0.46515425 0.56678622]fold 2[LightGBM] [Info] Number of positive: 1600, number of negative: 5594[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000330 seconds.You can set `force_col_wise=true` to remove the overhead.[LightGBM] [Info] Total Bins 393[LightGBM] [Info] Number of data points in the train set: 7194, number of used features: 7Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[17]    valid_0&#39;s auc: 0.770586[0.52559221 0.40000825 0.43907974 ... 0.40122056 0.46515425 0.56678622]fold 3[LightGBM] [Info] Number of positive: 1600, number of negative: 5594[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000292 seconds.You can set `force_col_wise=true` to remove the overhead.[LightGBM] [Info] Total Bins 393[LightGBM] [Info] Number of data points in the train set: 7194, number of used features: 7Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[17]    valid_0&#39;s auc: 0.770586[0.52559221 0.40000825 0.43907974 ... 0.40122056 0.46515425 0.56678622]fold 4[LightGBM] [Info] Number of positive: 1600, number of negative: 5594[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000302 seconds.You can set `force_col_wise=true` to remove the overhead.[LightGBM] [Info] Total Bins 393[LightGBM] [Info] Number of data points in the train set: 7194, number of used features: 7Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[17]    valid_0&#39;s auc: 0.770586[0.52559221 0.40000825 0.43907974 ... 0.40122056 0.46515425 0.56678622]fold 5[LightGBM] [Info] Number of positive: 1600, number of negative: 5594[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000300 seconds.You can set `force_col_wise=true` to remove the overhead.[LightGBM] [Info] Total Bins 393[LightGBM] [Info] Number of data points in the train set: 7194, number of used features: 7Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[17]    valid_0&#39;s auc: 0.770586[0.52559221 0.40000825 0.43907974 ... 0.40122056 0.46515425 0.56678622]CV AUC: 0.81</code></pre><p>另一种贝叶斯搜索，参考:<br>[《网格搜索、随机搜索和贝叶斯搜索实用教程》[(<a href="https://blog.csdn.net/fengdu78/article/details/121134090?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164200107216780274194329%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164200107216780274194329&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-121134090.pc_search_insert_es_download&amp;utm_term=%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%90%9C%E7%B4%A2&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/fengdu78/article/details/121134090?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164200107216780274194329%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164200107216780274194329&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-121134090.pc_search_insert_es_download&amp;utm_term=%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%90%9C%E7%B4%A2&amp;spm=1018.2226.3001.4187</a>)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#还没有写完，并不能正确运行</span></span><br><span class="line"><span class="keyword">from</span> skopt <span class="keyword">import</span> BayesSearchCV</span><br><span class="line"><span class="comment"># 参数范围由下面的一个指定</span></span><br><span class="line"><span class="keyword">from</span> skopt.space <span class="keyword">import</span> Real, Categorical, Integer</span><br><span class="line">search_spaces = &#123;</span><br><span class="line">  <span class="string">&#x27;C&#x27;</span>: Real(<span class="number">0.1</span>, <span class="number">1e+4</span>),</span><br><span class="line">  <span class="string">&#x27;gamma&#x27;</span>: Real(<span class="number">1e-6</span>, <span class="number">1e+1</span>, <span class="string">&#x27;log-uniform&#x27;</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来创建一个RandomizedSearchCV带参数n_iter_search的对象，并将使用训练数据来训练模型。</span></span><br><span class="line"></span><br><span class="line">n_iter_search = <span class="number">20</span> </span><br><span class="line">bayes_search = BayesSearchCV( </span><br><span class="line">    lgb.LGBMClassifier(), </span><br><span class="line">    search_spaces, </span><br><span class="line">    n_iter=n_iter_search, </span><br><span class="line">    cv=<span class="number">3</span>, </span><br><span class="line">    verbose=<span class="number">3</span> </span><br><span class="line">) </span><br><span class="line">bayes_search.fit(X_train, y_train)</span><br><span class="line">bayes_search.best_params_</span><br></pre></td></tr></table></figure><h2 id="六、模型微调与参数衰减"><a href="#六、模型微调与参数衰减" class="headerlink" title="六、模型微调与参数衰减"></a>六、模型微调与参数衰减</h2><h3 id="6-2-学习率衰减"><a href="#6-2-学习率衰减" class="headerlink" title="6.2 学习率衰减"></a>6.2 学习率衰减</h3><p>参考<a href="https://www.codenong.com/cs108978573/https://www.codenong.com/cs108978573/">《python实现LightGBM(进阶)python实现LightGBM(进阶)》</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd, numpy <span class="keyword">as</span> np, time</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">&quot;https://cdn.coggle.club/kaggle-flight-delays/flights_10k.csv.zip&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取有用的列</span></span><br><span class="line">data = data[[<span class="string">&quot;MONTH&quot;</span>,<span class="string">&quot;DAY&quot;</span>,<span class="string">&quot;DAY_OF_WEEK&quot;</span>,<span class="string">&quot;AIRLINE&quot;</span>,<span class="string">&quot;FLIGHT_NUMBER&quot;</span>,<span class="string">&quot;DESTINATION_AIRPORT&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;ORIGIN_AIRPORT&quot;</span>,<span class="string">&quot;AIR_TIME&quot;</span>, <span class="string">&quot;DEPARTURE_TIME&quot;</span>,<span class="string">&quot;DISTANCE&quot;</span>,<span class="string">&quot;ARRIVAL_DELAY&quot;</span>]]</span><br><span class="line">data.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出部分数据</span></span><br><span class="line">data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>] = (data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>]&gt;<span class="number">10</span>)*<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行编码</span></span><br><span class="line">cols = [<span class="string">&quot;AIRLINE&quot;</span>,<span class="string">&quot;FLIGHT_NUMBER&quot;</span>,<span class="string">&quot;DESTINATION_AIRPORT&quot;</span>,<span class="string">&quot;ORIGIN_AIRPORT&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cols:</span><br><span class="line">    data[item] = data[item].astype(<span class="string">&quot;category&quot;</span>).cat.codes +<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(data.drop([<span class="string">&quot;ARRIVAL_DELAY&quot;</span>], axis=<span class="number">1</span>), data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>], random_state=<span class="number">10</span>, test_size=<span class="number">0.25</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lgb_train = lgb.Dataset(X_train, y_train,free_raw_data=<span class="literal">False</span>)</span><br><span class="line">lgb_eval = lgb.Dataset(X_test, y_test, reference=lgb_train,free_raw_data=<span class="literal">False</span>)</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;metric&#x27;</span>: <span class="string">&#x27;binary_logloss&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.3</span>,</span><br><span class="line">    <span class="string">&#x27;feature_fraction&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">    <span class="string">&#x27;lambda_l1&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line">    <span class="string">&#x27;lambda_l2&#x27;</span>: <span class="number">2.9</span>,</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">15</span>,</span><br><span class="line">    <span class="string">&#x27;min_data_in_leaf&#x27;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="string">&#x27;min_gain_to_split&#x27;</span>: <span class="number">1.0</span>,</span><br><span class="line">    <span class="string">&#x27;min_sum_hessian_in_leaf&#x27;</span>: <span class="number">0.0038</span>,</span><br><span class="line">    <span class="string">&quot;verbosity&quot;</span>:-<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 学习率指数衰减,learning_rates弃用了</span></span><br><span class="line">gbm = lgb.train(params,</span><br><span class="line">                lgb_train,</span><br><span class="line">                num_boost_round=<span class="number">10</span>,</span><br><span class="line">                learning_rates=<span class="keyword">lambda</span> <span class="built_in">iter</span>: <span class="number">0.3</span> * (<span class="number">0.99</span> ** <span class="built_in">iter</span>),<span class="comment"># 学习率衰减</span></span><br><span class="line">                valid_sets=lgb_eval)</span><br><span class="line"><span class="comment">#设置learning_rates结果是accuarcy: 82.07% auc_score: 75.40%</span></span><br><span class="line"><span class="comment">#不设置learning_rates结果是accuarcy: 81.61% auc_score: 75.74%,还是不一样</span></span><br><span class="line"><span class="comment"># 学习率指数衰减</span></span><br><span class="line">gbm2 = lgb.train(params,</span><br><span class="line">                lgb_train,</span><br><span class="line">                num_boost_round=<span class="number">10</span>,</span><br><span class="line">                init_model=gbm,</span><br><span class="line">                valid_sets=lgb_eval,</span><br><span class="line">                callbacks=[lgb.reset_parameter(bagging_fraction=<span class="keyword">lambda</span> <span class="built_in">iter</span>: <span class="number">0.3</span> * (<span class="number">0.99</span> ** <span class="built_in">iter</span>))])</span><br><span class="line"><span class="comment">#不设置init_model，结果是accuarcy: 81.69% auc_score: 75.25%</span></span><br><span class="line"><span class="comment">#  设置init_model，结果是accuarcy: 81.94% auc_score: 76.32%</span></span><br><span class="line"><span class="comment">#lgb.reset_parameter参数可以是列表或者衰减函数，不知道为啥bagging_fraction设置不同值结果是一样的</span></span><br><span class="line">y_pred1,y_pred2 = gbm.predict(X_test,num_iteration=gbm.best_iteration),gbm2.predict(X_test,num_iteration=gbm2.best_iteration)</span><br><span class="line">pred1,pred2 =[<span class="number">1</span> <span class="keyword">if</span> x &gt;<span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> y_pred1],[<span class="number">1</span> <span class="keyword">if</span> x &gt;<span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> y_pred2]</span><br><span class="line">accuracy1,accuracy2 = accuracy_score(y_test,pred1),accuracy_score(y_test,pred2)</span><br><span class="line">auc_score1,auc_score2=metrics.roc_auc_score(y_test,y_pred1),metrics.roc_auc_score(y_test,y_pred2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy1*<span class="number">100.0</span>),<span class="string">&quot;auc_score: %.2f%%&quot;</span> % (auc_score1*<span class="number">100.0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy2*<span class="number">100.0</span>),<span class="string">&quot;auc_score: %.2f%%&quot;</span> % (auc_score2*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>[1]    valid_0&#39;s binary_logloss: 0.48425[2]    valid_0&#39;s binary_logloss: 0.471031[3]    valid_0&#39;s binary_logloss: 0.46278[4]    valid_0&#39;s binary_logloss: 0.456369[5]    valid_0&#39;s binary_logloss: 0.449357[6]    valid_0&#39;s binary_logloss: 0.444377[7]    valid_0&#39;s binary_logloss: 0.440908[8]    valid_0&#39;s binary_logloss: 0.438597[9]    valid_0&#39;s binary_logloss: 0.435632[10]    valid_0&#39;s binary_logloss: 0.434647accuarcy: 82.07% auc_score: 75.40%accuarcy: 82.19% auc_score: 76.08%</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 学习率阶梯衰减,bagging_fraction&#x27;如果使用列表，列表元素数量要和  &#x27;num_boost_round&#x27;值一样</span></span><br><span class="line">gbm3 = lgb.train(params,</span><br><span class="line">                lgb_train,</span><br><span class="line">                num_boost_round=<span class="number">10</span>,</span><br><span class="line">                init_model=gbm,<span class="comment">#</span></span><br><span class="line">                valid_sets=lgb_eval,</span><br><span class="line">                callbacks=[lgb.reset_parameter(bagging_fraction=[<span class="number">0.6</span>]*<span class="number">5</span>+[<span class="number">0.2</span>]*<span class="number">3</span>+[<span class="number">0.1</span>]*<span class="number">2</span>)])</span><br><span class="line"></span><br><span class="line">y_pred = gbm3.predict(X_test,num_iteration=gbm3.best_iteration)<span class="comment">#结果是0-1之间的概率值，是一维数组</span></span><br><span class="line">pred =[<span class="number">1</span> <span class="keyword">if</span> x &gt;<span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> y_pred]</span><br><span class="line">accuracy = accuracy_score(y_test,pred)</span><br><span class="line">auc_score=metrics.roc_auc_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>),<span class="string">&quot;auc_score: %.2f%%&quot;</span> % (auc_score*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>accuarcy: 81.94% auc_score: 76.30%</code></pre><h2 id="七、特征筛选方法"><a href="#七、特征筛选方法" class="headerlink" title="七、特征筛选方法"></a>七、特征筛选方法</h2><h3 id="7-1-筛选最重要的3个特征"><a href="#7-1-筛选最重要的3个特征" class="headerlink" title="7.1 筛选最重要的3个特征"></a>7.1 筛选最重要的3个特征</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过feature_importances_方法得到特征重要性，值越高越重要</span></span><br><span class="line">gbm = lgb.LGBMClassifier(max_depth=<span class="number">9</span>)</span><br><span class="line">gbm.fit(train, y_train,</span><br><span class="line">            eval_set=[(test, y_test)],</span><br><span class="line">            eval_metric=<span class="string">&#x27;binary_logloss&#x27;</span>,</span><br><span class="line">            callbacks=[lgb.early_stopping(<span class="number">5</span>)])</span><br><span class="line">df=pd.DataFrame(gbm.feature_importances_,gbm.feature_name_,columns=[<span class="string">&#x27;value&#x27;</span>])</span><br><span class="line">df.sort_values(<span class="string">&#x27;value&#x27;</span>,inplace=<span class="literal">True</span>,ascending=<span class="literal">False</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><pre><code>Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[52]    valid_0&#39;s binary_logloss: 0.429146</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>value</th>    </tr>  </thead>  <tbody>    <tr>      <th>DEPARTURE_TIME</th>      <td>276</td>    </tr>    <tr>      <th>ORIGIN_AIRPORT</th>      <td>262</td>    </tr>    <tr>      <th>DESTINATION_AIRPORT</th>      <td>250</td>    </tr>    <tr>      <th>FLIGHT_NUMBER</th>      <td>236</td>    </tr>    <tr>      <th>AIR_TIME</th>      <td>227</td>    </tr>    <tr>      <th>DISTANCE</th>      <td>184</td>    </tr>    <tr>      <th>AIRLINE</th>      <td>124</td>    </tr>    <tr>      <th>MONTH</th>      <td>0</td>    </tr>    <tr>      <th>DAY</th>      <td>0</td>    </tr>    <tr>      <th>DAY_OF_WEEK</th>      <td>0</td>    </tr>  </tbody></table></div><p>上图看出，最重要的是DEPARTURE_TIME、ORIGIN_AIRPORT、DESTINATION_AIRPORT</p><h3 id="7-2-利用PermutationImportance排列特征重要性"><a href="#7-2-利用PermutationImportance排列特征重要性" class="headerlink" title="7.2 利用PermutationImportance排列特征重要性"></a>7.2 利用PermutationImportance排列特征重要性</h3><ul><li><a href="https://eli5.readthedocs.io/en/latest/autodocs/sklearn.html#module-eli5.sklearn.permutation_importance">eli5文档</a></li><li><a href="https://blog.csdn.net/lz_peter/article/details/88654198?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164201788816780357244048%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164201788816780357244048&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-88654198.pc_search_insert_es_download&amp;utm_term=PermutationImportance&amp;spm=1018.2226.3001.4187">利用PermutationImportance挑选变量</a></li><li><a href="https://www.kaggle.com/dansbecker/permutation-importance">kaggle教程</a></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> eli5</span><br><span class="line"><span class="keyword">from</span> eli5.sklearn <span class="keyword">import</span> PermutationImportance</span><br><span class="line">perm = PermutationImportance(gbm, random_state=<span class="number">1</span>).fit(test,y_test)</span><br><span class="line">eli5.show_weights(perm, feature_names =gbm.feature_name_)</span><br></pre></td></tr></table></figure><pre><code>Training until validation scores don&#39;t improve for 5 roundsEarly stopping, best iteration is:[52]    valid_0&#39;s binary_logloss: 0.429146&lt;style&gt;table.eli5-weights tr:hover &#123;    filter: brightness(85%);&#125;</code></pre><p>&lt;/style&gt;</p><pre><code>    &lt;table class=&quot;eli5-weights eli5-feature-importances&quot; style=&quot;border-collapse: collapse; border: none; margin-top: 0em; table-layout: auto;&quot;&gt;&lt;thead&gt;&lt;tr style=&quot;border: none;&quot;&gt;    &lt;th style=&quot;padding: 0 1em 0 0.5em; text-align: right; border: none;&quot;&gt;Weight&lt;/th&gt;    &lt;th style=&quot;padding: 0 0.5em 0 0.5em; text-align: left; border: none;&quot;&gt;Feature&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;    &lt;tr style=&quot;background-color: hsl(120, 100.00%, 80.00%); border: none;&quot;&gt;        &lt;td style=&quot;padding: 0 1em 0 0.5em; text-align: right; border: none;&quot;&gt;            0.0396                &amp;plusmn; 0.0096        &lt;/td&gt;        &lt;td style=&quot;padding: 0 0.5em 0 0.5em; text-align: left; border: none;&quot;&gt;            DEPARTURE_TIME        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr style=&quot;background-color: hsl(120, 100.00%, 90.14%); border: none;&quot;&gt;        &lt;td style=&quot;padding: 0 1em 0 0.5em; text-align: right; border: none;&quot;&gt;            0.0144                &amp;plusmn; 0.0057        &lt;/td&gt;        &lt;td style=&quot;padding: 0 0.5em 0 0.5em; text-align: left; border: none;&quot;&gt;            DESTINATION_AIRPORT        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr style=&quot;background-color: hsl(120, 100.00%, 90.50%); border: none;&quot;&gt;        &lt;td style=&quot;padding: 0 1em 0 0.5em; text-align: right; border: none;&quot;&gt;            0.0137                &amp;plusmn; 0.0043        &lt;/td&gt;        &lt;td style=&quot;padding: 0 0.5em 0 0.5em; text-align: left; border: none;&quot;&gt;            ORIGIN_AIRPORT        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr style=&quot;background-color: hsl(120, 100.00%, 92.95%); border: none;&quot;&gt;        &lt;td style=&quot;padding: 0 1em 0 0.5em; text-align: right; border: none;&quot;&gt;            0.0089                &amp;plusmn; 0.0067        &lt;/td&gt;        &lt;td style=&quot;padding: 0 0.5em 0 0.5em; text-align: left; border: none;&quot;&gt;            AIR_TIME        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr style=&quot;background-color: hsl(120, 100.00%, 95.47%); border: none;&quot;&gt;        &lt;td style=&quot;padding: 0 1em 0 0.5em; text-align: right; border: none;&quot;&gt;            0.0048                &amp;plusmn; 0.0041        &lt;/td&gt;        &lt;td style=&quot;padding: 0 0.5em 0 0.5em; text-align: left; border: none;&quot;&gt;            AIRLINE        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr style=&quot;background-color: hsl(120, 100.00%, 95.86%); border: none;&quot;&gt;        &lt;td style=&quot;padding: 0 1em 0 0.5em; text-align: right; border: none;&quot;&gt;            0.0042                &amp;plusmn; 0.0045        &lt;/td&gt;        &lt;td style=&quot;padding: 0 0.5em 0 0.5em; text-align: left; border: none;&quot;&gt;            DISTANCE        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr style=&quot;background-color: hsl(120, 100.00%, 96.10%); border: none;&quot;&gt;        &lt;td style=&quot;padding: 0 1em 0 0.5em; text-align: right; border: none;&quot;&gt;            0.0038                &amp;plusmn; 0.0029        &lt;/td&gt;        &lt;td style=&quot;padding: 0 0.5em 0 0.5em; text-align: left; border: none;&quot;&gt;            FLIGHT_NUMBER        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr style=&quot;background-color: hsl(0, 100.00%, 100.00%); border: none;&quot;&gt;        &lt;td style=&quot;padding: 0 1em 0 0.5em; text-align: right; border: none;&quot;&gt;            0                &amp;plusmn; 0.0000        &lt;/td&gt;        &lt;td style=&quot;padding: 0 0.5em 0 0.5em; text-align: left; border: none;&quot;&gt;            DAY_OF_WEEK        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr style=&quot;background-color: hsl(0, 100.00%, 100.00%); border: none;&quot;&gt;        &lt;td style=&quot;padding: 0 1em 0 0.5em; text-align: right; border: none;&quot;&gt;            0                &amp;plusmn; 0.0000        &lt;/td&gt;        &lt;td style=&quot;padding: 0 0.5em 0 0.5em; text-align: left; border: none;&quot;&gt;            DAY        &lt;/td&gt;    &lt;/tr&gt;    &lt;tr style=&quot;background-color: hsl(0, 100.00%, 100.00%); border: none;&quot;&gt;        &lt;td style=&quot;padding: 0 1em 0 0.5em; text-align: right; border: none;&quot;&gt;            0                &amp;plusmn; 0.0000        &lt;/td&gt;        &lt;td style=&quot;padding: 0 0.5em 0 0.5em; text-align: left; border: none;&quot;&gt;            MONTH        &lt;/td&gt;    &lt;/tr&gt;&lt;/tbody&gt;</code></pre><p>&lt;/table&gt;</p><p>所以前三重要的特征是DEPARTURE_TIME、DESTINATION_AIRPORT、ORIGIN_AIRPORT</p><h3 id="7-3-Null-Importances进行特征选择"><a href="#7-3-Null-Importances进行特征选择" class="headerlink" title="7.3 Null Importances进行特征选择"></a>7.3 Null Importances进行特征选择</h3><blockquote><p>参考<a href="https://www.kaggle.com/ogrellier/feature-selection-with-null-importances">kaggkle教程</a><br><a href="https://blog.csdn.net/weixin_39681171/article/details/109919282?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164216516716780357210720%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164216516716780357210720&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-109919282.pc_search_insert_es_download&amp;utm_term=null%20importance%E9%87%8D%E8%A6%81%E6%80%A7&amp;spm=1018.2226.3001.4187">《数据竞赛】99%情况下都有效的特征筛选策略—Null Importance》</a></p></blockquote><p>特征筛选策略 — Null Importance 特征筛选</p><h4 id="7-3-1-主要思想："><a href="#7-3-1-主要思想：" class="headerlink" title="7.3.1 主要思想："></a>7.3.1 主要思想：</h4><p>通过利用跑树模型得到特征的importance来判断特征的稳定性和好坏。</p><ol><li><p>将构建好的特征和正确的标签扔进树模型中，此时可以得到每个特征的重要性（split 和 gain）</p></li><li><p>将数据的标签打乱，再扔进模型中，得到打乱标签后，每个特征的重要性（split和gain）；重复n次；取n次特征重要性的平均值。</p></li><li><p>将1中正确标签跑的特征的重要性和2中打乱标签的特征中重要性进行比较；具体比较方式可以参考上面的kernel</p></li></ol><ul><li>当一个特征非常work，那它在正确标签的树模型中的importance应该很高，但它在打乱标签的树模型中的importance将很低（无法识别随机标签）；反之，一个垃圾特征，那它在正确标签的模型中importance很一般，打乱标签的树模型中importance将大于等于正确标签模型的importance。所以通过同时判断每个特征在正确标签的模型和打乱标签的模型中的importance（split和gain），可以选择特征稳定和work的特征。</li><li>思想大概就是这样吧，importance受到特征相关性的影响，特征的重要性会被相关特征的重要性稀释，看importance也不一定准，用这个来对暴力特征进行筛选还是可以的。</li></ul><h4 id="7-3-2实现步骤"><a href="#7-3-2实现步骤" class="headerlink" title="7.3.2实现步骤"></a>7.3.2实现步骤</h4><p>Null Importance算法的实现步骤为：</p><ol><li>在原始数据集上运行模型并且记录每个特征重要性。以此作为基准；</li><li>构建Null importances分布：对我们的标签进行随机Shuffle，并且计算shuffle之后的特征的重要性；</li><li>对2进行多循环操作，得到多个不同shuffle之后的特征重要性；</li><li>设计score函数，得到未shuffle的特征重要性与shuffle之后特征重要性的偏离度，并以此设计特征筛选策略；</li><li>计算不同筛选情况下的模型的分数，并进行记录；</li><li>将分数最好的几个分数对应的特征进行返回。实现步骤</li></ol><h4 id="7-3-3-读取数据集，计算Real-Targe和shuffle-Target下的特征重要度"><a href="#7-3-3-读取数据集，计算Real-Targe和shuffle-Target下的特征重要度" class="headerlink" title="7.3.3 读取数据集，计算Real Targe和shuffle Target下的特征重要度"></a>7.3.3 读取数据集，计算Real Targe和shuffle Target下的特征重要度</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> lightgbm <span class="keyword">import</span> LGBMClassifier</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.simplefilter(<span class="string">&#x27;ignore&#x27;</span>, UserWarning)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">gc.enable()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd, numpy <span class="keyword">as</span> np, time</span><br><span class="line">data= pd.read_csv(<span class="string">&quot;https://cdn.coggle.club/kaggle-flight-delays/flights_10k.csv.zip&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取有用的列</span></span><br><span class="line">data= data[[<span class="string">&quot;AIRLINE&quot;</span>,<span class="string">&quot;FLIGHT_NUMBER&quot;</span>,<span class="string">&quot;DESTINATION_AIRPORT&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;ORIGIN_AIRPORT&quot;</span>,<span class="string">&quot;AIR_TIME&quot;</span>, <span class="string">&quot;DEPARTURE_TIME&quot;</span>,<span class="string">&quot;DISTANCE&quot;</span>,<span class="string">&quot;ARRIVAL_DELAY&quot;</span>]]</span><br><span class="line">data.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># 筛选出部分数据</span></span><br><span class="line">data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>] = (data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>]&gt;<span class="number">10</span>)*<span class="number">1</span></span><br><span class="line"><span class="comment">#categorical_feats  = [&quot;AIRLINE&quot;,&quot;FLIGHT_NUMBER&quot;,&quot;DESTINATION_AIRPORT&quot;,&quot;ORIGIN_AIRPORT&quot;]</span></span><br><span class="line">categorical_feats = [f <span class="keyword">for</span> f <span class="keyword">in</span> data.columns <span class="keyword">if</span> data[f].dtype == <span class="string">&#x27;object&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#将上面四列特征转为类别特征，但不是one-hot编码</span></span><br><span class="line"><span class="keyword">for</span> f_ <span class="keyword">in</span> categorical_feats:</span><br><span class="line">    data[f_], _ = pd.factorize(data[f_])</span><br><span class="line">    <span class="comment"># Set feature type as categorical</span></span><br><span class="line">    data[f_] = data[f_].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(data.drop([<span class="string">&quot;ARRIVAL_DELAY&quot;</span>], axis=<span class="number">1</span>), data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>], random_state=<span class="number">10</span>, test_size=<span class="number">0.25</span>)</span><br></pre></td></tr></table></figure><p>创建评分函数<br>feature<em>importances</em> :特征重要性的类型。default=’split’。</p><ul><li>如果是split，则结果包含该特征在模型中使用的次数。 </li><li>如果为“gain”，则结果包含使用该特征的分割的总增益。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_feature_importances</span>(<span class="params">X_train, X_test, y_train, y_test,shuffle, seed=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># 获取特征</span></span><br><span class="line">    train_features = <span class="built_in">list</span>(X_train.columns)   </span><br><span class="line">    <span class="comment"># 判断是否shuffle TARGET</span></span><br><span class="line">    y_train,y_test= y_train.copy(),y_test.copy()</span><br><span class="line">    <span class="keyword">if</span> shuffle:</span><br><span class="line">        <span class="comment"># Here you could as well use a binomial distribution</span></span><br><span class="line">        y_train,y_test= y_train.copy().sample(frac=<span class="number">1.0</span>),y_test.copy().sample(frac=<span class="number">1.0</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    lgb_train = lgb.Dataset(X_train, y_train,free_raw_data=<span class="literal">False</span>,silent=<span class="literal">True</span>)</span><br><span class="line">    lgb_eval = lgb.Dataset(X_test, y_test, reference=lgb_train,free_raw_data=<span class="literal">False</span>,silent=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 在 RF 模式下安装 LightGBM，它比 sklearn RandomForest 更快   </span></span><br><span class="line">    lgb_params = &#123;</span><br><span class="line">    <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;metric&#x27;</span>: <span class="string">&#x27;binary_logloss&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.3</span>,</span><br><span class="line">    <span class="string">&#x27;feature_fraction&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">    <span class="string">&#x27;lambda_l1&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line">    <span class="string">&#x27;lambda_l2&#x27;</span>: <span class="number">2.9</span>,</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">15</span>,</span><br><span class="line">    <span class="string">&#x27;min_data_in_leaf&#x27;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="string">&#x27;min_gain_to_split&#x27;</span>: <span class="number">1.0</span>,</span><br><span class="line">    <span class="string">&#x27;min_sum_hessian_in_leaf&#x27;</span>: <span class="number">0.0038</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    clf = lgb.train(params=lgb_params,train_set=lgb_train,valid_sets=lgb_eval,num_boost_round=<span class="number">10</span>, categorical_feature=categorical_feats)<span class="comment">#将object特征设置为分类特征，但是并不需要进行one-hot编码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#得到特征重要性</span></span><br><span class="line">    imp_df = pd.DataFrame()</span><br><span class="line">    imp_df[<span class="string">&quot;feature&quot;</span>] = <span class="built_in">list</span>(train_features)</span><br><span class="line">    imp_df[<span class="string">&quot;importance_gain&quot;</span>] = clf.feature_importance(importance_type=<span class="string">&#x27;gain&#x27;</span>)</span><br><span class="line">    imp_df[<span class="string">&quot;importance_split&quot;</span>] = clf.feature_importance(importance_type=<span class="string">&#x27;split&#x27;</span>)</span><br><span class="line">    imp_df[<span class="string">&#x27;trn_score&#x27;</span>] = roc_auc_score(y_test, clf.predict( X_test))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> imp_df</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">123</span>)</span><br><span class="line"><span class="comment"># 获得市实际的特征重要性，即没有shuffletarget</span></span><br><span class="line">actual_imp_df = get_feature_importances(X_train, X_test, y_train, y_test, shuffle=<span class="literal">False</span>)</span><br><span class="line">actual_imp_df</span><br></pre></td></tr></table></figure><pre><code>[LightGBM] [Info] Number of positive: 1600, number of negative: 5594[LightGBM] [Warning] Auto-choosing col-wise multi-threading, the overhead of testing was 0.000416 seconds.You can set `force_col_wise=true` to remove the overhead.[LightGBM] [Info] Total Bins 1406[LightGBM] [Info] Number of data points in the train set: 7194, number of used features: 7[1]    valid_0&#39;s binary_logloss: 0.479157[2]    valid_0&#39;s binary_logloss: 0.46882[3]    valid_0&#39;s binary_logloss: 0.454724[4]    valid_0&#39;s binary_logloss: 0.445913[5]    valid_0&#39;s binary_logloss: 0.440924[6]    valid_0&#39;s binary_logloss: 0.438309[7]    valid_0&#39;s binary_logloss: 0.433886[8]    valid_0&#39;s binary_logloss: 0.432747[9]    valid_0&#39;s binary_logloss: 0.431001[10]    valid_0&#39;s binary_logloss: 0.429621</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>feature</th>      <th>importance_gain</th>      <th>importance_split</th>      <th>trn_score</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>AIRLINE</td>      <td>153.229680</td>      <td>15</td>      <td>0.764829</td>    </tr>    <tr>      <th>1</th>      <td>FLIGHT_NUMBER</td>      <td>189.481180</td>      <td>23</td>      <td>0.764829</td>    </tr>    <tr>      <th>2</th>      <td>DESTINATION_AIRPORT</td>      <td>1036.401096</td>      <td>23</td>      <td>0.764829</td>    </tr>    <tr>      <th>3</th>      <td>ORIGIN_AIRPORT</td>      <td>650.938854</td>      <td>22</td>      <td>0.764829</td>    </tr>    <tr>      <th>4</th>      <td>AIR_TIME</td>      <td>119.763649</td>      <td>17</td>      <td>0.764829</td>    </tr>    <tr>      <th>5</th>      <td>DEPARTURE_TIME</td>      <td>994.109417</td>      <td>37</td>      <td>0.764829</td>    </tr>    <tr>      <th>6</th>      <td>DISTANCE</td>      <td>93.170790</td>      <td>13</td>      <td>0.764829</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">null_imp_df = pd.DataFrame()</span><br><span class="line">nb_runs = <span class="number">10</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start = time.time()</span><br><span class="line">dsp = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nb_runs):</span><br><span class="line">    <span class="comment"># 获取当前的特征重要性</span></span><br><span class="line">    imp_df = get_feature_importances(X_train, X_test, y_train, y_test, shuffle=<span class="literal">True</span>)</span><br><span class="line">    imp_df[<span class="string">&#x27;run&#x27;</span>] = i + <span class="number">1</span> </span><br><span class="line">    <span class="comment"># 将特征重要性连起来</span></span><br><span class="line">    null_imp_df = pd.concat([null_imp_df, imp_df], axis=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 删除上一条信息</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dsp)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\b&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># Display current run and time used</span></span><br><span class="line">    spent = (time.time() - start) / <span class="number">60</span></span><br><span class="line">    dsp = <span class="string">&#x27;Done with %4d of %4d (Spent %5.1f min)&#x27;</span> % (i + <span class="number">1</span>, nb_runs, spent)</span><br><span class="line">    <span class="built_in">print</span>(dsp, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">null_imp_df</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>feature</th>      <th>importance_gain</th>      <th>importance_split</th>      <th>trn_score</th>      <th>run</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>AIRLINE</td>      <td>26.436000</td>      <td>8</td>      <td>0.525050</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>FLIGHT_NUMBER</td>      <td>142.159161</td>      <td>35</td>      <td>0.525050</td>      <td>1</td>    </tr>    <tr>      <th>2</th>      <td>DESTINATION_AIRPORT</td>      <td>231.459383</td>      <td>20</td>      <td>0.525050</td>      <td>1</td>    </tr>    <tr>      <th>3</th>      <td>ORIGIN_AIRPORT</td>      <td>319.862975</td>      <td>26</td>      <td>0.525050</td>      <td>1</td>    </tr>    <tr>      <th>4</th>      <td>AIR_TIME</td>      <td>97.764902</td>      <td>24</td>      <td>0.525050</td>      <td>1</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>2</th>      <td>DESTINATION_AIRPORT</td>      <td>254.016771</td>      <td>20</td>      <td>0.509197</td>      <td>10</td>    </tr>    <tr>      <th>3</th>      <td>ORIGIN_AIRPORT</td>      <td>271.220462</td>      <td>20</td>      <td>0.509197</td>      <td>10</td>    </tr>    <tr>      <th>4</th>      <td>AIR_TIME</td>      <td>82.260759</td>      <td>17</td>      <td>0.509197</td>      <td>10</td>    </tr>    <tr>      <th>5</th>      <td>DEPARTURE_TIME</td>      <td>137.511192</td>      <td>25</td>      <td>0.509197</td>      <td>10</td>    </tr>    <tr>      <th>6</th>      <td>DISTANCE</td>      <td>73.353821</td>      <td>19</td>      <td>0.509197</td>      <td>10</td>    </tr>  </tbody></table><p>70 rows × 5 columns</p></div><p>可视化演示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_distributions</span>(<span class="params">actual_imp_df_, null_imp_df_, feature_</span>):</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">13</span>, <span class="number">6</span>))</span><br><span class="line">    gs = gridspec.GridSpec(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 画出 Split importances</span></span><br><span class="line">    ax = plt.subplot(gs[<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    a = ax.hist(null_imp_df_.loc[null_imp_df_[<span class="string">&#x27;feature&#x27;</span>] == feature_, <span class="string">&#x27;importance_split&#x27;</span>].values, label=<span class="string">&#x27;Null importances&#x27;</span>)</span><br><span class="line">    ax.vlines(x=actual_imp_df_.loc[actual_imp_df_[<span class="string">&#x27;feature&#x27;</span>] == feature_, <span class="string">&#x27;importance_split&#x27;</span>].mean(), </span><br><span class="line">               ymin=<span class="number">0</span>, ymax=np.<span class="built_in">max</span>(a[<span class="number">0</span>]), color=<span class="string">&#x27;r&#x27;</span>,linewidth=<span class="number">10</span>, label=<span class="string">&#x27;Real Target&#x27;</span>)</span><br><span class="line">    ax.legend()</span><br><span class="line">    ax.set_title(<span class="string">&#x27;Split Importance of %s&#x27;</span> % feature_.upper(), fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Null Importance (split) Distribution for %s &#x27;</span> % feature_.upper())</span><br><span class="line">    <span class="comment"># 画出 Gain importances</span></span><br><span class="line">    ax = plt.subplot(gs[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    a = ax.hist(null_imp_df_.loc[null_imp_df_[<span class="string">&#x27;feature&#x27;</span>] == feature_, <span class="string">&#x27;importance_gain&#x27;</span>].values, label=<span class="string">&#x27;Null importances&#x27;</span>)</span><br><span class="line">    ax.vlines(x=actual_imp_df_.loc[actual_imp_df_[<span class="string">&#x27;feature&#x27;</span>] == feature_, <span class="string">&#x27;importance_gain&#x27;</span>].mean(), </span><br><span class="line">               ymin=<span class="number">0</span>, ymax=np.<span class="built_in">max</span>(a[<span class="number">0</span>]), color=<span class="string">&#x27;r&#x27;</span>,linewidth=<span class="number">10</span>, label=<span class="string">&#x27;Real Target&#x27;</span>)</span><br><span class="line">    ax.legend()</span><br><span class="line">    ax.set_title(<span class="string">&#x27;Gain Importance of %s&#x27;</span> % feature_.upper(), fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Null Importance (gain) Distribution for %s &#x27;</span> % feature_.upper())</span><br><span class="line"></span><br><span class="line"><span class="comment">#画出“DESTINATION_AIRPORT”的特征重要性</span></span><br><span class="line">display_distributions(actual_imp_df_=actual_imp_df, null_imp_df_=null_imp_df, feature_=<span class="string">&#x27;DESTINATION_AIRPORT&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="lightGBM_files/lightGBM_91_0.png" alt="png"></p><h4 id="7-3-4计算Score"><a href="#7-3-4计算Score" class="headerlink" title="7.3.4计算Score"></a>7.3.4计算Score</h4><ol><li>以未进行特征shuffle的特征重要性除以shuffle之后的0.75分位数作为我们的score<br>因为’MONTH’,’DAY’,’DAY_OF_WEEK’三个特征没有什么用，画的的图结果不好看，所以把这三个去掉了。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">feature_scores = []</span><br><span class="line"><span class="keyword">for</span> _f <span class="keyword">in</span> actual_imp_df[<span class="string">&#x27;feature&#x27;</span>].unique():</span><br><span class="line">    f_null_imps_gain = null_imp_df.loc[null_imp_df[<span class="string">&#x27;feature&#x27;</span>] == _f, <span class="string">&#x27;importance_gain&#x27;</span>].values</span><br><span class="line">    f_act_imps_gain = actual_imp_df.loc[actual_imp_df[<span class="string">&#x27;feature&#x27;</span>] == _f, <span class="string">&#x27;importance_gain&#x27;</span>].mean()</span><br><span class="line">    gain_score = np.log(<span class="number">1e-10</span> + f_act_imps_gain / (<span class="number">1</span> + np.percentile(f_null_imps_gain, <span class="number">75</span>)))  <span class="comment"># Avoid didvide by zero</span></span><br><span class="line">    f_null_imps_split = null_imp_df.loc[null_imp_df[<span class="string">&#x27;feature&#x27;</span>] == _f, <span class="string">&#x27;importance_split&#x27;</span>].values</span><br><span class="line">    f_act_imps_split = actual_imp_df.loc[actual_imp_df[<span class="string">&#x27;feature&#x27;</span>] == _f, <span class="string">&#x27;importance_split&#x27;</span>].mean()</span><br><span class="line">    split_score = np.log(<span class="number">1e-10</span> + f_act_imps_split / (<span class="number">1</span> + np.percentile(f_null_imps_split, <span class="number">75</span>)))  <span class="comment"># Avoid didvide by zero</span></span><br><span class="line">    feature_scores.append((_f, split_score, gain_score))</span><br><span class="line"></span><br><span class="line">scores_df = pd.DataFrame(feature_scores, columns=[<span class="string">&#x27;feature&#x27;</span>, <span class="string">&#x27;split_score&#x27;</span>, <span class="string">&#x27;gain_score&#x27;</span>])</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">16</span>, <span class="number">16</span>))</span><br><span class="line">gs = gridspec.GridSpec(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># Plot Split importances</span></span><br><span class="line">ax = plt.subplot(gs[<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">sns.barplot(x=<span class="string">&#x27;split_score&#x27;</span>, y=<span class="string">&#x27;feature&#x27;</span>, data=scores_df.sort_values(<span class="string">&#x27;split_score&#x27;</span>, ascending=<span class="literal">False</span>).iloc[<span class="number">0</span>:<span class="number">70</span>], ax=ax)</span><br><span class="line">ax.set_title(<span class="string">&#x27;Feature scores wrt split importances&#x27;</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># Plot Gain importances</span></span><br><span class="line">ax = plt.subplot(gs[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">sns.barplot(x=<span class="string">&#x27;gain_score&#x27;</span>, y=<span class="string">&#x27;feature&#x27;</span>, data=scores_df.sort_values(<span class="string">&#x27;gain_score&#x27;</span>, ascending=<span class="literal">False</span>).iloc[<span class="number">0</span>:<span class="number">70</span>], ax=ax)</span><br><span class="line">ax.set_title(<span class="string">&#x27;Feature scores wrt gain importances&#x27;</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line"></span><br><span class="line">null_imp_df.to_csv(<span class="string">&#x27;null_importances_distribution_rf.csv&#x27;</span>)</span><br><span class="line">actual_imp_df.to_csv(<span class="string">&#x27;actual_importances_ditribution_rf.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="lightGBM_files/lightGBM_93_0.png" alt="png"></p><ol><li>shuffle target之后特征重要性低于实际target对应特征的重要性0.25分位数的次数百分比。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">correlation_scores = []</span><br><span class="line"><span class="keyword">for</span> _f <span class="keyword">in</span> actual_imp_df[<span class="string">&#x27;feature&#x27;</span>].unique():</span><br><span class="line">    f_null_imps = null_imp_df.loc[null_imp_df[<span class="string">&#x27;feature&#x27;</span>] == _f, <span class="string">&#x27;importance_gain&#x27;</span>].values</span><br><span class="line">    f_act_imps = actual_imp_df.loc[actual_imp_df[<span class="string">&#x27;feature&#x27;</span>] == _f, <span class="string">&#x27;importance_gain&#x27;</span>].values</span><br><span class="line">    gain_score = <span class="number">100</span> * (f_null_imps &lt; np.percentile(f_act_imps, <span class="number">25</span>)).<span class="built_in">sum</span>() / f_null_imps.size</span><br><span class="line">    f_null_imps = null_imp_df.loc[null_imp_df[<span class="string">&#x27;feature&#x27;</span>] == _f, <span class="string">&#x27;importance_split&#x27;</span>].values</span><br><span class="line">    f_act_imps = actual_imp_df.loc[actual_imp_df[<span class="string">&#x27;feature&#x27;</span>] == _f, <span class="string">&#x27;importance_split&#x27;</span>].values</span><br><span class="line">    split_score = <span class="number">100</span> * (f_null_imps &lt; np.percentile(f_act_imps, <span class="number">25</span>)).<span class="built_in">sum</span>() / f_null_imps.size</span><br><span class="line">    correlation_scores.append((_f, split_score, gain_score))</span><br><span class="line"></span><br><span class="line">corr_scores_df = pd.DataFrame(correlation_scores, columns=[<span class="string">&#x27;feature&#x27;</span>, <span class="string">&#x27;split_score&#x27;</span>, <span class="string">&#x27;gain_score&#x27;</span>])</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">16</span>, <span class="number">16</span>))</span><br><span class="line">gs = gridspec.GridSpec(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># Plot Split importances</span></span><br><span class="line">ax = plt.subplot(gs[<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">sns.barplot(x=<span class="string">&#x27;split_score&#x27;</span>, y=<span class="string">&#x27;feature&#x27;</span>, data=corr_scores_df.sort_values(<span class="string">&#x27;split_score&#x27;</span>, ascending=<span class="literal">False</span>).iloc[<span class="number">0</span>:<span class="number">70</span>], ax=ax)</span><br><span class="line">ax.set_title(<span class="string">&#x27;Feature scores wrt split importances&#x27;</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># Plot Gain importances</span></span><br><span class="line">ax = plt.subplot(gs[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">sns.barplot(x=<span class="string">&#x27;gain_score&#x27;</span>, y=<span class="string">&#x27;feature&#x27;</span>, data=corr_scores_df.sort_values(<span class="string">&#x27;gain_score&#x27;</span>, ascending=<span class="literal">False</span>).iloc[<span class="number">0</span>:<span class="number">70</span>], ax=ax)</span><br><span class="line">ax.set_title(<span class="string">&#x27;Feature scores wrt gain importances&#x27;</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.suptitle(<span class="string">&quot;Features&#x27; split and gain scores&quot;</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">fig.subplots_adjust(top=<span class="number">0.93</span>)</span><br></pre></td></tr></table></figure><p><img src="lightGBM_files/lightGBM_95_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">correlation_scores</span><br></pre></td></tr></table></figure><pre><code>[(&#39;AIRLINE&#39;, 100.0, 100.0), (&#39;FLIGHT_NUMBER&#39;, 0.0, 60.0), (&#39;DESTINATION_AIRPORT&#39;, 100.0, 100.0), (&#39;ORIGIN_AIRPORT&#39;, 50.0, 100.0), (&#39;AIR_TIME&#39;, 10.0, 90.0), (&#39;DEPARTURE_TIME&#39;, 100.0, 100.0), (&#39;DISTANCE&#39;, 30.0, 100.0)]</code></pre><ol><li>计算特征筛选之后的最佳分数并记录相应特征<br>通过运行下面的代码，train_features选择不同的特征来拟合模型，最终Results for threshold  20/30效果最好。此时的模型特征为<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">split_feats = [_f <span class="keyword">for</span> _f, _score, _ <span class="keyword">in</span> correlation_scores <span class="keyword">if</span> _score &gt;=<span class="number">20</span>]</span><br><span class="line">split_feats</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;AIRLINE&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;DESTINATION_AIRPORT&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ORIGIN_AIRPORT&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;DEPARTURE_TIME&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;DISTANCE&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#此时的特征为</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score_feature_selection</span>(<span class="params">data,train_features=<span class="literal">None</span>, cat_feats=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># Fit LightGBM </span></span><br><span class="line">    lgb_train = lgb.Dataset(data[train_features], data[<span class="string">&quot;ARRIVAL_DELAY&quot;</span>],free_raw_data=<span class="literal">False</span>,silent=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 在 RF 模式下安装 LightGBM，它比 sklearn RandomForest 更快   </span></span><br><span class="line">    lgb_params = &#123;</span><br><span class="line">    <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;metric&#x27;</span>: <span class="string">&#x27;binary_logloss&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.3</span>,</span><br><span class="line">    <span class="string">&#x27;feature_fraction&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">    <span class="string">&#x27;lambda_l1&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line">    <span class="string">&#x27;lambda_l2&#x27;</span>: <span class="number">2.9</span>,</span><br><span class="line">    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">15</span>,</span><br><span class="line">    <span class="string">&#x27;min_data_in_leaf&#x27;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="string">&#x27;min_gain_to_split&#x27;</span>: <span class="number">1.0</span>,</span><br><span class="line">    <span class="string">&#x27;metric&#x27;</span>: <span class="string">&#x27;auc&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;min_sum_hessian_in_leaf&#x27;</span>: <span class="number">0.0038</span>,</span><br><span class="line">    <span class="string">&quot;verbosity&quot;</span>:-<span class="number">1</span>&#125;</span><br><span class="line">    <span class="comment">#&quot;force_col_wise&quot;:true&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    hist = lgb.cv(params=lgb_params,train_set=lgb_train,</span><br><span class="line">    num_boost_round=<span class="number">10</span>, categorical_feature=cat_feats,</span><br><span class="line">    nfold=<span class="number">5</span>,stratified=<span class="literal">True</span>,shuffle=<span class="literal">True</span>,early_stopping_rounds=<span class="number">5</span>,seed=<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the last mean / std values </span></span><br><span class="line">    <span class="keyword">return</span> hist[<span class="string">&#x27;auc-mean&#x27;</span>][-<span class="number">1</span>], hist[<span class="string">&#x27;auc-stdv&#x27;</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># features = [f for f in data.columns if f not in [&#x27;SK_ID_CURR&#x27;, &#x27;TARGET&#x27;]]</span></span><br><span class="line"><span class="comment"># score_feature_selection(df=data[features], train_features=features, target=data[&#x27;TARGET&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> threshold <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> , <span class="number">40</span>, <span class="number">50</span> ,<span class="number">60</span> , <span class="number">70</span>, <span class="number">80</span> , <span class="number">90</span>, <span class="number">99</span>]:</span><br><span class="line">    split_feats = [_f <span class="keyword">for</span> _f, _score, _ <span class="keyword">in</span> correlation_scores <span class="keyword">if</span> _score &gt;= threshold]</span><br><span class="line">    split_cat_feats = [_f <span class="keyword">for</span> _f, _score, _ <span class="keyword">in</span> correlation_scores <span class="keyword">if</span> (_score &gt;= threshold) &amp; (_f <span class="keyword">in</span> categorical_feats)]</span><br><span class="line">    gain_feats = [_f <span class="keyword">for</span> _f, _, _score <span class="keyword">in</span> correlation_scores <span class="keyword">if</span> _score &gt;= threshold]</span><br><span class="line">    gain_cat_feats = [_f <span class="keyword">for</span> _f, _, _score <span class="keyword">in</span> correlation_scores <span class="keyword">if</span> (_score &gt;= threshold) &amp; (_f <span class="keyword">in</span> categorical_feats)]</span><br><span class="line">                                                                                             </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Results for threshold %3d&#x27;</span> % threshold)</span><br><span class="line">    split_results = score_feature_selection(data,train_features=split_feats, cat_feats=split_cat_feats)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\t SPLIT : %.6f +/- %.6f&#x27;</span> % (split_results[<span class="number">0</span>], split_results[<span class="number">1</span>]))</span><br><span class="line">    gain_results = score_feature_selection(data,train_features=gain_feats, cat_feats=gain_cat_feats)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\t GAIN  : %.6f +/- %.6f&#x27;</span> % (gain_results[<span class="number">0</span>], gain_results[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><pre><code>Results for threshold   0     SPLIT : 0.757882 +/- 0.012114     GAIN  : 0.757882 +/- 0.012114Results for threshold  10     SPLIT : 0.756999 +/- 0.011506     GAIN  : 0.757882 +/- 0.012114Results for threshold  20     SPLIT : 0.757959 +/- 0.012558     GAIN  : 0.757882 +/- 0.012114Results for threshold  30     SPLIT : 0.757959 +/- 0.012558     GAIN  : 0.757882 +/- 0.012114Results for threshold  40     SPLIT : 0.745729 +/- 0.013217     GAIN  : 0.757882 +/- 0.012114Results for threshold  50     SPLIT : 0.745729 +/- 0.013217     GAIN  : 0.757882 +/- 0.012114Results for threshold  60     SPLIT : 0.727063 +/- 0.006758     GAIN  : 0.757882 +/- 0.012114Results for threshold  70     SPLIT : 0.727063 +/- 0.006758     GAIN  : 0.756999 +/- 0.011506Results for threshold  80     SPLIT : 0.727063 +/- 0.006758     GAIN  : 0.756999 +/- 0.011506Results for threshold  90     SPLIT : 0.727063 +/- 0.006758     GAIN  : 0.756999 +/- 0.011506Results for threshold  99     SPLIT : 0.727063 +/- 0.006758     GAIN  : 0.757959 +/- 0.012558</code></pre><h2 id="八、自定义损失函数和评测函数"><a href="#八、自定义损失函数和评测函数" class="headerlink" title="八、自定义损失函数和评测函数"></a>八、自定义损失函数和评测函数</h2><blockquote><p>参考<a href="https://blog.csdn.net/zwqjoy/article/details/121289448?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164217860316780255221706%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164217860316780255221706&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-121289448.pc_search_insert_es_download&amp;utm_term=lgb%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187">XGB/LGB—-自定义损失函数与评价函数</a><br><a href="https://github.com/microsoft/LightGBM/blob/master/examples/python-guide/advanced_example.py">参考示例</a></p><ul><li>自定义损失函数，预测概率小于0.1的正样本（标签为正样本，但模型预测概率小于0.1），梯度增加一倍。</li><li>自定义评价函数，阈值大于0.8视为正样本（标签为正样本，但模型预测概率大于0.8）。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正常模型效果</span></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#特征去掉&#x27;MONTH&#x27;,&#x27;DAY&#x27;,&#x27;DAY_OF_WEEK&#x27;三个没用的之后，正常模型阈值0.5时accuarcy: 83.03% auc_score: 83.67%</span></span><br><span class="line"><span class="comment">#acc阈值 0.8时accuarcy: 80.40% auc_score: 83.67%</span></span><br><span class="line">lgb_train = lgb.Dataset(X_train, y_train,free_raw_data=<span class="literal">False</span>,silent=<span class="literal">True</span>)</span><br><span class="line">lgb_eval = lgb.Dataset(X_test, y_test, reference=lgb_train,free_raw_data=<span class="literal">False</span>,silent=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 在 RF 模式下安装 LightGBM，它比 sklearn RandomForest 更快   </span></span><br><span class="line">lgb_params = &#123;</span><br><span class="line"><span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;metric&#x27;</span>: <span class="string">&#x27;binary_logloss&#x27;</span>,<span class="comment">#别名binary_error</span></span><br><span class="line"><span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">16</span>,</span><br><span class="line"><span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.3</span>,</span><br><span class="line"><span class="string">&#x27;feature_fraction&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line"><span class="string">&#x27;lambda_l1&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line"><span class="string">&#x27;lambda_l2&#x27;</span>: <span class="number">2.9</span>,</span><br><span class="line"><span class="string">&#x27;max_depth&#x27;</span>: <span class="number">15</span>,</span><br><span class="line"><span class="string">&#x27;min_data_in_leaf&#x27;</span>: <span class="number">12</span>,</span><br><span class="line"><span class="string">&#x27;min_gain_to_split&#x27;</span>: <span class="number">1.0</span>,</span><br><span class="line"><span class="string">&#x27;min_sum_hessian_in_leaf&#x27;</span>: <span class="number">0.0038</span>,</span><br><span class="line"><span class="string">&quot;verbosity&quot;</span>:-<span class="number">5</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">clf2 = lgb.train(params=lgb_params,train_set=lgb_train,valid_sets=lgb_eval,num_boost_round=<span class="number">10</span>, </span><br><span class="line">                categorical_feature=categorical_feats)</span><br><span class="line"></span><br><span class="line">y_pred = clf2.predict(X_test,num_iteration=clf2.best_iteration)<span class="comment">#结果是0-1之间的概率值，是一维数组</span></span><br><span class="line">pred =[<span class="number">1</span> <span class="keyword">if</span> x &gt;<span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> y_pred]</span><br><span class="line">accuracy = accuracy_score(y_test,pred)</span><br><span class="line">auc_score=metrics.roc_auc_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>),<span class="string">&quot;auc_score: %.2f%%&quot;</span> % (auc_score*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>[1]    valid_0&#39;s binary_logloss: 0.479157[2]    valid_0&#39;s binary_logloss: 0.46882[3]    valid_0&#39;s binary_logloss: 0.454724[4]    valid_0&#39;s binary_logloss: 0.445913[5]    valid_0&#39;s binary_logloss: 0.440924[6]    valid_0&#39;s binary_logloss: 0.438309[7]    valid_0&#39;s binary_logloss: 0.433886[8]    valid_0&#39;s binary_logloss: 0.432747[9]    valid_0&#39;s binary_logloss: 0.431001[10]    valid_0&#39;s binary_logloss: 0.429621accuarcy: 81.69% auc_score: 76.48%</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义目标函数，预测概率小于0.1的正样本（标签为正样本，但模型预测概率小于0.1），梯度增加一倍。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loglikelihood</span>(<span class="params">preds, train_data</span>):</span></span><br><span class="line">    labels=train_data.get_label()</span><br><span class="line">    preds=<span class="number">1.</span>/(<span class="number">1.</span>+np.exp(-preds))</span><br><span class="line">    </span><br><span class="line">    grad=[(p-l) <span class="keyword">if</span> p&gt;=<span class="number">0.1</span> <span class="keyword">else</span> <span class="number">2</span>*(p-l) <span class="keyword">for</span> (p,l) <span class="keyword">in</span> <span class="built_in">zip</span>(preds,labels) ]</span><br><span class="line">    hess=[p*(<span class="number">1.</span>-p) <span class="keyword">if</span> p&gt;=<span class="number">0.1</span> <span class="keyword">else</span> <span class="number">2</span>*p*(<span class="number">1.</span>-p) <span class="keyword">for</span> p <span class="keyword">in</span> preds ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grad, hess</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义评价指标binary_error，阈值大于0.8视为正样本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_error</span>(<span class="params">preds, train_data</span>):</span></span><br><span class="line">    labels = train_data.get_label()</span><br><span class="line">    preds = <span class="number">1.</span> / (<span class="number">1.</span> + np.exp(-preds))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;error&#x27;</span>, np.mean(labels != (preds &gt; <span class="number">0.8</span>)), <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">clf3 = lgb.train(lgb_params,</span><br><span class="line">                lgb_train,</span><br><span class="line">                num_boost_round=<span class="number">10</span>,</span><br><span class="line">                init_model=clf2,</span><br><span class="line">                fobj=loglikelihood, <span class="comment"># 目标函数</span></span><br><span class="line">                feval=binary_error, <span class="comment"># 评价指标</span></span><br><span class="line">                valid_sets=lgb_eval)</span><br><span class="line"></span><br><span class="line">y_pred = clf3.predict(X_test,num_iteration=clf3.best_iteration)<span class="comment">#结果是0-1之间的概率值，是一维数组</span></span><br><span class="line">pred =[<span class="number">1</span> <span class="keyword">if</span> x &gt;<span class="number">0.8</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> y_pred]</span><br><span class="line">accuracy2 = accuracy_score(y_test,pred)</span><br><span class="line">auc_score2=metrics.roc_auc_score(y_test,y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy2*<span class="number">100.0</span>),<span class="string">&quot;auc_score: %.2f%%&quot;</span> % (auc_score2*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><pre><code>[11]    valid_0&#39;s binary_logloss: 4.68218    valid_0&#39;s error: 0.196414[12]    valid_0&#39;s binary_logloss: 4.51541    valid_0&#39;s error: 0.196414[13]    valid_0&#39;s binary_logloss: 4.4647    valid_0&#39;s error: 0.19558[14]    valid_0&#39;s binary_logloss: 4.5248    valid_0&#39;s error: 0.196414[15]    valid_0&#39;s binary_logloss: 4.51904    valid_0&#39;s error: 0.196414[16]    valid_0&#39;s binary_logloss: 4.52481    valid_0&#39;s error: 0.196414[17]    valid_0&#39;s binary_logloss: 4.4928    valid_0&#39;s error: 0.196414[18]    valid_0&#39;s binary_logloss: 4.43027    valid_0&#39;s error: 0.196414[19]    valid_0&#39;s binary_logloss: 4.4285    valid_0&#39;s error: 0.196414[20]    valid_0&#39;s binary_logloss: 4.42314    valid_0&#39;s error: 0.196831accuarcy: 81.19% auc_score: 76.47%</code></pre><h2 id="九-模型部署与加速"><a href="#九-模型部署与加速" class="headerlink" title="九 模型部署与加速"></a>九 模型部署与加速</h2><blockquote><p><a href="https://treelite.readthedocs.io/en/latest/tutorials/import.html">参考文档</a><br><a href="https://blog.csdn.net/sinat_26917383/article/details/113287642?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164218367916780271548371%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164218367916780271548371&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-113287642.pc_search_insert_es_download&amp;utm_term=import+treelite.sklearn%E5%A4%B1%E8%B4%A5&amp;spm=1018.2226.3001.4187">python+Treelite：Sklearn树模型训练迁移到c、java部署</a></p></blockquote><p>由于 Treelite 的范围仅限于预测，因此必须使用其他机器学习包来训练决策树集成模型。在本文档中，我们将展示如何导入已在其他地方训练过的集成模型。</p><p>import treelite失败，无法导入，不知道为什么</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gbm9 = lgb.LGBMClassifier()</span><br><span class="line">gbm9.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = gbm9.predict(X_test)</span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line">auc_score=metrics.roc_auc_score(y_test,gbm9.predict_proba(X_test)[:,<span class="number">1</span>])<span class="comment">#predict_proba输出正负样本概率值，取第二列为正样本概率值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy*<span class="number">100.0</span>),<span class="string">&quot;auc_score: %.2f%%&quot;</span> % (auc_score*<span class="number">100.0</span>))</span><br><span class="line"></span><br><span class="line">gbm9.booster_.save_model(<span class="string">&quot;model9.txt&quot;</span>)<span class="comment">#保存模型为txt格式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> treelite</span><br><span class="line"><span class="keyword">import</span> treelite.sklearn</span><br><span class="line">model = treelite.sklearn.import_model(gbm9)<span class="comment">#导入 scikit-learn 模型</span></span><br><span class="line">y_pred = model.predict(X_test)</span><br><span class="line">accuracy2 = accuracy_score(y_test,y_pred)</span><br><span class="line">auc_score2=metrics.roc_auc_score(y_test,model.predict_proba(X_test)[:,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuarcy: %.2f%%&quot;</span> % (accuracy2*<span class="number">100.0</span>),<span class="string">&quot;auc_score: %.2f%%&quot;</span> % (auc_score2*<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://lightgbm.readthedocs.io/en/latest/Python-Intro.html&quot; title=&quot;官方文档&quot;&gt;LightGBM 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;阿水知乎贴：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/266865429&quot; title=&quot;《你应该知道的LightGBM各种操作》&quot;&gt;《你应该知道的LightGBM各种操作》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://lightgbm.readthedocs.io/en/latest/Python-API.html&quot; title=&quot;Python API&quot;&gt;Python API（包括Scikit-learn API）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://coggle.club/blog/30days-of-ml-202201&quot; title=&quot;《Coggle 30 Days of ML（22年1&amp;amp;2月）》&quot;&gt;《Coggle 30 Days of ML（22年1&amp;amp;2月）》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;学习内容：&lt;/p&gt;
&lt;p&gt;LightGBM（Light Gradient Boosting Machine）是微软开源的一个实现 GBDT 算法的框架，支持高效率的并行训练。LightGBM 提出的主要原因是为了解决 GBDT 在海量数据遇到的问题。本次学习内容包括使用LightGBM完成各种操作，包括竞赛和数据挖掘中的模型训练、验证和调参过程。&lt;/p&gt;
&lt;p&gt;打卡汇总：&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;任务名称&lt;/th&gt;
&lt;th&gt;难度、分数&lt;/th&gt;
&lt;th&gt;所需技能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;任务1模型训练与预测&lt;/td&gt;
&lt;td&gt;低、1&lt;/td&gt;
&lt;td&gt;LightGBM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;任务2：模型保存与加载&lt;/td&gt;
&lt;td&gt;低、1&lt;/td&gt;
&lt;td&gt;LightGBM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;任务3：分类、回归和排序任务&lt;/td&gt;
&lt;td&gt;高、3&lt;/td&gt;
&lt;td&gt;LightGBM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;任务4：模型可视化&lt;/td&gt;
&lt;td&gt;低、1&lt;/td&gt;
&lt;td&gt;graphviz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;任务5：模型调参（网格、随机、贝叶斯）&lt;/td&gt;
&lt;td&gt;中、2&lt;/td&gt;
&lt;td&gt;模型调参&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;任务6：模型微调与参数衰减&lt;/td&gt;
&lt;td&gt;中、2&lt;/td&gt;
&lt;td&gt;LightGBM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;任务7：特征筛选方法&lt;/td&gt;
&lt;td&gt;高、3&lt;/td&gt;
&lt;td&gt;特征筛选方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;任务8：自定义损失函数&lt;/td&gt;
&lt;td&gt;中、2&lt;/td&gt;
&lt;td&gt;损失函数&amp;amp;评价函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;任务9：模型部署与加速&lt;/td&gt;
&lt;td&gt;高、3&lt;/td&gt;
&lt;td&gt;Treelite&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;</summary>
    
    
    
    <category term="集成学习" scheme="https://zhxnlp.github.io/categories/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="集成学习" scheme="https://zhxnlp.github.io/tags/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Boosting" scheme="https://zhxnlp.github.io/tags/Boosting/"/>
    
    <category term="Bagging" scheme="https://zhxnlp.github.io/tags/Bagging/"/>
    
    <category term="Stacking" scheme="https://zhxnlp.github.io/tags/Stacking/"/>
    
  </entry>
  
  <entry>
    <title>2021使用hexo+github搭建个人博客</title>
    <link href="https://zhxnlp.github.io/2021/12/31/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/2021%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://zhxnlp.github.io/2021/12/31/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/2021%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-12-30T22:45:50.000Z</published>
    <updated>2022-01-14T19:47:29.800Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ul><li>主要参考文档：<a href="https://hexo.io/zh-cn/docs/">hexo文档</a>、<a href="https://molunerfinn.com/hexo-theme-melody-doc/#features">melody主题文档</a>、<a href="https://www.youtube.com/watch?v=xvIRGmKWpFM">youtube教学视频</a>、<a href="https://space.bilibili.com/362224537/channel/series">bilibili的hexo教学视频</a>、<a href="https://hexo.io/themes/">hexo主题网站</a>。</li><li><a href="https://blog.csdn.net/wapchief/article/details/54602515?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164088400916780366527950%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164088400916780366527950&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-10-54602515.pc_search_insert_es_download_v2&amp;utm_term=github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA&amp;spm=1018.2226.3001.4187">《使用hexo+github免费搭建个人博客网站超详细教程》</a>、hexo文档：<a href="https://hexo.io/zh-cn/docs/github-pages">将 Hexo 部署到 GitHub Pages</a>。</li><li>bilibili搭建博客视频资料<a href="https://www.bilibili.com/video/BV1mU4y1j72n?p=5">《【2021最新版】保姆级Hexo+github搭建个人博客》</a></li><li><a href="https://yarn.bootcss.com/">yarn1中文文档</a>、<a href="https://www.yarnpkg.cn/">yarn2文档</a>、<a href="https://www.npmjs.cn/">npm中文文档</a>、<a href="http://bit.ly/2QhJTNaYaml">Yaml官网</a>、<a href="http://bit.ly/2zxeDCC">Yaml教程</a> </li><li><a href="https://hexo.io/zh-cn/docs/commands">hexo常用命令</a>、<a href="https://github.com/hexojs/awesome-hexo">Hexo Awesome文档</a>、<a href="https://github.com/hexojs/hexo">Hexo Github</a><span id="more"></span> <h2 id="一、必备软件安装"><a href="#一、必备软件安装" class="headerlink" title="一、必备软件安装"></a>一、必备软件安装</h2>首先安装Node.js、git，再安装hexo-cli（cli是命令行接口，即commend  line interface。本身也会装hexo，且可以通过命令操作hexo）。<br>安装nodejs参考帖子<a href="https://blog.csdn.net/qq_56591814/article/details/121980469?spm=1001.2014.3001.5501">《Datawhale第32期组队学习——task0：新闻推荐系统项目搭建：centos下前端配置》</a><br>安装git工具，以及github注册创建仓库，参考我另一篇帖子<a href="https://blog.csdn.net/qq_56591814/article/details/119841785?spm=1001.2014.3001.5501">《GitHub 详细教程》</a>。<br>hexo支持yaml和json。凡是使用Yaml的地方也可以使用json替代。但是json相较yaml更加烦琐而功能相同，且各大网站基本都支持Yaml，所以推荐大家使用Yaml。</li></ul><h2 id="二、-hexo本地搭建博客"><a href="#二、-hexo本地搭建博客" class="headerlink" title="二、 hexo本地搭建博客"></a>二、 hexo本地搭建博客</h2><p>常用命令：</p><ul><li>hexo clean：清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令</li><li>hexo g -d :Hexo 在生成完毕后自动部署网站</li><li>hexo s：本地部署网站</li><li>hexo —draft：显示草稿</li></ul><h3 id="2-1-本地生成博客内容"><a href="#2-1-本地生成博客内容" class="headerlink" title="2.1 本地生成博客内容"></a>2.1 本地生成博客内容</h3><p>新建blog文件夹，运行<code>hexo init [folder]</code>。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。<br>本命令相当于执行了以下几步：</p><ol><li>Git clone hexo-starter 和 hexo-theme-landscape 主题到当前目录或指定目录。</li><li>使用 Yarn 1、pnpm 或 npm 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 Node.js 安装。</li></ol><p>有些包没有安装成功，直接运行<code>npm install</code>安装。<br>输入dir可以查看目录下文件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">dir</span><span class="comment">#我这个是已经发布过的hexo 博客</span></span><br><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><ul><li>_config.yml：网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。配置文件遵循yaml语法。</li><li>package.json：应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</li><li>scaffolds：<a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</li><li>source：资源文件夹。除 <em>posts 文件夹之外，开头命名为 </em> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</li><li>themes：主题 文件夹，Hexo 会根据主题来生成静态页面。</li></ul><p>输入<code>hexo g</code>静态生成本地网页。（g就是generate生成的缩写）<br><img src="https://img-blog.csdnimg.cn/3480ea39bd374d73816019e2e6afe7cf.png" alt="在这里插入图片描述"><br>此时会发现根目录下多了一个<code>public</code>的文件夹，里面就是生成的网页文件。<br>再次运行<code>hexo s</code>启动网站（s就是server的意思）。此时就可以在<a href="http://localhost:4000/中查看本地生成的博客网站。">http://localhost:4000/中查看本地生成的博客网站。</a></p><p>您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的：<code>hexo g -d hexo d -g</code>。</p><h3 id="2-2-文章写作、自动摘录"><a href="#2-2-文章写作、自动摘录" class="headerlink" title="2.2 文章写作、自动摘录"></a>2.2 文章写作、自动摘录</h3><blockquote><p><a href="https://www.youtube.com/watch?v=HLJ9jJy7CMg">youtube视频</a></p><ul><li>实现博客主页只显示部分文章内容，只需要在md文件某一行插入<code>&lt;!--more--&gt;</code>。首页只会显示标记以前的内容，标记后的内容可以通过阅读更多查阅，也可以设置自动摘录。</li><li>ipynb转md文件，在文件目录下打开cmd运行：<code>jupyter nbconvert --to markdown bert.ipynb</code>就行。<br>注意：使用自动摘录可能会导致代码区出错。所以如果你想在索引页中显示代码，那么你最好不要使用这个功能！</li></ul></blockquote><p>自动摘录，设置melody.yml：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: <span class="number">150</span></span><br></pre></td></tr></table></figure></p><ol><li><code>hexo new [layout] &lt;title&gt;</code>新建文章，生成一个标题为post title的md文件<br>如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;post title&quot;</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: E:\Git Bash\blog\source\_posts\post-title.md</span><br></pre></td></tr></table></figure>打开md文件发现开头已经写了front-master（开头这部分自动生成的就是front master）：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: post title</span><br><span class="line">date: <span class="number">2021</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">22</span>:07:<span class="number">24</span></span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ol><ul><li>-p, —path    自定义新文章的路径</li><li>-r, —replace    如果存在同名文章，将其替换</li><li>-s, —slug    文章的 Slug，作为新文章的文件名和发布后的 URL</li></ul><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 —path 参数来覆盖上述行为、自行决定文件的目录：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hexo new page --path about/me <span class="string">&quot;About me&quot;</span></span><br></pre></td></tr></table></figure></p><p>以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 “About me”</p><ol><li>运行<code>hexo new draft &quot;draft title&quot;</code>可以生成草稿。草稿可以预览其效果，但是不会被hexo渲染生成，即网站不会存在草稿文章。</li><li>运行<code>hexo new page &quot;page title&quot;</code>可以生成纯网页html。</li></ol><p>这三种类型的默认模板在scaffolds文件夹下面。即post.md，draft.md，page.md。模板使用nonjunks访问系统变量和函数。</p><h3 id="2-3-博客发布到网上"><a href="#2-3-博客发布到网上" class="headerlink" title="2.3 博客发布到网上"></a>2.3 博客发布到网上</h3><h3 id="2-3-1-配置主题模板"><a href="#2-3-1-配置主题模板" class="headerlink" title="2.3.1 配置主题模板"></a>2.3.1 配置主题模板</h3><p>下载next主题：<code>git clone git://github.com/theme-next/hexo-theme-next themes/next</code>。这句代码表示创建themes/next文件夹，并下载github.com/theme-next/hexo-theme-next仓库的文件。</p><p>回到hexo根目录下用记事本打开_config.yml文件。<br>配置模板，参考<a href="https://github.com/theme-next/hexo-theme-next">themes/next仓库文档</a>和<a href="http://theme-next.iissnan.com/getting-started.html">配置文档</a>。<br><img src="https://img-blog.csdnimg.cn/e181732eb6cc4a4a98cb664d9cca716e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>更改主题参考：<a href="https://blog.csdn.net/weixin_42419856/article/details/81141546?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164090083216780265493528%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164090083216780265493528&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-81141546.pc_search_insert_es_download_v2&amp;utm_term=github%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98&amp;spm=1018.2226.3001.4187">《如何更改使用hexo-github搭建博客的主题 theme》</a>。<br>hexo主题在这：<a href="https://hexo.io/themes/">Themes</a>。我安装的主题是<a href="https://molunerfinn.com/">melody</a>，<a href="https://molunerfinn.com/hexo-theme-melody-doc/quick-start.html#installation">说明文档</a>很详细。<br>安装后网页打开显示：<code>extends includes/layout.pug block content #recent-posts.recent-posts include includes/rec</code>。</p><p>运行<code>npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</code><br>提示有些包版本低，升级就行。npm查看本地安装的包的版本号<code>npm ls &lt;packageName&gt;</code>。<br>npm install —save constantinople jstransformer hexo-renderer-pug pug debug</p><h3 id="2-3-2-配置自己的远程仓库地址"><a href="#2-3-2-配置自己的远程仓库地址" class="headerlink" title="2.3.2 配置自己的远程仓库地址"></a>2.3.2 配置自己的远程仓库地址</h3><p><a href="https://blog.csdn.net/qq_38225558/article/details/90765491?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164088400916780366557862%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164088400916780366557862&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-8-90765491.pc_search_insert_es_download_v2&amp;utm_term=github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA&amp;spm=1018.2226.3001.4187"><GitHub搭建个人博客教程></a><br>在开始之前，必须先在 _config.yml 中修改部署配置参数，可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- <span class="built_in">type</span>: git</span><br><span class="line">  repo:</span><br><span class="line">- <span class="built_in">type</span>: heroku</span><br><span class="line">  repo:</span><br></pre></td></tr></table></figure><p>我配置的是：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git<span class="comment">#英文：接一个空格，下同</span></span><br><span class="line">  repo: https://github.com/zhxnlp/zhxnlp.github.io<span class="comment">#自己的仓库地址</span></span><br><span class="line">  branch: mian<span class="comment">#github在今年默认展示main分支，而不是master。</span></span><br></pre></td></tr></table></figure></p><h3 id="2-3-3-发布github博客"><a href="#2-3-3-发布github博客" class="headerlink" title="2.3.3 发布github博客"></a>2.3.3 发布github博客</h3><p>继续在本目录命令行，安装部署工具<code>npm install hexo-deployer-git -save</code>（方便以后更新）。<br>在blog目录（hexo项目根目录）运行<code>git init</code>本地仓库初始化。然后绑定仓库：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git branch -M main<span class="comment">#将本地仓库默认改为mian分支</span></span><br><span class="line">git remote add origin git@github.com:zhxnlp/zhxnlp.github.io.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p>已有仓库估计出错。新建仓库名为<code>zhxnlp.github.io</code>，绑定好仓库后，运行<code>hexo g</code>生成页面。<br>运行<code>hexo d</code>即deployee，将本地仓库文件上传到网上。也可直接输入 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>。</p><p>打开博客网址<code>https://zhxnlp.github.io/</code>，网页界面报错：<br>extends includes/layout.pug block content include includes/recent-posts.pug include includes/pagination.pug。<br>这是确少hexo插件，安装插件见上一节内容。</p><p>hexo g报错：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ERROR TypeError: E:\Git Bash\blog\node_modules\hexo-theme-melody\layout\includes</span><br><span class="line">\layout.pug:<span class="number">11</span></span><br><span class="line">    <span class="number">9</span>|</span><br><span class="line">    <span class="number">10</span>| - var pageDescription = page.description || page.title || config.descrip</span><br><span class="line">tion || <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &gt; <span class="number">11</span>| - var pageKeywords = (config.keywords || []).join(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="number">12</span>| - <span class="keyword">if</span> (page.tags &amp;&amp; page.tags.data) pageKeywords = page.tags.data.<span class="built_in">map</span>(fun</span><br><span class="line">ction(tag) &#123;<span class="keyword">return</span> tag.name;&#125;).join(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="number">13</span>| - <span class="keyword">if</span> (page.keywords) pageKeywords = page.keywords.join(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="number">14</span>| - var pageAuthor = config.email ? config.author + <span class="string">&#x27;,&#x27;</span> + config.email : c</span><br><span class="line">onfig.author</span><br><span class="line"></span><br><span class="line">(config.keywords || []).join <span class="keyword">is</span> <span class="keyword">not</span> a function</span><br><span class="line">    at <span class="built_in">eval</span> (<span class="built_in">eval</span> at wrap (E:\Git Bash\blog\node_modules\pug-runtime\wrap.js:<span class="number">6</span>:<span class="number">1</span></span><br><span class="line"><span class="number">0</span>), &lt;anonymous&gt;:<span class="number">24</span>:<span class="number">44</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这是因为根目录下<code>keyword</code>报错（估计是格式不对），导致hexo-theme-melody\layout\includes<br>\layout.pug文件第11行执行错误，改了就好了。</p><p>又报错10054，</p><blockquote><p>我是已经有仓库了，但是为了搭建博客改了域名为<code>https://github.com/zhxnlp/zhxnlp.github.io</code>，但是本地没有改，结果pull时出错。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ git pull origin mian</span><br><span class="line">starting fsmonitor-daemon <span class="keyword">in</span> <span class="string">&#x27;E:/Git Bash/bert2&#x27;</span></span><br><span class="line">fatal: couldn<span class="string">&#x27;t find remote ref mian</span></span><br></pre></td></tr></table></figure><br><code>fatal: couldn&#39;t find remote ref mian</code>表示仓库没有文件（域名被我改了，原来的仓库地址啥也没有）<br>git隐藏文件夹下：将 .git/cofig 文件中的 url 进行修改：<code>url = git@github.com:zhxnlp/zhxnlp.github.io</code>。</p></blockquote><h3 id="2-4-主题配置"><a href="#2-4-主题配置" class="headerlink" title="2.4 主题配置"></a>2.4 主题配置</h3><p>从这里开始都是配置主题的内容，可以在前面部分搭好之后再慢慢弄。<br>2.4这一节都是<a href="https://hexo.io/zh-cn/docs/front-matter">hexo文档内容</a>。</p><h4 id="2-4-1-front-master参数"><a href="#2-4-1-front-master参数" class="headerlink" title="2.4.1 front master参数"></a>2.4.1 front master参数</h4><blockquote><p><a href="https://www.youtube.com/watch?v=Rl48Yk4A_V8">youtube视频</a></p></blockquote><p>Front-matter 是文件最上方以 —- 分隔的区域，用于指定个别文件的变量，默认是：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: post title</span><br><span class="line">date: <span class="number">2021</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">22</span>:07:<span class="number">24</span></span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><br>可以用以下<a href="https://hexo.io/zh-cn/docs/front-matter">参数设置</a>其它属性：</p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td>config.default_layout</td></tr><tr><td>title</td><td>标题</td><td>文章的文件名</td></tr><tr><td>date</td><td>建立日期</td><td>文件建立日期</td></tr><tr><td>updated</td><td>更新日期</td><td>文件更新日期</td></tr><tr><td>comments</td><td>开启文章的评论功能</td><td>true/on/off</td></tr><tr><td>tags</td><td>标签（不适用于分页）</td><td></td></tr><tr><td>categories</td><td>分类（不适用于分页）</td><td></td></tr><tr><td>permalink</td><td>覆盖文章网址</td><td></td></tr><tr><td>excerpt</td><td>纯文本页面摘录。</td><td></td></tr><tr><td>lang</td><td>设置语言覆盖</td><td>Inherited from _config.yml</td></tr></tbody></table></div><h4 id="2-4-2-布局"><a href="#2-4-2-布局" class="headerlink" title="2.4.2  布局"></a>2.4.2  布局</h4><p>默认布局为 post，根据 _config.yml 中 default_layout 设置的值。 当文章中禁用布局（设为layout: false时），将不会对其进行主题处理。 但是，它仍然会被任何可用的渲染器渲染：如果一篇文章是用 Markdown 编写的，并且安装了 Markdown 渲染器（如默认的 hexo-renderer-marked），它将被渲染为 HTML。<br>标签插件默认启用，除非设置disableNunjucks禁用或者被渲染器禁用。</p><h4 id="2-4-3-标签和分类"><a href="#2-4-3-标签和分类" class="headerlink" title="2.4.3 标签和分类"></a>2.4.3 标签和分类</h4><p>启用首页显示分类和标签，只需要_config.melody.yml文件设置：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Main menu navigation</span></span><br><span class="line">menu:</span><br><span class="line">  Home: /</span><br><span class="line">  Archives: /archives</span><br><span class="line">  Tags: /tags</span><br><span class="line">  Categories: /categories</span><br><span class="line">  <span class="comment">#about: /about</span></span><br></pre></td></tr></table></figure><p>修改source/tags/index.md文件内容为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: <span class="number">2018</span>-01-05 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>修改source/categories/index.md内容为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: <span class="number">2018</span>-01-05 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><ul><li>只有md文章支持分类和标签。分类具有顺序性和层次性，而标签没有顺序和层次。一个文章可以有多个标签，多个分类，用中括号[]就可以达到并列效果。</li><li><p>标签和分类插件使用的是YAML语法，直接categories: 1,2会把1,2作为一个分类。正确是用- 的形式设置分类和多标签：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure><p>Hexo 不支持指定多个同级分类。下面的指定方法，会使分类Life成为Diary的子分类，而不是并列分类：</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"> - Diary</span><br><span class="line"> - Life</span><br></pre></td></tr></table></figure><p>如果想设置并列分类，可以写成：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"> - [Diary]</span><br><span class="line"> - [Life]</span><br></pre></td></tr></table></figure><br>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的并列子分类，同时 Life 是一个没有子分类的分类。</p><h4 id="2-4-4-标签插件（Tag-Plugins）"><a href="#2-4-4-标签插件（Tag-Plugins）" class="headerlink" title="2.4.4 标签插件（Tag Plugins）"></a>2.4.4 标签插件（Tag Plugins）</h4><p>标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。具体查看<a href="https://hexo.io/zh-cn/docs/tag-plugins">官方文档</a>。感觉这部分内容不重要，我用得少。</p><h4 id="2-4-5-资源文件夹-图片嵌入"><a href="#2-4-5-资源文件夹-图片嵌入" class="headerlink" title="2.4.5 资源文件夹/图片嵌入"></a>2.4.5 资源文件夹/图片嵌入</h4><ol><li>资源文件夹</li></ol><ul><li>资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。</li><li>例如你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于<code>![](/images/image.jpg)</code>的方法访问它们。</li><li>Hexo也提供了更组织化的方式来管理资源。管理资源功能可以通过将 config.yml 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><ul><li>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个和文章文件同名的资源文件夹，里面放入所有和文章有关的资源，然后通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</li></ul><ol><li>相对路径引用标签插件：<br>Hexo 3 中，许多新的<a href="https://hexo.io/docs/tag-plugins#Include-Assets">标签插件</a>被加入到了核心代码中，这使得你可以更简单地在文章中引用你的资源。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure><p>比如说：当你<code>打开文章资源文件夹功能</code>后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](example.jpg)</code> ，它将 不会 出现在首页上。正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This <span class="keyword">is</span> an example image %&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><ol><li>使用 Markdown 嵌入图像<br>hexo-renderer-marked 3.1.0 引入了一个新选项，允许您在不使用 <code>asset_img</code> 标签插件的情况下在 Markdown 中嵌入图像。</li></ol><p>启用功能：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure><p>启用后，asset image将自动解析为其相应帖子的路径。 例如，“image.jpg”位于“/2020/01/02/foo/image.jpg”，表示它是“/2020/01/02/foo/”帖子的asset image ，<code>![](image.jpg)</code>将呈现为 <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code>。</p><h4 id="2-4-6-数据文件夹"><a href="#2-4-6-数据文件夹" class="headerlink" title="2.4.6 数据文件夹"></a>2.4.6 数据文件夹</h4><p>有时您可能需要在主题中使用某些资料，而这些资料并不在文章内，并且是需要重复使用的，那么您可以考虑使用 Hexo 3.0 新增的「数据文件」功能。此功能会载入 source/_data 内的 YAML 或 JSON 文件，如此一来您便能在网站中复用这些文件了。<br>举例来说，在 source/_data 文件夹中新建 menu.yml 文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Home: /</span><br><span class="line">Gallery: /gallery/</span><br><span class="line">Archives: /archives/</span><br></pre></td></tr></table></figure><p>您就能在模板中使用这些资料：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">for</span> (var link <span class="keyword">in</span> site.data.menu) &#123; %&gt;</span><br><span class="line">  &lt;a href=<span class="string">&quot;&lt;%= site.data.menu[link] %&gt;&quot;</span>&gt; &lt;%= link %&gt; &lt;/a&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>渲染结果如下 :</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;/&quot;</span>&gt; Home &lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;/gallery/&quot;</span>&gt; Gallery &lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;/archives/&quot;</span>&gt; Archives &lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="2-4-7-服务器"><a href="#2-4-7-服务器" class="headerlink" title="2.4.7 服务器"></a>2.4.7 服务器</h4><p>直接参考<a href="https://hexo.io/zh-cn/docs/server">官方文档</a></p><h2 id="三-、自定义配置"><a href="#三-、自定义配置" class="headerlink" title="三 、自定义配置"></a>三 、自定义配置</h2><blockquote><p>参考本帖开头给的hexo文档和molody文档。最后一些修改我没写（第三方服务等）。</p><h3 id="3-1-配置"><a href="#3-1-配置" class="headerlink" title="3.1 配置"></a>3.1 配置</h3><p>在 网站配置文件_config.yml 中可以修改大部分的配置：</p><h4 id="3-1-1-网站、网址参数"><a href="#3-1-1-网站、网址参数" class="headerlink" title="3.1.1 网站、网址参数"></a>3.1.1 网站、网址参数</h4><div class="table-container"><table><thead><tr><th>网站参数</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>网站标题</td></tr><tr><td>subtitle</td><td>网站副标题</td></tr><tr><td>description</td><td>网站描述</td></tr><tr><td>keywords</td><td>网站的关键词。支持多个关键词。</td></tr><tr><td>author</td><td>文章作者。也可以通过修改front matter修改单篇文章的作者</td></tr><tr><td>language</td><td>简体中文为 zh-Hans或 zh-CN，请参考你的主题的文档自行设置，也支持多国语言</td></tr><tr><td>timezone</td><td>网站时区。Hexo 默认使用您电脑的时区。其它请参考 时区列表 进行设置</td></tr></tbody></table></div></blockquote><ul><li>description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，会显示在网站源代码中而不会显示在网页中。通常建议在其中包含您网站的关键词。</li><li>时区一般不需要改。如果你自动生成网页不在本地，而是海外，会造成时区差异，则可能需要设置。</li></ul><div class="table-container"><table><thead><tr><th>网址参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>url</td><td>网址, 必须以 http:// 或 https:// 开头</td><td></td></tr><tr><td>root</td><td>网站根目录</td><td>url’s pathname</td></tr><tr><td>permalink</td><td>文章的 永久链接 格式</td><td>:year/:month/:day/:title/</td></tr><tr><td>permalink_defaults</td><td>永久链接中各部分的默认值</td><td></td></tr><tr><td>pretty_urls</td><td>改写 permalink 的值来美化 URL</td><td></td></tr><tr><td>pretty_urls.trailing_index</td><td>设置为 false 时去除永久链接中尾部的 index.html</td><td>true</td></tr><tr><td>pretty_urls.trailing_html</td><td>设置为 false 时去除永久链接中尾部的 .html (对尾部的 index.html无效)</td><td>true</td></tr></tbody></table></div><ul><li>文章链接默认是年月日标题的格式。比如我的hello world文章链接是<code>https://zhxnlp.github.io/2021/12/31/hello-world/</code></li><li>如果您的<code>网站存放在子目录</code>中，例如 <a href="http://example.com/blog，则请将您的">http://example.com/blog，则请将您的</a> url 设为 <a href="http://example.com/blog">http://example.com/blog</a> 并把 root 设为 /blog/。(貌似是私人仓库设置网站在子目录，参见后面文档）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html</span></span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: false</span><br><span class="line"><span class="comment"># 此时页面的永久链接会变为 http://example.com/foo/bar/</span></span><br></pre></td></tr></table></figure><h4 id="3-1-2-目录-amp-文章"><a href="#3-1-2-目录-amp-文章" class="headerlink" title="3.1.2 目录&amp;文章"></a>3.1.2 目录&amp;文章</h4><p>如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p><div class="table-container"><table><thead><tr><th>目录参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>source_dir</td><td>资源文件夹，这个文件夹用来存放内容。</td><td>source</td></tr><tr><td>public_dir</td><td>公共文件夹，这个文件夹用于存放生成的站点文件。</td><td>public</td></tr><tr><td>tag_dir</td><td>标签文件夹</td><td>tags</td></tr><tr><td>archive_dir</td><td>归档文件夹</td><td>archives</td></tr><tr><td>category_dir</td><td>分类文件夹</td><td>categories</td></tr><tr><td>code_dir</td><td>Include code 文件夹，source_dir 下的子目录</td><td>downloads/code</td></tr><tr><td>i18n_dir</td><td>国际化（i18n）文件夹</td><td>:lang</td></tr><tr><td>skip_render</td><td>跳过hexo对指定文件的渲染。一般用于发布网站密钥等。匹配到的文件将会被不做改动地复制到 public 目录中。您可使用 glob 表达式来匹配路径。</td><td></td></tr></tbody></table></div><p>例如：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">skip_render: <span class="string">&quot;mypage/**/*&quot;</span></span><br><span class="line"><span class="comment"># 将会直接将 `source/mypage/index.html` 和 `source/mypage/code.js` 不做改动地输出到 &#x27;public&#x27; 目录</span></span><br><span class="line"><span class="comment"># 你也可以用这种方法来跳过对指定文章文件的渲染</span></span><br><span class="line">skip_render: <span class="string">&quot;_posts/test-post.md&quot;</span></span><br><span class="line"><span class="comment"># 这将会忽略对 &#x27;test-post.md&#x27; 的渲染</span></span><br></pre></td></tr></table></figure></p><div class="table-container"><table><thead><tr><th>文章参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>new_post_name</td><td>新文章的文件名称</td><td>:title.md</td></tr><tr><td>default_layout</td><td>预设布局</td><td>post</td></tr><tr><td>auto_spacing</td><td>在中文和英文之间加入空格</td><td>false</td></tr><tr><td>titlecase</td><td>把标题转换为 title case</td><td>false</td></tr><tr><td>external_link</td><td>在新标签中打开链接</td><td>true</td></tr><tr><td>external_link.enable</td><td>在新标签中打开链接</td><td>true</td></tr><tr><td>external_link.field</td><td>对整个网站（site）生效或仅对文章（post）生效</td><td>site</td></tr><tr><td>external_link.exclude</td><td>需要排除的域名。主域名和子域名如 www 需分别配置</td><td>[]</td></tr><tr><td>filename_case</td><td>把文件名称转换为 (1) 小写或 (2) 大写</td><td>0</td></tr><tr><td>render_drafts</td><td>是否在网站上显示草稿</td><td>false</td></tr><tr><td>post_asset_folder</td><td>启动 <a href="https://hexo.io/zh-cn/docs/asset-folders">Asset 文件夹</a></td><td>false</td></tr><tr><td>relative_link</td><td>把链接改为与根目录的相对位置</td><td>false</td></tr><tr><td>future</td><td>显示未来的文章</td><td>true</td></tr><tr><td>highlight</td><td>代码高亮设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#Highlight-js">Highlight.js</a> 进行设置</td></tr><tr><td>prismjs</td><td>代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#PrismJS">PrismJS</a> 进行设置</td></tr></tbody></table></div><h4 id="3-1-3-分类-amp-标签-amp-日期-时间-amp-分页扩展"><a href="#3-1-3-分类-amp-标签-amp-日期-时间-amp-分页扩展" class="headerlink" title="3.1.3 分类 &amp; 标签&amp;日期 / 时间&amp;分页扩展"></a>3.1.3 分类 &amp; 标签&amp;日期 / 时间&amp;分页扩展</h4><div class="table-container"><table><thead><tr><th>分类标签参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>default_category</td><td>默认分类</td><td>uncategorized</td></tr><tr><td>category_map</td><td>分类别名</td><td></td></tr><tr><td>tag_map</td><td>标签别名</td><td></td></tr></tbody></table></div><p>Hexo 使用 Moment.js 来解析和显示时间</p><div class="table-container"><table><thead><tr><th>时间参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>date_format</td><td>日期格式</td><td>YYYY-MM-DD</td></tr><tr><td>time_format</td><td>时间格式</td><td>HH:mm:ss</td></tr><tr><td>updated_option</td><td>当 Front Matter 中没有指定 updated 时 updated 的取值</td><td>mtime</td></tr></tbody></table></div><p>分页和扩展参数：</p><div class="table-container"><table><thead><tr><th>分页参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>per_page</td><td>每页显示的文章量 (0 = 关闭分页功能)</td><td>10</td></tr><tr><td>pagination_dir</td><td>分页目录位置</td><td>page</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>扩展参数</th><th>描述</th></tr></thead><tbody><tr><td>theme</td><td>当前3主题名称。值为false时禁用主题</td></tr><tr><td>theme_config</td><td>主题的配置文件。在这里放置的配置会覆盖主题目录下的 _config.yml 中的配置</td></tr><tr><td>deploy</td><td>部署部分的设置，比如git、heroke。</td></tr><tr><td>meta_generator</td><td>Meta generator标签。 值为 false 时 Hexo 不会在头部插入该标签</td></tr></tbody></table></div><h4 id="3-1-4-include-和-exclude文件"><a href="#3-1-4-include-和-exclude文件" class="headerlink" title="3.1.4 include 和 exclude文件"></a>3.1.4 include 和 exclude文件</h4><ul><li>Hexo 默认会不包括 source/ 下的文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和 _data 等目录除外）</li><li><p>在 Hexo 配置文件中，通过设置 include/exclude 可以让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 <a href="https://github.com/isaacs/minimatch">glob 表达式</a> 对目录和文件进行匹配。</p></li><li><p>include 和 exclude 选项只会应用到 source/ ，而 ignore 选项会应用到所有文件夹。</p></li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>include</td><td>如果想发布隐藏文件，需要设置在include里</td></tr><tr><td>exclude</td><td>剔除 source/ 下的这些文件和目录不再发布到网上。</td></tr><tr><td>ignore</td><td>Hexo 会忽略整个 Hexo 项目下的这些文件夹或文件</td></tr></tbody></table></div><p>举例：<br><code>.nojekyll文件</code>告诉github不要使用jekyll引擎渲染，因为会有一些其它操作，比如忽略Vander目录，会造成一些网站的奇怪错误。所以建议github发布博客，把.nojekyll文件放在根目录下，<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 处理或不处理目录或文件</span></span><br><span class="line">include:</span><br><span class="line">  - <span class="string">&quot;.nojekyll&quot;</span> </span><br><span class="line">  - <span class="string">&quot;css/_typing.css&quot;</span><span class="comment"># 处理 &#x27;source/css/_typing.css&#x27;</span></span><br><span class="line">  - <span class="string">&quot;_css/*&quot;</span> <span class="comment"># 处理 &#x27;source/_css/&#x27; 中的任何文件，但不包括子目录及其其中的文件。 </span></span><br><span class="line">  - <span class="string">&quot;_css/**/*&quot;</span> <span class="comment"># 处理 &#x27;source/_css/&#x27; 中的任何文件和子目录下的任何文件</span></span><br><span class="line"></span><br><span class="line">exclude:<span class="comment">#剔除文件，使其不包括在网站发布文件中</span></span><br><span class="line">  - <span class="string">&quot;js/test.js&quot;</span><span class="comment"># 不处理 &#x27;source/js/test.js&#x27;  </span></span><br><span class="line">  - <span class="string">&quot;js/*&quot;</span><span class="comment"># 不处理 &#x27;source/js/&#x27; 中的文件、但包括子目录下的所有目录和文件</span></span><br><span class="line">    </span><br><span class="line">ignore: </span><br><span class="line">  - <span class="string">&quot;**/foo&quot;</span> <span class="comment"># 忽略任何一个名叫 &#x27;foo&#x27; 的文件夹 </span></span><br><span class="line">  - <span class="string">&quot;**/themes/*/foo&quot;</span> <span class="comment"># 只忽略 &#x27;themes/&#x27; 下的 &#x27;foo&#x27; 文件夹 </span></span><br><span class="line">  - <span class="string">&quot;**/themes/**/foo&quot;</span> <span class="comment"># 对 &#x27;themes/&#x27; 目录下的每个文件夹中忽略名叫 &#x27;foo&#x27; 的子文件夹</span></span><br></pre></td></tr></table></figure></p><p>具体示例<a href="https://hexo.io/zh-cn/docs/configuration">参考文档</a></p><h4 id="3-1-5代替配置文件"><a href="#3-1-5代替配置文件" class="headerlink" title="3.1.5代替配置文件"></a>3.1.5代替配置文件</h4><p>这个的好处是：</p><ol><li>测试配置文件时，不需要来回更改主配置文件，只需要把主配置文件复制一份作为测试版就行。</li><li>同一根目录下，可以运行多个网站<br>使用 —config 参数来指定自定义配置文件的路径，例如：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 &#x27;custom.yml&#x27; 和 &#x27;custom2.json&#x27;，优先使用 &#x27;_config.yml&#x27;，然后是 &#x27;_config.yml&#x27;</span></span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,_config.yml</span><br></pre></td></tr></table></figure>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 _multiconfig.yml。如果遇到重复的配置，靠后的配置文件覆盖靠前的配置文件。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</li></ol><p>例如，使用 —options 指定了两个自定义配置文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ hexo generate --config custom.yml,custom2.json</span><br></pre></td></tr></table></figure><p>如果 custom.yml 中指定了 foo: bar，在 custom2.json 中指定了 “foo”: “dinosaur”，那么在 _multiconfig.yml 中你会得到 foo: dinosaur。</p><hr><p><strong>代替主题配置文件</strong><br>Hexo 5.0.0 起提供独立的 _config.[theme].yml 文件。默认主题配置文件会覆盖主网站配置文件。主题配置文件应放置于站点根目录下，并配置站点 _config.yml 文件中的 theme。例如配置melody主题：</p><ol><li>安装主题：<code>npm install hexo-theme-melody</code></li><li>根目录创建<code>_config.melody.yml</code>文件</li><li>将<code>./node_modules/hexo-theme-melody/_config.yml</code>的内容复制到刚才的<code>_config.melody.yml</code>里面。</li></ol><p>强烈建议你将所有的主题配置集中在一处。<br>Hexo 在合并主题配置时，Hexo 配置文件中的 theme_config 的优先级最高，其次是 _config.[theme].yml 文件，最后是位于主题目录下的 _config.yml 文件。</p><h3 id="3-2-Permalinks永久链接"><a href="#3-2-Permalinks永久链接" class="headerlink" title="3.2 Permalinks永久链接"></a>3.2 Permalinks永久链接</h3><p>可以在 _config.yml 配置中调整网站的永久链接或者在每篇文章的 Front-matter 中指定。</p><div class="table-container"><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>:year</td><td>文章的发表年份（4 位数）</td></tr><tr><td>:month</td><td>文章的发表月份（2 位数）</td></tr><tr><td>:i_month</td><td>文章的发表月份（去掉开头的零）</td></tr><tr><td>:day</td><td>文章的发表日期 (2 位数)</td></tr><tr><td>:i_day</td><td>文章的发表日期（去掉开头的零）</td></tr><tr><td>:hour</td><td>文章发表时的小时 (2 位数)</td></tr><tr><td>:minute</td><td>文章发表时的分钟 (2 位数)</td></tr><tr><td>:second</td><td>文章发表时的秒钟 (2 位数)</td></tr><tr><td>:title</td><td>文件名称 (relative to “source/_posts/“ folder)</td></tr><tr><td>:name</td><td>文件名称</td></tr><tr><td>:post_title</td><td>文章标题</td></tr><tr><td>:id</td><td>文章 ID (not persistent across cache reset)，每次发布id可能会不一样</td></tr><tr><td>:category</td><td>分类。如果文章没有分类，则是 default_category 配置信息。</td></tr><tr><td>:hash</td><td>SHA1 hash of filename (same as :title) and date (12-hexadecimal)</td></tr></tbody></table></div><p>使用第三方插件，例如disqus管理评论，会在每个网页下面生成对话窗口。如果id不唯一，多个文章评论会揉在一起。如果要生成唯一id，可以使用下面这个插件。<br><img src="https://img-blog.csdnimg.cn/28f3856e48ca437ab6064e06ede56c4d.png" alt=""></p><p>可在 permalink_defaults 参数下调整永久链接中各变量的默认值：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">permalink_defaults:</span><br><span class="line">  lang: en</span><br></pre></td></tr></table></figure><br>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">source/_posts/hello-world.md</span><br><span class="line">title: Hello World</span><br><span class="line">date: <span class="number">2013</span>-07-<span class="number">14</span> <span class="number">17</span>:01:<span class="number">34</span></span><br><span class="line">categories:</span><br><span class="line">- foo</span><br><span class="line">- bar</span><br></pre></td></tr></table></figure><h3 id="3-3-主题"><a href="#3-3-主题" class="headerlink" title="3.3 主题"></a>3.3 主题</h3><p>只要在 themes 文件夹内，新增一个任意名称的文件夹，并修改 _config.yml 内的 theme 设定，即可切换主题。一个主题可能会有以下的结构：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── languages</span><br><span class="line">├── layout</span><br><span class="line">├── scripts</span><br><span class="line">└── source</span><br></pre></td></tr></table></figure><ul><li>_config.yml：主题的配置文件。和 Hexo 配置文件不同，主题配置文件修改时会自动更新，无需重启 Hexo Server。</li><li>languages：语言文件夹。请参见 <a href="https://hexo.io/zh-cn/docs/internationalization">国际化 (i18n)</a>。</li><li>layout：布局文件夹。用于存放主题的模板文件，决定了网站内容的呈现方式，Hexo 内建 <a href="https://github.com/node-swig/swig-templates">Swig</a> 模板引擎，您可以另外安装插件来获得 <a href="https://github.com/hexojs/hexo-renderer-ejs">EJS</a>、<a href="https://github.com/hexojs/hexo-renderer-haml">Haml</a>、<a href="https://github.com/hexojs/hexo-renderer-jade">Jade</a> 或 <a href="https://github.com/maxknee/hexo-render-pug">Pug</a> 支持。Hexo 根据模板文件的扩展名来决定所使用的模板引擎，参考 <a href="https://hexo.io/zh-cn/docs/templates">模板</a> 以获得更多信息。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">archive.pug   - 使用 Pug</span><br><span class="line">layout.swig   - 使用 Swig</span><br></pre></td></tr></table></figure><ul><li>scripts：脚本文件夹。在启动时，Hexo 会载入此文件夹内的 JavaScript 文件，请参见 <a href="https://hexo.io/zh-cn/docs/plugins">插件</a> 以获得更多信息。</li><li>source：资源文件夹，除了模板以外的 Asset，例如 CSS、JavaScript 文件等，都应该放在这个文件夹中。文件或文件夹开头名称为 _（下划线线）或隐藏的文件会被忽略。<br>如果文件可以被渲染的话，会经过解析然后储存到 public 文件夹，否则会直接拷贝到 public 文件夹。</li></ul><p>分享发布主题，请参考文档。</p><h3 id="3-4-模版"><a href="#3-4-模版" class="headerlink" title="3.4 模版"></a>3.4 模版</h3><h4 id="3-4-1-模板名称"><a href="#3-4-1-模板名称" class="headerlink" title="3.4.1 模板名称"></a>3.4.1 模板名称</h4><p>模板决定了网站内容的呈现方式，每个主题至少都应包含一个 index 模板，以下是各页面相对应的模板名称：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">模板         用途      回退</span><br><span class="line">index     首页</span><br><span class="line">post     文章     index</span><br><span class="line">page     分页     index</span><br><span class="line">archive     归档     index</span><br><span class="line">category 分类归档 archive</span><br><span class="line">tag         标签归档 archive</span><br></pre></td></tr></table></figure><h4 id="3-4-2-布局（Layout）"><a href="#3-4-2-布局（Layout）" class="headerlink" title="3.4.2 布局（Layout）"></a>3.4.2 布局（Layout）</h4><p>每个模板都默认使用 layout 布局，您可在 front-matter 指定其他布局，或是设为 false 来关闭布局功能，您甚至可在布局中再使用其他布局来建立嵌套布局。<br>其它内容参考<a href="https://hexo.io/zh-cn/docs/templates">官方文档</a>。</p><h3 id="3-5-变量和函数、代码高亮"><a href="#3-5-变量和函数、代码高亮" class="headerlink" title="3.5 变量和函数、代码高亮"></a>3.5 变量和函数、代码高亮</h3><p>变量包括全局变量和网站变量、page变量等等<br>辅助函数包括取得路径、gravatar根据邮箱地址返回 Gravatar 头像 URL等等。这部分内容参考官网文档。</p><h3 id="3-6-安装搜索"><a href="#3-6-安装搜索" class="headerlink" title="3.6 安装搜索"></a>3.6 安装搜索</h3><p>参考帖子：<a href="https://blog.csdn.net/weixin_33826268/article/details/88022470?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164099797316780264072146%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164099797316780264072146&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-88022470.pc_search_insert_es_download_v2&amp;utm_term=hexo-algolia&amp;spm=1018.2226.3001.4187">Hexo+Next集成Algolia搜索</a>、<a href="https://blog.csdn.net/qq_35479468/article/details/107335663?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164099797316780264072146%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164099797316780264072146&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-107335663.pc_search_insert_es_download_v2&amp;utm_term=hexo-algolia&amp;spm=1018.2226.3001.4187">《为Hexo增加algolia搜索功能》</a><br> <a href="https://www.algolia.com/users/sign_in用github注册登录后，创建index。然后进入API">https://www.algolia.com/users/sign_in用github注册登录后，创建index。然后进入API</a> Keys。点击ALL API Keys-NEW API Keys新建API Keys。<br><img src="https://img-blog.csdnimg.cn/1e019db7a74547a58efa5f41253322a4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>创建完后保存好API Keys。<br><img src="https://img-blog.csdnimg.cn/3811cf7a5af34f12b76c03dbce2af133.png" alt="在这里插入图片描述"><br>在Hexo根目录<code>npm install hexo-algolia --save</code>安装，然后在_config.yml中加入algolia的配置，注意改成前面API Keys页面相应配置。这里注意apikey填写刚才你创建的那个有权限的，其余的在your api keys里面可以找到。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">algolia:</span><br><span class="line">  applicationID: <span class="string">&#x27;your applicationID&#x27;</span></span><br><span class="line">  apiKey: <span class="string">&#x27;your apiKey&#x27;</span><span class="comment">#我写的是刚才创建的额那个key</span></span><br><span class="line">  adminApiKey: <span class="string">&#x27;your adminApiKey&#x27;</span></span><br><span class="line">  indexName: <span class="string">&#x27;your indexName&#x27;</span><span class="comment">#github-io</span></span><br><span class="line">  chunkSize: <span class="number">5000</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c78753e5ff3241429d69ad8d30160838.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>设置环境变量：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">export HEXO_ALGOLIA_INDEXING_KEY=your apiKey<span class="comment">#刚才创建那个</span></span><br><span class="line">hexo algolia</span><br></pre></td></tr></table></figure><p>到主题目录下的_config.yml，修改为开启：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">algolia_search:</span><br><span class="line">  enable: true</span><br><span class="line">  hits:</span><br><span class="line">    per_page: <span class="number">10</span> </span><br><span class="line">  labels:</span><br><span class="line">    input_placeholder: Search <span class="keyword">for</span> Posts</span><br><span class="line">    hits_empty: <span class="string">&quot;我们没有找到任何搜索结果: $&#123;query&#125;&quot;</span> </span><br><span class="line">    hits_stats: <span class="string">&quot;找到$&#123;hits&#125;条结果，用时$&#123;time&#125; ms&quot;</span></span><br></pre></td></tr></table></figure><p>然后运行<code>hexo g -d</code>就行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要参考文档：&lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot;&gt;hexo文档&lt;/a&gt;、&lt;a href=&quot;https://molunerfinn.com/hexo-theme-melody-doc/#features&quot;&gt;melody主题文档&lt;/a&gt;、&lt;a href=&quot;https://www.youtube.com/watch?v=xvIRGmKWpFM&quot;&gt;youtube教学视频&lt;/a&gt;、&lt;a href=&quot;https://space.bilibili.com/362224537/channel/series&quot;&gt;bilibili的hexo教学视频&lt;/a&gt;、&lt;a href=&quot;https://hexo.io/themes/&quot;&gt;hexo主题网站&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/wapchief/article/details/54602515?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164088400916780366527950%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;amp;request_id=164088400916780366527950&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-10-54602515.pc_search_insert_es_download_v2&amp;amp;utm_term=github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA&amp;amp;spm=1018.2226.3001.4187&quot;&gt;《使用hexo+github免费搭建个人博客网站超详细教程》&lt;/a&gt;、hexo文档：&lt;a href=&quot;https://hexo.io/zh-cn/docs/github-pages&quot;&gt;将 Hexo 部署到 GitHub Pages&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;bilibili搭建博客视频资料&lt;a href=&quot;https://www.bilibili.com/video/BV1mU4y1j72n?p=5&quot;&gt;《【2021最新版】保姆级Hexo+github搭建个人博客》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://yarn.bootcss.com/&quot;&gt;yarn1中文文档&lt;/a&gt;、&lt;a href=&quot;https://www.yarnpkg.cn/&quot;&gt;yarn2文档&lt;/a&gt;、&lt;a href=&quot;https://www.npmjs.cn/&quot;&gt;npm中文文档&lt;/a&gt;、&lt;a href=&quot;http://bit.ly/2QhJTNaYaml&quot;&gt;Yaml官网&lt;/a&gt;、&lt;a href=&quot;http://bit.ly/2zxeDCC&quot;&gt;Yaml教程&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hexo.io/zh-cn/docs/commands&quot;&gt;hexo常用命令&lt;/a&gt;、&lt;a href=&quot;https://github.com/hexojs/awesome-hexo&quot;&gt;Hexo Awesome文档&lt;/a&gt;、&lt;a href=&quot;https://github.com/hexojs/hexo&quot;&gt;Hexo Github&lt;/a&gt;</summary>
    
    
    
    <category term="软件应用" scheme="https://zhxnlp.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="前端开发" scheme="https://zhxnlp.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="github" scheme="https://zhxnlp.github.io/tags/github/"/>
    
    <category term="hexo" scheme="https://zhxnlp.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记10：统计学习方法_——HMM和CRF</title>
    <link href="https://zhxnlp.github.io/2021/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95_%E2%80%94%E2%80%94HMM%E5%92%8CCRF/"/>
    <id>https://zhxnlp.github.io/2021/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010%EF%BC%9A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95_%E2%80%94%E2%80%94HMM%E5%92%8CCRF/</id>
    <published>2021-12-25T15:32:54.000Z</published>
    <updated>2022-01-02T20:45:01.029Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考文章<a href="https://www.zhihu.com/question/35866596/answer/236886066?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1400823417357139968&amp;utm_content=group3_Answer&amp;utm_campaign=shareopn">《如何用简单易懂的例子解释条件随机场（CRF）模型？它和HMM有什么区别？》</a><br><a href="https://zhuanlan.zhihu.com/p/178731739?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1400823417357139968&amp;utm_campaign=shareopn">《条件随机场CRF之从公式到代码》</a><br><a href="https://zhuanlan.zhihu.com/p/148813079?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1400823417357139968&amp;utm_campaign=shareopn">《CRF条件随机场的原理、例子、公式推导和应用》</a><br><span id="more"></span></p><h2 id="一、概率图模型"><a href="#一、概率图模型" class="headerlink" title="一、概率图模型"></a>一、概率图模型</h2><h3 id="1-1-概览"><a href="#1-1-概览" class="headerlink" title="1.1 概览"></a>1.1 概览</h3><p>在统计概率图（probability graph models）中，参考宗成庆老师的书，是这样的体系结构：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/c8b569f3f6d04c488431dce83ed52f8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在概率图模型中，数据(样本)由图$G=(V,E)$建模表示：</p><ul><li>V：节点v的集合。v∈V表示随机变量$Y_v$。</li><li>E：边e的集合。e∈E表示随机变量之间的概率依赖关系。</li><li>P(Y):由图表示的联合概率分布</li></ul><p>有向图和无向图区别在于如何求概率分布P(Y)。</p><h3 id="1-2-有向图"><a href="#1-2-有向图" class="headerlink" title="1.2 有向图"></a>1.2 有向图</h3><p>有向图模型，这么求联合概率： </p><script type="math/tex; mode=display">P(x_{1}...x_{n})=\prod_{i=0}P(x_{i}|\pi (x_{i}))</script><p>对于下图求概率有：<br><img src="https://img-blog.csdnimg.cn/7256a9d4eb6e4d7ea9647c6d47746801.png" alt="在这里插入图片描述"></p><script type="math/tex; mode=display">P(x_{1}...x_{n})=P(x_{1})\cdot P(x_{2}| x_{1})\cdot P(x_{3}| x_{2})\cdot P(x_{4})|P(x_{2})P(x_{5}|x_{3},x_{4})</script><h3 id="1-3-无向图"><a href="#1-3-无向图" class="headerlink" title="1.3 无向图"></a>1.3 无向图</h3><p>基本概念：</p><ol><li>团：节点子集，子集中任何两个节点均有边相连</li><li>最大团：不能再加入节点使其更大的团</li><li>因子分解：联合概率分布P(Y)表示为<code>所有最大团上随机变量函数的乘积的形式</code>为因子分解。</li></ol><p>所以有：联合概率分布为最大团势函数的乘积。</p><script type="math/tex; mode=display">P(Y)=\frac{1}{Z}\prod_{C}\psi _{C}(Y_{C})=\frac{1}{Z}\prod_{C}exp^{-E(Y_{C})}</script><ul><li>C：无向图的最大团</li><li>$Y_{C}$:最大团C上的节点(随机变量）</li><li>Z：规范化因子。$Z=\sum<em>{Y}\prod</em>{C}\psi <em>{C}(Y</em>{C})$,使得输出P(Y)具有概率意义。</li><li>$\psi <em>{C}(Y</em>{C})$:严格正的势函数，通常为指数函数$\psi <em>{C}(Y</em>{C})=exp^{-E(Y_{C})}$。</li></ul><p>马尔科夫性，保证概率图为概率无向图：</p><ul><li>成对马尔科夫性：u和v没有边相连，O为其它所有节点，$Y_u和Y_v$互相独立。</li><li>局部马尔科夫性：对于任意节点v、相连节点集合W和无边相连集合O，给定$Y_W$情况下，$Y_v和Y_O$互相独立：</li><li>全局马尔科夫性：节点A和B被节点集合C分割，$Y_A和Y_B$互相独立：</li></ul><p>总之就是没有边相连的节点概率互相独立。</p><p>对于一个无向图，举例如下：</p><p><img src="https://img-blog.csdnimg.cn/f77a15a1b61a4829868472dce880feb5.png" alt="在这里插入图片描述"></p><script type="math/tex; mode=display">P(Y)=\frac{1}{Z}\prod_{C}\psi( _{X_{1},X_{3},X_{4}})\psi( _{X_{2},X_{3},X_{4}})</script><h3 id="1-4-生成式模型和判别式模型"><a href="#1-4-生成式模型和判别式模型" class="headerlink" title="1.4 生成式模型和判别式模型"></a>1.4 生成式模型和判别式模型</h3><h3 id="1-4-1生成式模型和判别式模型区别"><a href="#1-4-1生成式模型和判别式模型区别" class="headerlink" title="1.4.1生成式模型和判别式模型区别"></a>1.4.1生成式模型和判别式模型区别</h3><p>有监督学习中，训练数据包括输入X和标签Y。所以模型求的是X和Y的概率分布。根据概率论的知识可以知道，对应的概率分布（以概率密度函数指代概率分布）有两种：</p><ul><li>联合概率分布：$P_{\theta }(X,Y)$，表示数据和标签同时出现的概率，对应于生成式模型。</li><li>条件概率分布：P_{\theta }(Y|X)，表示给定数据条件下，对应标签的概率，对应于判别式模型。</li></ul><p>进一步理解：</p><ul><li>生成式模型：除了能够根据输入数据 X 来预测对应的标签 Y ,还能根据训练得到的模型产生服从训练数据集分布的数据( X ，Y），相当于生成一组新的数据，所以称之为生成式模型。</li><li>判别式模型：仅仅根据X由条件概率$P_{\theta }(Y|X)$来预测标签Y。牺牲了生成数据的能力，但是比生成式模型的预测准确率高。<h4 id="1-4-2-为啥判别式模型预测效果更好"><a href="#1-4-2-为啥判别式模型预测效果更好" class="headerlink" title="1.4.2 为啥判别式模型预测效果更好"></a>1.4.2 为啥判别式模型预测效果更好</h4>原因如下：由全概率公式和信息熵公式可以得到：<script type="math/tex; mode=display">P(X,Y)=\int P(Y|X)P(X)dX</script>即计算全概率公式$P(X,Y)$时引入了输入数据的概率分布$P(X)$，而这个并不是我们关心的。我们只关心给定X情况下Y的分布，这就相对削弱了模型的预测能力。<br>另外从信息熵的角度进行定量分析。</li></ul><ol><li>X的信息熵定义为：<script type="math/tex; mode=display">H(X)=-\int P(X)logP(X)dX</script></li><li>两个离散随机变量 X  和 Y  的联合熵 (Joint Entropy) 表示两事件同时发生系统的不确定度:<script type="math/tex; mode=display">H(X,Y)=-\int P(X,Y)logP(X,Y)dXdY</script></li><li>条件熵 (Conditional Entropy) H(Y|X)表示在已知随机变量X的条件下随机变量Y的不确定性：<script type="math/tex; mode=display">H(Y|X)=-\int P(Y|X)logP(Y|X)dX</script></li></ol><p>可以推导出来$H(Y|X)=H(X,Y)-H(X)$.一般H(X)&gt;0（所有离散分布和很多连续分布满足这个条件），可以知道条件分布的信息熵小于联合分布，即判别模型比生成式模型含有更多的信息，所以同条件下比生成式模型效果更好。&lt;/font &gt;</p><h2 id="二、隐式马尔科夫模型HMM"><a href="#二、隐式马尔科夫模型HMM" class="headerlink" title="二、隐式马尔科夫模型HMM"></a>二、隐式马尔科夫模型HMM</h2><h3 id="2-1-HMM定义"><a href="#2-1-HMM定义" class="headerlink" title="2.1 HMM定义"></a>2.1 HMM定义</h3><ul><li>隐马尔可夫模型是关于时序的概率模型</li><li>描述由一个<code>隐藏的马尔可夫链</code>随机生成<code>不可观测的状态随机序列</code>(state sequence)，再由各个状态生成一个观测而产生<code>观测随机序列</code>(observation sequence )的过程,序列的每一个位置又可以看作是一个时刻。</li></ul><p>设Q是所有可能状态的集合，V是所有可能观测的集合：</p><script type="math/tex; mode=display">Q=(q_{1},q_{2},...q_{N})和V=(v_{1},v_{2},...v_{M})</script><p>对于长度为T的状态序列I和观测序列O有：</p><script type="math/tex; mode=display">i=(i_{1},i_{2},...i_{T})和O=(o_{1},o_{2},...o_{T})</script><p>其中:</p><ul><li>状态转移概率矩阵$A=(a<em>{ij})</em>{N\times N}\qquad i,j\epsilon (1,N)$。$a_{ij}$表示t时刻状态$q_i$转移到t+1时刻$q_j$的概率</li><li>观测概率（发射概率）矩阵$B=[b<em>{j}(k)]</em>{N\times M} \quad j\epsilon (1,N)k\epsilon (1,M)$。$b_{j}(k)$表示t时刻状态$q_i$生成观测$v_k$的概率。&lt;/font&gt;</li><li>初始状态概率向量$\pi =(\pi <em>{i})=P(i</em>{1}=q_{i})\quad i\epsilon (1,N)$。表示初始时刻处于状态$q_i$的概率。<br><img src="https://img-blog.csdnimg.cn/82df5f741379490f83e123408e52d70d.png" alt="在这里插入图片描述"></li><li>隐状态节点$i<em>t$在A的指导下生成下一个隐状态节点$i</em>{t+1}$，并且$i_t$在B的指导下生成观测节点$o_t$ , 并且我只能观测到序列O。</li><li>根据概率图分类，可以看到HMM属于有向图，并且是生成式模型，直接对联合概率分布建模:<br><img src="https://img-blog.csdnimg.cn/a468a47db0c34f2db5239e2c4bbf0d91.png" alt="在这里插入图片描述"><blockquote><p>只是我们都去这么来表示HMM是个生成式模型,实际不这么计算。</p><h3 id="2-2-HMM三要素和两个基本假设"><a href="#2-2-HMM三要素和两个基本假设" class="headerlink" title="2.2 HMM三要素和两个基本假设"></a>2.2 HMM三要素和两个基本假设</h3></blockquote></li></ul><ol><li>HMM由<code>初始状态概率向量π、状态转移概率矩阵A、 观测概率矩阵B</code>三元素构成。<br>所以HMM模型$\lambda$可以写成：$\lambda =(A,B,\pi)$。<code>三者共同决定了隐藏的马尔可夫链生成不可观测的状态序列</code>。而状态序列和矩阵B综合产生观测序列。</li><li>HMM模型基本假设<ul><li>齐次马尔科夫性假设：隐马尔可夫链任意时刻t的状态只依赖前一时刻t-1的状态，即$P(i<em>{t}|i</em>{i-1})$。&lt;/font&gt;</li><li>观测独立性假设：任意时刻的观测只依赖当前时刻的状态，即$P(o<em>{t}|i</em>{i})$。&lt;/font&gt;</li></ul></li></ol><h3 id="2-3-HMM三个基本问题"><a href="#2-3-HMM三个基本问题" class="headerlink" title="2.3 HMM三个基本问题"></a>2.3 HMM三个基本问题</h3><ol><li>概率计算：给定模型$\lambda =(A,B,\pi)$和观测序列O，计算观测序列O出现的概率$P(O|\lambda)$。</li><li>学习问题：已知观测序列O，用最大似然估计的方法计算模型$\lambda =(A,B,\pi)$的参数。（该模型下观测序列O的概率最大）</li><li>预测（解码）问题：已知模型$\lambda =(A,B,\pi)$和观测序列，求最有可能的对应状态序列。</li></ol><ul><li>==HMM可以用于序列标记，观测序列O为tokens，状态序列I为其对应的标记。此时问题是给定序列O预测对应序列I。==</li><li>问题2对应模型建立过程，问题3 对应解码过程（crf.decode）<h3 id="2-4-HMM基本解法"><a href="#2-4-HMM基本解法" class="headerlink" title="2.4 HMM基本解法"></a>2.4 HMM基本解法</h3><h4 id="2-4-1-极大似然估计（根据I和O求λ）"><a href="#2-4-1-极大似然估计（根据I和O求λ）" class="headerlink" title="2.4.1 极大似然估计（根据I和O求λ）"></a>2.4.1 极大似然估计（根据I和O求λ）</h4>一般做NLP的序列标注等任务，在训练阶段肯定是有隐状态序列的，即根据观测序列O和状态序列I求模型$\lambda =(A,B,\pi)$的参数，是一个有监督学习。</li></ul><ol><li>根据状态序列求状态转移矩阵A：<script type="math/tex; mode=display">\mathbf{a_{ij}=\frac{A_{ij}}{\sum_{j=1}^{N}A_{ij}}}</script></li><li>根据状态序列I和观测序列O求观测概率矩阵B：<script type="math/tex; mode=display">\mathbf{b_{j}(k)=\frac{B_{jk}}{\sum_{k=1}^{M}B_{jk}}}</script></li><li>直接估计π<h4 id="2-4-2-前向后向算法（没有I）"><a href="#2-4-2-前向后向算法（没有I）" class="headerlink" title="2.4.2 前向后向算法（没有I）"></a>2.4.2 前向后向算法（没有I）</h4>只有观测序列O，没有状态序列I，无监督过程。计算就是一个就EM的过程。<br><img src="https://img-blog.csdnimg.cn/1d4febff1b6043bda7cc7d466111afe4.png" alt=""><h4 id="2-4-3-序列标注（解码）过程"><a href="#2-4-3-序列标注（解码）过程" class="headerlink" title="2.4.3 序列标注（解码）过程"></a>2.4.3 序列标注（解码）过程</h4></li></ol><ul><li>学习完了HMM的分布参数，也就确定了一个HMM模型。序列标注问题也就是“预测过程”(解码过程)。对应了序列建模问题3。</li><li>学习后已知了 联合概率P(I,O),现在要求出条件概率P(I|O)：<script type="math/tex; mode=display">I_{max}=\underset{all I}{argmax}\frac{P(I,O)}{P(O)}</script></li><li>用Viterbi算法解码，在给定的观测序列下找出一条概率最大的隐状态序列。&lt;/font&gt;</li><li>Viterbi计算有向无环图的一条最大路径，用DP思想减少重复的计算。如图：<br><img src="https://img-blog.csdnimg.cn/8c629c14f21748149969da86a07b677d.png" alt="在这里插入图片描述"><h2 id="三、最大熵马尔科夫MEMM模型"><a href="#三、最大熵马尔科夫MEMM模型" class="headerlink" title="三、最大熵马尔科夫MEMM模型"></a>三、最大熵马尔科夫MEMM模型</h2><h3 id="3-1-MEMM原理和区别"><a href="#3-1-MEMM原理和区别" class="headerlink" title="3.1 MEMM原理和区别"></a>3.1 MEMM原理和区别</h3>MEMM是判别式模型，直接对条件概率建模：<br><img src="https://img-blog.csdnimg.cn/9f9ee1ef4db54e94826a3f87bf85770e.png" alt="在这里插入图片描述"><br>MEMM需要注意：</li></ul><ol><li><p>HMM是$o<em>t$只依赖当前时刻的隐藏状态$i_t$，HEMM是当前时刻隐状态$i_t$依赖观测节点$o_t$和上一时刻状态$i</em>{t-1}$。&lt;/font&gt;</p></li><li><p><code>判别式模型是用函数直接判别，学习边界，MEMM即通过特征函数来界定</code>。HMM是生成式模型，参数即为各种概率分布元参数，数据量足够可以用最大似然估计。但同样，MEMM也有极大似然估计方法、梯度下降、牛顿迭代发、拟牛顿下降、BFGS、L-BFGS等等</p></li><li>需要注意，之所以图的箭头这么画，是由MEMM的公式决定的，而公式是creator定义出来的。</li><li>序列标注解码时，一样用维特比算法求概率最大的隐状态序列。</li></ol><ul><li>HMM中，观测节点$o_t$只依赖当前时刻的隐藏状态$i_t$。</li><li>更多的实际场景下，观测序列是需要很多的特征来刻画的。比如说，我在做NER时，我的标注$i<em>t$不仅跟当前状态 $o_t$相关，而且还跟前后标注 $i</em>{j}(j≠i)$相关，比如字母大小写、词性等等。&lt;/font&gt;</li><li>MEMM模型:允许“定义特征”，直接学习条件概率&lt;/font&gt;，即：<br><img src="https://img-blog.csdnimg.cn/87be161d470f4af4ba6e3a6a69fbce8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>$Z(o,i{}’)$：归一化系数</li><li>$f(o,i)$：特征函数，需要自定义，其个数可任意制定</li><li>λ：特征函数系数，需要训练得到<br><img src="https://img-blog.csdnimg.cn/09d86caafb094b6f8a63771e7e77e4e5.png" alt="在这里插入图片描述"><h3 id="3-2-标注偏置"><a href="#3-2-标注偏置" class="headerlink" title="3.2 标注偏置"></a>3.2 标注偏置</h3><img src="https://img-blog.csdnimg.cn/a42fb328efa94ae4b8898d3169acd9db.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>用Viterbi算法解码MEMM，状态1倾向于转换到状态2，同时状态2倾向于保留在状态2。 过程细节：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">P(<span class="number">1</span>-&gt; <span class="number">1</span>-&gt; <span class="number">1</span>-&gt; <span class="number">1</span>)= <span class="number">0.4</span> x <span class="number">0.45</span> x <span class="number">0.5</span> = <span class="number">0.09</span> ，</span><br><span class="line">P(<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>)= <span class="number">0.2</span> X <span class="number">0.3</span> X <span class="number">0.3</span> = <span class="number">0.018</span>，</span><br><span class="line">P(<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>)= <span class="number">0.6</span> X <span class="number">0.2</span> X <span class="number">0.5</span> = <span class="number">0.06</span>，</span><br><span class="line">P(<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>)= <span class="number">0.4</span> X <span class="number">0.55</span> X <span class="number">0.3</span> = <span class="number">0.066</span> </span><br></pre></td></tr></table></figure><p>但是得到的最优的状态转换路径是1-&gt;1-&gt;1-&gt;1，<br>为什么呢？因为状态2可以转换的状态比状态1要多，从而使转移概率降低,即MEMM倾向于选择拥有更少转移的状态&lt;/font&gt;。原因如下：</p><p><img src="https://img-blog.csdnimg.cn/d8f64347c3df42a58170e7768592096d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="四、条件随机场CRF"><a href="#四、条件随机场CRF" class="headerlink" title="四、条件随机场CRF"></a>四、条件随机场CRF</h2><h3 id="4-1-CRF定义"><a href="#4-1-CRF定义" class="headerlink" title="4.1 CRF定义"></a>4.1 CRF定义</h3><ol><li>条件随机场：给定随机变量X条件下，输出随机变量Y的条件概率模型，其中Y构成无向图G=(V,E)表示的马尔科夫随机场。&lt;/font&gt;&lt;/font &gt;<br>对任意节点v，条件随机场满足：<script type="math/tex; mode=display">P(Y_{v}|X,Y_{w},w\neq v)=P(Y_{v}|X,Y_{w},w\sim v)</script>w≠ v表示v之外的所有结点，w~v表示与v有边相连的所有结点。即$P(Y_{v}$之和与v有边连接的结点有关。</li><li><code>线性链条件随机场，最大团是相邻两个结点的集合</code>。满足马尔科夫性(隐状态只和前后时刻状态有关）：<script type="math/tex; mode=display">P(Y_{i}|X,Y_{1},Y_{2}...Y_{n})=P(Y_{i}|X,Y_{i+1},Y_{i-1})</script></li><li><p>线性链CRF是判别模型，学习方法是利用训练数据的（正则化）极大似然估计得到条件概率模型P(Y|X)。可用于序列标注问题。此时条件概率P(Y|X)中：</p><ul><li>Y为输出变量，即标记序列（状态序列）</li><li>X为输入变量，即需要标注的状态序列。</li></ul></li><li><p>预测时，对于给定输入序列x，求出条件概率最大的输出序列y。<br><img src="https://img-blog.csdnimg.cn/8720f5b7ee7040339fd7e12f6cfee126.png" alt="在这里插入图片描述"></p><h3 id="4-2-线性链CRF的计算"><a href="#4-2-线性链CRF的计算" class="headerlink" title="4.2 线性链CRF的计算"></a>4.2 线性链CRF的计算</h3><p>概率无向图的联合概率分布可以在因子分解下表示为：<br><img src="https://img-blog.csdnimg.cn/984eb14e02934c4da21d22985b7d3255.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li>下标i表示我当前所在的节点（token）位置。&lt;/font&gt;</li><li>下标k表示我这是第几个特征函数&lt;/font&gt;，并且每个特征函数都附属一个权重$\lambda_{k}$ 。&lt;/font&gt;即每个团里面，我将为$token_i$构造M个特征，每个特征执行一定的限定作用，然后建模时我再为每个特征函数加权求和。 </li><li>Z(O)是用来归一化的，形成概率值。</li><li>$P(I|O)$表示了在给定的一条观测序列 O的条件下，我用CRF所求出来的隐状态序列$I=(i<em>{1},i</em>{2},…i_{T})$的概率。而至于观测序列 O，它可以是一整个训练语料的所有的观测序列；也可以是在推断阶段的一句sample。比如序列标注进行预测，最终选的是最大概率的那条（by viterbi）。</li><li>对于CRF，可以为他定义两款特征函数：转移特征&amp;状态特征。 我们将建模总公式展开：</li></ol><p><img src="https://img-blog.csdnimg.cn/bc28595886384e76ab860cf1eb9175d9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 转移特征针对的是前后token之间的限定。&lt;/font&gt;</p><p>为了简单起见，将转移特征和状态特征及其权值用统一符号表示。条件随机场简化公式如下：<br><img src="https://img-blog.csdnimg.cn/a407494d8818498dbde165b83a141b1a.png" alt="在这里插入图片描述"><br>再进一步理解的话，我们需要把特征函数部分抠出来：<br><img src="https://img-blog.csdnimg.cn/69ed4fa41ce64a27b87f8ecd717cf56d.png" alt="在这里插入图片描述"><br>我们为$token_i$打分，满足条件的就有所贡献。最后将所得的分数进行log线性表示，求和后归一化，即可得到概率值。<br>具体应用求解参考<a href="https://www.zhihu.com/question/35866596/answer/236886066?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1400823417357139968&amp;utm_content=group3_Answer&amp;utm_campaign=shareopn">《如何用简单易懂的例子解释条件随机场（CRF）模型？它和HMM有什么区别？》</a>。</p><h3 id="4-3-从公式到代码的理解"><a href="#4-3-从公式到代码的理解" class="headerlink" title="4.3 从公式到代码的理解"></a>4.3 从公式到代码的理解</h3><p>实际计算时，采用概率的对数形式，即logP(Y)。使用最大似然估计来计算分布的参数，即我们的目标就是最大化ogP(Y)。<br><img src="https://img-blog.csdnimg.cn/12330b71b141418f9fb7cc3ec9039943.png" alt="在这里插入图片描述"><br>即$-logP(Y)=logZ(x)-score$。<br>对应到代码中，forward_score 就是$logZ(x)$，gold_score就是特征函数部分的score。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">neg_log_likelihood</span>(<span class="params">self, sentence, tags</span>):</span></span><br><span class="line">    feats = self._get_lstm_features(sentence)</span><br><span class="line">    forward_score = self._forward_alg(feats)</span><br><span class="line">    gold_score = self._score_sentence(feats, tags)</span><br><span class="line">    <span class="keyword">return</span> forward_score - gold_score</span><br></pre></td></tr></table></figure></p><ul><li>因为模型建立的初衷就是要考虑到$i<em>{k-1}$对$i</em>{k}$的影响和X对观测序列的影响.所以我们将图分解成若干个$(i<em>{k-1},i</em>{k},X)$。</li><li>其中$i<em>{k}$表示观测变量的状态值，比如在BIO标注中状态取值范围是{B,I,O,START,STOP}，则k最大取5，$i</em>{k}$有5个状态值可取。<br><img src="https://img-blog.csdnimg.cn/6081457d466243bbbbf3e97d99cd0e9b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>只关注其中的某一个团$C<em>i$,特征函数部分的gold_score表示给定序列X下，表现出的$(i</em>{k-1}，i_{k})$的费归一化概率，与两个东西有关：</li></ul><ol><li>给定序列X下出现$i<em>{k}$的概率，以$h(i</em>{k},X)$表示。这个概率使用lstm、cnn建模X对$i_{k})$映射就可以得到，对应结点上的状态特征。</li><li>给定序列X下由$i<em>{k-1}$转移到$i</em>{k}$的概率，由$g(i<em>{k-1},i</em>{k};X)$表示，对应边上的转移特征。在CRF中，观测变量只受临近节点的影响。</li><li>考虑到深度学习模型已经能比较充分捕捉各个$i<em>{k}$与X 的联系，所以假设 $i</em>{k-1}$ 转移到$i<em>{k}$的概率与X无关，所以有：$g(i</em>{k-1},i<em>{k};X)=g(i</em>{k-1},i_{k})$</li></ol><p>考虑以上几点，可以得到：</p><script type="math/tex; mode=display">gold-score=\sum_{c}\sum_{k}\lambda _{k}f_{k}(c,y,x)=\sum_{c}\sum_{k}(g(i_{k-1},i_{k})+h(i_{k},X))</script><p>剩下计算过程参考：<a href="https://zhuanlan.zhihu.com/p/178731739?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1400823417357139968&amp;utm_campaign=shareopn">《条件随机场CRF之从公式到代码》</a><br><img src="https://img-blog.csdnimg.cn/b2612debc2c94e7fbdcaf918a69bc0a7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="五、-HMM-vs-MEMM-vs-CRF"><a href="#五、-HMM-vs-MEMM-vs-CRF" class="headerlink" title="五、 HMM vs. MEMM vs. CRF"></a>五、 HMM vs. MEMM vs. CRF</h2><h3 id="5-1-HMM-vs-MEMM"><a href="#5-1-HMM-vs-MEMM" class="headerlink" title="5.1 HMM vs MEMM"></a>5.1 HMM vs MEMM</h3><p>HMM模型中存在两个假设：一是输出观察值之间严格独立，二是状态的转移过程中<code>当前状态只与前一状态有关</code>。但实际上序列标注问题不仅和单个词相关，而且和观察序列的长度，单词的上下文，等等相关。<code>MEMM解决了HMM输出独立性假设的问题</code>。因为HMM只限定在了观测与状态之间的依赖，而<code>MEMM引入自定义特征函数，不仅可以表达观测之间的依赖，还可表示当前观测与前后多个状态之间的复杂依赖</code>。</p><h3 id="5-2-MEMM-vs-CRF"><a href="#5-2-MEMM-vs-CRF" class="headerlink" title="5.2 MEMM vs CRF"></a>5.2 MEMM vs CRF</h3><p>CRF不仅解决了HMM输出独立性假设的问题，还解决了MEMM的标注偏置问题，<code>MEMM容易陷入局部最优是因为只在局部做归一化，而CRF统计了全局概率，在做归一化时考虑了数据在全局的分布</code>，而不是仅仅在局部归一化，这样就解决了MEMM中的标记偏置的问题。使得序列标注的解码变得最优解。HMM、MEMM属于有向图，所以考虑了x与y的影响，但没将x当做整体考虑进去（这点问题应该只有HMM）。CRF属于无向图，没有这种依赖性，克服此问题。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考文章&lt;a href=&quot;https://www.zhihu.com/question/35866596/answer/236886066?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=1400823417357139968&amp;amp;utm_content=group3_Answer&amp;amp;utm_campaign=shareopn&quot;&gt;《如何用简单易懂的例子解释条件随机场（CRF）模型？它和HMM有什么区别？》&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/178731739?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=1400823417357139968&amp;amp;utm_campaign=shareopn&quot;&gt;《条件随机场CRF之从公式到代码》&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/148813079?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=1400823417357139968&amp;amp;utm_campaign=shareopn&quot;&gt;《CRF条件随机场的原理、例子、公式推导和应用》&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://zhxnlp.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="CRF" scheme="https://zhxnlp.github.io/tags/CRF/"/>
    
    <category term="机器学习" scheme="https://zhxnlp.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="统计学习方法" scheme="https://zhxnlp.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>task3：新闻推荐系统项目调试</title>
    <link href="https://zhxnlp.github.io/2021/12/17/12%E6%9C%88%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/task3%EF%BC%9A%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    <id>https://zhxnlp.github.io/2021/12/17/12%E6%9C%88%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/task3%EF%BC%9A%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</id>
    <published>2021-12-16T17:08:37.000Z</published>
    <updated>2022-01-02T20:50:36.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-项目运行环境"><a href="#0-项目运行环境" class="headerlink" title="0    项目运行环境"></a>0    项目运行环境</h2><p>0.1    获取软件安装包<br>软件安装包地址：<a href="https://share.weiyun.com/u3ZIjZfg">https://share.weiyun.com/u3ZIjZfg</a><br> <span id="more"></span><br>0.2    使用软件版本<br>操作系统：Windows10<br>MySQL：8.0.25<br>Redis：5.0.14<br>Mongodb：5.0.5<br>Mini-Conda Python 3.8<br>Node.js：16.13.1<br>前端IDE：WebStorm 2021.1<br>后端IDE：PyCharm Professional 2021.1<br>访问MySQL和Mongodb的数据库工具：DataGrip 2021.1<br>访问Redis的工具：redis-desktop-manager-0.9.9.99.exe</p><h2 id="1-项目下载与IDE导入"><a href="#1-项目下载与IDE导入" class="headerlink" title="1    项目下载与IDE导入"></a>1    项目下载与IDE导入</h2><p>项目地址：<br><a href="https://github.com/datawhalechina/fun-rec">https://github.com/datawhalechina/fun-rec</a><br>1.1    前端项目导入<br>使用WebStrom IDE工具，导入前端项目</p><p>1.2    后端项目导入<br>使用PyCharm IDE工具，导入后端项目</p><h2 id="2-数据库安装与使用（Windows10）"><a href="#2-数据库安装与使用（Windows10）" class="headerlink" title="2    数据库安装与使用（Windows10）"></a>2    数据库安装与使用（Windows10）</h2><h3 id="2-1-MySQL数据库安装与使用"><a href="#2-1-MySQL数据库安装与使用" class="headerlink" title="2.1    MySQL数据库安装与使用"></a>2.1    MySQL数据库安装与使用</h3><p>卸载mysql：<a href="https://blog.csdn.net/dh12313012/article/details/87274385?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163976655316780269838594%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163976655316780269838594&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-87274385.pc_search_insert_es_download_v2&amp;utm_term=centos%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BDmysql&amp;spm=1018.2226.3001.4187">帖子1</a>、<a href="https://blog.csdn.net/weixin_44443884/article/details/106231811?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163976655316780269838594%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163976655316780269838594&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-106231811.pc_search_insert_es_download_v2&amp;utm_term=centos%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BDmysql&amp;spm=1018.2226.3001.4187">帖子2</a><br>参考胡瑞峰文档和帖子<a href="https://blog.csdn.net/hu10131013/article/details/107711192?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163957716016780269846658%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163957716016780269846658&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-107711192.pc_search_insert_es_download_v2&amp;utm_term=windows%E5%AE%89%E8%A3%85mysql&amp;spm=1018.2226.3001.4187">《Windows环境安装 安装mysql-8.0.18-winx64详细图解(zip包版本)》</a></p><p>2.0 centos装的mysql8无法启动，运行<code>service mysql start</code>显示这个命令找不到</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不装这个下面安装报错，缺少安装包</span></span><br><span class="line">wget http://www.percona.com/redir/downloads/Percona-XtraDB-Cluster/<span class="number">5.5</span><span class="number">.37</span>-<span class="number">25.10</span>/RPM/rhel6/x86_64/Percona-XtraDB-Cluster-shared-<span class="number">55</span>-<span class="number">5.5</span><span class="number">.37</span>-<span class="number">25.10</span><span class="number">.756</span>.el6.x86_64.rpm</span><br><span class="line">rpm -ivh Percona-XtraDB-Cluster-shared-<span class="number">55</span>-<span class="number">5.5</span><span class="number">.37</span>-<span class="number">25.10</span><span class="number">.756</span>.el6.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install -y mariadb-server</span><br></pre></td></tr></table></figure><h4 id="2-1-1-MySQL数据库安装"><a href="#2-1-1-MySQL数据库安装" class="headerlink" title="2.1.1    MySQL数据库安装"></a>2.1.1    MySQL数据库安装</h4><p>（1）安装包下载<br>下载地址：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a><br>安装包版本：8.0.25</p><p>（2）配置环境变量<br>变量名：MYSQL_HOME<br>变量值：D:\mysql-8.0.25-winx64<br>在桌面上点击”此电脑–右击–选择属性–选择高级–环境变量”，上方点新建系统变量</p><p> <img src="https://img-blog.csdnimg.cn/70bb500defa44234bacf8095ed29e9e7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>在下方环境变量PATH添加：%MYSQL_HOME%\bin<br> <img src="https://img-blog.csdnimg.cn/2ed4bd1facab45aaa5f5f31c4bfa10bb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>（3）生成data文件<br>在解压后mysql-8.0.18-winx64的文件下创建my.ini配置文件<br>具体内容如下<br>将下面的内容复制到刚创建的文件中 ，主要需要修改的字段为basedir和datadir<br>basedir=自己的mysql目录<br>datadir=mysql的data存储的目录</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line">port=<span class="number">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line">basedir=D:/Java/Database/mysql-<span class="number">8.0</span><span class="number">.18</span>-winx64</span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录 (data文件夹如果没有的话会自动创建)</span></span><br><span class="line">datadir=D:/Java/Database/mysql-<span class="number">8.0</span><span class="number">.18</span>-winx64/data</span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line">max_connections=<span class="number">200</span></span><br><span class="line"><span class="comment"># 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统</span></span><br><span class="line">max_connect_errors=<span class="number">10</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为UTF8</span></span><br><span class="line">character-<span class="built_in">set</span>-server=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"><span class="comment"># 默认使用“mysql_native_password”插件认证</span></span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">[mysql]</span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-<span class="built_in">set</span>=utf8</span><br><span class="line">[client]</span><br><span class="line"><span class="comment"># 设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line">port=<span class="number">3306</span></span><br><span class="line">default-character-<span class="built_in">set</span>=utf8</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/691660bdac224b65999438778b5a2136.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>打开CMD，进入D:\mysql-8.0.25-winx64\bin目录，执行如下命令初始化创建data目录。<br>cd D:\mysql-8.0.25-winx64\bin<br>mysqld —initialize-insecure —user=mysql</p><p>（5）启动MySQL服务，并配置成系统服务<br><img src="https://img-blog.csdnimg.cn/a03d94e194ac4975806f082908c1b9dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>使用系统管理员身份，启动CMD，执行如下命令将MySQL配置成Windows系统服务：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysqld -install --serviceName <span class="string">&quot;MySQL&quot;</span></span><br><span class="line">Service successfully installed.</span><br></pre></td></tr></table></figure><p>安装mysql服务方便以后启动：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D:\Java\Database\mysql-<span class="number">8.0</span><span class="number">.18</span>-winx64\<span class="built_in">bin</span>&gt;mysqld.exe install mysql</span><br><span class="line">Service successfully installed</span><br></pre></td></tr></table></figure><p>在服务列表中能找到刚刚安装的mysql服务，可设置其启动的方式 </p><p>右键单击此电脑打开任务管理器的服务，启动MySQL服务。<br> <img src="https://img-blog.csdnimg.cn/dea6a6cef5d4492aa5941fe029a440f6.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/b425fee1e9a44921807b7f3df002101a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><code>net start mysql</code>：启动mysql服务<br><code>net stop mysql</code>： 停止mysql服务</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动mysql服务需要使用管理员角色</span></span><br><span class="line"><span class="comment"># 通过net start命令启动mysql服务 (net stop mysql --终止mysql服务命令)</span></span><br><span class="line">  D:\Java\Database\mysql-<span class="number">8.0</span><span class="number">.18</span>-winx64\<span class="built_in">bin</span>&gt;net start mysql</span><br><span class="line">  mysql 服务正在启动 .</span><br><span class="line">  mysql 服务已经启动成功</span><br></pre></td></tr></table></figure><h4 id="2-1-2-设置root用户密码"><a href="#2-1-2-设置root用户密码" class="headerlink" title="2.1.2    设置root用户密码"></a>2.1.2    设置root用户密码</h4><p>（1）登录MySQL<br>在CMD中，输入以下命令登录MySQL（新安装的MySQL，可以无密码登录）：<br><code>mysql -u root</code> -p</p><p>（2）设置root用户密码<br>输入如下命令，键入回车后执行SQL语句，设置root用户密码为123456：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure><p>（3）刷新保存配置<br>输入如下命令，保存配置并生效：<code>flush privileges;</code><br>输入<code>quit</code>退出数据库。</p><h4 id="2-1-3-使用DataGrip连接MySQL数据库"><a href="#2-1-3-使用DataGrip连接MySQL数据库" class="headerlink" title="2.1.3    使用DataGrip连接MySQL数据库"></a>2.1.3    使用DataGrip连接MySQL数据库</h4><p>DataGrip2021安装参考<a href="https://blog.csdn.net/qq_31762741/article/details/115134775?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163957944416780265418841%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163957944416780265418841&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-115134775.pc_search_insert_es_download_v2&amp;utm_term=datagrip%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&amp;spm=1018.2226.3001.4187">帖子1</a>、<a href="https://blog.csdn.net/weixin_45078818/article/details/116054375?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163957944416780265418841%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163957944416780265418841&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-116054375.pc_search_insert_es_download_v2&amp;utm_term=datagrip%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&amp;spm=1018.2226.3001.4187">帖子2</a>。<br>（1）打开DataGrip工具，新建MySQL连接</p><p><img src="https://img-blog.csdnimg.cn/2c81891e8fa144e293df9d0fbdc37cf2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>（2）配置MySQL连接<br> <img src="https://img-blog.csdnimg.cn/0f8c2899749f493195e7b5f486b8dd56.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>（3）连接MySQL数据库<br>第一次连接mysql会报错，提示你缺少驱动，点击Download Driver Files就会自动帮你安装连接驱动。<img src="https://img-blog.csdnimg.cn/09b34b59e4e34be7a5fec1394f5dd1fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>（4）更换中文语言教程，参考<a href="https://blog.csdn.net/qq_31762741/article/details/115134775?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163957944416780265418841%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163957944416780265418841&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-115134775.pc_search_insert_es_download_v2&amp;utm_term=datagrip%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&amp;spm=1018.2226.3001.4187">此贴</a>。<br>（5）创建userinfo和loginfo数据库<br>新建一个console窗口，在mysql窗口中输入如下SQL语句，创建数据库：<br>create database userinfo;<br>create database loginfo;<br>（此时不能创建mongodb连接，因为还没装mongodb，也没有启动。装了也连不上）</p><p>2.2    MongoDB数据库安装与使用<br>参考帖子<a href="https://blog.csdn.net/qq_46092061/article/details/119811965?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163958533516780271568946%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163958533516780271568946&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-119811965.pc_search_insert_es_download_v2&amp;utm_term=windows%E9%85%8D%E7%BD%AEmongodb%E6%95%99%E7%A8%8B&amp;spm=1018.2226.3001.4187">《【2021/8/19-最新教程】Windows安装MongoDB及配置（超详细）》</a><br>2.2.1    MongoDB数据库安装<br>（1）安装包下载<br>下载地址：<a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a><br>安装包版本：5.0.5</p><p>（2）配置环境变量<br>在PATH下添加环境变量：D:\mongodb-win32-x86_64-windows-5.0.5\bin</p><p>（3）创建目录及配置文件<br>在bin目录同级的目录创建data目录，继续在data目录下创建db以及log，log目录中还需要创建mongod.log文件。<br> <img src="https://img-blog.csdnimg.cn/b03fdda88be74e648b00a70204c5cfd5.png" alt="在这里插入图片描述"></p><p>然后在bin目录的同级目录创建mongod.cfg文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">    destination: file</span><br><span class="line">    path: D:\mongodb-win32-x86_64-windows-<span class="number">5.0</span><span class="number">.5</span>\data\log\mongod.log</span><br><span class="line">storage:</span><br><span class="line">    dbPath: D:\mongodb-win32-x86_64-windows-<span class="number">5.0</span><span class="number">.5</span>\data\db</span><br><span class="line">net:</span><br><span class="line">    port: <span class="number">27017</span></span><br></pre></td></tr></table></figure><ul><li>path是配置打印日志的目录</li><li>dbpath是配置数据的存储位置</li><li>port是配置的端口号</li></ul><p>（4）启动MongoDB服务，并配置成系统服务</p><p>使用系统管理员身份，启动CMD，在D:\mongodb-win32-x86_64-windows-5.0.5\bin目录下执行如下命令将MongoDB配置成Windows系统服务：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mongod --config D:\mongodb-win32-x86_64-windows-<span class="number">5.0</span><span class="number">.5</span>\mongod.cfg --install --serviceName <span class="string">&quot;MongoDB&quot;</span></span><br></pre></td></tr></table></figure></p><p>打开任务管理器的服务，查看MongoDB服务。<br> 此时就可以通过<code>net start MongoDB</code>和<code>net stop MongoDB</code>以及<code>net delete MongoDB</code>开启、关闭、删除MongoDB。</p><p>2.2.2    使用DataGrip连接MongoDB数据库<br>（1）打开DataGrip工具，新建MongoDB连接</p><p>（2）配置MongoDB连接</p><p>（3）连接MongoDB数据库<br>连接MongoDB数据库，在console中输入语句创建两个库（由于库中没有数据，在MongoDB中还看不到这两个库，等完成项目部署并运行调试之后，刷新MongoDB之后会出来这两个库）：<br>use NewsRecSys;<br>use SinaNews;</p><h3 id="2-3-Redis数据库安装与使用"><a href="#2-3-Redis数据库安装与使用" class="headerlink" title="2.3    Redis数据库安装与使用"></a>2.3    Redis数据库安装与使用</h3><p>2.3.1    Redis数据库安装<br>（1）安装包下载<br>下载地址：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a><br>安装包版本：5.0.14</p><p>（2）启动Redis服务，并配置成系统服务<br>使用系统管理员身份，启动CMD，执行如下命令将Redis配置成Windows系统服务：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd D:\Redis-x64-<span class="number">5.0</span><span class="number">.14</span><span class="comment">#命令地址</span></span><br><span class="line">redis-server.exe --service-install redis.windows.conf --serviceName <span class="string">&quot;Redis5.0.14&quot;</span></span><br><span class="line"><span class="comment">#或者运行下面这个</span></span><br><span class="line">redis-server --service-install redis.windows.conf --loglevel verbose</span><br></pre></td></tr></table></figure><p>打开任务管理器的服务，查看Redis服务。</p><p>启动Redis：<code>net start Redis</code></p><h4 id="2-3-2-使用redis-desktop-manager连接Redis数据库"><a href="#2-3-2-使用redis-desktop-manager连接Redis数据库" class="headerlink" title="2.3.2    使用redis-desktop-manager连接Redis数据库"></a>2.3.2    使用redis-desktop-manager连接Redis数据库</h4><blockquote><p>参考<a href="https://blog.csdn.net/weixin_40668023/article/details/91905748?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Redis%20Desktop%20Manager%E6%95%99%E7%A8%8B&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-91905748.pc_search_insert_es_download_v2&amp;spm=1018.2226.3001.4187">《Redis可视化工具Redis Desktop Manager使用教程》</a><br><a href="https://blog.csdn.net/weixin_33859504/article/details/93832144?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163958926516780255243373%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163958926516780255243373&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-93832144.pc_search_insert_es_download_v2&amp;utm_term=Redis%20Desktop%20Manager%E6%95%99%E7%A8%8B&amp;spm=1018.2226.3001.4187">《Redis DeskTop Manager 使用教程》</a></p></blockquote><p>（1）安装Redis Desktop Manager软件<br>下载地址：从腾讯微云中获取，参见0.1节</p><p>（2）连接Redis数据库<br> <img src="https://img-blog.csdnimg.cn/2b34a7914af54615bf17a245e738a4b8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 最后点ok就行。点击左侧Redis-@localhost出现下拉列表：<br><img src="https://img-blog.csdnimg.cn/332005dea44d4513b09e0d126f8e5e33.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="3-前端项目运行"><a href="#3-前端项目运行" class="headerlink" title="3    前端项目运行"></a>3    前端项目运行</h2><p><a href="https://blog.csdn.net/xudali_1012/article/details/117534094?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163959359416780274139155%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163959359416780274139155&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-117534094.pc_search_insert_es_download_v2&amp;utm_term=webstorm%E5%AE%89%E8%A3%85&amp;spm=1018.2226.3001.4187">安装WebStorm-2021</a><br><img src="https://img-blog.csdnimg.cn/122c2d83f4484699a0adfefe7aa58c84.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>导入前端项目：open打开vue文件夹就行<br><img src="https://img-blog.csdnimg.cn/a39350a1ceac4cf5b27541f3c675f4e2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="3-1-安装依赖包"><a href="#3-1-安装依赖包" class="headerlink" title="3.1    安装依赖包"></a>3.1    安装依赖包</h3><p>安装<br>安装node<br><img src="https://img-blog.csdnimg.cn/bbad58c531214107817c7e3a0406a0b4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>首先安装淘宝的npm，在Terminal中执行如下命令：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm install</span><br></pre></td></tr></table></figure><h3 id="3-2-修改前端访问IP和端口"><a href="#3-2-修改前端访问IP和端口" class="headerlink" title="3.2    修改前端访问IP和端口"></a>3.2    修改前端访问IP和端口</h3><p>打开文件package.json，修改第49行的IP和端口，修改内容如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --open --port 8686 --contentBase src --hot --host 0.0.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;nodemon src/main.js&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">#锐锋是127.0.0.1</span></span><br></pre></td></tr></table></figure><p>127.0.0.1表示游览器的访问IP（也称为本地IP），8686表示访问端口</p><h3 id="3-3-修改访问后端API接口的IP和端口"><a href="#3-3-修改访问后端API接口的IP和端口" class="headerlink" title="3.3    修改访问后端API接口的IP和端口"></a>3.3    修改访问后端API接口的IP和端口</h3><p>打开文件main.js，文件路径：src/main.js，修改第23行的IP和端口，修改内容如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// Vue.prototype.$http = axios</span><br><span class="line">Vue.use(VueAxios, axios);</span><br><span class="line">// axios公共基路径，以后所有的请求都会在前面加上这个路径</span><br><span class="line">// axios.defaults.baseURL = <span class="string">&quot;http://10.170.4.60:3000&quot;</span>;</span><br><span class="line">// axios.defaults.baseURL = <span class="string">&quot;http://47.108.56.188:3000&quot;</span>;</span><br><span class="line">axios.defaults.baseURL = <span class="string">&quot;http://127.0.0.1:5000&quot;</span></span><br></pre></td></tr></table></figure><p>127.0.0.1表示后端项目的访问IP（也称为本地IP），5000表示访问端口</p><h3 id="3-4-运行前端项目"><a href="#3-4-运行前端项目" class="headerlink" title="3.4    运行前端项目"></a>3.4    运行前端项目</h3><p>在Terminal中执行命令运行前端项目:<code>npm run dev</code><br><img src="https://img-blog.csdnimg.cn/0993baf2421249babfed2927ecaeb7bf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>浏览器会自动访问地址：<a href="http://127.0.0.1:8686/#/">http://127.0.0.1:8686/#/</a><br><img src="https://img-blog.csdnimg.cn/83ecc2fc191940a3be7e5e1e9d5b34a1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>通过打开“开发者工具”，调节设备工具栏，显示正常比例的页面<br> <img src="https://img-blog.csdnimg.cn/59ef280c39df421d814fa4174b65f836.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="4-后端项目运行"><a href="#4-后端项目运行" class="headerlink" title="4    后端项目运行"></a>4    后端项目运行</h2><h3 id="4-1-配置环境-安装依赖"><a href="#4-1-配置环境-安装依赖" class="headerlink" title="4.1    配置环境,安装依赖"></a>4.1    配置环境,安装依赖</h3><ol><li>安装conda环境，并创建虚拟环境<br>创建指定路径的Python环境：<code>conda create --prefix venv python=3.8</code></li></ol><p>虚拟环境位置：<br><img src="https://img-blog.csdnimg.cn/f5457bb18bdd400383c037add2dc7b52.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>包装在libs下面的site-pakeages:<br><img src="https://img-blog.csdnimg.cn/6156da64eced4666966c649f2091d7c6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d54e9b59faaa44dbb4a1418d5103bfee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>在PyCharm中，设置Python解释器<br> <img src="https://img-blog.csdnimg.cn/c6c89560e48f47348d21338b5be58911.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li>安装依赖文件<br>在Terminal中执行命令安装依赖包：<code>pip install -r requirements.txt</code></li></ol><p><img src="https://img-blog.csdnimg.cn/6e4b9062a1064cfcbabc9aba8baf960e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="4-2-修改端口，配置文件"><a href="#4-2-修改端口，配置文件" class="headerlink" title="4.2 修改端口，配置文件"></a>4.2 修改端口，配置文件</h3><ol><li>修改后端项目的IP和端口<br>打开文件server.py，修改第233行的IP和端口，修改内容如下：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 允许服务器被公开访问</span></span><br><span class="line">    <span class="comment"># app.run(debug=True, host=&#x27;0.0.0.0&#x27;, port=3000, threaded=True)</span></span><br><span class="line">    <span class="comment"># 只能被自己的机子访问</span></span><br><span class="line">    app.run(debug=<span class="literal">True</span>, host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">5000</span>, threaded=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>127.0.0.1表示后端提供给前端的IP（也称为本地IP），5000表示端口。</p><ol><li>修改项目路径配置文件proj_path.py<br>因为没有配置home路径，所以改为读取项目地址。修改项目路径配置文件proj_path.py，文件路径：conf/proj_path.py</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># home_path = os.environ[&#x27;HOME&#x27;]</span></span><br><span class="line"><span class="comment"># proj_path = home_path + &quot;/fun-rec/codes/news_recsys/news_rec_server/&quot;</span></span><br><span class="line">proj_path = os.path.join(sys.path[<span class="number">1</span>], <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>核对数据库配置文件dao_config.py<br>打开数据库配置文件dao_config.py，文件路径：conf/dao_config.py，核对以下配置：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MySQL默认配置</span></span><br><span class="line">mysql_username = <span class="string">&quot;root&quot;</span></span><br><span class="line">mysql_passwd = <span class="string">&quot;123456&quot;</span></span><br><span class="line">mysql_hostname = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">mysql_port = <span class="string">&quot;3306&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MongoDB配置</span></span><br><span class="line">mongo_hostname = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">mongo_port = <span class="number">27017</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis配置</span></span><br><span class="line">redis_hostname = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">redis_port = <span class="number">6379</span></span><br></pre></td></tr></table></figure><h3 id="4-3-启动雪花算法服务"><a href="#4-3-启动雪花算法服务" class="headerlink" title="4.3     启动雪花算法服务"></a>4.3     启动雪花算法服务</h3><p>在Terminal中执行命令启动雪花算法服务，用于生成用户ID，启动命令如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">snowflake_start_server --address=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> --port=<span class="number">8910</span> --dc=<span class="number">1</span> --worker=<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="4-4-创建logs目录"><a href="#4-4-创建logs目录" class="headerlink" title="4.4    创建logs目录"></a>4.4    创建logs目录</h3><p>在根目录下，创建logs目录，如下图所示：<br><img src="https://img-blog.csdnimg.cn/3582ab8e23ff4b07b3a9989699e6c4d2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="4-5-启动后端项目"><a href="#4-5-启动后端项目" class="headerlink" title="4.5 启动后端项目"></a>4.5 启动后端项目</h3><p>启动server.py程序（注：在此之前，必须启动数据库并创建数据库，详见2.1.3节和2.2.2节），执行如下命令：<br>python server.py<br><img src="https://img-blog.csdnimg.cn/12c5b5947bd84a71aaab73cf9e51670e.png" alt="在这里插入图片描述"></p><h2 id="5-项目整体运行与调试"><a href="#5-项目整体运行与调试" class="headerlink" title="5    项目整体运行与调试"></a>5    项目整体运行与调试</h2><p>注册用户</p><h3 id="5-1-爬取新浪新闻"><a href="#5-1-爬取新浪新闻" class="headerlink" title="5.1    爬取新浪新闻"></a>5.1    爬取新浪新闻</h3><p>通过查看crawl_news.sh文件（文件路径：scheduler/crawl_news.sh），可知爬取新浪新闻的代码在如下目录<br>/materials/news_scrapy/sinanews/run.py<br>使用PyCharm的Run按钮，手动执行该代码，需要配置参数：<br>—pages=30</p><p><img src="https://img-blog.csdnimg.cn/3a0d7d8f91774f90b1ca2f709db08c52.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c65de70dd5f9404abdc7d56d20804897.png" alt="在这里插入图片描述"></p><h3 id="5-2-更新物料画像"><a href="#5-2-更新物料画像" class="headerlink" title="5.2    更新物料画像"></a>5.2    更新物料画像</h3><p>通过查看offline_material_and_user_process.sh文件（文件路径：scheduler/offline_material_and_user_process.sh），可知更新物料画像的代码在如下目录：<br>materials/process_material.py<br>使用PyCharm的Run按钮，手动执行该代码<br> <img src="https://img-blog.csdnimg.cn/17cd2ccaf3d94bf5ac8d8b93a167f6e5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="5-3-更新用户画像"><a href="#5-3-更新用户画像" class="headerlink" title="5.3    更新用户画像"></a>5.3    更新用户画像</h3><p>通过查看offline_material_and_user_process.sh文件（文件路径：scheduler/offline_material_and_user_process.sh），可知更新用户画像的代码在如下目录：<br>materials/process_user.py<br>使用PyCharm的Run按钮，手动执行该代码<br> <img src="https://img-blog.csdnimg.cn/ba2509dd448a450caff81142bfe76b6f.png" alt="在这里插入图片描述"></p><h3 id="5-4-清除前一天redis中的数据，更新最新今天最新的数据"><a href="#5-4-清除前一天redis中的数据，更新最新今天最新的数据" class="headerlink" title="5.4    清除前一天redis中的数据，更新最新今天最新的数据"></a>5.4    清除前一天redis中的数据，更新最新今天最新的数据</h3><p>通过查看offline_material_and_user_process.sh文件（文件路径：scheduler/offline_material_and_user_process.sh），可知清除前一天redis中的数据，更新最新今天最新的数据的代码在如下目录：<br>materials/update_redis.py<br>使用PyCharm的Run按钮，手动执行该代码</p><p><img src="https://img-blog.csdnimg.cn/f4265cf10e72450da4b50457a9c301c4.png" alt="在这里插入图片描述"></p><h3 id="5-5-离线将推荐列表和热门列表存入redis"><a href="#5-5-离线将推荐列表和热门列表存入redis" class="headerlink" title="5.5    离线将推荐列表和热门列表存入redis"></a>5.5    离线将推荐列表和热门列表存入redis</h3><p>通过查看run_offline.sh文件（文件路径：scheduler/run_offline.sh），可知离线将推荐列表和热门列表存入redis的代码在如下目录：<br>recprocess/offline.py<br>使用PyCharm的Run按钮，手动执行该代码<br> <img src="https://img-blog.csdnimg.cn/6fd3cdaa10e64cc19040601fa4313ea9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="5-6-重新登录用户查看新闻"><a href="#5-6-重新登录用户查看新闻" class="headerlink" title="5.6    重新登录用户查看新闻"></a>5.6    重新登录用户查看新闻</h3><p> <img src="https://img-blog.csdnimg.cn/65be2740b23243a6b677e8e0fad1f1b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0-项目运行环境&quot;&gt;&lt;a href=&quot;#0-项目运行环境&quot; class=&quot;headerlink&quot; title=&quot;0    项目运行环境&quot;&gt;&lt;/a&gt;0    项目运行环境&lt;/h2&gt;&lt;p&gt;0.1    获取软件安装包&lt;br&gt;软件安装包地址：&lt;a href=&quot;https://share.weiyun.com/u3ZIjZfg&quot;&gt;https://share.weiyun.com/u3ZIjZfg&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="12月组队学习：推荐系统" scheme="https://zhxnlp.github.io/categories/12%E6%9C%88%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="推荐系统" scheme="https://zhxnlp.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="数据库" scheme="https://zhxnlp.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="前端开发" scheme="https://zhxnlp.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>task2：新闻推荐系统项目搭建：centos下前端配置</title>
    <link href="https://zhxnlp.github.io/2021/12/16/12%E6%9C%88%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/task2%EF%BC%9A%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%EF%BC%9Acentos%E4%B8%8B%E5%89%8D%E7%AB%AF%E9%85%8D%E7%BD%AE/"/>
    <id>https://zhxnlp.github.io/2021/12/16/12%E6%9C%88%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/task2%EF%BC%9A%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%EF%BC%9Acentos%E4%B8%8B%E5%89%8D%E7%AB%AF%E9%85%8D%E7%BD%AE/</id>
    <published>2021-12-15T22:01:41.000Z</published>
    <updated>2021-12-31T23:24:30.237Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h2 id="0-解决npm命令语法不正确问题"><a href="#0-解决npm命令语法不正确问题" class="headerlink" title="0.解决npm命令语法不正确问题"></a>0.解决npm命令语法不正确问题</h2><h3 id="0-1-powershell报错"><a href="#0-1-powershell报错" class="headerlink" title="0.1  powershell报错"></a>0.1  powershell报错</h3><p><img src="https://img-blog.csdnimg.cn/2a4d50e19ca7476a8ac33976be4071c0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>解决方案：<br>根据上面提升报错的环境变量把环境变量Path中含有 ； 的分开写<br><span id="more"></span><br><img src="https://img-blog.csdnimg.cn/99d033d1644845a38a4ddf0fcda8e270.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li>第二个报错<br><img src="https://img-blog.csdnimg.cn/10342ec9d4534a2ea2828cf81b5953ef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ol><ul><li>PowerShell默认禁止运行脚本，但是因为安装Anaconda后再启动PowerShell时需要运行脚本，所以会报错。</li><li>以管理员身份运行PowerShell，执行 <code>set-ExecutionPolicy RemoteSigned</code>，然后输入 <code>Y</code>，重启PowerShell：<br><img src="https://img-blog.csdnimg.cn/cd8fb0e578a24c169c0592a9476b0281.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h3 id="0-2-win10家庭版升级"><a href="#0-2-win10家庭版升级" class="headerlink" title="0.2 win10家庭版升级"></a>0.2 win10家庭版升级</h3>参考帖子<a href="https://blog.csdn.net/weixin_30540691/article/details/101459865?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164069499916780265470211%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164069499916780265470211&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-101459865.pc_search_insert_es_download_v2&amp;utm_term=windows10%E6%BF%80%E6%B4%BB%E5%AF%86%E9%92%A5&amp;spm=1018.2226.3001.4187">《win10激活密钥》</a>。<br>专业版秘钥用不了，装的教育版。直接此电脑——右键属性——产品密钥，输入合适的密钥就安装对应的win10版本。（教育版：NW6C2-QMPVW-D7KKK-3GKT6-VCFB2）<br><img src="https://img-blog.csdnimg.cn/256f5169649c47089d4edf7832ce946f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>激活步骤：<br>管理员打开powershell，输入以下命令：（cmd打开会提示没有slmgr.vbs命令）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">slmgr.vbs /upk                               //卸载秘钥</span><br><span class="line">slmgr /ipk NW6C2-QMPVW-D7KKK-3GKT6-VCFB2     //产品密钥可用并且需要连接互联网</span><br><span class="line">slmgr /skms kms<span class="number">.03</span>k.org                     //指定KMS服务器的地址和端口,服务器地址和端口请根据实际情况修改。</span><br><span class="line">slmgr /ato                                  //进行激活</span><br></pre></td></tr></table></figure></li></ul><h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2><h3 id="1-1-centos安装nodejs"><a href="#1-1-centos安装nodejs" class="headerlink" title="1.1 centos安装nodejs"></a>1.1 centos安装nodejs</h3><p>切换到目录：<code>cd /usr/local</code><br>压缩包解压:<code>tar -zxvf node-v15.10.0-linux-x64.tar.gz</code><br>mv命令将解压文件夹重命名为nodejs<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tar -xvf file.tar //解压 tar包</span><br><span class="line">tar xf node-v16<span class="number">.13</span><span class="number">.1</span>-linux-x64.tar.xz//解压 tar.xz包</span><br><span class="line">tar -xzvf file.tar.gz //解压tar.gz</span><br><span class="line">tar -xjvf file.tar.bz2   //解压 tar.bz2</span><br><span class="line">tar –xZvf file.tar.Z   //解压tar.Z</span><br><span class="line">unrar e file.rar //解压rar</span><br><span class="line">unzip file.<span class="built_in">zip</span> //解压<span class="built_in">zip</span></span><br><span class="line"></span><br><span class="line">rm-f　　-force　　忽略不存在的文件，强制删除，无任何提示</span><br><span class="line">-i　　　--interactive　　　 进行交互式地删除</span><br><span class="line">rm -ivrf dirname 删除目录</span><br></pre></td></tr></table></figure><br>建立软连接：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ln -s /usr/local/nodejs/<span class="built_in">bin</span>/node /usr/local/<span class="built_in">bin</span></span><br><span class="line">ln -s /usr/local/nodejs/<span class="built_in">bin</span>/npm /usr/local/<span class="built_in">bin</span></span><br></pre></td></tr></table></figure><p>查看是否正确安装<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@<span class="number">192</span> local]<span class="comment"># node -v</span></span><br><span class="line">v15<span class="number">.10</span><span class="number">.0</span></span><br><span class="line">[root@<span class="number">192</span> local]<span class="comment"># npm -v</span></span><br><span class="line"><span class="number">7.5</span><span class="number">.3</span></span><br></pre></td></tr></table></figure><br>各种报错：</p><ol><li><p>安装nodejs15后执行<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>报错：<br><img src="https://img-blog.csdnimg.cn/f050c16ed60942cfbb875cac6d2df79e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这是npm的版本太低了版本过低不支持nodejs。</p></li><li><p>结果再次<code>npm install -g cnpm --registry=https://registry.npm.taobao.orgnpm</code>报错<br><img src="https://img-blog.csdnimg.cn/57130bfa4bde44d99b2a3ad0128d26a2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>怀疑是上一次的nodejs没删干净，但其实是ping www.baidu.com都有问题<br><img src="https://img-blog.csdnimg.cn/cfab59f2a1254876a6a8a2a82a83d7d2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ol><p>之后参考：<a href="https://blog.csdn.net/weixin_43700340/article/details/88393833?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163965925416780274135285%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163965925416780274135285&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-88393833.pc_search_insert_es_download_v2&amp;utm_term=ping%20www.baidu.com&amp;spm=1018.2226.3001.4187">linux里面ping www.baidu.com ping不通的问题</a>。就ok了<br>配置DNS：打开文件 vim /etc/resolv.conf，注释第二行并输入：<br><img src="https://img-blog.csdnimg.cn/f149a64bfda74cba96a0855d5bf95291.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Google</span></span><br><span class="line">nameserver <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">nameserver <span class="number">8.8</span><span class="number">.4</span><span class="number">.4</span></span><br></pre></td></tr></table></figure><p>现在ping registry.npmjs.org也ok了。<br>输入<code>npm config set registry http://registry.npm.taobao.org</code>。测试<code>ping registry.npm.taobao.org</code>成功。</p><ul><li>查看npm源地址<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line"><span class="comment">#http://registry.npmjs.org 为国外镜像地址</span></span><br><span class="line"><span class="comment">#设置阿里云镜像</span></span><br><span class="line">npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org</span><br><span class="line"><span class="comment">#http://registry.npm.taobao.org/现在是淘宝镜像</span></span><br><span class="line">npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org<span class="comment">#安装cnpm</span></span><br></pre></td></tr></table></figure>这个是不知道中间执行了啥报错了。即越做越错。<br><img src="https://img-blog.csdnimg.cn/7ea41e5a166c4a01a36e5575aa615546.png" alt="在这里插入图片描述"></li></ul><p>装完nodejs16，弄好DNS服务。<code>npm install -g npm@8.3.0</code>升级npm到8.3。</p><h3 id="1-2-win10安装nodejs"><a href="#1-2-win10安装nodejs" class="headerlink" title="1.2  win10安装nodejs"></a>1.2  win10安装nodejs</h3><p>官网下载安装node-v16.13.1-x64后，cmd运行<code>npm -v</code>一直显示命令语法不正确。升级win10家庭版到专业版，各种操作都不行。打开git-bash，运行就ok了。<br><img src="https://img-blog.csdnimg.cn/5ccfc4ee6f3c4252a31b4d6b51e0467a.png" alt="在这里插入图片描述"><br>运行<code>npm config set registry http://registry.npm.taobao.org</code><br>运行<code>npm install -g npm@8.3.0</code>升级npm到8.3。<br>安装vue：<code>pip install vue</code><br>安装vue-cli：<code>npm install -g @vue/cli</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ npm install joi</span><br><span class="line">npm ERR! code EPERM</span><br><span class="line">npm ERR! syscall mkdir</span><br><span class="line">npm ERR! path D:\</span><br><span class="line">npm ERR! errno -<span class="number">4048</span></span><br><span class="line">npm ERR! Error: EPERM: operation <span class="keyword">not</span> permitted, mkdir <span class="string">&#x27;D:\&#x27;</span></span><br><span class="line"><span class="string">npm ERR!  [Error: EPERM: operation not permitted, mkdir &#x27;</span>D:\<span class="string">&#x27;] &#123;</span></span><br><span class="line"><span class="string">npm ERR!   errno: -4048,</span></span><br><span class="line"><span class="string">npm ERR!   code: &#x27;</span>EPERM<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">npm ERR!   syscall: &#x27;</span>mkdi<span class="string">r&#x27;,</span></span><br><span class="line"><span class="string">npm ERR!   path: &#x27;</span>D:\\<span class="string">&#x27;</span></span><br><span class="line"><span class="string">npm ERR! &#125;</span></span><br><span class="line"><span class="string">npm ERR!</span></span><br><span class="line"><span class="string">npm ERR! The operation was rejected by your operating system.</span></span><br><span class="line"><span class="string">npm ERR! It&#x27;</span>s possible that the file was already <span class="keyword">in</span> use (by a text editor <span class="keyword">or</span> ant</span><br><span class="line">ivirus),</span><br><span class="line">npm ERR! <span class="keyword">or</span> that you lack permissions to access it.</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! If you believe this might be a permissions issue, please double-check t</span><br><span class="line">he</span><br><span class="line">npm ERR! permissions of the file <span class="keyword">and</span> its containing directories, <span class="keyword">or</span> <span class="keyword">try</span> running</span><br><span class="line">npm ERR! the command again <span class="keyword">as</span> root/Administrator.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     C:\Users\LS\AppData\Local\npm-cache\_logs\<span class="number">2021</span>-<span class="number">12</span>-30T16_48_16_213Z-</span><br><span class="line">debug-<span class="number">0.</span>log</span><br></pre></td></tr></table></figure><p>bash没有管理员权限。此时右键单击git-bash.exe，以管理员身份运行<code>npm install joi</code>。<br><img src="https://img-blog.csdnimg.cn/4e900e52f9e54dbc8a01ecfeff76941b.png" alt="在这里插入图片描述"></p><h2 id="2-vue"><a href="#2-vue" class="headerlink" title="2. vue"></a>2. vue</h2><h3 id="2-1-安装vue"><a href="#2-1-安装vue" class="headerlink" title="2.1 安装vue"></a>2.1 安装vue</h3><p>安装vue：<code>pip install vue</code><br>安装vue-cli：<code>npm install -g @vue/cli</code><br><img src="https://img-blog.csdnimg.cn/ee2645568b0444388b67156108860054.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>报错一大堆，我一直以为是安装失败。后来才知道是有些包过时弃用了不碍事。改了两处：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">npm install uuid@<span class="number">8.3</span><span class="number">.2</span></span><br><span class="line">npm install joi</span><br></pre></td></tr></table></figure><p>之后建立软连接：<code>ln -s /usr/local/nodejs/bin/vue /usr/local/bin/vue</code><br>输入 <code>vue -v</code><br><img src="https://img-blog.csdnimg.cn/cdf0eea5932d4a5fb9e12c6e627865a0.png" alt="在这里插入图片描述"><br>原来已经装成功了。</p><p>wget <a href="http://www.percona.com/redir/downloads/Percona-XtraDB-Cluster/5.5.37-25.10/RPM/rhel6/x86_64/Percona-XtraDB-Cluster-shared-55-5.5.37-25.10.756.el6.x86_64.rpm">http://www.percona.com/redir/downloads/Percona-XtraDB-Cluster/5.5.37-25.10/RPM/rhel6/x86_64/Percona-XtraDB-Cluster-shared-55-5.5.37-25.10.756.el6.x86_64.rpm</a><br>wget <a href="http://www.percona.com/redir/downloads/Percona-XtraDB-Cluster/5.5.37-25.10/RPM/rhel6/x86_64/Percona-XtraDB-Cluster-shared-55-5.5.37-25.10.756.el6.x86_64.rpm">http://www.percona.com/redir/downloads/Percona-XtraDB-Cluster/5.5.37-25.10/RPM/rhel6/x86_64/Percona-XtraDB-Cluster-shared-55-5.5.37-25.10.756.el6.x86_64.rpm</a><br>rpm -ivh Percona-XtraDB-Cluster-shared-55-5.5.37-25.10.756.el6.x86_64.rpm</p><h3 id="2-2-创建vue项目"><a href="#2-2-创建vue项目" class="headerlink" title="2.2 创建vue项目"></a>2.2 创建vue项目</h3><p>官网教程：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2">创建一个项目</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vue create hello-world</span><br></pre></td></tr></table></figure><p>可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。<br><img src="https://img-blog.csdnimg.cn/ae49532f1d9640b2b91814fbaec5ff33.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>vue create 命令有一些可选项，你可以通过运行以下命令进行探索：<code>vue create --help</code><br>你也可以通过 vue ui 命令以图形化界面创建和管理项目：<code>vue ui</code><br>上述命令会打开一个浏览器窗口，并以图形化界面将你引导至项目创建的流程。<br><img src="https://img-blog.csdnimg.cn/4e72d8d9381b47aa9e84f7e6cbae730e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br><span class="line"><span class="comment"># `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同</span></span><br><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure><p>Vue项目目录和说明见教程：</p><h3 id="2-3-使用Vue开发H5页面"><a href="#2-3-使用Vue开发H5页面" class="headerlink" title="2.3 使用Vue开发H5页面"></a>2.3 使用Vue开发H5页面</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vue create创建项目</span></span><br><span class="line">vue create test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入项目具体路径</span></span><br><span class="line">cd test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载依赖</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动运行项目</span></span><br><span class="line">npm run serve </span><br></pre></td></tr></table></figure><p>此时输不了命令，也没有app界面弹出（minicentos没有图形界面）<br>ctrl+z退出后输入npm run build：<br><img src="https://img-blog.csdnimg.cn/193c0c2d582b4cc59f17cd4e80bc8ed5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0b33543fc78340a8b0ec8f70d659adad.png" alt="在这里插入图片描述"><br>构建完成后，可以看到前端项目根目录下多了一个dist文件夹，这就是要部署的前台文件。</p><blockquote><p>参考<a href="https://blog.csdn.net/weixin_30367543/article/details/99511206?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163968487616780265472282%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163968487616780265472282&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-99511206.pc_search_insert_es_download_v2&amp;utm_term=centos%E9%83%A8%E7%BD%B2vue%E9%A1%B9%E7%9B%AE&amp;spm=1018.2226.3001.4187">《centos部署vue项目》</a><a href="https://blog.csdn.net/qq_41082746/article/details/106698019?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=centos%E9%83%A8%E7%BD%B2vue%E9%A1%B9%E7%9B%AE&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-106698019.pc_search_insert_es_download_v2&amp;spm=1018.2226.3001.4187">《Centos7部署Vue项目》</a><br>参考链接：<br><a href="https://www.runoob.com/vue3/vue3-directory-structure.html">https://www.runoob.com/vue3/vue3-directory-structure.html</a><br><a href="https://blog.csdn.net/weixin_41887155/article/details/107648969">https://blog.csdn.net/weixin_41887155/article/details/107648969</a><br><a href="https://www.cnblogs.com/jhpy/p/11873270.html">https://www.cnblogs.com/jhpy/p/11873270.html</a><br><a href="https://blog.csdn.net/chao2458/article/details/81284522">https://blog.csdn.net/chao2458/article/details/81284522</a></p></blockquote><h3 id="2-4-部署新闻推荐前端项目"><a href="#2-4-部署新闻推荐前端项目" class="headerlink" title="2.4 部署新闻推荐前端项目"></a>2.4 部署新闻推荐前端项目</h3><ol><li><p>跳转到前端项目文件目录：cd Vue-newsinfo</p></li><li><p>本地安装node环境，在项目根目录命令行输入命令<code>npm install</code>安装依赖包</p></li></ol><p>如果因为版本或者网络问题下载失败请执行npm install -g cnpm -registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org/</a> 和cnpm install</p><ol><li>启动前端服务：<code>npm run dev</code></li></ol><p>本机访问地址<a href="http://localhost:8686/#/">http://localhost:8686/#/</a></p><ol><li>根据需要修改package.json下<code>&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --open --port 8686 --contentBase src --hot --host 0.0.0.0&quot;&#125;</code>,中的ip和端口号)</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">npm ERR! JSON.parse package.json must be actual JSON, <span class="keyword">not</span> just JavaScript</span><br><span class="line"><span class="comment">#修改package.json错误导致</span></span><br></pre></td></tr></table></figure><ol><li><p>修改main.js：<code>vim /home/Vue-newsinfo/src/main.js</code><br>这个是后端访问的地址，也就是网页F12时用户操作的地址。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Vue.use(VueAxios, axios);</span><br><span class="line">// axios公共基路径，以后所有的请求都会在前面加上这个路径</span><br><span class="line">//axios.defaults.baseURL = <span class="string">&quot;http://47.108.56.188:3000&quot;</span>;</span><br><span class="line">//axios.defaults.baseURL = <span class="string">&quot;http://127.0.0.1:3000&quot;</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&quot;http://0.0.0.0:3000&quot;</span></span><br></pre></td></tr></table></figure><p>centos本地服务启动后想退出按<code>ctrl+c</code>不是ctrl+z。<br><code>netstat -tunlp | grep 8080</code>查看端口是否被占用<br><code>systemctl stop firewalld.service</code>关闭防火墙<br><code>yum install telnet httpd</code>安装telnet、httpd。<br><code>netstat -nlp</code> 查看是否映射成功<br><code>telnet 192.168.112.1 10022</code>连接主机<br><code>telnet 192.168.112.1 6379</code>连接redis</p></li><li><p>虚拟机端口映射<br>参考<a href="https://blog.csdn.net/aod83029/article/details/102163544?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-102163544.nonecase&amp;spm=1018.2226.3001.4187">此贴</a><br><img src="https://img-blog.csdnimg.cn/dacfd75c157e49ffaf91f4dc348df679.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/14430c3bc0fe4bcfa8b8ffd3a0e8ed5f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>最后输入<code>http://localhost:8686/#/</code>访问。</p></li><li><p>点击F12或者右键选择检查打开开发者模式,选中移动端浏览（点击左上角箭头右边的手机按钮）开始体验</p></li></ol><h2 id="3-后端配置"><a href="#3-后端配置" class="headerlink" title="3. 后端配置"></a>3. 后端配置</h2><h3 id="3-1-创建conda虚拟环境"><a href="#3-1-创建conda虚拟环境" class="headerlink" title="3.1 创建conda虚拟环境"></a>3.1 创建conda虚拟环境</h3><p>输入conda命令，如正常返回，说明conda安装成功。<br>查看已有环境列表，*表示当前环境，base表示默认环境：<code>conda env list</code><br><img src="https://img-blog.csdnimg.cn/4aa8a52871144e4e9bb81ee9f7fd7159.png" alt="在这里插入图片描述"><br><code>python --version</code>查看python版本</p><ol><li>使用命令<code>conda create -n sina python=3.6.8</code>创建环境，这里创建了名称为sina的python版本号为3.6.8的虚拟环境，稍微等待，过程中输入“y”。</li></ol><p>将后端文件全部拷贝到centos上，切换到目录：<code>cd /home/news_rec_server</code></p><ol><li>创建指定路径的Python环境：<code>conda create --prefix venv python=3.6.8</code>指定路径venv，名字是sina。<br><img src="https://img-blog.csdnimg.cn/8422680ac4a14d999f41439b1fa161fa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ol><p>进入其他环境需要使用<code>conda activate</code>手动切换（一开始没有命令，结果悲剧了）<br>退出当前环境，使用<code>conda deactivate</code>，默认回到base 环境</p><ul><li>在新的环境中使用下面的代码安装旧的环境中对应的包：<code>pip install -r requirements.txt</code></li><li>直接安装失败报错;</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Could <span class="keyword">not</span> fetch URL https://pypi.tuna.tsinghua.edu.cn/simple/pip/: There was a problem confirming the ssl certificate: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:<span class="number">852</span>) - skipping</span><br></pre></td></tr></table></figure><p>解决方法:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m pip install --upgrade pip --user -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br></pre></td></tr></table></figure></p><p>中间报错一次，将selenium==4.0.0改成3.14.1就ok了。<br><img src="https://img-blog.csdnimg.cn/80c20c68c2624b679714085067ec21af.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>删除虚拟环境，直接找到环境所在的目录，手动删除</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda remove -n your_env_name(虚拟环境名称) --<span class="built_in">all</span> 删除虚拟环境</span><br><span class="line">conda remove --name your_env_name package_name 删除虚拟环境中的某个包</span><br></pre></td></tr></table></figure><p>旧环境导出：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#切换到需要生成requirements.txt 的虚拟环境中;在终端运行下面的代码</span></span><br><span class="line">pip freeze &gt;requirements.txt</span><br><span class="line"></span><br><span class="line">pip <span class="built_in">list</span> --<span class="built_in">format</span>=freeze &gt; requirements.txt</span><br><span class="line"><span class="comment">#该命令可以得到安装在本地的库的版本名</span></span><br></pre></td></tr></table></figure><ul><li>进入环境后，可使用如下命令安装依赖的包，使用的是已经配置好的清华的源，这里以“opencv-python”包为例，由于使用了清华大学的镜像源，下载速度很快。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-python</span><br></pre></td></tr></table></figure><ul><li>换回conda默认的源，访问起来可能有些慢，但总比无法访问好。<br>conda config —remove-key channels<h3 id="3-2-后端文件配置"><a href="#3-2-后端文件配置" class="headerlink" title="3.2 后端文件配置"></a>3.2 后端文件配置</h3><h3 id="4-2-修改端口，配置文件"><a href="#4-2-修改端口，配置文件" class="headerlink" title="4.2 修改端口，配置文件"></a>4.2 修改端口，配置文件</h3></li></ul><ol><li>修改后端项目的IP和端口<br>后端获取网页地址的代码在最后一行（点击登录的时候login信息）<br><img src="https://img-blog.csdnimg.cn/524998e228654f8ab9af0f49894fe994.png" alt="在这里插入图片描述"></li></ol><p>打开文件server.py，修改第233行的IP和端口，修改内容如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 允许服务器被公开访问</span></span><br><span class="line">     app.run(debug=<span class="literal">True</span>, host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">3000</span>, threaded=<span class="literal">True</span>)<span class="comment">#我的这个不变</span></span><br><span class="line">    <span class="comment"># 只能被自己的机子访问</span></span><br><span class="line">    <span class="comment">#app.run(debug=True, host=&#x27;127.0.0.1&#x27;, port=5000, threaded=True)</span></span><br></pre></td></tr></table></figure><p>127.0.0.1表示后端提供给前端的IP（也称为本地IP），5000表示端口。</p><ol><li>修改项目路径配置文件proj_path.py<br>因为没有配置home路径，所以改为读取项目地址。修改项目路径配置文件proj_path.py，文件路径：conf/proj_path.py</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># home_path = os.environ[&#x27;HOME&#x27;]</span></span><br><span class="line"><span class="comment"># proj_path = home_path + &quot;/fun-rec/codes/news_recsys/news_rec_server/&quot;</span></span><br><span class="line">proj_path = os.path.join(sys.path[<span class="number">1</span>], <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>核对数据库配置文件dao_config.py<br>打开数据库配置文件dao_config.py，文件路径：conf/dao_config.py，核对以下配置：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MySQL默认配置</span></span><br><span class="line">mysql_username = <span class="string">&quot;root&quot;</span></span><br><span class="line">mysql_passwd = <span class="string">&quot;123456&quot;</span></span><br><span class="line">mysql_hostname = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">mysql_port = <span class="string">&quot;3306&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MongoDB配置</span></span><br><span class="line">mongo_hostname = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">mongo_port = <span class="number">27017</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis配置</span></span><br><span class="line">redis_hostname = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">redis_port = <span class="number">6379</span></span><br></pre></td></tr></table></figure><h3 id="4-3-启动雪花算法服务"><a href="#4-3-启动雪花算法服务" class="headerlink" title="4.3     启动雪花算法服务"></a>4.3     启动雪花算法服务</h3><p>news_rec_server下在Terminal中执行命令启动雪花算法服务，用于生成用户ID，启动命令如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">snowflake_start_server --address=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> --port=<span class="number">8910</span> --dc=<span class="number">1</span> --worker=<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="4-4-创建数据库"><a href="#4-4-创建数据库" class="headerlink" title="4.4 创建数据库"></a>4.4 创建数据库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql -u root -p <span class="comment">#登录mysql</span></span><br><span class="line">grep <span class="string">&quot;password&quot;</span> /var/log/mysqld.log<span class="comment">#查看密码，直接复制登录</span></span><br><span class="line">CREATE DATABASE loginfo；</span><br><span class="line">CREATE DATABASE userinfo;</span><br></pre></td></tr></table></figure><p>创建mongodb库</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mongo</span><br><span class="line">use SinaNews</span><br><span class="line">use NewsRecSys</span><br></pre></td></tr></table></figure><h3 id="4-4-创建logs目录"><a href="#4-4-创建logs目录" class="headerlink" title="4.4    创建logs目录"></a>4.4    创建logs目录</h3><p>在根目录下，创建logs目录，如下图所示：<br><img src="https://img-blog.csdnimg.cn/3582ab8e23ff4b07b3a9989699e6c4d2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="4-5-启动后端项目"><a href="#4-5-启动后端项目" class="headerlink" title="4.5 启动后端项目"></a>4.5 启动后端项目</h3><p>启动server.py程序（注：在此之前，必须启动数据库并创建数据库，详见2.1.3节和2.2.2节），执行如下命令：<br>先在sina虚拟环境下安装flask：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda activate sina</span><br><span class="line">pip install Flask</span><br></pre></td></tr></table></figure><p>python server.py<br><img src="https://img-blog.csdnimg.cn/12c5b5947bd84a71aaab73cf9e51670e.png" alt="在这里插入图片描述"></p><h2 id="5-项目整体运行与调试"><a href="#5-项目整体运行与调试" class="headerlink" title="5    项目整体运行与调试"></a>5    项目整体运行与调试</h2><p>注册用户，注册的用户数据在mysql的userinfo table下面：<br><img src="https://img-blog.csdnimg.cn/6f7d11017cfa4727921003d6aa673d25.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以直接删除就没有用户注册信息了（datagrap删除后要刷新）<br> 现在就可以登录网址注册登录了，但是没有新闻展示，因为还没有开始推送新闻，所以用户看不到新闻。终端报错：<img src="https://img-blog.csdnimg.cn/6736c30e0356408d97c8184ea616c0c8.png" alt="在这里插入图片描述"></p><h3 id="5-1-爬取新浪新闻"><a href="#5-1-爬取新浪新闻" class="headerlink" title="5.1    爬取新浪新闻"></a>5.1    爬取新浪新闻</h3><p>通过查看crawl_news.sh文件（文件路径：scheduler/crawl_news.sh），可知爬取新浪新闻的代码在如下目录<br>/materials/news_scrapy/sinanews/run.py<br>使用PyCharm的Run按钮，手动执行该代码，需要配置参数：<br>—pages=30</p><p><img src="https://img-blog.csdnimg.cn/3a0d7d8f91774f90b1ca2f709db08c52.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c65de70dd5f9404abdc7d56d20804897.png" alt="在这里插入图片描述"></p><h3 id="5-2-更新物料画像"><a href="#5-2-更新物料画像" class="headerlink" title="5.2    更新物料画像"></a>5.2    更新物料画像</h3><p>通过查看offline_material_and_user_process.sh文件（文件路径：scheduler/offline_material_and_user_process.sh），可知更新物料画像的代码在如下目录：<br>materials/process_material.py<br>使用PyCharm的Run按钮，手动执行该代码<br> <img src="https://img-blog.csdnimg.cn/17cd2ccaf3d94bf5ac8d8b93a167f6e5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="5-3-更新用户画像"><a href="#5-3-更新用户画像" class="headerlink" title="5.3    更新用户画像"></a>5.3    更新用户画像</h3><p>通过查看offline_material_and_user_process.sh文件（文件路径：scheduler/offline_material_and_user_process.sh），可知更新用户画像的代码在如下目录：<br>materials/process_user.py<br>使用PyCharm的Run按钮，手动执行该代码<br> <img src="https://img-blog.csdnimg.cn/ba2509dd448a450caff81142bfe76b6f.png" alt="在这里插入图片描述"></p><h3 id="5-4-清除前一天redis中的数据，更新最新今天最新的数据"><a href="#5-4-清除前一天redis中的数据，更新最新今天最新的数据" class="headerlink" title="5.4    清除前一天redis中的数据，更新最新今天最新的数据"></a>5.4    清除前一天redis中的数据，更新最新今天最新的数据</h3><p>通过查看offline_material_and_user_process.sh文件（文件路径：scheduler/offline_material_and_user_process.sh），可知清除前一天redis中的数据，更新最新今天最新的数据的代码在如下目录：<br>materials/update_redis.py<br>使用PyCharm的Run按钮，手动执行该代码</p><p><img src="https://img-blog.csdnimg.cn/f4265cf10e72450da4b50457a9c301c4.png" alt="在这里插入图片描述"></p><h3 id="5-5-离线将推荐列表和热门列表存入redis"><a href="#5-5-离线将推荐列表和热门列表存入redis" class="headerlink" title="5.5    离线将推荐列表和热门列表存入redis"></a>5.5    离线将推荐列表和热门列表存入redis</h3><p>通过查看run_offline.sh文件（文件路径：scheduler/run_offline.sh），可知离线将推荐列表和热门列表存入redis的代码在如下目录：<br>recprocess/offline.py<br>使用PyCharm的Run按钮，手动执行该代码<br> <img src="https://img-blog.csdnimg.cn/6fd3cdaa10e64cc19040601fa4313ea9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h2 id=&quot;0-解决npm命令语法不正确问题&quot;&gt;&lt;a href=&quot;#0-解决npm命令语法不正确问题&quot; class=&quot;headerlink&quot; title=&quot;0.解决npm命令语法不正确问题&quot;&gt;&lt;/a&gt;0.解决npm命令语法不正确问题&lt;/h2&gt;&lt;h3 id=&quot;0-1-powershell报错&quot;&gt;&lt;a href=&quot;#0-1-powershell报错&quot; class=&quot;headerlink&quot; title=&quot;0.1  powershell报错&quot;&gt;&lt;/a&gt;0.1  powershell报错&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2a4d50e19ca7476a8ac33976be4071c0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;解决方案：&lt;br&gt;根据上面提升报错的环境变量把环境变量Path中含有 ； 的分开写&lt;br&gt;</summary>
    
    
    
    <category term="12月组队学习：推荐系统" scheme="https://zhxnlp.github.io/categories/12%E6%9C%88%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="推荐系统" scheme="https://zhxnlp.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="数据库" scheme="https://zhxnlp.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="前端开发" scheme="https://zhxnlp.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>task1：新闻推荐系统项目搭建：数据库安装与使用</title>
    <link href="https://zhxnlp.github.io/2021/12/14/12%E6%9C%88%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/task1%EF%BC%9A%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhxnlp.github.io/2021/12/14/12%E6%9C%88%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/task1%EF%BC%9A%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2021-12-13T16:41:19.000Z</published>
    <updated>2022-01-02T19:49:12.689Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>参考：<a href="https://github.com/datawhalechina/fun-rec/blob/master/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/2.2%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/docs/2.2.1.1%20Mysql%E5%9F%BA%E7%A1%80.md">Mysql基础.md</a><br>本项目来自<a href="https://github.com/datawhalechina/fun-rec/tree/master/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/2.2%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98">《fun-rec/docs/第二章 推荐系统实战/2.2新闻推荐系统实战/》</a><br><a href="https://share.weiyun.com/u3ZIjZfg">【交流分享-腾讯微云】</a></p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> vim /etc/resolv.conf</span><br><span class="line"><span class="comment">#Google</span></span><br><span class="line">nameserver <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">nameserver <span class="number">8.8</span><span class="number">.4</span><span class="number">.4</span></span><br><span class="line"></span><br><span class="line">conda activate</span><br></pre></td></tr></table></figure><ol><li><p>mysql命令</p><span id="more"></span><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld<span class="comment">#启动mysql</span></span><br><span class="line">systemctl status mysqld.service<span class="comment">#查看mysql状态，running就是启动中</span></span><br><span class="line">systemctl stop mysqld.service<span class="comment">#关闭mysql服务</span></span><br><span class="line">mysql -u root -p <span class="comment">#登录mysql</span></span><br><span class="line">grep <span class="string">&quot;password&quot;</span> /var/log/mysqld.log<span class="comment">#查看密码，直接复制登录</span></span><br><span class="line">netstat -nlp <span class="comment">#查看是否映射成功</span></span><br></pre></td></tr></table></figure><p>安装成功后没有mysql服务报错 没有此服务<br>我们应该找到 自己的mysq安装文件夹（博主的mysql在“ /home/tool/mysql_5.7.22”）<br>将/home/tool/mysql_5.7.22/support-files/mysql.server 拷贝到 /etc/init.d/mysql</p></li><li><p>mongodb命令：</p></li></ol><ul><li>添加路径：<code>export PATH=/usr/local/mongodb/bin:$PATH</code></li><li>启动mongo服务：<code>mongod --dbpath /var/lib/mongo --logpath /var/log/mongodb/mongod.log --fork</code></li><li>通过 ps ax | grep mongod查看数据库启动情况，如下图表示启动成功：</li><li>关闭mongodb服务通过ps ax | grep mongod命令查看mongodb运行的id<br><img src="https://img-blog.csdnimg.cn/890bf81dcb7a4899886c3e77f3ec1a4e.png" alt="在这里插入图片描述"><br>然后输入kill -9 进程id，杀死mongodb服务，如上图执行命令</li></ul><ol><li>redis命令</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">systemctl start redis.service   <span class="comment">#启动redis服务</span></span><br><span class="line">systemctl stop redis.service   <span class="comment">#停止redis服务</span></span><br><span class="line">systemctl restart redis.service   <span class="comment">#重新启动服务</span></span><br><span class="line">systemctl status redis.service   <span class="comment">#查看服务当前状态</span></span><br><span class="line">systemctl enable redis.service   <span class="comment">#设置开机自启动</span></span><br><span class="line">systemctl disable redis.service   <span class="comment">#停止开机自启动</span></span><br></pre></td></tr></table></figure><h2 id="一、Mysql用户"><a href="#一、Mysql用户" class="headerlink" title="一、Mysql用户"></a>一、Mysql用户</h2><p>启动MySQL/重启</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@master software]<span class="comment"># service mysql start</span></span><br><span class="line">[root@master software]<span class="comment"># service mysql restart</span></span><br><span class="line">systemctl status mysqld.service<span class="comment">#查看mysql状态，running就是启动中</span></span><br><span class="line">systemctl stop mysqld.service<span class="comment">#关闭mysql服务</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用户登录</span></span><br><span class="line">[root@master software]<span class="comment"># mysql -uroot -p</span></span><br><span class="line">mysql&gt; exit<span class="comment">#退出</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">CREATE USER <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;你的密码&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋予admin用户全部的权限，你也可以只授予部分权限</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure><p>监听不到mysql端口查看<a href="https://blog.csdn.net/weixin_43671497/article/details/84931578?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E7%9C%8B%E4%B8%8D%E5%88%B0mysql%E7%AB%AF%E5%8F%A3&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-9-84931578.pc_search_insert_es_download_v2&amp;spm=1018.2226.3001.4187">帖子</a>。<br>即之前为了免密登陆在<code>vi /etc/my.cnf</code>打开mysql设置文件，在最后一行加了<code>skip-grant-tables</code>或<code>skip-network</code>导致3306端口无法被监听到。注释掉这句话之后重启mysql服务就行。</p><h2 id="二、Mysql-数据库"><a href="#二、Mysql-数据库" class="headerlink" title="二、Mysql-数据库"></a>二、Mysql-数据库</h2><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td> CREATE DATABASE [IF NOT EXISTS] &lt;数据库名称&gt;;</td><td>查看数据库。IF NOT EXISTS（可选项）避免数据库重名</td></tr><tr><td> SHOW DATABASES [LIKE ‘数据库名’];;</td><td>查看所有存在的数据库</td></tr><tr><td>USE &lt;数据库名&gt;</td><td>选择数据库</td></tr><tr><td> DROP DATABASE [IF EXISTS] &lt;数据库名&gt;</td><td>删除数据库</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CREATE DATABASE shop;<span class="comment">#创建名为shop的数据库。</span></span><br><span class="line">SHOW DATABASES;<span class="comment">#查看数据库</span></span><br><span class="line">SHOW CREATE DATABASE shop;<span class="comment">#查看创建的数据库shop</span></span><br><span class="line">DROP DATABASE shop;<span class="comment">#删除shop数据库</span></span><br></pre></td></tr></table></figure><h2 id="三、Mysql-表的基本操作"><a href="#三、Mysql-表的基本操作" class="headerlink" title="三、Mysql-表的基本操作"></a>三、Mysql-表的基本操作</h2><h3 id="3-1-表的创建和修改"><a href="#3-1-表的创建和修改" class="headerlink" title="3.1 表的创建和修改"></a>3.1 表的创建和修改</h3><p>创建表的语法结构如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &lt;表名&gt; （&lt;字段<span class="number">1</span>&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;，</span><br><span class="line">   &lt;字段<span class="number">2</span>&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;，</span><br><span class="line">   &lt;字段<span class="number">3</span>&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;，</span><br><span class="line">   &lt;字段<span class="number">4</span>&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;，</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   &lt;该表的约束<span class="number">1</span>&gt;， &lt;该表的约束<span class="number">2</span>&gt;，……）；</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- 创建一个名为Product的表</span><br><span class="line">CREATE TABLE Product(</span><br><span class="line">  product_id CHAR(<span class="number">4</span>) NOT NULL,</span><br><span class="line">  product_name VARCHAR(<span class="number">100</span>) NOT NULL,</span><br><span class="line">  product_type VARCHAR(<span class="number">32</span>) NOT NULL,</span><br><span class="line">  sale_price INT,</span><br><span class="line">  purchase_price INT,</span><br><span class="line">  regist_date DATE,</span><br><span class="line">  PRIMARY KEY (product_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>DESC Product;</td><td>查询表product</td></tr><tr><td>DROP TABLE &lt;表名&gt;;</td><td>删除表，无法恢复</td></tr><tr><td>rename命令：ALTER TABLE Student RENAME Students;</td><td>更新表名Student =&gt; Students。</td></tr><tr><td>add命令：ALTER TABLE Students ADD sex CHAR(1), ADD age INT;</td><td>插入字段，用逗号隔开</td></tr><tr><td>drop命令：ALTER TABLE Students DROP stu_num;</td><td>删除字段</td></tr><tr><td>modify命令：ALTER TABLE Students MODIFY age CHAR(3);</td><td>修改字段类型</td></tr><tr><td>change：ALTER TABLE Students CHANGE name stu_name CHAR(12);</td><td>修改字段名name =&gt;stu_name，数据类型改为CHAR(12)。</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- 通过FIRST在表首插入字段stu_num</span><br><span class="line">ALTER TABLE Students ADD stu_num INT FIRST;</span><br><span class="line"></span><br><span class="line">-- 通过AFTER在字段sex后插入字段height</span><br><span class="line">ALTER TABLE Students ADD height INT AFTER sex;</span><br></pre></td></tr></table></figure><h3 id="3-2-表的查询"><a href="#3-2-表的查询" class="headerlink" title="3.2 表的查询"></a>3.2 表的查询</h3><h3 id="3-2-1-SELECT语句查询和算式运算"><a href="#3-2-1-SELECT语句查询和算式运算" class="headerlink" title="3.2. 1. SELECT语句查询和算式运算"></a>3.2. 1. SELECT语句查询和算式运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SELECT &lt;字段名&gt;, ……</span><br><span class="line"> FROM &lt;表名&gt;;</span><br><span class="line"><span class="comment">#查询全部字段</span></span><br><span class="line">SELECT *</span><br><span class="line"> FROM &lt;表名&gt;;</span><br></pre></td></tr></table></figure><ol><li>通过AS语句对展示的字段另起别名，这不会修改表内字段的名字：</li><li>设定汉语别名时需要使用双引号（”）括起来，英文字符则不需要:</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SELECT  </span><br><span class="line">  product_id AS <span class="string">&quot;产品编号&quot;</span>,</span><br><span class="line">  product_type AS <span class="string">&quot;产品类型&quot;</span>  </span><br><span class="line"> FROM Product;</span><br></pre></td></tr></table></figure><p>可以在SELECT语句中使用计算表达式：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  product_name,</span><br><span class="line">  sale_price,</span><br><span class="line">  sale_price * <span class="number">2</span> AS <span class="string">&quot;sale_price_x2&quot;</span></span><br><span class="line"> FROM Product;</span><br><span class="line"></span><br><span class="line">-- 结果如下</span><br><span class="line">+--------------+------------+---------------+</span><br><span class="line">| product_name | sale_price | sale_price_x2 |</span><br><span class="line">+--------------+------------+---------------+</span><br><span class="line">| T恤衫        |       <span class="number">1000</span> |          <span class="number">2000</span> |</span><br><span class="line">| 打孔器       |        <span class="number">500</span> |          <span class="number">1000</span> |</span><br><span class="line">| 运动T恤      |       <span class="number">4000</span> |          <span class="number">8000</span> |</span><br><span class="line">| 菜刀         |       <span class="number">3000</span> |          <span class="number">6000</span> |</span><br><span class="line">| 高压锅       |       <span class="number">6800</span> |         <span class="number">13600</span> |</span><br><span class="line">| 叉子         |        <span class="number">500</span> |          <span class="number">1000</span> |</span><br><span class="line">| 擦菜板       |        <span class="number">880</span> |          <span class="number">1760</span> |</span><br><span class="line">| 圆珠笔       |        <span class="number">100</span> |           <span class="number">200</span> |</span><br><span class="line">+--------------+------------+---------------+</span><br></pre></td></tr></table></figure></p><ol><li>常数的查询：SELECT子句中，除了可以写字段外，还可以写常数。即将查询的字段填入常数</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  <span class="string">&#x27;商品&#x27;</span> AS string,</span><br><span class="line">  <span class="string">&#x27;2009-05-24&#x27;</span> AS date,</span><br><span class="line">  product_id,</span><br><span class="line">  product_name</span><br><span class="line"> FROM Product;</span><br><span class="line"></span><br><span class="line">-- 结果如下</span><br><span class="line">+--------+------------+------------+--------------+</span><br><span class="line">| string | date       | product_id | product_name |</span><br><span class="line">+--------+------------+------------+--------------+</span><br><span class="line">| 商品   | <span class="number">2009</span>-05-<span class="number">24</span> | 0001       | T恤衫        |</span><br><span class="line">| 商品   | <span class="number">2009</span>-05-<span class="number">24</span> | 0002       | 打孔器       |</span><br><span class="line">| 商品   | <span class="number">2009</span>-05-<span class="number">24</span> | 0003       | 运动T恤      |</span><br><span class="line">| 商品   | <span class="number">2009</span>-05-<span class="number">24</span> | 0004       | 菜刀         |</span><br><span class="line">| 商品   | <span class="number">2009</span>-05-<span class="number">24</span> | 0005       | 高压锅       |</span><br><span class="line">| 商品   | <span class="number">2009</span>-05-<span class="number">24</span> | 0006       | 叉子         |</span><br><span class="line">| 商品   | <span class="number">2009</span>-05-<span class="number">24</span> | 0007       | 擦菜板       |</span><br><span class="line">| 商品   | <span class="number">2009</span>-05-<span class="number">24</span> | 0008       | 圆珠笔       |</span><br><span class="line">+--------+------------+------------+--------------+</span><br><span class="line"><span class="number">8</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol><li>去重：在SELECT语句中使用DISTINCT可以去除重复行。<br>NULL 也被视为一类数据。NULL 存在于多行中时，会被合并为一条NULL 数据。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT </span><br><span class="line">    -&gt;   DISTINCT regist_date </span><br><span class="line">    -&gt;  FROM Product;</span><br><span class="line"></span><br><span class="line"><span class="comment">#原表regist_date 字段有三个重复的2009-09-20 </span></span><br></pre></td></tr></table></figure><p>多个字段组合删除：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  DISTINCT product_type, regist_date</span><br><span class="line"> FROM Product;</span><br><span class="line"></span><br><span class="line"><span class="comment">#（删除product_type, regist_date都重复的商品）</span></span><br></pre></td></tr></table></figure></p><h4 id="3-2-6-指定查询和比较运算符"><a href="#3-2-6-指定查询和比较运算符" class="headerlink" title="3.2.6 指定查询和比较运算符"></a>3.2.6 指定查询和比较运算符</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SELECT &lt;字段名&gt;, ……</span><br><span class="line">  FROM &lt;表名&gt;</span><br><span class="line"> WHERE &lt;条件表达式&gt;;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SELECT product_name</span><br><span class="line">  FROM Product</span><br><span class="line"> WHERE product_type = <span class="string">&#x27;衣服&#x27;</span>;</span><br><span class="line"> -- 结果如下</span><br><span class="line">+--------------+</span><br><span class="line">| product_name |</span><br><span class="line">+--------------+</span><br><span class="line">| T恤衫        |</span><br><span class="line">| 运动T恤      |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><ul><li>WHERE 子句中通过使用比较运算符可以组合出各种各样的条件表达式。（&gt;&lt;=等等）不能对NULL使用任何比较运算符，只能通过IS NULL、IS NOT NULL语句来判断</li><li><p>字符串比较：按照字典顺序进行比较，也就是像姓名那样，按照条目在字典中出现的顺序来进行排序。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span>  &lt; <span class="string">&#x27;10&#x27;</span> &lt; <span class="string">&#x27;11&#x27;</span> &lt; <span class="string">&#x27;2&#x27;</span> &lt; <span class="string">&#x27;222&#x27;</span> &lt; <span class="string">&#x27;3&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>也可以使用逻辑运算符AND OR NOT。NULL和任何值做逻辑运算结果都是不确定（第三种真值UNKNOWN）。因此尽量给字段加上NOT NULL的约束。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SELECT product_type, sale_price</span><br><span class="line">    FROM Product</span><br><span class="line">WHERE product_type = <span class="string">&#x27;厨房用具&#x27;</span> </span><br><span class="line">AND sale_price &gt;= <span class="number">3000</span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-表的复制"><a href="#3-3-表的复制" class="headerlink" title="3.3 表的复制"></a>3.3 表的复制</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>CREATE TABLE Product_COPY1 SELECT * FROM Product;</td><td>从product表复制表Product_COPY1</td></tr><tr><td>CREATE TABLE Product_COPY1 LIKe Product;</td><td>通过LIKE复制表结构</td></tr></tbody></table></div><h2 id="四、Mysql-分组查询"><a href="#四、Mysql-分组查询" class="headerlink" title="四、Mysql-分组查询"></a>四、Mysql-分组查询</h2><h3 id="4-1-聚合函数"><a href="#4-1-聚合函数" class="headerlink" title="4.1 聚合函数"></a>4.1 聚合函数</h3><p>通过 SQL 对数据进行某种操作或计算时需要使用函数。</p><ul><li>COUNT：计算表中的记录数（行数）</li><li>SUM： 计算表中数值列中数据的合计值</li><li>AVG： 计算表中数值列中数据的平均值</li><li>MAX： 求出表中任意列中数据的最大值</li><li>MIN： 求出表中任意列中数据的最小值</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) FROM Product;<span class="comment">#其它的函数均不可以将*作为参数</span></span><br><span class="line">SELECT COUNT(purchase_price) FROM Product;<span class="comment">#字段名为参数，只会计算不包含NULL的行。AVG函数，计算时分母也不会算上NULL行。</span></span><br></pre></td></tr></table></figure><ul><li>MAX/MIN函数几乎适用于所有数据类型的列，包括字符和日期。SUM/AVG函数只适用于数值类型的列。</li><li>在聚合函数删除重复值，DISTINCT必须写在括号中。这是因为必须要在计算行数之前删除 product_type 字段中的重复数据。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT product_type)</span><br><span class="line"> FROM Product;</span><br><span class="line"> </span><br><span class="line">-- 结果如下</span><br><span class="line">+------------------------------+</span><br><span class="line">| COUNT(DISTINCT product_type) |</span><br><span class="line">+------------------------------+</span><br><span class="line">|                            <span class="number">3</span> |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><h3 id="4-2-对表分组"><a href="#4-2-对表分组" class="headerlink" title="4.2 对表分组"></a>4.2 对表分组</h3><p>类似pandas的group by语句，也是group by分组，语法结构如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SELECT &lt;列名<span class="number">1</span>&gt;, &lt;列名<span class="number">2</span>&gt;, &lt;列名<span class="number">3</span>&gt;, ……</span><br><span class="line"> FROM &lt;表名&gt;</span><br><span class="line"> GROUP BY &lt;列名<span class="number">1</span>&gt;, &lt;列名<span class="number">2</span>&gt;, &lt;列名<span class="number">3</span>&gt;, ……;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SELECT product_type, COUNT(*)</span><br><span class="line"> FROM Product</span><br><span class="line"> GROUP BY product_type;</span><br><span class="line"> </span><br><span class="line">-- 结果如下</span><br><span class="line">+--------------+----------+</span><br><span class="line">| product_type | COUNT(*) |</span><br><span class="line">+--------------+----------+</span><br><span class="line">| 衣服         |        <span class="number">2</span> |</span><br><span class="line">| 办公用品     |        <span class="number">2</span> |</span><br><span class="line">| 厨房用具     |        <span class="number">4</span> |</span><br><span class="line">+--------------+----------+</span><br></pre></td></tr></table></figure><ol><li><p>在该语句中，我们首先通过GROUP BY函数对指定的字段product_type进行分组。分组时，product_type字段中具有相同值的行会汇聚到同一组。</p></li><li><p>最后通过COUNT函数，统计不同分组的包含的行数。</p></li><li>NULL的数据会被聚合为一组。</li><li>语句顺序：1. SELECT → 2. FROM → 3. WHERE → 4. GROUP BY</li></ol><p>windows下安装PyMySQL：<code>python -m pip install PyMySQL</code><br>centos安装： <code>pip install PyMySQL</code></p><h2 id="五、redis安装连接"><a href="#五、redis安装连接" class="headerlink" title="五、redis安装连接"></a>五、redis安装连接</h2><p>redis安装地址：<a href="https://redis.io/download">官网</a>，选择安装5.0.14。<br>参考文章<a href="https://blog.csdn.net/username666/article/details/104687598?utm_source=app&amp;app_version=4.20.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen">《CentOS 7安装Redis5.0.7》</a>、<a href="https://www.cnblogs.com/heqiuyong/p/10463334.html">《Centos7安装Redis》</a></p><ol><li>解压安装<br>解压：<code>tar -zxvf redis-5.0.14.tar.gz</code><br>进入目录后安装：<code>cd redis-5.0.14</code><br>先运行：<code>make</code><br>然后指定目录安装：<code>make install PREFIX=/usr/local/redis</code><br>第一次只编译了一次，没有redis -cli命令<br>==后来liunx系统时间不对。本地时间2021-12-14，liunx时间是2021-7-20。编译显示创建不完整，也是错误。==<br><img src="https://img-blog.csdnimg.cn/e0dfd02e23ac43b58d0b42c208ecaf3b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ol><ol><li>前台启动</li></ol><p>[root@localhost redis-5.0.3]# cd /usr/local/redis/bin/<br>[root@localhost bin]# ./redis-server<br>启动后如图所示：<br><img src="https://img-blog.csdnimg.cn/c599aad448364629a38ec1e9006bc4ce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>==前台启动的时候exit没退出直接ctrl+z强行退出，结果其实redis服务一直没退，后面systemctl start redis.service、systemctl status redis.service一直显示redis状态没开，端口被占用。xshell重现连接才好的。==</p><ol><li>后台启动</li></ol><p>从 redis 的源码目录中复制 redis.conf 到 redis 的安装目录<br>[root@localhost bin]# cp /usr/local/redis-5.0.3/redis.conf /usr/local/redis/bin/</p><p>修改安装目录/usr/local/redis/bin/下的redis.conf配置文件：<code>vim redis.conf</code><br>修改以下配置：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#bind 127.0.0.1 # 将这行代码注释，监听所有的ip地址，外网可以访问</span></span><br><span class="line">protected-mode no <span class="comment"># 把yes改成no，允许外网访问</span></span><br><span class="line">daemonize yes <span class="comment"># 把no改成yes，后台运行</span></span><br><span class="line"></span><br><span class="line">./redis-server redis.conf<span class="comment">#此时就可以后台启动了</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7a7b65420e334069bd3aeca8651aee70.png" alt="在这里插入图片描述"></p><ol><li>设置开机启动<br>添加开机启动服务<code>[root@localhost bin]# vi /etc/systemd/system/redis.service</code></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="type">Type</span>=forking</span><br><span class="line">ExecStart=/usr/local/redis/<span class="built_in">bin</span>/redis-server /usr/local/redis/<span class="built_in">bin</span>/redis.conf<span class="comment">#改成自己redis.conf地址，不写的话后面报错</span></span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ol><li>设置开机启动<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">bin</span>]<span class="comment"># systemctl daemon-reload</span></span><br><span class="line">[root@localhost <span class="built_in">bin</span>]<span class="comment"># systemctl start redis.service</span></span><br><span class="line">[root@localhost <span class="built_in">bin</span>]<span class="comment"># systemctl enable redis.service</span></span><br></pre></td></tr></table></figure>其它服务操作命令：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">systemctl start redis.service   <span class="comment">#启动redis服务</span></span><br><span class="line">systemctl stop redis.service   <span class="comment">#停止redis服务</span></span><br><span class="line">systemctl restart redis.service   <span class="comment">#重新启动服务</span></span><br><span class="line">systemctl status redis.service   <span class="comment">#查看服务当前状态</span></span><br><span class="line">systemctl enable redis.service   <span class="comment">#设置开机自启动</span></span><br><span class="line">systemctl disable redis.service   <span class="comment">#停止开机自启动</span></span><br></pre></td></tr></table></figure></li><li><p>创建 redis 命令软链接：<code>[root@localhost ~]# ln -s /usr/local/redis/bin/redis-cli /usr/bin/redis</code></p></li><li><p>连接 redis并退出：（按上面走完就ok了。不知道为啥redis -cli不行）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@<span class="number">192</span> <span class="built_in">bin</span>]<span class="comment"># redis</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ping</span><br><span class="line">PONG</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; quit</span><br><span class="line">[root@<span class="number">192</span> <span class="built_in">bin</span>]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li><li>redis-cli 未找到命令的一个解决方式</li></ol><p>将redis解压后的安装文件redis-5.0.14下src目录里的redis-cli文件，复制到/usr/local/bin/路径中<br>[root@localhost redis-5.0.14]# cp src/redis-cli  /usr/local/bin/<br>现在就可以执行redis-cli命令了。</p><h2 id="六、redis操作命令"><a href="#六、redis操作命令" class="headerlink" title="六、redis操作命令"></a>六、redis操作命令</h2><p>具体操作参考<a href="https://github.com/datawhalechina/fun-rec/blob/master/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/2.2%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/docs/2.2.1.3%20Redis%E5%9F%BA%E7%A1%80.md">《Redis基础.md》</a></p><ul><li>EXPIRE key_name seconds  :多少秒后名为key_name的key自动删除。key存在返回1，否则返回0。<br>127.0.0.1:6378&gt; set key1 “value”：string类型的key<br>127.0.0.1:6378&gt;  lpush key2 “value”：list类型key<br>127.0.0.1:6378&gt; SADD key3 “value”：set类型key</li><li>DEL key：删除key，可以是列表</li><li>TYPE key：查看key的类型</li></ul><p>Python调用Redis：<br>windows下安装redis库：<code>python -m pip install redis</code><br>centos下安装：<code>pip install redis</code></p><h2 id="七、MongoDB"><a href="#七、MongoDB" class="headerlink" title="七、MongoDB"></a>七、MongoDB</h2><h3 id="7-1-安装MongoDB"><a href="#7-1-安装MongoDB" class="headerlink" title="7.1 安装MongoDB"></a>7.1 安装MongoDB</h3><p>先安装libcurl 和openssl。</p><ol><li>yum命令出现Loaded plugins: fastestmirror Determining fastest mirrors 在进行yum安装的时候报错。参考<a href="https://blog.csdn.net/Me_find/article/details/110653042?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163948605316780274130394%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163948605316780274130394&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-110653042.pc_search_insert_es_download_v2&amp;utm_term=%E5%B7%B2%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6%EF%BC%9Afastestmirror&amp;spm=1018.2226.3001.4187">此文</a>进行修改。</li><li>[Errno 14] curl#6 - “Could not resolve host: mirrors.163.com； Unknown error“。参考<a href="https://blog.csdn.net/N199109/article/details/113175144?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163948646516780261960225%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163948646516780261960225&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-113175144.pc_search_insert_es_download_v2&amp;utm_term=Could%20not%20resolve%20host:%20mirrors.163.com;%20%E6%9C%AA%E7%9F%A5%E7%9A%84%E9%94%99%E8%AF%AF&amp;spm=1018.2226.3001.4187">此文</a></li></ol><p>然后直接<code>yum install libcurl  yum install openssl</code><br>一开始两个显示网站下载太慢尝试其它镜像，第三个网站顺利下载了。</p><p>at /etc/issue <a href="https://blog.csdn.net/shuaigexiaobo/article/details/78030008?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163949014816780265412839%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163949014816780265412839&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-78030008.pc_search_insert_es_download_v2&amp;utm_term=%E6%9F%A5%E7%9C%8Bcentos%E7%89%88%E6%9C%AC&amp;spm=1018.2226.3001.4187">查看centos版本</a>。然后在<a href="https://www.mongodb.com/try/download/community">官网</a>下载。<br><img src="https://img-blog.csdnimg.cn/4d56ad46c01e4f6f98b49408a1f9b75a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>copy链接之后：<code>wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-5.0.5.tgz</code><br>解压：<code>tar -zxvf mongodb-linux-x86_64-rhel70-5.0.5.tgz</code><br>重命名<code>mv mongodb-linux-x86_64-rhel70-5.0.5 mongodb-5</code></p><p>可以将MongoDB 的可执行文件（bin目录下）添加到 PATH 路径中<code>export PATH=/usr/local/mongodb/bin:$PATH</code>（这步貌似是临时的，但是不执行mongod命令无法执行）<br>配置MongoDB，编辑etc下的profile文件，加入一句指令：<code>export PATH=$PATH:/usr/local/mongodb-5/bin</code>。配置完保存，之后将CentOS7关机重启。<br><img src="https://img-blog.csdnimg.cn/0b0c083d51f34046abdd703c9f993b6e.png" alt="在这里插入图片描述"></p><p>创建数据存储目录：<code>mkdir -p /var/lib/mongo</code><br>创建日志目录：<code>mkdir -p /var/log/mongodb</code></p><p>启动mongo服务：<code>mongod --dbpath /var/lib/mongo --logpath /var/log/mongodb/mongod.log --fork</code></p><p>通过 ps ax | grep mongod查看数据库启动情况，如下图表示启动成功：<br><img src="https://img-blog.csdnimg.cn/77391c2abd7f4c608af2b92a3f66c3dd.png" alt="在这里插入图片描述"></p><blockquote><p>配置文件参考<a href="https://blog.csdn.net/qq_43317529/article/details/83033691?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163964441616780264030489%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163964441616780264030489&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-83033691.pc_search_insert_es_download_v2&amp;utm_term=centos%E5%AE%89%E8%A3%85mongodb&amp;spm=1018.2226.3001.4187">帖子1</a>、<a href="https://blog.csdn.net/m0_37027631/article/details/99934697?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=centos%E5%AE%89%E8%A3%85mongodb&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-99934697.pc_search_insert_es_download_v2&amp;spm=1018.2226.3001.4187">帖子2</a></p></blockquote><p>在usr/mongodb目录下新建一个名为mongodb.conf的配置文件，写入如下配置内容（不能有中文）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">port=<span class="number">27017</span></span><br><span class="line">dbpath=/var/lib/mongo</span><br><span class="line">logpath=/var/log/mongodb</span><br><span class="line">logappend=true</span><br><span class="line">fork=false</span><br><span class="line">maxConns=<span class="number">100</span></span><br><span class="line">noauth=true</span><br><span class="line">journal=true</span><br><span class="line">bind_ip = <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>保存。然后输入命令启动<code>mongod --config /usr/local/mongodb-5/mongodb.conf</code></p><p>关闭mongodb服务通过ps ax | grep mongod命令查看mongodb运行的id<br><img src="https://img-blog.csdnimg.cn/890bf81dcb7a4899886c3e77f3ec1a4e.png" alt="在这里插入图片描述"><br>然后输入kill -9 进程id，杀死mongodb服务，如上图执行命令<br>保存。然后输入命令启动mongod —config /usr/local/mongodb-5/mongodb.conf</p><h3 id="7-2-Mongodb操作"><a href="#7-2-Mongodb操作" class="headerlink" title="7.2 Mongodb操作"></a>7.2 Mongodb操作</h3><h4 id="7-2-1-数据库"><a href="#7-2-1-数据库" class="headerlink" title="7.2.1 数据库"></a>7.2.1 数据库</h4><p><img src="https://img-blog.csdnimg.cn/9d92e4e368984efdb91a388cefa3b95a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>“show dbs” ：显示所有数据的列表。</li><li>“db” ：显示当前数据库对象或集合。</li><li>“use”：连接到一个指定的数据库。</li><li>use 数据库名：创建数据库。刚创建的数据库 tobytest并不在数据库的列表中，需要插入数据。</li><li>db.tobytest.insert({“name”:”Toby”})：向数据库插入数据<h4 id="7-2-2-创建集合"><a href="#7-2-2-创建集合" class="headerlink" title="7.2.2 创建集合"></a>7.2.2 创建集合</h4></li><li><code>db.createCollection(name, options)</code>：创建集合</li><li><code>show collections 或 show tables</code> :查看集合</li><li><code>db.collection.drop()</code>：删除集合</li></ul><p>name: 要创建的集合名称<br>options: 可选参数, 指定有关内存大小及索引的选项</p><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">db.createCollection(<span class="string">&quot;tobycollection&quot;</span>)</span><br><span class="line">db.tobycollection.drop()</span><br></pre></td></tr></table></figure><h4 id="7-2-3-插入文档"><a href="#7-2-3-插入文档" class="headerlink" title="7.2.3  插入文档"></a>7.2.3  插入文档</h4><p><code>db.COLLECTION_NAME.insert(document)</code>：插入文档<br><code>db.COLLECTION_NAME.save(document)</code>：插入文档</p><ul><li>save()：如果 _id 主键存在则更新数据，如果不存在就插入数据。该方法新版本中已废弃，可以使用 db.collection.insertOne() 或 db.collection.replaceOne() 来代替。</li><li>insert(): 若插入的数据主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常，提示主键重复，不保存当前数据。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">db.col.insert(&#123;title:<span class="string">&#x27;Toby MongoDB&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>description:<span class="string">&#x27;this is MongoDB&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>tags:[<span class="string">&#x27;mongodb&#x27;</span>,<span class="string">&#x27;database&#x27;</span>,<span class="string">&#x27;NoSQL&#x27;</span>],</span><br><span class="line"><span class="meta">... </span>likes:<span class="number">1</span></span><br><span class="line"><span class="meta">... </span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#col 是我们的集合名，如果该集合不在该数据库中， MongoDB 会自动创建该集合并插入文档。</span></span><br></pre></td></tr></table></figure><ul><li>更新文档</li><li>删除文档</li><li>查询文档</li><li>排序</li></ul><h3 id="7-3-Python-MongoDB"><a href="#7-3-Python-MongoDB" class="headerlink" title="7.3 Python MongoDB"></a>7.3 Python MongoDB</h3><p>Python 要连接 MongoDB 需要 MongoDB 驱动，这里我们使用 PyMongo 驱动来连接。<br>安装：<code>pip install pymongo</code></p><p>用vim打开一个空白文档，然后把已经复制的代码给粘贴进来，发现它有自动缩进功能，最终导致粘贴的文本一行比一行靠右，看起来乱成一团。比较快的解决办法是，在粘贴文档前，在命令行模式下，输入：<code>:set paste</code><br>编辑完后输入：<code>:set nopaste</code></p><h2 id="八、scrapy"><a href="#八、scrapy" class="headerlink" title="八、scrapy"></a>八、scrapy</h2><p>按照教程写的编辑好那些文件之后执行sh run<em>scrapy_sina.sh报错：<br>参考：[帖子](<a href="https://blog.csdn.net/lmhlmh">https://blog.csdn.net/lmhlmh</a></em>/article/details/107135295?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163950211916780271576675%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=163950211916780271576675&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-107135295.pc_search_insert_es_download_v2&amp;utm_term=Unknown%20command:%20crawl&amp;spm=1018.2226.3001.4187)<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Scrapy <span class="number">2.5</span><span class="number">.1</span> - no active project</span><br><span class="line">Unknown command: crawl</span><br></pre></td></tr></table></figure><br><code>no active project</code>：说明我的工程有问题。</p><p>于是去看了看目录结构。查了下手册。在使用命令行startproject的时候，会自动生成scrapy.cfg</p><p>问题就出在这里，别人的项目文件中只有代码，没有配置文件，于是自己找了一个配置文件scrapy.cfg<br><img src="https://img-blog.csdnimg.cn/b32e3a99203643f9846fce7c0ed15f9e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li>No module named ‘pymongo‘</li></ol><ul><li>这是因为我的centos有python2和3两个版本。执行py文件的时候要写python3 xx.py。而教程里面都是直接写python。</li><li>改动成python就可以执行python3操作：<ul><li>cd /usr/bin</li><li>备份原路径：mv python python.bak</li><li>python 链接到python3 ：ln -s python3 python</li><li>查看版本：python -V现在显示python3而不是2了</li><li>修改yum配置文件（yum要使用python2才可以运行）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以下两个配置文件最顶部的\#!/usr/bin/python修改为 #!/usr/bin/python2</span></span><br><span class="line">vim /usr/<span class="built_in">bin</span>/yum</span><br><span class="line">vim /usr/libexec/urlgrabber-ext-down</span><br></pre></td></tr></table></figure>vim向下删除到文档结尾：dG<br>运行 sh run_scrapy_sina.sh显示没有库sinanews，将monitor_news.py的<code>from sinanews.settings import MONGO_HOST, MONGO_PORT, DB_NAME, COLLECTION_NAME</code>前面的sinanews.删除。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;@[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://github.com/datawhalechina/fun-rec/blob/master/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/2.2%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/docs/2.2.1.1%20Mysql%E5%9F%BA%E7%A1%80.md&quot;&gt;Mysql基础.md&lt;/a&gt;&lt;br&gt;本项目来自&lt;a href=&quot;https://github.com/datawhalechina/fun-rec/tree/master/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/2.2%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98&quot;&gt;《fun-rec/docs/第二章 推荐系统实战/2.2新闻推荐系统实战/》&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://share.weiyun.com/u3ZIjZfg&quot;&gt;【交流分享-腾讯微云】&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; vim /etc/resolv.conf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Google&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nameserver &lt;span class=&quot;number&quot;&gt;8.8&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.8&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nameserver &lt;span class=&quot;number&quot;&gt;8.8&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.4&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conda activate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;mysql命令&lt;/p&gt;</summary>
    
    
    
    <category term="12月组队学习：推荐系统" scheme="https://zhxnlp.github.io/categories/12%E6%9C%88%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="推荐系统" scheme="https://zhxnlp.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="数据库" scheme="https://zhxnlp.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="前端开发" scheme="https://zhxnlp.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>task0：Fun-Rec推荐系统视频讲解</title>
    <link href="https://zhxnlp.github.io/2021/12/13/12%E6%9C%88%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/task0%EF%BC%9AFun-Rec%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%A7%86%E9%A2%91%E8%AE%B2%E8%A7%A3/"/>
    <id>https://zhxnlp.github.io/2021/12/13/12%E6%9C%88%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/task0%EF%BC%9AFun-Rec%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E8%A7%86%E9%A2%91%E8%AE%B2%E8%A7%A3/</id>
    <published>2021-12-13T09:52:39.000Z</published>
    <updated>2021-12-31T23:24:06.472Z</updated>
    
    <content type="html"><![CDATA[<p>视频讲解地址：<a href="https://datawhale.feishu.cn/minutes/obcnzns778b725r5l535j32o">Task01：熟悉推荐系统基本流程</a><br><a href="http://47.108.56.188:8686/#/recLists">推荐系统项目网页地址</a></p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>本项目是离线的推荐系统。即不是实时的通过用户 ID 等信息通过模型实时、动态地获取用户的推荐列表，而是==提前已经把用户的这个推荐列表计算好了，用Redis存到了这个倒排索引表里面。我们线下线上真正要做的事情就是从这个 Redis 里面去拉取就够了。所以这里可能就会存在一个 T + 1 的延迟。（后面一天才会更新前一天的动态数据）==</p><p>推荐系统架构如下图：<br><span id="more"></span><br><img src="https://img-blog.csdnimg.cn/7dd55b57470b4889b907e1b7cea0bb95.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>除了离线offline部分，系统还有online部分，跟后端数据交互。<br>onlineserver：offline得到的的倒排索引数据经过online server处理后才给到online。如果不处理直接拉过来，会产生问题：</p><ul><li>推荐页和热门页挤在一起重复曝光（推荐页看过的热门页又看了一遍）</li><li>同的类别的很多东西会摞在一起，影响体验（同类产品score可能相近）</li><li>新用户需要冷启动策略<br>recsysserver：和onlineserver一样处理后端数据</li></ul><p>offline：得到用户第二天需要展示的推荐列表。</p><ul><li>爬取新物料并处理成物料画像</li><li>获得用户操作的动态信息，更新用户画像（年龄性别、物料侧标签得到的长短期兴趣等）</li><li>根据模型做出推荐列表</li></ul><p>画像处理有两部分：处理新来物料，更新旧物料动态属性。处理完后从Mongo DB 存到Redis（前端新闻展示信息）。如果还是在Mongo DB操作会很卡。<br>热门页：直接更新物料库里所有新闻的热度，做出倒排索引存入Redis。<br>推荐页：用模型得出倒排索引，涉及冷启动问题</p><h2 id="二、网页"><a href="#二、网页" class="headerlink" title="二、网页"></a>二、网页</h2><p>打开<a href="http://47.108.56.188:8686/#/之后按下F12键，然后登陆系统。在network里面有login、user_id等字典信息，是通过json的前后端交互得到的。">http://47.108.56.188:8686/#/之后按下F12键，然后登陆系统。在network里面有login、user_id等字典信息，是通过json的前后端交互得到的。</a><br>code表示前后端处理状态/进度，这里表示登陆成功login success。<br><img src="https://img-blog.csdnimg.cn/b8ef0c7375144a0d9b411452d187529e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>现在跳转到推荐页。rec_list?user_id=zhxscut：表示当前页展示信息。也有状态和json。<br>登陆之后跳转到推荐页也是按设定逻辑前后端交互好的。<br><img src="https://img-blog.csdnimg.cn/f5bc5d79199d420fa77ac37ad41811f7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>data点开之后是一个数组，每个数组点开是一条新闻。包括类别、时间、标题、收藏、喜欢、阅读次数、url等。<br><img src="https://img-blog.csdnimg.cn/4ef2b5364bcf49c6bfa11a12530bc86e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/916adedbb25f4d1b8fef12006497639d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>左侧推荐页面展示10条数据，往下拉的时候不够了不够展示了，再往下拉的时候他会重新请求重新去后端拉 10 个数据，右侧显示几个新的rec_list。<br>点击热门页，右侧显示hot_list?user_id=zhxscut：。<br>打开一篇新闻，会有news_detail?和一个action。点击喜欢或者收藏会有一个action。<br><img src="https://img-blog.csdnimg.cn/a80a2ba84cfd4449be881a60f24b02ce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>前后端交互核心：通过url链接。前端展示的 URL （这个项目的网址）和我们后端资源访问的 URL （推荐新闻页面）是不一样的</p><h2 id="三、项目代码解读"><a href="#三、项目代码解读" class="headerlink" title="三、项目代码解读"></a>三、项目代码解读</h2><h3 id="3-1-前端url"><a href="#3-1-前端url" class="headerlink" title="3.1 前端url"></a>3.1 前端url</h3><p><img src="https://img-blog.csdnimg.cn/35b7d1fc8b024bf6afb52ae91857aa6e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>router.js：路由，path：‘/’就是根目录，默认是signin界面。对应的是componence下面的signin.vue页面,展示的样式、处理逻辑等。<br><img src="https://img-blog.csdnimg.cn/44dbec30656441d483551bd666dd8b45.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>除了登陆页面还有注册、hot_list、rec_list页面等。</p><p>前后端交互的时候，我们可以大框架都可以看不懂，但是我们可以。但至少要知道比如说我推荐什么东西之后，一些我要搞的东西可能有些变化。那我们应该去看哪块的代码，他怎么是写的，我应该怎么改，大概需要了解一下这个</p><p><img src="https://img-blog.csdnimg.cn/9a0b9612f6214c1b8a6efe1983bcd58e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>上图表示post后端请求验证用户名和密码，登陆后跳转到推荐页。<br>状态码：<br><img src="https://img-blog.csdnimg.cn/3039bde92f3642f58b9dbe50de19d2cd.png" alt="在这里插入图片描述"></p><h3 id="3-2-后端url"><a href="#3-2-后端url" class="headerlink" title="3.2 后端url"></a>3.2 后端url</h3><p><img src="https://img-blog.csdnimg.cn/4c53729673c84bdfa5c5fb4e5d55619b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>后端url通过get list 方法获取，即通过 get 请求去后端拉取数据。<br>get 请求它就是这种格式：一个问号后面加上一些参数，比如说用户名或者是年龄性别之类的，当然还有 post 的请求。<br>get 请求：前端往后端发东西的时候会把一些具体的参数写在这个 URL 里面。</p><p>flask ： Python 的一个 web 框架，做20w用户的网站是没问题的，再多就不行了。<br><img src="https://img-blog.csdnimg.cn/56648b9d7b6a4c748efbcc201fa5f0c2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>server：app.route是一个路由，装饰器，第一个参数是url，第二个参数是get请求（对应下面的arg.get）。然后绑定一个具体的函数rec_list。<br>绑定的函数通过 flask 路由，根据当前的这个 URL 实现它要处理的具体逻辑，比如说现在是获取推荐列表（上一步reclist.vue里面的推荐列表）</p><p>try：<br>    rec_new_list=：表示从后端Redis拿取数据，即onlineserver、recsysserver后端请求这块。</p><p>signin没有url，不用get请求，而是post请求直接request.get_data。</p><h2 id="四、推荐系统流程"><a href="#四、推荐系统流程" class="headerlink" title="四、推荐系统流程"></a>四、推荐系统流程</h2><h3 id="4-1-物料处理"><a href="#4-1-物料处理" class="headerlink" title="4.1 物料处理"></a>4.1 物料处理</h3><p>物料处理自动化主要体现在使用 clone Tab 然后把整个链路给连串起来了：<br><img src="https://img-blog.csdnimg.cn/8ce84dd9357840a3bf380a9e1c61adbc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>上图表示：每天0点会运行很多命令。</p><ul><li>爬虫获取物料，代码在materials下的news_scrapy。爬取完存在mongoDB。</li><li>写入日志</li><li>离线处理物料（新闻物料和用户画像）</li><li>处理完写入日志</li><li>通过算法策略等用处理后物料生成排序列表，存入Redis</li><li>再写入日志。<br>整个过程就串起来了。</li></ul><p><img src="https://img-blog.csdnimg.cn/d5398c3bab1040e6b7a6e9635fba29d5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>终端输入mongo，进入后输入show dbs，显示所有数据库。<br>第一个是存推荐系统相关的物料画像、用户画像。<br>输入use SinaNews切换数据库、show collections显示数据。<br>通过以下命令查看爬取的新闻：<br><img src="https://img-blog.csdnimg.cn/b50bc5cb5707436c8b96bea51cff5037.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>每天爬取的数据会存盘一次，方便回溯。</p><h3 id="4-2-物料处理"><a href="#4-2-物料处理" class="headerlink" title="4.2 物料处理"></a>4.2 物料处理</h3><p>爬取的物料通过下面的sh文件，运行里面的三个py代码，更新画像和更新Redis。第三个py文件没有排序列表，而是新闻的详细信息。<br><img src="https://img-blog.csdnimg.cn/33ff79550d8547dea94218577908e27d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="4-2-1-更新物料画像，代码如下："><a href="#4-2-1-更新物料画像，代码如下：" class="headerlink" title="4.2.1 更新物料画像，代码如下："></a>4.2.1 更新物料画像，代码如下：</h4><p><img src="https://img-blog.csdnimg.cn/86d84fd455c84809b4f8bfd265c1ba25.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>更新存入mongo是为了备份，避免Redis数据被清空。</p><p>mongo NewsRecSys下面有三个集合。Feature集合是特征画像（物料池），只存了一份（方便处理，也可以分布式存储），包含每天用户交互的一些新闻产生的动态特征。<br>第二个部分update_news_items()代码如下：（点击函数跳转）<br><img src="https://img-blog.csdnimg.cn/ca5611c0c224475e899880b24850c8e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>遍历今天爬去的所有数据（SinaNews），去重，初始化等生成特征画像，存入物料池（比如点击收藏开始都是0，热度是1000，逐渐衰减）<br>以上对应：<br><img src="https://img-blog.csdnimg.cn/bebbbf63bba442f88b25d89d6127c2e5.png" alt="在这里插入图片描述"></p><h4 id="4-2-2-当天新闻动态画像更新"><a href="#4-2-2-当天新闻动态画像更新" class="headerlink" title="4.2.2 当天新闻动态画像更新"></a>4.2.2 当天新闻动态画像更新</h4><ul><li>用户浏览新闻时，会有点击、收藏、喜欢等操作。这个是需要实时反馈的，但是又不可能每次都去MongoDB 那个物料库里面去把他拉回来展示。把新闻展示的物料分成了两部分，一部分是静态的，一部分是动态的，都是存在 Redis 里面。</li><li>静态：标题、类别、详情页</li><li>动态：阅读次数、喜欢次数和收藏次数。</li><li>用户在前端交互完之后，立马修改动态的信息，并且再拉回来再展示。此时物料池并没有更新</li><li>Redis 在清除缓存前，需要遍历动态画像，更新到物料画像池。</li></ul><p>动态信息更新到物料池代码：<br><img src="https://img-blog.csdnimg.cn/018c45ebe4d9446b8cfcece9e97e4513.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/b21498be38cd47c1ae173921256a000f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>dao_config：注释了每个数据库存了什么。<br><img src="https://img-blog.csdnimg.cn/361ad3949e8c4829a2eb4826c3030895.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>上面显示动态数据在2号库，静态在1号库。redis就是一个k-v系统。<br><img src="https://img-blog.csdnimg.cn/76823696fd5d43b7b1c3e3d5e2c7bb47.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>通过get得到静态信息。<br>==通过新闻 ID get对应的静态信息和动态信息，拼接起来送到这个前端展示==</p><p>redis-cli —raw参数设置可以看中文，否则有些信息显示乱码。redis-cli 无空格。2号库动态信息展示如图：<br><img src="https://img-blog.csdnimg.cn/7fd2bb930b6e4dc7babe6a4cf16206a8.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;视频讲解地址：&lt;a href=&quot;https://datawhale.feishu.cn/minutes/obcnzns778b725r5l535j32o&quot;&gt;Task01：熟悉推荐系统基本流程&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://47.108.56.188:8686/#/recLists&quot;&gt;推荐系统项目网页地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;本项目是离线的推荐系统。即不是实时的通过用户 ID 等信息通过模型实时、动态地获取用户的推荐列表，而是==提前已经把用户的这个推荐列表计算好了，用Redis存到了这个倒排索引表里面。我们线下线上真正要做的事情就是从这个 Redis 里面去拉取就够了。所以这里可能就会存在一个 T + 1 的延迟。（后面一天才会更新前一天的动态数据）==&lt;/p&gt;
&lt;p&gt;推荐系统架构如下图：&lt;br&gt;</summary>
    
    
    
    <category term="12月组队学习：推荐系统" scheme="https://zhxnlp.github.io/categories/12%E6%9C%88%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="推荐系统" scheme="https://zhxnlp.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="数据库" scheme="https://zhxnlp.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="前端开发" scheme="https://zhxnlp.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记8：transformers</title>
    <link href="https://zhxnlp.github.io/2021/12/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08%EF%BC%9Atransformer%E6%80%BB%E7%BB%93%EF%BC%881%EF%BC%89/"/>
    <id>https://zhxnlp.github.io/2021/12/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08%EF%BC%9Atransformer%E6%80%BB%E7%BB%93%EF%BC%881%EF%BC%89/</id>
    <published>2021-12-05T16:03:13.000Z</published>
    <updated>2022-01-02T20:47:22.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、attention"><a href="#一、attention" class="headerlink" title="一、attention"></a>一、attention</h2><h3 id="1-1循环神经网络的不足："><a href="#1-1循环神经网络的不足：" class="headerlink" title="1.1循环神经网络的不足："></a>1.1循环神经网络的不足：</h3><ul><li>长距离衰减问题</li><li>解码阶段，越靠后的内容，翻译效果越差</li><li>解码阶段缺乏对编码阶段各个词的直接利用<h3 id="1-2-attention在机器翻译的优点"><a href="#1-2-attention在机器翻译的优点" class="headerlink" title="1.2 attention在机器翻译的优点"></a>1.2 attention在机器翻译的优点</h3></li></ul><ol><li>使用全部token信息而非最后时刻的context信息。由此在解码时每时刻可以计算attention权重，让输出对输入进行聚焦的能力，找到此时刻解码时最该注意的词。</li><li>attention的计算是序列各tokens的v向量和attention权重加权求和，每个词关注到所有词，一步到位，不存在长距离衰减</li><li>可以关注到不同位置的词语，而且使用多头和多层注意力、加入FFNN，表达能力更强。<span id="more"></span><h3 id="1-3-self-Attention和循环神经网络对比"><a href="#1-3-self-Attention和循环神经网络对比" class="headerlink" title="1.3 self Attention和循环神经网络对比"></a>1.3 self Attention和循环神经网络对比</h3>LSTM:非词袋模型，含有顺序信息，无法解决长距离依赖，无法并行，没有注意力机制<br>Self Attention：词袋模型，不含位置信息，没有长距离依赖，可以并行，有注意力机制。<h3 id="1-4为什么求内积之后除以-sqrt-d"><a href="#1-4为什么求内积之后除以-sqrt-d" class="headerlink" title="1.4为什么求内积之后除以$\sqrt{d}$"></a>1.4为什么求内积之后除以$\sqrt{d}$</h3>&#8195;&#8195;上面计算相似度s=<q,k>时，s要除以$\sqrt(d_{key})$(Key 向量的长度）。原因是词向量embedding维度过高时，s过大，softmax函数会进入饱和区。&lt;/font&gt;例如：<br>&#8195;&#8195;对于两个d维向量q,k，假设它们都采样自“均值为0、方差为1”的分布。Attention是内积后softmax，主要设计的运算是$e^{q⋅k}$，我们可以大致认为内积之后、softmax之前的数值在$-3\sqrt{d}$到$3\sqrt{d}$这个范围内，由于d通常都至少是64，所以$e^{3\sqrt{d}}$比较大而$e^{-3\sqrt{d}}$比较小，softmax函数进入饱和区。这样会有两个影响：</li></ol><ul><li>带来严重的梯度消失问题，导致训练效果差。</li><li>softmax之后，归一化后计算出来的结果a要么趋近于1要么趋近于0，Attention的分布非常接近一个one hot分布了，加权求和退化成胜者全拿，则解码时只关注注意力最高的（attention模型还是希望别的词也有权重）</li></ul><p>相应地，解决方法就有两个:（参考苏剑林<a href="https://kexue.fm/archives/8620">《浅谈Transformer的初始化、参数化与标准化》</a>）</p><ul><li>像NTK参数化那样，在内积之后除以$\sqrt{d}$，使q⋅k的方差变为1，对应$e^3$,$e^{−3}$都不至于过大过小，这也是常规的Transformer如BERT里边的Self Attention的做法。对公式s=<q,k>进行优化：（q和k求内积，所以其实key和q的向量长度一样。）<script type="math/tex; mode=display">s=\frac{<q,k>}{\sqrt{d_{key}}}</script></li><li>另外就是不除以$\sqrt{d}$，但是初始化q,k的全连接层的时候，其初始化方差要多除以一个d，这同样能使得使q⋅k的初始方差变为1，T5采用了这样的做法。<h3 id="1-5-slef-attention过程"><a href="#1-5-slef-attention过程" class="headerlink" title="1.5 slef-attention过程"></a>1.5 slef-attention过程</h3><img src="https://img-blog.csdnimg.cn/369d5ca872984b4bbe1b5a6eb0eb084e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU2NTkxODE0,size_16,color_FFFFFF,t_70#pic_center" alt="slef-attention过程"><br>一个粗略的类比是把它看作是在一个文件柜里面搜索<br>向量     |含义<br>———— | ——-<br>Query   |一个==便签==，上面写着你正在研究的主题<br>Key  | 柜子里的文件夹的==标签==<br>Value  |文件夹里面的内容</li></ul><p>&#8195;&#8195;首先将==主题便签==与==标签==匹配，会为每个文件夹产生一个分数（attention score）。然后取出匹配的那些文件夹里面的内容 Value 向量。最后我们将每个 Value 向量和分数加权求和，就得到 Self Attention 的输出。</p><h3 id="1-6-多头注意力可视化"><a href="#1-6-多头注意力可视化" class="headerlink" title="1.6 多头注意力可视化"></a>1.6 多头注意力可视化</h3><p>下面以head=8举例说明如下：</p><ol><li>输入 X 和8组权重矩阵$W^Q$, $W^K$ $W^V$相乘，得到 8 组 Q, K, V 矩阵。进行attention计算，得到 8 组 Z 矩阵（特就是head）</li><li>把8组矩阵拼接起来，乘以权重矩阵$W^O$，得到最终的矩阵 Z。这个矩阵包含了所有 attention heads（注意力头） 的信息。</li><li>矩阵Z会输入到 FFNN (Feed orward Neural Network)层。（前馈神经网络层接收的也是 1 个矩阵，而不是8个。其中每行的向量表示一个词）</li></ol><p>多头注意力结果串联在一起维度可能比较高，所以通过$W^{O}$进行一次线性变换，实现降维和各头信息融合的目的，得到最终结果。&lt;/font &gt;<br><img src="https://img-blog.csdnimg.cn/cb223fd81b044e83b39fd710b9cd2c3d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-75Lmm5LiN6KeJ5bey5pil5rex77yB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>&#8195;&#8195;在前面的讲解中，我们的 K、Q、V 矩阵的序列长度都是一样的。但是在实际中，K、V 矩阵的序列长度是一样的（加权求和），而 Q 矩阵的序列长度可以不一样。<br>&#8195;&#8195;这种情况发生在：在解码器部分的Encoder-Decoder Attention层中，Q 矩阵是来自解码器下层，而 K、V 矩阵则是来自编码器的输出。&lt;/font &gt;</p><h2 id="二、transformers"><a href="#二、transformers" class="headerlink" title="二、transformers"></a>二、transformers</h2><h3 id="2-1-自注意力模型的缺点及transformer的提出"><a href="#2-1-自注意力模型的缺点及transformer的提出" class="headerlink" title="2.1 自注意力模型的缺点及transformer的提出"></a>2.1 自注意力模型的缺点及transformer的提出</h3><p>自注意力模型有如下问题:.</p><ol><li>在计算自注意力时,没有考虑输入的位置信息,因此无法对序列进行建模;.</li><li>输入向量 T ,同时承担了Q、K、V三种角色,导致其不容易学习;</li><li>只考虑了两个输入序列单元之间的关系,无法建模多个输入序列单元之间更复杂的关系;</li><li>自注意力计算结果互斥,无法同时关注多个输入</li></ol><p>解决如下：</p><ul><li>加入位置编码信息，具体使用sin/cos函数，将一个位置索引值映射到一个 d 维向量上。尝试用位置嵌入（可学习的Position Embeddings(cite)）来代替固定的位置编码，结果发现两种方法产生了几乎相同的效果。于是我们选择了正弦版本，因为它可以使模型外推到，比训练集序列更长的序列。</li><li>输入X经过三个不同参数矩阵映射为不同的向量矩阵QKV（线性变换）</li><li>多层自注意力，建模多个输入序列不同单元的高阶信息。加入FFNN层通过非线性变换、前后两个linear层增强语义信息。通过残差连接和norm，使模型学习的更快。残差连接解决深层网络退化问题，norm使训练数据分布更加稳定，增强网络稳定性，加快收敛速度；使异常值不那么异常，减少过拟合。</li><li>多头自注意力：学习不同语义空间下的语义信息，表达能力更强，，可以进行多语义匹配，也相当于多个卷积核提取不同类型的特征。解决注意力互斥问题。 <h3 id="2-2-模型具体结构"><a href="#2-2-模型具体结构" class="headerlink" title="2.2 模型具体结构"></a>2.2 模型具体结构</h3>可以看出每一层都是计算之后（attention计算或者linear计算）dropout，再Add，再Norm。唯一不同是FFNN层第一层linear计算后激活，再dropout，再linear第二层。<h4 id="2-2-1-Encoder-Layer"><a href="#2-2-1-Encoder-Layer" class="headerlink" title="2.2.1 Encoder Layer"></a>2.2.1 Encoder Layer</h4>Self-Attention模型的作用是提取语义级别的信息（不存在长距离依赖），而FFNN是在各个时序上对特征进行非线性变换，提高网络表达能力。</li></ul><p><img src="https://img-blog.csdnimg.cn/953b03a12dcf4a7b82e15408bb6ab508.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-75Lmm5LiN6KeJ5bey5pil5rex77yB,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>encoder层前向传播代码表示为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, src: Tensor, src_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, src_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span></span>) -&gt; Tensor:</span></span><br><span class="line"><span class="comment">#attention层：</span></span><br><span class="line">        src = positional_encoding(src, src.shape[-<span class="number">1</span>])</span><br><span class="line">        src2 = self.self_attn(src, src, src, attn_mask=src_mask, </span><br><span class="line">        key_padding_mask=src_key_padding_mask)[<span class="number">0</span>]</span><br><span class="line">        src = src + self.dropout1(src2)</span><br><span class="line">        src = self.norm1(src)</span><br><span class="line">        <span class="comment">#FFNN层：</span></span><br><span class="line">        src2 = self.linear2(self.dropout(self.activation(self.linear1(src))))</span><br><span class="line">        src = src + self.dropout2(src2)</span><br><span class="line">        src = self.norm2(src)</span><br><span class="line">        <span class="keyword">return</span> src</span><br></pre></td></tr></table></figure></p><h4 id="2-2-2-Transformer-layer组成Encoder"><a href="#2-2-2-Transformer-layer组成Encoder" class="headerlink" title="2.2.2 Transformer layer组成Encoder"></a>2.2.2 Transformer layer组成Encoder</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransformerEncoder</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">r&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        encoder_layer（必备）</span></span><br><span class="line"><span class="string">        num_layers： encoder_layer的层数（必备）</span></span><br><span class="line"><span class="string">        norm: 归一化的选择（可选）</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    例子：</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; encoder_layer = TransformerEncoderLayer(d_model=512, nhead=8)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; transformer_encoder = TransformerEncoder(encoder_layer, num_layers=6)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; src = torch.randn((10, 32, 512))</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; out = transformer_encoder(src)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, encoder_layer, num_layers, norm=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(TransformerEncoder, self).__init__()</span><br><span class="line">        self.layer = encoder_layer</span><br><span class="line">        self.num_layers = num_layers</span><br><span class="line">        self.norm = norm</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, src: Tensor, mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, src_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span></span>) -&gt; Tensor:</span></span><br><span class="line">        output = positional_encoding(src, src.shape[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layers):</span><br><span class="line">            output = self.layer(output, src_mask=mask, src_key_padding_mask=src_key_padding_mask)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.norm <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            output = self.norm(output)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例子</span></span><br><span class="line">encoder_layer = TransformerEncoderLayer(d_model=<span class="number">512</span>, nhead=<span class="number">8</span>)</span><br><span class="line">transformer_encoder = TransformerEncoder(encoder_layer, num_layers=<span class="number">6</span>)</span><br><span class="line">src = torch.randn((<span class="number">10</span>, <span class="number">32</span>, <span class="number">512</span>))</span><br><span class="line">out = transformer_encoder(src)</span><br><span class="line"><span class="built_in">print</span>(out.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># torch.Size([10, 32, 512])</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-TransformerDecoderLayer"><a href="#2-2-3-TransformerDecoderLayer" class="headerlink" title="2.2.3 TransformerDecoderLayer"></a>2.2.3 TransformerDecoderLayer</h4><ul><li>相比encoder多了Encoder-Decoder Attention层，用来帮解码器把注意力集中到输入序列的合适位置。其个decoder block的Encoder-Decoder Attention层输入k、v值都是encoder最后层的输出memory。<ul><li>在解码器里，Self Attention 层只允许关注到输出序列中早于当前位置之前的单词，即屏蔽掉未来时刻的信息。具体是用mask下三角矩阵实现的，它会将我们想要屏蔽的单元格设置为负无穷大或者一个非常大的负数。&lt;/font&gt;先正常通过qk计算attention score，再乘以mask矩阵。这样进行softmax计算时，屏蔽位置的attention权重为0。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, tgt: Tensor, memory: Tensor, tgt_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">               memory_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>,tgt_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, memory_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span></span>) -&gt; Tensor:</span></span><br><span class="line">       <span class="string">r&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">       参数：</span></span><br><span class="line"><span class="string">           tgt: 目标语言序列（必备）</span></span><br><span class="line"><span class="string">           memory: 从最后一个encoder_layer跑出的句子（必备）</span></span><br><span class="line"><span class="string">           tgt_mask: 目标语言序列的mask（可选）</span></span><br><span class="line"><span class="string">           memory_mask（可选）</span></span><br><span class="line"><span class="string">           tgt_key_padding_mask（可选）</span></span><br><span class="line"><span class="string">           memory_key_padding_mask（可选）</span></span><br><span class="line"><span class="string">       &#x27;&#x27;&#x27;</span></span><br><span class="line">       <span class="comment">#1.self-attention层</span></span><br><span class="line">       tgt2 = self.self_attn(tgt, tgt, tgt, attn_mask=tgt_mask,</span><br><span class="line">                             key_padding_mask=tgt_key_padding_mask)[<span class="number">0</span>]</span><br><span class="line">       tgt = tgt + self.dropout1(tgt2)</span><br><span class="line">       tgt = self.norm1(tgt)</span><br><span class="line">       <span class="comment">#Encoder-Decoder Attention层</span></span><br><span class="line">       tgt2 = self.multihead_attn(tgt, memory, memory, attn_mask=memory_mask,</span><br><span class="line">                                  key_padding_mask=memory_key_padding_mask)[<span class="number">0</span>]</span><br><span class="line">       tgt = tgt + self.dropout2(tgt2)</span><br><span class="line">       tgt = self.norm2(tgt)</span><br><span class="line">       <span class="comment">#3.FFNN层</span></span><br><span class="line">       tgt2 = self.linear2(self.dropout(self.activation(self.linear1(tgt))))</span><br><span class="line">       tgt = tgt + self.dropout3(tgt2)</span><br><span class="line">       tgt = self.norm3(tgt)</span><br><span class="line">       <span class="keyword">return</span> tgt</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可爱的小例子</span></span><br><span class="line">decoder_layer = nn.TransformerDecoderLayer(d_model=<span class="number">512</span>, nhead=<span class="number">8</span>)</span><br><span class="line">memory = torch.randn((<span class="number">10</span>, <span class="number">32</span>, <span class="number">512</span>))</span><br><span class="line">tgt = torch.randn((<span class="number">20</span>, <span class="number">32</span>, <span class="number">512</span>))</span><br><span class="line">out = decoder_layer(tgt, memory)</span><br><span class="line"><span class="built_in">print</span>(out.shape)</span><br><span class="line"><span class="comment"># torch.Size([20, 32, 512])</span></span><br></pre></td></tr></table></figure><h4 id="2-2-4-TransformerDecoderLayer组成Decoder"><a href="#2-2-4-TransformerDecoderLayer组成Decoder" class="headerlink" title="2.2.4 TransformerDecoderLayer组成Decoder"></a>2.2.4 TransformerDecoderLayer组成Decoder</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, tgt: Tensor, memory: Tensor, tgt_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                memory_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, tgt_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                memory_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span></span>) -&gt; Tensor:</span></span><br><span class="line">        output = tgt</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layers):</span><br><span class="line">            output = self.layer(output, memory, tgt_mask=tgt_mask,</span><br><span class="line">                         memory_mask=memory_mask,</span><br><span class="line">                         tgt_key_padding_mask=tgt_key_padding_mask,</span><br><span class="line">                         memory_key_padding_mask=memory_key_padding_mask)</span><br><span class="line">        <span class="keyword">if</span> self.norm <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            output = self.norm(output)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可爱的小例子</span></span><br><span class="line">decoder_layer =TransformerDecoderLayer(d_model=<span class="number">512</span>, nhead=<span class="number">8</span>)</span><br><span class="line">transformer_decoder = TransformerDecoder(decoder_layer, num_layers=<span class="number">6</span>)</span><br><span class="line">memory = torch.rand(<span class="number">10</span>, <span class="number">32</span>, <span class="number">512</span>)</span><br><span class="line">tgt = torch.rand(<span class="number">20</span>, <span class="number">32</span>, <span class="number">512</span>)</span><br><span class="line">out = transformer_decoder(tgt, memory)</span><br><span class="line"><span class="built_in">print</span>(out.shape)</span><br><span class="line"><span class="comment"># torch.Size([20, 32, 512])</span></span><br></pre></td></tr></table></figure><h4 id="2-2-5-Transformer"><a href="#2-2-5-Transformer" class="headerlink" title="2.2.5 Transformer"></a>2.2.5 Transformer</h4><p><img src="https://img-blog.csdnimg.cn/54303ee411f5480697043101334f35ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-75Lmm5LiN6KeJ5bey5pil5rex77yB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transformer</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">r&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        d_model: 词嵌入的维度（必备）（Default=512）</span></span><br><span class="line"><span class="string">        nhead: 多头注意力中平行头的数目（必备）（Default=8）</span></span><br><span class="line"><span class="string">        num_encoder_layers:编码层层数（Default=8）</span></span><br><span class="line"><span class="string">        num_decoder_layers:解码层层数（Default=8）</span></span><br><span class="line"><span class="string">        dim_feedforward: 全连接层的神经元的数目，又称经过此层输入的维度（Default = 2048）</span></span><br><span class="line"><span class="string">        dropout: dropout的概率（Default = 0.1）</span></span><br><span class="line"><span class="string">        activation: 两个线性层中间的激活函数，默认relu或gelu</span></span><br><span class="line"><span class="string">        custom_encoder: 自定义encoder（Default=None）</span></span><br><span class="line"><span class="string">        custom_decoder: 自定义decoder（Default=None）</span></span><br><span class="line"><span class="string">        lay_norm_eps: layer normalization中的微小量，防止分母为0（Default = 1e-5）</span></span><br><span class="line"><span class="string">        batch_first: 若`True`，则为(batch, seq, feture)，若为`False`，则为(seq, batch, feature)（Default：False）</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    例子：</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; transformer_model = Transformer(nhead=16, num_encoder_layers=12)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; src = torch.rand((10, 32, 512))</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; tgt = torch.rand((20, 32, 512))</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; out = transformer_model(src, tgt)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, d_model: <span class="built_in">int</span> = <span class="number">512</span>, nhead: <span class="built_in">int</span> = <span class="number">8</span>, num_encoder_layers: <span class="built_in">int</span> = <span class="number">6</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 num_decoder_layers: <span class="built_in">int</span> = <span class="number">6</span>, dim_feedforward: <span class="built_in">int</span> = <span class="number">2048</span>, dropout: <span class="built_in">float</span> = <span class="number">0.1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 activation = F.relu, custom_encoder: <span class="type">Optional</span>[<span class="type">Any</span>] = <span class="literal">None</span>, custom_decoder: <span class="type">Optional</span>[<span class="type">Any</span>] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 layer_norm_eps: <span class="built_in">float</span> = <span class="number">1e-5</span>, batch_first: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>(Transformer, self).__init__()</span><br><span class="line">        <span class="keyword">if</span> custom_encoder <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.encoder = custom_encoder</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            encoder_layer = TransformerEncoderLayer(d_model, nhead, dim_feedforward, dropout,</span><br><span class="line">                                                    activation, layer_norm_eps, batch_first)</span><br><span class="line">            encoder_norm = nn.LayerNorm(d_model, eps=layer_norm_eps)</span><br><span class="line">            self.encoder = TransformerEncoder(encoder_layer, num_encoder_layers)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> custom_decoder <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.decoder = custom_decoder</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            decoder_layer = TransformerDecoderLayer(d_model, nhead, dim_feedforward, dropout,</span><br><span class="line">                                                    activation, layer_norm_eps, batch_first)</span><br><span class="line">            decoder_norm = nn.LayerNorm(d_model, eps=layer_norm_eps)</span><br><span class="line">            self.decoder = TransformerDecoder(decoder_layer, num_decoder_layers, decoder_norm)</span><br><span class="line"></span><br><span class="line">        self._reset_parameters()</span><br><span class="line"></span><br><span class="line">        self.d_model = d_model</span><br><span class="line">        self.nhead = nhead</span><br><span class="line"></span><br><span class="line">        self.batch_first = batch_first</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, src: Tensor, tgt: Tensor, src_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, tgt_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                memory_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, src_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                tgt_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, memory_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span></span>) -&gt; Tensor:</span></span><br><span class="line">        <span class="string">r&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            src: 源语言序列（送入Encoder）（必备）</span></span><br><span class="line"><span class="string">            tgt: 目标语言序列（送入Decoder）（必备）</span></span><br><span class="line"><span class="string">            src_mask: （可选)</span></span><br><span class="line"><span class="string">            tgt_mask: （可选）</span></span><br><span class="line"><span class="string">            memory_mask: （可选）</span></span><br><span class="line"><span class="string">            src_key_padding_mask: （可选）</span></span><br><span class="line"><span class="string">            tgt_key_padding_mask: （可选）</span></span><br><span class="line"><span class="string">            memory_key_padding_mask: （可选）</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        形状：</span></span><br><span class="line"><span class="string">            - src: shape:`(S, N, E)`, `(N, S, E)` if batch_first.</span></span><br><span class="line"><span class="string">            - tgt: shape:`(T, N, E)`, `(N, T, E)` if batch_first.</span></span><br><span class="line"><span class="string">            - src_mask: shape:`(S, S)`.</span></span><br><span class="line"><span class="string">            - tgt_mask: shape:`(T, T)`.</span></span><br><span class="line"><span class="string">            - memory_mask: shape:`(T, S)`.</span></span><br><span class="line"><span class="string">            - src_key_padding_mask: shape:`(N, S)`.</span></span><br><span class="line"><span class="string">            - tgt_key_padding_mask: shape:`(N, T)`.</span></span><br><span class="line"><span class="string">            - memory_key_padding_mask: shape:`(N, S)`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            [src/tgt/memory]_mask确保有些位置不被看到，如做decode的时候，只能看该位置及其以前的，而不能看后面的。</span></span><br><span class="line"><span class="string">            若为ByteTensor，非0的位置会被忽略不做注意力；若为BoolTensor，True对应的位置会被忽略；</span></span><br><span class="line"><span class="string">            若为数值，则会直接加到attn_weights</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            [src/tgt/memory]_key_padding_mask 使得key里面的某些元素不参与attention计算，三种情况同上</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            - output: shape:`(T, N, E)`, `(N, T, E)` if batch_first.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        注意：</span></span><br><span class="line"><span class="string">            src和tgt的最后一维需要等于d_model，batch的那一维需要相等</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        例子:</span></span><br><span class="line"><span class="string">            &gt;&gt;&gt; output = transformer_model(src, tgt, src_mask=src_mask, tgt_mask=tgt_mask)</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        memory = self.encoder(src, mask=src_mask, src_key_padding_mask=src_key_padding_mask)</span><br><span class="line">        output = self.decoder(tgt, memory, tgt_mask=tgt_mask, memory_mask=memory_mask,</span><br><span class="line">                              tgt_key_padding_mask=tgt_key_padding_mask,</span><br><span class="line">                              memory_key_padding_mask=memory_key_padding_mask)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_square_subsequent_mask</span>(<span class="params">self, sz: <span class="built_in">int</span></span>) -&gt; Tensor:</span></span><br><span class="line">        <span class="string">r&#x27;&#x27;&#x27;产生关于序列的mask，被遮住的区域赋值`-inf`，未被遮住的区域赋值为`0`&#x27;&#x27;&#x27;</span></span><br><span class="line">        mask = (torch.triu(torch.ones(sz, sz)) == <span class="number">1</span>).transpose(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        mask = mask.<span class="built_in">float</span>().masked_fill(mask == <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)).masked_fill(mask == <span class="number">1</span>, <span class="built_in">float</span>(<span class="number">0.0</span>))</span><br><span class="line">        <span class="keyword">return</span> mask</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_reset_parameters</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">r&#x27;&#x27;&#x27;用正态分布初始化参数&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> self.parameters():</span><br><span class="line">            <span class="keyword">if</span> p.dim() &gt; <span class="number">1</span>:</span><br><span class="line">                xavier_uniform_(p)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 小例子</span></span><br><span class="line">transformer_model = Transformer(nhead=<span class="number">16</span>, num_encoder_layers=<span class="number">12</span>)</span><br><span class="line">src = torch.rand((<span class="number">10</span>, <span class="number">32</span>, <span class="number">512</span>))</span><br><span class="line">tgt = torch.rand((<span class="number">20</span>, <span class="number">32</span>, <span class="number">512</span>))</span><br><span class="line">out = transformer_model(src, tgt)</span><br><span class="line"><span class="built_in">print</span>(out.shape)</span><br><span class="line"><span class="comment"># torch.Size([20, 32, 512])</span></span><br></pre></td></tr></table></figure><p>总结一下，其实经过位置编码，多头注意力，Encoder Layer和Decoder Layer形状不会变的，而Encoder和Decoder分别与src和tgt形状一致</p><p><img src="https://img-blog.csdnimg.cn/5eb80e29d6994914bbcf1d87b443aedd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-75Lmm5LiN6KeJ5bey5pil5rex77yB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b80d230b08314554b1e37a76c24ce7d2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-75Lmm5LiN6KeJ5bey5pil5rex77yB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0de6fb81505b4454b11e817d02099362.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-75Lmm5LiN6KeJ5bey5pil5rex77yB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>2.2.3  最后的线性层和 Softmax 层<br>Decoder 最终的输出是一个向量，其中每个元素是浮点数。输出向量经过线性层（普通的全连接神经网络）映射为一个更长的向量，这个向量称为 logits 向量。<br><img src="https://img-blog.csdnimg.cn/5f3bd119d54d47f0888c24c92f5ad07a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-75Lmm5LiN6KeJ5bey5pil5rex77yB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>三、GPT-2</p><ul><li>BERT全称是“Bidirectional Encoder Representation from Transformers“，即双向Transformer解码器。</li><li>“自回归（auto-regression）”：这类模型的实际工作方式是，在产生每个 token 之后，将这个 token 添加到输入的序列中，形成一个新序列。然后这个新序列成为模型在下一个时间步的输入，这种做法可以使得 RNN 非常有效。</li><li>gpt2的训练方式是生成文本，类似解码。bert是用masker-ML训练，是提取特征建立语言模型。</li><li>GPT-2 能够处理 1024 个 token。GPT-2 和传统的语言模型一样，一次输出一个 token。但若是一直选择模型建议的单词，它有时会陷入重复的循环之中，唯一的出路就是点击第二个或者第三个建议的单词。GPT-2 有一个 top-k 参数，可以用来选择top-1之外的其他词。</li><li>GPT-2 的每一层都保留了它自己对第一个 token 的解释，而且会在预测第二个 token 时使用它，但是不会反过来根据后面的token重新计算前面的token。<h3 id="3-2-模型输出流程"><a href="#3-2-模型输出流程" class="headerlink" title="3.2 模型输出流程"></a>3.2 模型输出流程</h3><img src="https://img-blog.csdnimg.cn/44e0d2b8065946c98d6cb62d7c041be9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-75Lmm5LiN6KeJ5bey5pil5rex77yB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>输入一共会经过四个矩阵（QKV多头矩阵、多头结果拼接转换矩阵W0，两层全连接的矩阵）<br>W0：经过一个线性映射得到想要的维度，随后输入全连接网络。</li></ul><p><img src="https://img-blog.csdnimg.cn/9b611c0e51174b91b41a668679d8c8b2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K-75Lmm5LiN6KeJ5bey5pil5rex77yB,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>输入token embedding向量序列流过decoder得到的输出向量和嵌入矩阵相乘，得到选词概率logits。<br>类似于根据输出向量和词表词向量计算相似度（相乘得到）。</p><h3 id="3-3-灾难性遗忘"><a href="#3-3-灾难性遗忘" class="headerlink" title="3.3 灾难性遗忘"></a>3.3 灾难性遗忘</h3><p>  为了进一步提升精调后模型的通用性以及收敛速度,可以在下游任务精调时加入一定权重的预训练任务损失。这样做是为了缓解在下游任务精调的过程中出现灾难性遗忘( Catastrophic Forgetting )问题。<br>  因为在下游任务精调过程中, GPT 的训练目标是优化下游任务数据上的效果,更强调特殊性。因此,势必会对预训练阶段学习的通用知识产生部分的覆盖或擦除,丢失一定的通用性。通过结合下游任务精调损失和预训练任务损失,可以有效地缓解灾难性遗忘问题,在优化下游任务效果的同时保留一定的通用性。<br>损失函数=精调任务损失+λ \lambdaλ预训练任务损失<br>一般设置λ = 0.5 \lambda=0.5λ=0.5，因为在精调下游任务时，主要目的还是优化有标注数据集的效果，即优化精调任务损失。预训练任务损失的加入只是为了提升精调模型的通用性，其重要程度不及精调任务损失。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、attention&quot;&gt;&lt;a href=&quot;#一、attention&quot; class=&quot;headerlink&quot; title=&quot;一、attention&quot;&gt;&lt;/a&gt;一、attention&lt;/h2&gt;&lt;h3 id=&quot;1-1循环神经网络的不足：&quot;&gt;&lt;a href=&quot;#1-1循环神经网络的不足：&quot; class=&quot;headerlink&quot; title=&quot;1.1循环神经网络的不足：&quot;&gt;&lt;/a&gt;1.1循环神经网络的不足：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;长距离衰减问题&lt;/li&gt;
&lt;li&gt;解码阶段，越靠后的内容，翻译效果越差&lt;/li&gt;
&lt;li&gt;解码阶段缺乏对编码阶段各个词的直接利用&lt;h3 id=&quot;1-2-attention在机器翻译的优点&quot;&gt;&lt;a href=&quot;#1-2-attention在机器翻译的优点&quot; class=&quot;headerlink&quot; title=&quot;1.2 attention在机器翻译的优点&quot;&gt;&lt;/a&gt;1.2 attention在机器翻译的优点&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;使用全部token信息而非最后时刻的context信息。由此在解码时每时刻可以计算attention权重，让输出对输入进行聚焦的能力，找到此时刻解码时最该注意的词。&lt;/li&gt;
&lt;li&gt;attention的计算是序列各tokens的v向量和attention权重加权求和，每个词关注到所有词，一步到位，不存在长距离衰减&lt;/li&gt;
&lt;li&gt;可以关注到不同位置的词语，而且使用多头和多层注意力、加入FFNN，表达能力更强。</summary>
    
    
    
    <category term="8月组队学习：nlp之transformers" scheme="https://zhxnlp.github.io/categories/8%E6%9C%88%E7%BB%84%E9%98%9F%E5%AD%A6%E4%B9%A0%EF%BC%9Anlp%E4%B9%8Btransformers/"/>
    
    <category term="读书笔记" scheme="https://zhxnlp.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="transformers" scheme="https://zhxnlp.github.io/tags/transformers/"/>
    
    <category term="深度学习" scheme="https://zhxnlp.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="神经网络" scheme="https://zhxnlp.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>集成学习3： XGBoost&amp;LightGBM</title>
    <link href="https://zhxnlp.github.io/2021/12/04/datawhale%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A03%EF%BC%9A%20XGBoost&amp;LightGBM/"/>
    <id>https://zhxnlp.github.io/2021/12/04/datawhale%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A03%EF%BC%9A%20XGBoost&amp;LightGBM/</id>
    <published>2021-12-04T13:13:48.000Z</published>
    <updated>2022-01-02T21:06:22.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、XGBoost"><a href="#一、XGBoost" class="headerlink" title="一、XGBoost"></a>一、XGBoost</h2><blockquote><p><a href="https://xgboost.readthedocs.io/en/latest/python/python_intro.html">XGBoost官方文档</a></p><h3 id="1-1-XGBoost原理及构建"><a href="#1-1-XGBoost原理及构建" class="headerlink" title="1.1 XGBoost原理及构建"></a>1.1 XGBoost原理及构建</h3><p>XGBoost本质上还是一个GBDT，是一个优化的分布式梯度增强库，旨在实现高效，灵活和便携。Xgboost以CART决策树为子模型，通过Gradient Tree Boosting实现多棵CART树的集成学习，得到最终模型。</p></blockquote><p>XGBoost的最终模型构建：<br><img src="https://img-blog.csdnimg.cn/d87b34dc7f8747f4b0cd74dcea1eb70d.png" alt="在这里插入图片描述"><br>因此，目标函数的构建为：                                </p><script type="math/tex; mode=display">\mathcal{L}(\phi)=\sum_{i} l\left(\hat{y}_{i}, y_{i}\right)+\sum_{k} \Omega\left(f_{k}\right)</script><span id="more"></span>                                    <p>其中，$\sum<em>{i} l(\hat{y}</em>{i}, y<em>{i})$为loss function，$\sum</em>{k} \Omega\left(f_{k}\right)$为正则化项。    </p><p>(2) 叠加式的训练(Additive Training)：       </p><p>给定样本$x_i$，$\hat{y}_i^{(0)} = 0$(初始预测)，$\hat{y}_i^{(1)} = \hat{y}_i^{(0)} + f_1(x_i)$，$\hat{y}_i^{(2)} = \hat{y}_i^{(0)} + f_1(x_i) + f_2(x_i) = \hat{y}_i^{(1)} + f_2(x_i)$…….以此类推，可以得到：<script type="math/tex">\hat{y}_i^{(K)} = \hat{y}_i^{(K-1)} + f_K(x_i)</script> 其中，$\hat{y}_i^{(K-1)}$ 为前K-1棵树的预测结果，$f_K(x_i)$ 为第K棵树的预测结果。<br>因此，目标函数可以分解为：                                        </p><script type="math/tex; mode=display">\mathcal{L}^{(K)}=\sum_{i=1}^{n} l\left(y_{i}, \hat{y}_{i}^{(K-1)}+f_{K}\left(\mathrm{x}_{i}\right)\right)+\sum_{k} \Omega\left(f_{k}\right)</script><p>由于正则化项也可以分解为前K-1棵树的复杂度加第K棵树的复杂度，因此：<script type="math/tex">\mathcal{L}^{(K)}=\sum_{i=1}^{n} l\left(y_{i}, \hat{y}_{i}^{(K-1)}+f_{K}\left(\mathrm{x}_{i}\right)\right)+\sum_{k=1} ^{K-1}\Omega\left(f_{k}\right)+\Omega\left(f_{K}\right)</script>由于$\sum<em>{k=1} ^{K-1}\Omega\left(f</em>{k}\right)$在模型构建到第K棵树的时候已经固定，无法改变，因此是一个已知的常数，可以在最优化的时候省去，故：                     </p><script type="math/tex; mode=display">\mathcal{L}^{(K)}=\sum_{i=1}^{n} l\left(y_{i}, \hat{y}_{i}^{(K-1)}+f_{K}\left(\mathrm{x}_{i}\right)\right)+\Omega\left(f_{K}\right)</script><p>(3) 使用泰勒级数<strong>近似</strong>目标函数：                                      </p><script type="math/tex; mode=display">\mathcal{L}^{(K)} \simeq \sum_{i=1}^{n}\left[l\left(y_{i}, \hat{y}^{(K-1)}\right)+g_{i} f_{K}\left(\mathrm{x}_{i}\right)+\frac{1}{2} h_{i} f_{K}^{2}\left(\mathrm{x}_{i}\right)\right]+\Omega\left(f_{K}\right)</script><p>其中，$g<em>{i}=\partial</em>{\hat{y}(t-1)} l\left(y<em>{i}, \hat{y}^{(t-1)}\right)$和$h</em>{i}=\partial<em>{\hat{y}^{(t-1)}}^{2} l\left(y</em>{i}, \hat{y}^{(t-1)}\right)$<br>在这里，我们补充下泰勒级数的相关知识：<br>在数学中，泰勒级数（英语：Taylor series）用无限项连加式——级数来表示一个函数，这些相加的项由函数在某一点的导数求得。具体的形式如下：                          </p><script type="math/tex; mode=display">f(x)=\frac{f\left(x_{0}\right)}{0 !}+\frac{f^{\prime}\left(x_{0}\right)}{1 !}\left(x-x_{0}\right)+\frac{f^{\prime \prime}\left(x_{0}\right)}{2 !}\left(x-x_{0}\right)^{2}+\ldots+\frac{f^{(n)}\left(x_{0}\right)}{n !}\left(x-x_{0}\right)^{n}+......</script><p>由于$\sum<em>{i=1}^{n}l\left(y</em>{i}, \hat{y}^{(K-1)}\right)$在模型构建到第K棵树的时候已经固定，无法改变，因此是一个已知的常数，可以在最优化的时候省去，故：                               </p><script type="math/tex; mode=display">\tilde{\mathcal{L}}^{(K)}=\sum_{i=1}^{n}\left[g_{i} f_{K}\left(\mathbf{x}_{i}\right)+\frac{1}{2} h_{i} f_{K}^{2}\left(\mathbf{x}_{i}\right)\right]+\Omega\left(f_{K}\right)</script><p>(4) 如何定义一棵树：<br>为了说明如何定义一棵树的问题，我们需要定义几个概念：</p><ul><li>第一个概念是样本所在的节点位置$q(x)$</li><li>第二个概念是有哪些样本落在节点j上$I<em>{j}=\left{i \mid q\left(\mathbf{x}</em>{i}\right)=j\right}$</li><li>第三个概念是每个结点的预测值$w_{q(x)}$</li><li>第四个概念是模型复杂度$\Omega\left(f<em>{K}\right)$，它可以由叶子节点的个数以及节点函数值来构建，则：$\Omega\left(f</em>{K}\right) = \gamma T+\frac{1}{2} \lambda \sum<em>{j=1}^{T} w</em>{j}^{2}$。如下图的例子：<br><img src="https://img-blog.csdnimg.cn/f2eccb86e4634309ab1fd8841cd25bfe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><p>$q(x_1) = 1,q(x_2) = 3,q(x_3) = 1,q(x_4) = 2,q(x_5) = 3$<br>$I_1 = {1,3},I_2 = {4},I_3 = {2,5}$，$w = (15,12,20)$<br>因此，目标函数用以上符号替代后：                                      </p><script type="math/tex; mode=display">\begin{aligned}\tilde{\mathcal{L}}^{(K)} &=\sum_{i=1}^{n}\left[g_{i} f_{K}\left(\mathrm{x}_{i}\right)+\frac{1}{2} h_{i} f_{K}^{2}\left(\mathrm{x}_{i}\right)\right]+\gamma T+\frac{1}{2} \lambda \sum_{j=1}^{T} w_{j}^{2} \\&=\sum_{j=1}^{T}\left[\left(\sum_{i \in I_{j}} g_{i}\right) w_{j}+\frac{1}{2}\left(\sum_{i \in I_{j}} h_{i}+\lambda\right) w_{j}^{2}\right]+\gamma T\end{aligned}</script><p>由于我们的目标就是最小化目标函数，现在的目标函数化简为一个关于w的二次函数：<script type="math/tex">\tilde{\mathcal{L}}^{(K)}=\sum_{j=1}^{T}\left[\left(\sum_{i \in I_{j}} g_{i}\right) w_{j}+\frac{1}{2}\left(\sum_{i \in I_{j}} h_{i}+\lambda\right) w_{j}^{2}\right]+\gamma T</script>根据二次函数求极值的公式：$y=ax^2 bx c$求极值，对称轴在$x=-\frac{b}{2 a}$，极值为$y=\frac{4 a c-b^{2}}{4 a}$，因此：                                       </p><script type="math/tex; mode=display">w_{j}^{*}=-\frac{\sum_{i \in I_{j}} g_{i}}{\sum_{i \in I_{j}} h_{i}+\lambda}</script><p>以及</p><script type="math/tex; mode=display">\tilde{\mathcal{L}}^{(K)}(q)=-\frac{1}{2} \sum_{j=1}^{T} \frac{\left(\sum_{i \in I_{j}} g_{i}\right)^{2}}{\sum_{i \in I_{j}} h_{i}+\lambda}+\gamma T</script><p>(5) 如何寻找树的形状：<br>不难发现，刚刚的讨论都是基于树的形状已经确定了计算$w$和$L$，但是实际上我们需要像学习决策树一样找到树的形状。因此，我们借助决策树学习的方式，使用目标函数的变化来作为分裂节点的标准。我们使用一个例子来说明：<br><img src="https://img-blog.csdnimg.cn/b7e9e79cd9f84537acaeabcb0d3c056e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-N7UR4bz6-1638620761777)(./17.png)\]"></p><p>例子中有8个样本，分裂方式如下，因此:                                    </p><script type="math/tex; mode=display">\tilde{\mathcal{L}}^{(old)} = -\frac{1}{2}[\frac{(g_7 + g_8)^2}{H_7+H_8 + \lambda} + \frac{(g_1 +...+ g_6)^2}{H_1+...+H_6 + \lambda}] + 2\gamma \\\tilde{\mathcal{L}}^{(new)} = -\frac{1}{2}[\frac{(g_7 + g_8)^2}{H_7+H_8 + \lambda} + \frac{(g_1 +...+ g_3)^2}{H_1+...+H_3 + \lambda} + \frac{(g_4 +...+ g_6)^2}{H_4+...+H_6 + \lambda}] + 3\gamma\\\tilde{\mathcal{L}}^{(old)} - \tilde{\mathcal{L}}^{(new)} = \frac{1}{2}[ \frac{(g_1 +...+ g_3)^2}{H_1+...+H_3 + \lambda} + \frac{(g_4 +...+ g_6)^2}{H_4+...+H_6 + \lambda} - \frac{(g_1+...+g_6)^2}{h_1+...+h_6+\lambda}] - \gamma</script><p>因此，从上面的例子看出：分割节点的标准为$max{\tilde{\mathcal{L}}^{(old)} - \tilde{\mathcal{L}}^{(new)} }$，即：                               </p><script type="math/tex; mode=display">\mathcal{L}_{\text {split }}=\frac{1}{2}\left[\frac{\left(\sum_{i \in I_{L}} g_{i}\right)^{2}}{\sum_{i \in I_{L}} h_{i}+\lambda}+\frac{\left(\sum_{i \in I_{R}} g_{i}\right)^{2}}{\sum_{i \in I_{R}} h_{i}+\lambda}-\frac{\left(\sum_{i \in I} g_{i}\right)^{2}}{\sum_{i \in I} h_{i}+\lambda}\right]-\gamma</script><h3 id="1-2-精确贪心分裂算法"><a href="#1-2-精确贪心分裂算法" class="headerlink" title="1.2 精确贪心分裂算法"></a>1.2 精确贪心分裂算法</h3><ul><li>生成新树的过程中，最基本的操作是节点分裂。节点分裂中最重 要的环节是找到最优特征及最优切分点。</li><li>精确贪心算法：首先找到所有的候 选特征及所有的候选切分点, 求其 $\mathcal{L}<em>{\text {split }}$, 然后 选择使$\mathcal{L}</em>{\mathrm{split}}$ 最大的特征及 对应切分点作为最优特征和最优切分点。节点分裂时只选择当前最优的分裂策略, 而非全局最优的分裂策略。</li><li>精确贪心算法的计算过程如下所示：<br><img src="https://img-blog.csdnimg.cn/514f06dee037441fa765f0b9cab7f428.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h3 id="1-3-基于直方图的近似算法："><a href="#1-3-基于直方图的近似算法：" class="headerlink" title="1.3 基于直方图的近似算法："></a>1.3 基于直方图的近似算法：</h3></li><li>精确贪心算法优点：它计算了所有特征、所有切分点的收益, 并从中选择了最优的, 从而保证模型能比较好地拟合了训练数据。</li><li>精确贪心算法缺点：当数据不能完全加载到内存时非常低效。算法在计算过程中需要不断在内存与磁盘之间进行数据交换，非常耗时, 并且在分布式环境中面临同样的问题</li></ul><p>基于直方图的近似算法，可以更高效地选 择最优特征及切分点。主要思想是：</p><ol><li>对某一特征寻找最优切分点时，首先对该特征的所有切分点按分位数 (如百分位) 分桶, 得到一个候选切分点集。</li><li>特征的每一个切分点都可以分到对应的分桶，对每个桶计算特征统计G和H得到直方图, G为该桶内所有样本一阶特征统计g之和, H为该桶内所有样本二阶特征统计h之和</li><li>选择所有候选特征及候选切分点中对应桶的特征统计收益最大的作为最优特征及最优切分点</li></ol><p>基于直方图的近似算法的计算过程如下所示：<br>1) 对于每个特征 $k=1,2, \cdots, m,$ 按分位数对特征 $k$ 分桶 $\Theta,$ 可得候选切分点, $S<em>{k}=\left{S</em>{k 1}, S<em>{k 2}, \cdots, S</em>{k l}\right}^{1}$<br>2) 对于每个特征 $k=1,2, \cdots, m,$ 有：                           </p><script type="math/tex; mode=display">\begin{array}{l}G_{k v} \leftarrow=\sum_{j \in\left\{j \mid s_{k, v} \geq \mathbf{x}_{j k}>s_{k, v-1\;}\right\}} g_{j} \\H_{k v} \leftarrow=\sum_{j \in\left\{j \mid s_{k, v} \geq \mathbf{x}_{j k}>s_{k, v-1\;}\right\}} h_{j}\end{array}</script><p>3) 类似精确贪心算法，依据梯度统计找到最大增益的候选切分点。</p><p>下面用一个例子说明基于直方图的近似算法：<br>假设有一个年龄特征，其特征的取值为18、19、21、31、36、37、55、57，我们需要使用近似算法找到年龄这个特征的最佳分裂点：<br><img src="https://img-blog.csdnimg.cn/3788b0ba826d4cd9b470dea1837bfd48.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>近似算法实现了两种候选切分点的构建策略：全局策略和本地策略。</p><ul><li>全局策略是在树构建的初始阶段对每一个特征确定一个候选切分点的集合, 并在该树每一层的节点分裂中均采用此集合计算收益, 整个过程候选切分点集合不改变。全局策略需要更细的分桶才能达到本地策略的精确度, 但全局策略在选取候选切分点集合时比本地策略更简单。</li><li>本地策略则是在每一次节点分裂时均重新确定候选切分点。</li><li>在XGBoost系统中, 用户可以根据需求自由选择使用==精确贪心算法、近似算法全局策略、近似算法本地策略==, 算法均可通过参数进行配置。<h3 id="1-4-XGBoost代码讲解"><a href="#1-4-XGBoost代码讲解" class="headerlink" title="1.4 XGBoost代码讲解"></a>1.4 XGBoost代码讲解</h3></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># XGBoost原生工具库的上手：</span></span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb  <span class="comment"># 引入工具库</span></span><br><span class="line"><span class="comment"># read in data</span></span><br><span class="line">dtrain = xgb.DMatrix(<span class="string">&#x27;demo/data/agaricus.txt.train&#x27;</span>)   <span class="comment"># XGBoost的专属数据格式，但是也可以用dataframe或者ndarray</span></span><br><span class="line">dtest = xgb.DMatrix(<span class="string">&#x27;demo/data/agaricus.txt.test&#x27;</span>)  <span class="comment"># # XGBoost的专属数据格式，但是也可以用dataframe或者ndarray</span></span><br><span class="line"><span class="comment"># specify parameters via map</span></span><br><span class="line">param = &#123;<span class="string">&#x27;max_depth&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;eta&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;objective&#x27;</span>:<span class="string">&#x27;binary:logistic&#x27;</span> &#125;    <span class="comment"># 设置XGB的参数，使用字典形式传入</span></span><br><span class="line">num_round = <span class="number">2</span>     <span class="comment"># 使用线程数</span></span><br><span class="line">bst = xgb.train(param, dtrain, num_round)   <span class="comment"># 训练</span></span><br><span class="line"><span class="comment"># make prediction</span></span><br><span class="line">preds = bst.predict(dtest)   <span class="comment"># 预测</span></span><br></pre></td></tr></table></figure><p>XGBoost的参数设置(括号内的名称为sklearn接口对应的参数名字):</p><blockquote><p><a href="https://link.zhihu.com/?target=https://blog.csdn.net/luanpeng825485697/article/details/79907149">推荐博客</a>：<br><a href="https://link.zhihu.com/?target=https://xgboost.readthedocs.io/en/latest/parameter.html">推荐官方文档</a></p></blockquote><h4 id="1-4-1-XGBoost的参数"><a href="#1-4-1-XGBoost的参数" class="headerlink" title="1.4.1 XGBoost的参数"></a>1.4.1 XGBoost的参数</h4><p><strong>XGBoost的参数分为三种：</strong></p><ol><li>通用参数：（两种类型的booster，因为tree的性能比线性回归好得多，因此我们很少用线性回归。）<ul><li>booster:使用哪个弱学习器训练，默认gbtree，可选gbtree，gblinear 或dart</li><li>nthread：用于运行XGBoost的并行线程数，默认为最大可用线程数</li><li>verbosity：打印消息的详细程度。有效值为0（静默），1（警告），2（信息），3（调试）。</li></ul><ol><li><strong>Tree Booster的参数：</strong><ul><li>eta（learning_rate）：learning_rate，在更新中使用步长收缩以防止过度拟合，默认= 0.3，范围：[0,1]；典型值一般设置为：0.01-0.2</li><li>gamma（min_split_loss）：默认= 0，分裂节点时，损失函数减小值只有大于等于gamma节点才分裂，gamma值越大，算法越保守，越不容易过拟合，但性能就不一定能保证，需要平衡。范围：[0，∞]</li><li>max_depth：默认= 6，一棵树的最大深度。增加此值将使模型更复杂，并且更可能过度拟合。范围：[0，∞]</li><li>min_child_weight：默认值= 1，如果新分裂的节点的样本权重和小于min_child_weight则停止分裂 。这个可以用来减少过拟合，但是也不能太高，会导致欠拟合。范围：[0，∞]</li><li>max_delta_step：默认= 0，允许每个叶子输出的最大增量步长。如果将该值设置为0，则表示没有约束。如果将其设置为正值，则可以帮助使更新步骤更加保守。通常不需要此参数，但是当类极度不平衡时，它可能有助于逻辑回归。将其设置为1-10的值可能有助于控制更新。范围：[0，∞]</li><li>subsample：默认值= 1，构建每棵树对样本的采样率，如果设置成0.5，XGBoost会随机选择一半的样本作为训练集。范围：（0,1]</li><li>sampling_method：默认= uniform，用于对训练实例进行采样的方法。<ul><li>uniform：每个训练实例的选择概率均等。通常将subsample&gt; = 0.5 设置 为良好的效果。</li><li>gradient_based：每个训练实例的选择概率与规则化的梯度绝对值成正比，具体来说就是$\sqrt{g^2+\lambda h^2}$，subsample可以设置为低至0.1，而不会损失模型精度。</li></ul></li><li>colsample_bytree：默认= 1，列采样率，也就是特征采样率。范围为（0，1]</li><li>lambda（reg_lambda）：默认=1，L2正则化权重项。增加此值将使模型更加保守。</li><li>alpha（reg_alpha）：默认= 0，权重的L1正则化项。增加此值将使模型更加保守。</li><li>tree_method：默认=auto，XGBoost中使用的树构建算法。<ul><li>auto：使用启发式选择最快的方法。<ul><li>对于小型数据集，exact将使用精确贪婪（）。</li><li>对于较大的数据集，approx将选择近似算法（）。它建议尝试hist，gpu_hist，用大量的数据可能更高的性能。（gpu_hist）支持。external memory外部存储器。</li></ul></li><li>exact：精确的贪婪算法。枚举所有拆分的候选点。</li><li>approx：使用分位数和梯度直方图的近似贪婪算法。</li><li>hist：更快的直方图优化的近似贪婪算法。（LightGBM也是使用直方图算法）</li><li>gpu_hist：GPU hist算法的实现。</li></ul></li><li>scale_pos_weight:控制正负权重的平衡，这对于不平衡的类别很有用。Kaggle竞赛一般设置sum(negative instances) / sum(positive instances)，在类别高度不平衡的情况下，将参数设置大于0，可以加快收敛。</li><li>num_parallel_tree：默认=1，每次迭代期间构造的并行树的数量。此选项用于支持增强型随机森林。</li><li>monotone_constraints：可变单调性的约束，在某些情况下，如果有非常强烈的先验信念认为真实的关系具有一定的质量，则可以使用约束条件来提高模型的预测性能。（例如params_constrained[‘monotone_constraints’] = “(1,-1)”，(1,-1)我们告诉XGBoost对第一个预测变量施加增加的约束，对第二个预测变量施加减小的约束。）</li></ul></li><li><strong>Linear Booster的参数：</strong><ul><li>lambda（reg_lambda）：默认= 0，L2正则化权重项。增加此值将使模型更加保守。归一化为训练示例数。</li><li>alpha（reg_alpha）：默认= 0，权重的L1正则化项。增加此值将使模型更加保守。归一化为训练示例数。</li><li>updater：默认= shotgun。<ul><li>shotgun：基于shotgun算法的平行坐标下降算法。使用“ hogwild”并行性，因此每次运行都产生不确定的解决方案。</li><li>coord_descent：普通坐标下降算法。同样是多线程的，但仍会产生确定性的解决方案。</li></ul></li><li>feature_selector：默认= cyclic。特征选择和排序方法<ul><li>cyclic：通过每次循环一个特征来实现的。</li><li>shuffle：类似于cyclic，但是在每次更新之前都有随机的特征变换。</li><li>random：一个随机(有放回)特征选择器。</li><li>greedy：选择梯度最大的特征。（贪婪选择）</li><li>thrifty：近似贪婪特征选择（近似于greedy）</li></ul></li><li>top_k：要选择的最重要特征数（在greedy和thrifty内）</li></ul></li></ol></li><li><p>任务参数（这个参数用来控制理想的优化目标和每一步结果的度量方法。）</p><ul><li>objective：默认=reg:squarederror，表示最小平方误差。<ul><li><strong>reg:squarederror,最小平方误差。</strong></li><li><strong>reg:squaredlogerror,对数平方损失。$\frac{1}{2}[log(pred+1)-log(label+1)]^2$</strong></li><li><strong>reg:logistic,逻辑回归</strong></li><li>reg:pseudohubererror,使用伪Huber损失进行回归，这是绝对损失的两倍可微选择。</li><li><strong>binary:logistic,二元分类的逻辑回归，输出概率。</strong></li><li>binary:logitraw：用于二进制分类的逻辑回归，逻辑转换之前的输出得分。</li><li><strong>binary:hinge：二进制分类的铰链损失。这使预测为0或1，而不是产生概率。（SVM就是铰链损失函数）</strong></li><li>count:poisson –计数数据的泊松回归，泊松分布的输出平均值。</li><li>survival:cox：针对正确的生存时间数据进行Cox回归（负值被视为正确的生存时间）。</li><li>survival:aft：用于检查生存时间数据的加速故障时间模型。</li><li>aft_loss_distribution：survival:aft和aft-nloglik度量标准使用的概率密度函数。</li><li><strong>multi:softmax：设置XGBoost以使用softmax目标进行多类分类，还需要设置num_class（类数）</strong></li><li><strong>multi:softprob：与softmax相同，但输出向量，可以进一步重整为矩阵。结果包含属于每个类别的每个数据点的预测概率。</strong></li><li>rank:pairwise：使用LambdaMART进行成对排名，从而使成对损失最小化。</li><li>rank:ndcg：使用LambdaMART进行列表式排名，使标准化折让累积收益（NDCG）最大化。</li><li>rank:map：使用LambdaMART进行列表平均排名，使平均平均精度（MAP）最大化。</li><li>reg:gamma：使用对数链接进行伽马回归。输出是伽马分布的平均值。</li><li>reg:tweedie：使用对数链接进行Tweedie回归。</li><li>自定义损失函数和评价指标：<a href="https://xgboost.readthedocs.io/en/latest/tutorials/custom_metric_obj.html">https://xgboost.readthedocs.io/en/latest/tutorials/custom_metric_obj.html</a></li></ul></li><li>eval_metric：验证数据的评估指标，将根据目标分配默认指标（回归均方根，分类误差，排名的平均平均精度），用户可以添加多个评估指标<ul><li><strong>rmse，均方根误差；</strong>  <strong>rmsle：均方根对数误差；</strong>  mae：平均绝对误差；mphe：平均伪Huber错误；<strong>logloss：负对数似然；</strong> <strong>error：二进制分类错误率；</strong></li><li><strong>merror：多类分类错误率；</strong> <strong>mlogloss：多类logloss；</strong> <strong>auc：曲线下面积；</strong> aucpr：PR曲线下的面积；ndcg：归一化累计折扣；map：平均精度；</li></ul></li><li>seed ：随机数种子，[默认= 0]。</li></ul></li><li><p>命令行参数（这里不说了，因为很少用命令行控制台版本）</p><h4 id="1-4-2-XGBoost的调参说明："><a href="#1-4-2-XGBoost的调参说明：" class="headerlink" title="1.4.2 XGBoost的调参说明："></a>1.4.2 XGBoost的调参说明：</h4><p>参数调优的一般步骤:</p><ul><li>确定学习速率和提升参数调优的初始值</li><li>max_depth 和 min_child_weight 参数调优</li><li>gamma参数调优</li><li>subsample 和 colsample_bytree 参数优</li><li>正则化参数alpha调优</li><li>降低学习速率和使用更多的决策树</li></ul></li></ol><p>具体的api请查看：<a href="https://xgboost.readthedocs.io/en/latest/python/python_api.html">https://xgboost.readthedocs.io/en/latest/python/python_api.html</a><br>推荐github：<a href="https://github.com/dmlc/xgboost/tree/master/demo/guide-pytho">https://github.com/dmlc/xgboost/tree/master/demo/guide-pytho</a></p><h2 id="1-5-XGBoost案例"><a href="#1-5-XGBoost案例" class="headerlink" title="1.5 XGBoost案例"></a>1.5 XGBoost案例</h2><p>请查看datawhale<a href="https://github.com/zhxnlp/ensemble-learning/blob/main/CH4-%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E4%B9%8Bboosting/Boosting2.ipynb">《集成学习Boosting》</a></p><h2 id="二、LightGBM算法"><a href="#二、LightGBM算法" class="headerlink" title="二、LightGBM算法"></a>二、LightGBM算法</h2><h3 id="2-1-LightGBM算法的改进"><a href="#2-1-LightGBM算法的改进" class="headerlink" title="2.1 LightGBM算法的改进"></a>2.1 LightGBM算法的改进</h3><p>ightGBM也是像XGBoost一样，是一类集成算法，他跟XGBoost总体来说是一样的，算法本质上与Xgboost没有出入，只是在XGBoost的基础上进行了优化：</p><ul><li>优化速度和内存使用<ul><li>降低了计算每个分割增益的成本。<ul><li>使用直方图减法进一步提高速度。</li><li>减少内存使用。</li><li>减少并行学习的计算成本。</li></ul></li></ul></li><li>稀疏优化<ul><li>用离散的bin替换连续的值。如果#bins较小，则可以使用较小的数据类型（例如uint8_t）来存储训练数据 。 </li><li>无需存储其他信息即可对特征数值进行预排序  。</li></ul></li><li>精度优化  <ul><li>使用叶子数为导向的决策树建立算法而不是树的深度导向。</li><li>分类特征的编码方式的优化</li><li>通信网络的优化</li><li>并行学习的优化</li><li>GPU支持</li></ul></li></ul><p>LightGBM的优点：<br>　　1）更快的训练效率<br>　　2）低内存使用<br>　　3）更高的准确率<br>　　4）支持并行化学习</p><h3 id="2-2-LightGBM参数"><a href="#2-2-LightGBM参数" class="headerlink" title="2.2 LightGBM参数"></a>2.2 LightGBM参数</h3><blockquote><p>LightGBM参数说明： <a href="https://lightgbm.apachecn.org/#/docs/6">推荐文档1</a>、<a href="https://lightgbm.readthedocs.io/en/latest/Parameters.html">推荐文档2</a><br>LightGBM与网格搜索结合调参，<a href="https://blog.csdn.net/u012735708/article/details/83749703">参考代码</a>：</p></blockquote><p><strong>1.核心参数：</strong>（括号内名称是别名）  </p><ul><li>objective（objective，app ，application）：默认regression，用于设置损失函数<ul><li>回归问题：<ul><li>L2损失：regression（regression_l2，l2，mean_squared_error，mse，l2_root，root_mean_squared_error，rmse）</li><li>L1损失：regression_l1（l1, mean_absolute_error, mae）</li><li>其他损失：huber，fair，poisson，quantile，mape，gamma，tweedie</li></ul></li><li>二分类问题：二进制对数损失分类（或逻辑回归）：binary</li><li>多类别分类：<ul><li>softmax目标函数： multiclass（softmax）</li><li>One-vs-All 目标函数：multiclassova（multiclass_ova，ova，ovr）</li></ul></li><li>交叉熵：<ul><li>用于交叉熵的目标函数（具有可选的线性权重）：cross_entropy（xentropy）</li><li>交叉熵的替代参数化：cross_entropy_lambda（xentlambda） </li></ul></li></ul></li><li>boosting ：默认gbdt，设置提升类型，选项有gbdt，rf，dart，goss，别名：boosting_type，boost<ul><li>gbdt（gbrt）:传统的梯度提升决策树</li><li>rf（random_forest）：随机森林</li><li>dart：多个加性回归树的DROPOUT方法 Dropouts meet Multiple Additive Regression Trees，参见：<a href="https://arxiv.org/abs/1505.01866">https://arxiv.org/abs/1505.01866</a></li><li>goss：基于梯度的单边采样 Gradient-based One-Side Sampling   </li></ul></li><li>data（train，train_data，train_data_file，data_filename）：用于训练的数据或数据file</li><li>valid （test，valid_data，valid_data_file，test_data，test_data_file，valid_filenames）：验证/测试数据的路径，LightGBM将输出这些数据的指标</li><li>num_iterations：默认=100，类型= INT</li><li>n_estimators：提升迭代次数，<strong>LightGBM构造用于多类分类问题的树num_class * num_iterations</strong></li><li>learning_rate（shrinkage_rate，eta） ：收缩率，默认=0.1</li><li>num_leaves（num_leaf，max_leaves，max_leaf） ：默认=31，一棵树上的最大叶子数</li><li>tree_learner （tree，tree_type，tree_learner_type）：默认=serial，可选：serial，feature，data，voting<ul><li>serial：单台机器的 tree learner</li><li>feature：特征并行的 tree learner</li><li>data：数据并行的 tree learner</li><li>voting：投票并行的 tree learner</li></ul></li><li>num_threads（num_thread, nthread）：LightGBM 的线程数，为了更快的速度, 将此设置为真正的 CPU 内核数, 而不是线程的数量 (大多数 CPU 使用超线程来使每个 CPU 内核生成 2 个线程)，当你的数据集小的时候不要将它设置的过大 (比如, 当数据集有 10,000 行时不要使用 64 线程)，对于并行学习, 不应该使用全部的 CPU 内核, 因为这会导致网络性能不佳。  </li><li>device（device_type）：默认cpu，为树学习选择设备, 你可以使用 GPU 来获得更快的学习速度，可选cpu, gpu。</li><li>seed （random_seed，random_state）：与其他种子相比，该种子具有较低的优先级，这意味着如果您明确设置其他种子，它将被覆盖。</li></ul><p><strong>2.用于控制模型学习过程的参数：</strong></p><ul><li>max_depth：限制树模型的最大深度. 这可以在 #data 小的情况下防止过拟合. 树仍然可以通过 leaf-wise 生长。</li><li>min_data_in_leaf： 默认=20，一个叶子上数据的最小数量. 可以用来处理过拟合。</li><li>min_sum_hessian_in_leaf（min_sum_hessian_per_leaf, min_sum_hessian, min_hessian）：默认=1e-3，一个叶子上的最小 hessian 和. 类似于 min_data_in_leaf, 可以用来处理过拟合.</li><li>feature_fraction：default=1.0，如果 feature_fraction 小于 1.0, LightGBM 将会在每次迭代中随机选择部分特征. 例如, 如果设置为 0.8, 将会在每棵树训练之前选择 80% 的特征，可以用来加速训练，可以用来处理过拟合。</li><li>feature_fraction_seed：默认=2，feature_fraction 的随机数种子。</li><li>bagging_fraction（sub_row, subsample）：默认=1，不进行重采样的情况下随机选择部分数据</li><li>bagging_freq（subsample_freq）：bagging 的频率, 0 意味着禁用 bagging. k 意味着每 k 次迭代执行bagging</li><li>bagging_seed（bagging_fraction_seed） ：默认=3，bagging 随机数种子。</li><li>early_stopping_round（early_stopping_rounds, early_stopping）：默认=0，如果一个验证集的度量在 early_stopping_round 循环中没有提升, 将停止训练</li><li>lambda_l1（reg_alpha）：L1正则化系数</li><li>lambda_l2（reg_lambda）：L2正则化系数</li><li>min_split_gain（min_gain_to_split）：执行切分的最小增益，默认=0.</li><li>cat_smooth：默认=10，用于分类特征，可以降低噪声在分类特征中的影响, 尤其是对数据很少的类别</li></ul><p><strong>3.度量参数：</strong></p><ul><li>metric：default={l2 for regression}, {binary_logloss for binary classification}, {ndcg for lambdarank}, type=multi-enum, options=l1, l2, ndcg, auc, binary_logloss, binary_error …<ul><li>l1, absolute loss, alias=mean_absolute_error, mae</li><li>l2, square loss, alias=mean_squared_error, mse</li><li>l2_root, root square loss, alias=root_mean_squared_error, rmse</li><li>quantile, Quantile regression</li><li>huber, Huber loss</li><li>fair, Fair loss</li><li>poisson, Poisson regression</li><li>ndcg, NDCG</li><li>map, MAP</li><li>auc, AUC</li><li>binary_logloss, log loss</li><li>binary_error, 样本: 0 的正确分类, 1 错误分类</li><li>multi_logloss, mulit-class 损失日志分类</li><li>multi_error, error rate for mulit-class 出错率分类</li><li>xentropy, cross-entropy (与可选的线性权重), alias=cross_entropy</li><li>xentlambda, “intensity-weighted” 交叉熵, alias=cross_entropy_lambda</li><li>kldiv, Kullback-Leibler divergence, alias=kullback_leibler</li><li>支持多指标, 使用 , 分隔</li></ul></li><li>train_metric（training_metric, is_training_metric）：默认=False，如果你需要输出训练的度量结果则设置 true  </li></ul><p><strong>4.GPU 参数：</strong></p><ul><li>gpu_device_id：default为-1, 这个default意味着选定平台上的设备。     <h3 id="2-3-LightGBM与网格搜索结合调参"><a href="#2-3-LightGBM与网格搜索结合调参" class="headerlink" title="2.3 LightGBM与网格搜索结合调参"></a>2.3 LightGBM与网格搜索结合调参</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"> </span><br><span class="line">canceData=load_breast_cancer()</span><br><span class="line">X=canceData.data</span><br><span class="line">y=canceData.target</span><br><span class="line">X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=<span class="number">0</span>,test_size=<span class="number">0.2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">### 数据转换</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数据转换&#x27;</span>)</span><br><span class="line">lgb_train = lgb.Dataset(X_train, y_train, free_raw_data=<span class="literal">False</span>)</span><br><span class="line">lgb_eval = lgb.Dataset(X_test, y_test, reference=lgb_train,free_raw_data=<span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">### 设置初始参数--不含交叉验证参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;设置参数&#x27;</span>)</span><br><span class="line">params = &#123;</span><br><span class="line">          <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;metric&#x27;</span>: <span class="string">&#x27;auc&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;nthread&#x27;</span>:<span class="number">4</span>,</span><br><span class="line">          <span class="string">&#x27;learning_rate&#x27;</span>:<span class="number">0.1</span></span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">### 交叉验证(调参)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;交叉验证&#x27;</span>)</span><br><span class="line">max_auc = <span class="built_in">float</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">best_params = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 准确率</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调参1：提高准确率&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> num_leaves <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">100</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> max_depth <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>):</span><br><span class="line">        params[<span class="string">&#x27;num_leaves&#x27;</span>] = num_leaves</span><br><span class="line">        params[<span class="string">&#x27;max_depth&#x27;</span>] = max_depth</span><br><span class="line"> </span><br><span class="line">        cv_results = lgb.cv(</span><br><span class="line">                            params,</span><br><span class="line">                            lgb_train,</span><br><span class="line">                            seed=<span class="number">1</span>,</span><br><span class="line">                            nfold=<span class="number">5</span>,</span><br><span class="line">                            metrics=[<span class="string">&#x27;auc&#x27;</span>],</span><br><span class="line">                            early_stopping_rounds=<span class="number">10</span>,</span><br><span class="line">                            verbose_eval=<span class="literal">True</span></span><br><span class="line">                            )</span><br><span class="line">            </span><br><span class="line">        mean_auc = pd.Series(cv_results[<span class="string">&#x27;auc-mean&#x27;</span>]).<span class="built_in">max</span>()</span><br><span class="line">        boost_rounds = pd.Series(cv_results[<span class="string">&#x27;auc-mean&#x27;</span>]).idxmax()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> mean_auc &gt;= max_auc:</span><br><span class="line">            max_auc = mean_auc</span><br><span class="line">            best_params[<span class="string">&#x27;num_leaves&#x27;</span>] = num_leaves</span><br><span class="line">            best_params[<span class="string">&#x27;max_depth&#x27;</span>] = max_depth</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;num_leaves&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;max_depth&#x27;</span> <span class="keyword">in</span> best_params.keys():          </span><br><span class="line">    params[<span class="string">&#x27;num_leaves&#x27;</span>] = best_params[<span class="string">&#x27;num_leaves&#x27;</span>]</span><br><span class="line">    params[<span class="string">&#x27;max_depth&#x27;</span>] = best_params[<span class="string">&#x27;max_depth&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 过拟合</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调参2：降低过拟合&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> max_bin <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">256</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> min_data_in_leaf <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">102</span>,<span class="number">10</span>):</span><br><span class="line">            params[<span class="string">&#x27;max_bin&#x27;</span>] = max_bin</span><br><span class="line">            params[<span class="string">&#x27;min_data_in_leaf&#x27;</span>] = min_data_in_leaf</span><br><span class="line">            </span><br><span class="line">            cv_results = lgb.cv(</span><br><span class="line">                                params,</span><br><span class="line">                                lgb_train,</span><br><span class="line">                                seed=<span class="number">1</span>,</span><br><span class="line">                                nfold=<span class="number">5</span>,</span><br><span class="line">                                metrics=[<span class="string">&#x27;auc&#x27;</span>],</span><br><span class="line">                                early_stopping_rounds=<span class="number">10</span>,</span><br><span class="line">                                verbose_eval=<span class="literal">True</span></span><br><span class="line">                                )</span><br><span class="line">                    </span><br><span class="line">            mean_auc = pd.Series(cv_results[<span class="string">&#x27;auc-mean&#x27;</span>]).<span class="built_in">max</span>()</span><br><span class="line">            boost_rounds = pd.Series(cv_results[<span class="string">&#x27;auc-mean&#x27;</span>]).idxmax()</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> mean_auc &gt;= max_auc:</span><br><span class="line">                max_auc = mean_auc</span><br><span class="line">                best_params[<span class="string">&#x27;max_bin&#x27;</span>]= max_bin</span><br><span class="line">                best_params[<span class="string">&#x27;min_data_in_leaf&#x27;</span>] = min_data_in_leaf</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;max_bin&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;min_data_in_leaf&#x27;</span> <span class="keyword">in</span> best_params.keys():</span><br><span class="line">    params[<span class="string">&#x27;min_data_in_leaf&#x27;</span>] = best_params[<span class="string">&#x27;min_data_in_leaf&#x27;</span>]</span><br><span class="line">    params[<span class="string">&#x27;max_bin&#x27;</span>] = best_params[<span class="string">&#x27;max_bin&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调参3：降低过拟合&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> feature_fraction <span class="keyword">in</span> [<span class="number">0.6</span>,<span class="number">0.7</span>,<span class="number">0.8</span>,<span class="number">0.9</span>,<span class="number">1.0</span>]:</span><br><span class="line">    <span class="keyword">for</span> bagging_fraction <span class="keyword">in</span> [<span class="number">0.6</span>,<span class="number">0.7</span>,<span class="number">0.8</span>,<span class="number">0.9</span>,<span class="number">1.0</span>]:</span><br><span class="line">        <span class="keyword">for</span> bagging_freq <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">50</span>,<span class="number">5</span>):</span><br><span class="line">            params[<span class="string">&#x27;feature_fraction&#x27;</span>] = feature_fraction</span><br><span class="line">            params[<span class="string">&#x27;bagging_fraction&#x27;</span>] = bagging_fraction</span><br><span class="line">            params[<span class="string">&#x27;bagging_freq&#x27;</span>] = bagging_freq</span><br><span class="line">            </span><br><span class="line">            cv_results = lgb.cv(</span><br><span class="line">                                params,</span><br><span class="line">                                lgb_train,</span><br><span class="line">                                seed=<span class="number">1</span>,</span><br><span class="line">                                nfold=<span class="number">5</span>,</span><br><span class="line">                                metrics=[<span class="string">&#x27;auc&#x27;</span>],</span><br><span class="line">                                early_stopping_rounds=<span class="number">10</span>,</span><br><span class="line">                                verbose_eval=<span class="literal">True</span></span><br><span class="line">                                )</span><br><span class="line">                    </span><br><span class="line">            mean_auc = pd.Series(cv_results[<span class="string">&#x27;auc-mean&#x27;</span>]).<span class="built_in">max</span>()</span><br><span class="line">            boost_rounds = pd.Series(cv_results[<span class="string">&#x27;auc-mean&#x27;</span>]).idxmax()</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> mean_auc &gt;= max_auc:</span><br><span class="line">                max_auc=mean_auc</span><br><span class="line">                best_params[<span class="string">&#x27;feature_fraction&#x27;</span>] = feature_fraction</span><br><span class="line">                best_params[<span class="string">&#x27;bagging_fraction&#x27;</span>] = bagging_fraction</span><br><span class="line">                best_params[<span class="string">&#x27;bagging_freq&#x27;</span>] = bagging_freq</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;feature_fraction&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;bagging_fraction&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;bagging_freq&#x27;</span> <span class="keyword">in</span> best_params.keys():</span><br><span class="line">    params[<span class="string">&#x27;feature_fraction&#x27;</span>] = best_params[<span class="string">&#x27;feature_fraction&#x27;</span>]</span><br><span class="line">    params[<span class="string">&#x27;bagging_fraction&#x27;</span>] = best_params[<span class="string">&#x27;bagging_fraction&#x27;</span>]</span><br><span class="line">    params[<span class="string">&#x27;bagging_freq&#x27;</span>] = best_params[<span class="string">&#x27;bagging_freq&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调参4：降低过拟合&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> lambda_l1 <span class="keyword">in</span> [<span class="number">1e-5</span>,<span class="number">1e-3</span>,<span class="number">1e-1</span>,<span class="number">0.0</span>,<span class="number">0.1</span>,<span class="number">0.3</span>,<span class="number">0.5</span>,<span class="number">0.7</span>,<span class="number">0.9</span>,<span class="number">1.0</span>]:</span><br><span class="line">    <span class="keyword">for</span> lambda_l2 <span class="keyword">in</span> [<span class="number">1e-5</span>,<span class="number">1e-3</span>,<span class="number">1e-1</span>,<span class="number">0.0</span>,<span class="number">0.1</span>,<span class="number">0.4</span>,<span class="number">0.6</span>,<span class="number">0.7</span>,<span class="number">0.9</span>,<span class="number">1.0</span>]:</span><br><span class="line">        params[<span class="string">&#x27;lambda_l1&#x27;</span>] = lambda_l1</span><br><span class="line">        params[<span class="string">&#x27;lambda_l2&#x27;</span>] = lambda_l2</span><br><span class="line">        cv_results = lgb.cv(</span><br><span class="line">                            params,</span><br><span class="line">                            lgb_train,</span><br><span class="line">                            seed=<span class="number">1</span>,</span><br><span class="line">                            nfold=<span class="number">5</span>,</span><br><span class="line">                            metrics=[<span class="string">&#x27;auc&#x27;</span>],</span><br><span class="line">                            early_stopping_rounds=<span class="number">10</span>,</span><br><span class="line">                            verbose_eval=<span class="literal">True</span></span><br><span class="line">                            )</span><br><span class="line">                </span><br><span class="line">        mean_auc = pd.Series(cv_results[<span class="string">&#x27;auc-mean&#x27;</span>]).<span class="built_in">max</span>()</span><br><span class="line">        boost_rounds = pd.Series(cv_results[<span class="string">&#x27;auc-mean&#x27;</span>]).idxmax()</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> mean_auc &gt;= max_auc:</span><br><span class="line">            max_auc=mean_auc</span><br><span class="line">            best_params[<span class="string">&#x27;lambda_l1&#x27;</span>] = lambda_l1</span><br><span class="line">            best_params[<span class="string">&#x27;lambda_l2&#x27;</span>] = lambda_l2</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;lambda_l1&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;lambda_l2&#x27;</span> <span class="keyword">in</span> best_params.keys():</span><br><span class="line">    params[<span class="string">&#x27;lambda_l1&#x27;</span>] = best_params[<span class="string">&#x27;lambda_l1&#x27;</span>]</span><br><span class="line">    params[<span class="string">&#x27;lambda_l2&#x27;</span>] = best_params[<span class="string">&#x27;lambda_l2&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调参5：降低过拟合2&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> min_split_gain <span class="keyword">in</span> [<span class="number">0.0</span>,<span class="number">0.1</span>,<span class="number">0.2</span>,<span class="number">0.3</span>,<span class="number">0.4</span>,<span class="number">0.5</span>,<span class="number">0.6</span>,<span class="number">0.7</span>,<span class="number">0.8</span>,<span class="number">0.9</span>,<span class="number">1.0</span>]:</span><br><span class="line">    params[<span class="string">&#x27;min_split_gain&#x27;</span>] = min_split_gain</span><br><span class="line">    </span><br><span class="line">    cv_results = lgb.cv(</span><br><span class="line">                        params,</span><br><span class="line">                        lgb_train,</span><br><span class="line">                        seed=<span class="number">1</span>,</span><br><span class="line">                        nfold=<span class="number">5</span>,</span><br><span class="line">                        metrics=[<span class="string">&#x27;auc&#x27;</span>],</span><br><span class="line">                        early_stopping_rounds=<span class="number">10</span>,</span><br><span class="line">                        verbose_eval=<span class="literal">True</span></span><br><span class="line">                        )</span><br><span class="line">            </span><br><span class="line">    mean_auc = pd.Series(cv_results[<span class="string">&#x27;auc-mean&#x27;</span>]).<span class="built_in">max</span>()</span><br><span class="line">    boost_rounds = pd.Series(cv_results[<span class="string">&#x27;auc-mean&#x27;</span>]).idxmax()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> mean_auc &gt;= max_auc:</span><br><span class="line">        max_auc=mean_auc</span><br><span class="line">        </span><br><span class="line">        best_params[<span class="string">&#x27;min_split_gain&#x27;</span>] = min_split_gain</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;min_split_gain&#x27;</span> <span class="keyword">in</span> best_params.keys():</span><br><span class="line">    params[<span class="string">&#x27;min_split_gain&#x27;</span>] = best_params[<span class="string">&#x27;min_split_gain&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(best_params)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;bagging_fraction&#x27;</span>: <span class="number">0.7</span>,</span><br><span class="line"><span class="string">&#x27;bagging_freq&#x27;</span>: <span class="number">30</span>,</span><br><span class="line"><span class="string">&#x27;feature_fraction&#x27;</span>: <span class="number">0.8</span>,</span><br><span class="line"><span class="string">&#x27;lambda_l1&#x27;</span>: <span class="number">0.1</span>,</span><br><span class="line"><span class="string">&#x27;lambda_l2&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line"><span class="string">&#x27;max_bin&#x27;</span>: <span class="number">255</span>,</span><br><span class="line"><span class="string">&#x27;max_depth&#x27;</span>: <span class="number">4</span>,</span><br><span class="line"><span class="string">&#x27;min_data_in_leaf&#x27;</span>: <span class="number">81</span>,</span><br><span class="line"><span class="string">&#x27;min_split_gain&#x27;</span>: <span class="number">0.1</span>,</span><br><span class="line"><span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、XGBoost&quot;&gt;&lt;a href=&quot;#一、XGBoost&quot; class=&quot;headerlink&quot; title=&quot;一、XGBoost&quot;&gt;&lt;/a&gt;一、XGBoost&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://xgboost.readthedocs.io/en/latest/python/python_intro.html&quot;&gt;XGBoost官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-1-XGBoost原理及构建&quot;&gt;&lt;a href=&quot;#1-1-XGBoost原理及构建&quot; class=&quot;headerlink&quot; title=&quot;1.1 XGBoost原理及构建&quot;&gt;&lt;/a&gt;1.1 XGBoost原理及构建&lt;/h3&gt;&lt;p&gt;XGBoost本质上还是一个GBDT，是一个优化的分布式梯度增强库，旨在实现高效，灵活和便携。Xgboost以CART决策树为子模型，通过Gradient Tree Boosting实现多棵CART树的集成学习，得到最终模型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;XGBoost的最终模型构建：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/d87b34dc7f8747f4b0cd74dcea1eb70d.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;因此，目标函数的构建为：                                &lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\mathcal{L}(\phi)=\sum_{i} l\left(\hat{y}_{i}, y_{i}\right)+\sum_{k} \Omega\left(f_{k}\right)&lt;/script&gt;</summary>
    
    
    
    <category term="集成学习" scheme="https://zhxnlp.github.io/categories/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="集成学习" scheme="https://zhxnlp.github.io/tags/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Boosting" scheme="https://zhxnlp.github.io/tags/Boosting/"/>
    
    <category term="XGBoost" scheme="https://zhxnlp.github.io/tags/XGBoost/"/>
    
    <category term="LightGBM" scheme="https://zhxnlp.github.io/tags/LightGBM/"/>
    
  </entry>
  
  <entry>
    <title>集成学习2：Boosting算法：Adaboost&amp;GBDT</title>
    <link href="https://zhxnlp.github.io/2021/12/03/datawhale%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A02%EF%BC%9ABoosting%E7%AE%97%E6%B3%95%EF%BC%9AAdaboost&amp;GBDT/"/>
    <id>https://zhxnlp.github.io/2021/12/03/datawhale%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A02%EF%BC%9ABoosting%E7%AE%97%E6%B3%95%EF%BC%9AAdaboost&amp;GBDT/</id>
    <published>2021-12-02T22:49:40.000Z</published>
    <updated>2022-01-02T20:49:08.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-Boosting算法原理"><a href="#一、-Boosting算法原理" class="headerlink" title="一、 Boosting算法原理"></a>一、 Boosting算法原理</h2><ul><li>Bagging：通过Bootstrap 的方式对全样本数据集进行抽样得到抽样子集，对不同的子集使用同一种基本模型进行拟合，然后投票得出最终的预测。</li><li>Bagging主要通过降低方差的方式减少预测误差&lt;/font&gt;</li><li>Boosting：使用同一组数据集进行反复学习，得到一系列简单模型，然后组合这些模型构成一个预测性能十分强大的机器学习模型。</li><li>Boosting通过不断减少偏差的形式提高最终的预测效果，与Bagging有着本质的不同。</li></ul><p>在概率近似正确（PAC）学习的框架下：</p><ol><li>弱学习：识别准确率略高于1/2（即准确率仅比随机猜测略高的学习算法）</li><li>强学习：识别准确率很高并能在多项式时间内完成的学习算法</li><li>强可学习和弱可学习是等价的，弱可学习算法，能提升至强可学习算法<span id="more"></span></li></ol><ul><li>提升方法：从弱学习算法出发，反复学习，得到一系列弱分类器(又称为基本分类器)，再通过一定的形式去组合这些弱分类器构成一个强分类器。而弱可学习算法比强可学习算法容易得多。</li><li>大多数的Boosting方法都是通过改变训练数据集的概率分布(训练数据不同样本的权值)，针对不同概率分布的数据调用弱分类算法学习一系列的弱分类器。</li></ul><p>Boosting方法关键点：</p><ol><li>每一轮学习应该如何改变数据的概率分布</li><li>如何将各个弱分类器组合起来</li></ol><h2 id="二、-Adaboost算法"><a href="#二、-Adaboost算法" class="headerlink" title="二、 Adaboost算法"></a>二、 Adaboost算法</h2><h3 id="2-1-Adaboost算法原理"><a href="#2-1-Adaboost算法原理" class="headerlink" title="2.1 Adaboost算法原理"></a>2.1 Adaboost算法原理</h3><p>Adaboost解决上述的两个问题的方式是：</p><ol><li>提高那些被前一轮分类器错误分类的样本的权重&lt;/font&gt;，而降低那些被正确分类的样本的权重。错误分类样本权重的增大而在后一轮的训练中“备受关注”。</li><li>各个弱分类器通过采取加权多数表决的方式组合&lt;/font&gt;。分类错误率低的弱分类器权重高，分类错误率较大的弱分类器权重低。</li><li><p>Adaboost等Boosting模型增加了计算的复杂度和计算成本，用降低偏差的方式去减少总误差，但是过程中引入了方差，可能出现过拟合</p></li><li><p>Boosting方式无法做到现在流行的并行计算的方式进行训练，因为每一步迭代都要基于上一部的基本分类器。</p></li><li>Adaboost算法是由基本分类器组成的加法模型，损失函数为指数损失函数。</li></ol><p>Adaboost算法：</p><ul><li>输入：二分类的训练数据集$T=\left{\left(x<em>{1}, y</em>{1}\right),\left(x<em>{2}, y</em>{2}\right), \cdots,\left(x<em>{N}, y</em>{N}\right)\right}$，特征$x<em>{i} \in \mathcal{X} \subseteq \mathbf{R}^{n}$，类别$y</em>{i} \in \mathcal{Y}={-1,+1}$，$\mathcal{X}$是特征空间，$\mathcal{Y}$是类别集合，其中每个样本点由特征与类别组成。</li><li>输出：最终分类器$G(x)$。</li></ul><p>(1) 初始化训练集样本的权值分布：<script type="math/tex">D_{1}=\left(w_{11}, \cdots, w_{1 i}, \cdots, w_{1 N}\right), \quad w_{1 i}=\frac{1}{N}, \quad i=1,2, \cdots, N</script>其中权值是均匀分布，使得第一次没有先验信息的条件下每个样本在基本分类器的学习中作用一样。</p><p>(2) 对于学习轮次m=1,2,…,M</p><ol><li>使用具有权值分布$D<em>m$的训练数据集进行学习，得到基本分类器：$G</em>{m}(x): \mathcal{X} \rightarrow{-1,+1}$</li><li>计算$G<em>m(x)$在训练集上的分类误差率$$e</em>{m}=\sum<em>{i=1}^{N} P\left(G</em>{m}\left(x<em>{i}\right) \neq y</em>{i}\right)=\sum<em>{i=1}^{N} w</em>{m i} I\left(G<em>{m}\left(x</em>{i}\right) \neq y<em>{i}\right)$$<br>$w</em>{m i}$代表了在$G_m(x)$中分类错误的样本权重和，这点直接说明了权重分布$D_m$与$G_m(x)$的分类错误率$e_m$有直接关系。</li><li>计算$G<em>m(x)$的系数$\alpha</em>{m}=\frac{1}{2} \log \frac{1-e<em>{m}}{e</em>{m}}$，这里的log是自然对数ln<ul><li>$\alpha_{m}$表示了$G_m(x)$在最终分类器的重要性程度。</li><li>当$e<em>{m} \leqslant \frac{1}{2}$时，$\alpha</em>{m} \geqslant 0$，并且$\alpha_m$随着$e_m$的减少而增大，因此分类错误率越小的基本分类器在最终分类器的作用越大！                       </li></ul></li><li><p>更新训练数据集的权重分布</p><script type="math/tex; mode=display">D_{m+1}=(w_{m+1,1}, \cdots, w_{m+1, i}, \cdots, w_{m+1, N})</script><script type="math/tex; mode=display">w_{m+1, i}=\left\{\begin{array}{ll}\frac{w_{m i}}{Z_{m}} \mathrm{e}^{-\alpha_{m}}, & G_{m}\left(x_{i}\right)=y_{i} \\\frac{w_{m i}}{Z_{m}} \mathrm{e}^{\alpha_{m}}, & G_{m}\left(x_{i}\right) \neq y_{i}\end{array}\right.</script><script type="math/tex; mode=display">Z_{m}=\sum_{i=1}^{N} w_{m i} \exp \left(-\alpha_{m} y_{i} G_{m}\left(x_{i}\right)\right)</script><p>这里的$Z<em>m$是规范化因子，使得$D</em>{m+1}$成为概率分布。</p><p>从上式可以看到：被基本分类器$G<em>m(x)$错误分类的样本的权重扩大，被正确分类的样本权重减少，二者相比相差$\mathrm{e}^{2 \alpha</em>{m}}=\frac{1-e<em>{m}}{e</em>{m}}$倍。     </p></li></ol><p>(3) 构建基本分类器的线性组合$f(x)=\sum<em>{m=1}^{M} \alpha</em>{m} G_{m}(x)$，得到最终的分类器                       </p><script type="math/tex; mode=display">\begin{aligned}G(x) &=\operatorname{sign}(f(x)) \\&=\operatorname{sign}\left(\sum_{m=1}^{M} \alpha_{m} G_{m}(x)\right)\end{aligned}</script><script type="math/tex; mode=display">sign(x)=\begin{cases}1 & \text{ if } x\geqslant 0 \\ -1 & \text{ if } x< 0 \end{cases}</script><p>线性组合$f(x)$实现了将M个基本分类器的加权表决，系数$\alpha_m$标志了基本分类器$G_m(x)$的重要性，值得注意的是：所有的$\alpha_m$之和不为1。$f(x)$的符号决定了样本x属于哪一类,其绝对值表示分类的确信度。</p><p>简单来说：计算M个基本分类器，每个分类器的错误率、模型权重及样本权重</p><ol><li>均匀初始化样本权重$D_{1}$</li><li>对于轮次m，针对当前权重$D<em>{m}$ 学习分类器 $G</em>{m}(x)$，并计算其分类错误率$e_{m}$。</li><li>计算分类器$G<em>m(x)$的权重系数$\alpha</em>{m}=\frac{1}{2} \log \frac{1-e<em>{m}}{e</em>{m}}$&lt;/font&gt;。$e<em>{m} \leqslant \frac{1}{2}$时，$\alpha</em>{m} \geqslant 0$，并且$\alpha_m$随着$e_m$的减少而增大，因此分类错误率越小的基本分类器在最终分类器的作用越大！</li><li>更新权重分布 <script type="math/tex">w_{m+1, i}=\left\{\begin{array}{ll}\frac{w_{m i}}{Z_{m}} \mathrm{e}^{-\alpha_{m}}, & G_{m}\left(x_{i}\right)=y_{i} \\\frac{w_{m i}}{Z_{m}} \mathrm{e}^{\alpha_{m}}, & G_{m}\left(x_{i}\right) \neq y_{i}\end{array}\right.</script><br>一般来说$\alpha<em>{m} \geqslant 0，e^0=1$。被基本分类器$G_m(x)$错误分类的样本的权重扩大，被正确分类的样本权重减少。$e</em>{m}$减小，$\alpha<em>{m}$增大，${w</em>{m+1, i}}$增大。即错误率越低的分类器，分类器权重和错误样本权重都越大，感觉上越准确准确的分类器学习力度越大。</li><li>基本分类器加权组合表决</li><li>总结：Adaboost不改变训练数据，而是改变其权值分布，使每一轮的基学习器学习不同权重分布的样本集，最后加权组合表决。</li></ol><h3 id="2-2-Adaboost算法举例"><a href="#2-2-Adaboost算法举例" class="headerlink" title="2.2 Adaboost算法举例"></a>2.2 Adaboost算法举例</h3><p>下面，我们使用一组简单的数据来手动计算Adaboost算法的过程：(例子来源<a href="http://www.csie.edu.tw">http://www.csie.edu.tw</a>)                                                               </p><p>训练数据如下表，假设基本分类器的形式是一个分割$x<v$或$x>v$表示，阈值v由该基本分类器在训练数据集上分类错误率$e_m$最低确定。&lt;/font&gt;                                                </p><script type="math/tex; mode=display">\begin{array}{ccccccccccc}\hline \text { 序号 } & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\\hline x & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\y & 1 & 1 & 1 & -1 & -1 & -1 & 1 & 1 & 1 & -1 \\\hline\end{array}</script><p>解：<br>初始化样本权值分布</p><script type="math/tex; mode=display">\begin{aligned}D_{1} &=\left(w_{11}, w_{12}, \cdots, w_{110}\right) \\w_{1 i} &=0.1, \quad i=1,2, \cdots, 10\end{aligned}</script><ol><li><p>对m=1:                      </p><ul><li>在权值分布$D_1$的训练数据集上，遍历每个结点并计算分类误差率$e_m$，阈值取v=2.5时分类误差率最低，那么基本分类器为：<script type="math/tex; mode=display">G_{1}(x)=\left\{\begin{array}{ll}1, & x<2.5 \\-1, & x>2.5\end{array}\right.</script></li><li>样本7.8.9分错，$G<em>1(x)$在训练数据集上的误差率为$e</em>{1}=P\left(G<em>{1}\left(x</em>{i}\right) \neq y_{i}\right)=0.1*3=0.3$。                                        </li><li>计算$G<em>1(x)$的系数：$\alpha</em>{1}=\frac{1}{2} \log \frac{1-e<em>{1}}{e</em>{1}}=0.4236$               </li><li>更新训练数据的权值分布：                  <script type="math/tex; mode=display">\begin{aligned}D_{2}=&\left(w_{21}, \cdots, w_{2 i}, \cdots, w_{210}\right) \\w_{2 i}=& \frac{w_{1 i}}{Z_{1}} \exp \left(-\alpha_{1} y_{i} G_{1}\left(x_{i}\right)\right), \quad i=1,2, \cdots, 10 \\D_{2}=&(0.07143,0.07143,0.07143,0.07143,0.07143,0.07143,\\&0.16667,0.16667,0.16667,0.07143) \\f_{1}(x) &=0.4236 G_{1}(x)=array([ 0.4236,  0.4236,  0.4236, -0.4236, -0.4236, -0.4236, -0.4236,  -0.4236, -0.4236, -0.4236])\end{aligned}</script>权重为[0.07143×7,0.16667×3]</li></ul></li><li><p>对于m=2：                   </p><ul><li>在权值分布$D_2$的训练数据集上，遍历每个结点并计算分类误差率$e_m$，阈值取v=8.5时分类误差率最低，那么基本分类器为：                  <script type="math/tex; mode=display">G_{2}(x)=\left\{\begin{array}{ll}1, & x<8.5 \\-1, & x>8.5\end{array}\right.</script></li><li>样本4.5.6分错，$G_2(x)$在训练数据集上的误差率为$e_2 = 0.07143*3=0.2143$                    </li><li>计算$G_2(x)$的系数：$\alpha_2 = 0.6496$                        </li><li>更新训练数据的权值分布：                  <script type="math/tex; mode=display">\begin{aligned}D_{3}=&(0.0455,0.0455,0.0455,0.1667,0.1667,0.1667\\&0.1060,0.1060,0.1060,0.0455) \\f_{2}(x) &=0.4236 G_{1}(x)+0.6496 G_{2}(x)=array([ 1.0732,  1.0732,  1.0732,  0.226 ,  0.226 ,  0.226 ,  0.226 ,   0.226 ,  0.226 , -1.0732])\end{aligned}</script>权重为[0.00455×4,0.1060×3,0.16667×3]。</li></ul></li><li>对m=3：                          <ul><li>在权值分布$D_3$的训练数据集上，遍历每个结点并计算分类误差率$e_m$，阈值取v=5.5时分类误差率最低，那么基本分类器为：                     <script type="math/tex; mode=display">G_{3}(x)=\left\{\begin{array}{ll}1, & x>5.5 \\-1, & x<5.5\end{array}\right.</script></li><li>样本1.2.3.10分错，$G_3(x)$在训练数据集上的误差率为$e_3 =0.0455*4= 0.1820$                       </li><li>计算$G_3(x)$的系数：$\alpha_3 = 0.7514$                                 </li><li>更新训练数据的权值分布：<br>$D_{4}=(0.125,0.125,0.125,0.102,0.102,0.102,0.065,0.065,0.065,0.125)$                       <script type="math/tex; mode=display">f_{3}(x)=0.4236 G_{1}(x)+0.6496 G_{2}(x)+0.7514 G_{3}(x)=array([ 0.3218,  0.3218,  0.3218, -0.5254, -0.5254, -0.5254,  0.9774,   0.9774,  0.9774, -0.3218])</script>   分类器$\operatorname{sign}\left[f<em>{3}(x)\right]$在训练数据集上的误分类点的个数为0。<br>最终分类器为：$G(x)=\operatorname{sign}\left[f</em>{3}(x)\right]=\operatorname{sign}\left[0.4236 G<em>{1}(x)+0.6496 G</em>{2}(x)+0.7514 G_{3}(x)\right]$</li></ul></li></ol><p>==可以看到每次样本权重和都为1，分类器错误率越来越低，分类器权重越来越高。最终分类器结果就是基分类器结果乘以其权重的加和==</p><h3 id="2-3-Adaboos代码举例"><a href="#2-3-Adaboos代码举例" class="headerlink" title="2.3 Adaboos代码举例"></a>2.3 Adaboos代码举例</h3><p>数据集：CI的机器学习库里的<a href="https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data">葡萄酒数据集</a>，该数据集包含了178个样本和13个特征，从不同的角度对不同的化学特性进行描述，最终预测红酒属于哪一个类别。(案例来源《python机器学习(第二版》)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 引入数据科学相关工具包：</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">&quot;ggplot&quot;</span>)</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载训练数据：         </span></span><br><span class="line">wine = pd.read_csv(<span class="string">&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data&quot;</span>,header=<span class="literal">None</span>)</span><br><span class="line">wine.columns = [<span class="string">&#x27;Class label&#x27;</span>, <span class="string">&#x27;Alcohol&#x27;</span>, <span class="string">&#x27;Malic acid&#x27;</span>, <span class="string">&#x27;Ash&#x27;</span>, <span class="string">&#x27;Alcalinity of ash&#x27;</span>,<span class="string">&#x27;Magnesium&#x27;</span>, <span class="string">&#x27;Total phenols&#x27;</span>,<span class="string">&#x27;Flavanoids&#x27;</span>, <span class="string">&#x27;Nonflavanoid phenols&#x27;</span>, </span><br><span class="line">                <span class="string">&#x27;Proanthocyanins&#x27;</span>,<span class="string">&#x27;Color intensity&#x27;</span>, <span class="string">&#x27;Hue&#x27;</span>,<span class="string">&#x27;OD280/OD315 of diluted wines&#x27;</span>,<span class="string">&#x27;Proline&#x27;</span>]</span><br><span class="line"><span class="comment"># 数据查看：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Class labels&quot;</span>,np.unique(wine[<span class="string">&quot;Class label&quot;</span>]))</span><br><span class="line">wine.head()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/8e3e3b19c1f04d1b9257419b42646479.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>下面对数据做简单解读：</p><p>Class label：分类标签<br>Alcohol：酒精<br>Malic acid：苹果酸<br>Ash：灰<br>Alcalinity of ash：灰的碱度<br>Magnesium：镁<br>Total phenols：总酚<br>Flavanoids：黄酮类化合物<br>Nonflavanoid phenols：非黄烷类酚类<br>Proanthocyanins：原花青素<br>Color intensity：色彩强度<br>Hue：色调<br>OD280/OD315 of diluted wines：稀释酒OD280 OD350<br>Proline：脯氨酸</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line"><span class="comment"># 仅仅考虑2，3类葡萄酒，去除1类</span></span><br><span class="line">wine = wine[wine[<span class="string">&#x27;Class label&#x27;</span>] != <span class="number">1</span>]</span><br><span class="line">y = wine[<span class="string">&#x27;Class label&#x27;</span>].values</span><br><span class="line">X = wine[[<span class="string">&#x27;Alcohol&#x27;</span>,<span class="string">&#x27;OD280/OD315 of diluted wines&#x27;</span>]].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将分类标签变成二进制编码：</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">le = LabelEncoder()</span><br><span class="line">y = le.fit_transform(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按8：2分割训练集和测试集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="number">0.2</span>,random_state=<span class="number">1</span>,stratify=y)  <span class="comment"># stratify参数代表了按照y的类别等比例抽样</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用单一决策树建模</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">tree = DecisionTreeClassifier(criterion=<span class="string">&#x27;entropy&#x27;</span>,random_state=<span class="number">1</span>,max_depth=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line">tree = tree.fit(X_train,y_train)</span><br><span class="line">y_train_pred = tree.predict(X_train)</span><br><span class="line">y_test_pred = tree.predict(X_test)</span><br><span class="line">tree_train = accuracy_score(y_train,y_train_pred)</span><br><span class="line">tree_test = accuracy_score(y_test,y_test_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Decision tree train/test accuracies %.3f/%.3f&#x27;</span> % (tree_train,tree_test))</span><br><span class="line"></span><br><span class="line">Decision tree train/test accuracies <span class="number">0.916</span>/<span class="number">0.875</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用sklearn实现Adaboost(基分类器为决策树)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">AdaBoostClassifier相关参数：</span></span><br><span class="line"><span class="string">base_estimator：基本分类器，默认为DecisionTreeClassifier(max_depth=1)</span></span><br><span class="line"><span class="string">n_estimators：终止迭代的次数</span></span><br><span class="line"><span class="string">learning_rate：学习率</span></span><br><span class="line"><span class="string">algorithm：训练的相关算法，&#123;&#x27;SAMME&#x27;，&#x27;SAMME.R&#x27;&#125;，默认=&#x27;SAMME.R&#x27;</span></span><br><span class="line"><span class="string">random_state：随机种子</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line">ada = AdaBoostClassifier(base_estimator=tree,n_estimators=<span class="number">500</span>,learning_rate=<span class="number">0.1</span>,random_state=<span class="number">1</span>)</span><br><span class="line">ada = ada.fit(X_train,y_train)</span><br><span class="line">y_train_pred = ada.predict(X_train)</span><br><span class="line">y_test_pred = ada.predict(X_test)</span><br><span class="line">ada_train = accuracy_score(y_train,y_train_pred)</span><br><span class="line">ada_test = accuracy_score(y_test,y_test_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Adaboost train/test accuracies %.3f/%.3f&#x27;</span> % (ada_train,ada_test))</span><br><span class="line"></span><br><span class="line">Adaboost train/test accuracies <span class="number">1.000</span>/<span class="number">0.917</span></span><br></pre></td></tr></table></figure><p>结果分析：单层决策树似乎对训练数据欠拟合，而Adaboost模型正确地预测了训练数据的所有分类标签，而且与单层决策树相比，Adaboost的测试性能也略有提高。然而，为什么模型在训练集和测试集的性能相差这么大呢？我们使用图像来简单说明下这个道理！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 画出单层决策树与Adaboost的决策边界：</span></span><br><span class="line">x_min = X_train[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span></span><br><span class="line">x_max = X_train[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">y_min = X_train[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span></span><br><span class="line">y_max = X_train[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">0.1</span>),np.arange(y_min, y_max, <span class="number">0.1</span>))</span><br><span class="line">f, axarr = plt.subplots(nrows=<span class="number">1</span>, ncols=<span class="number">2</span>,sharex=<span class="string">&#x27;col&#x27;</span>,sharey=<span class="string">&#x27;row&#x27;</span>,figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> idx, clf, tt <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="number">0</span>, <span class="number">1</span>],[tree, ada],[<span class="string">&#x27;Decision tree&#x27;</span>, <span class="string">&#x27;Adaboost&#x27;</span>]):</span><br><span class="line">    clf.fit(X_train, y_train)</span><br><span class="line">    Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">    Z = Z.reshape(xx.shape)</span><br><span class="line">    axarr[idx].contourf(xx, yy, Z, alpha=<span class="number">0.3</span>)</span><br><span class="line">    axarr[idx].scatter(X_train[y_train==<span class="number">0</span>, <span class="number">0</span>],X_train[y_train==<span class="number">0</span>, <span class="number">1</span>],c=<span class="string">&#x27;blue&#x27;</span>, marker=<span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">    axarr[idx].scatter(X_train[y_train==<span class="number">1</span>, <span class="number">0</span>],X_train[y_train==<span class="number">1</span>, <span class="number">1</span>],c=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">    axarr[idx].set_title(tt)</span><br><span class="line">axarr[<span class="number">0</span>].set_ylabel(<span class="string">&#x27;Alcohol&#x27;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.text(<span class="number">0</span>, -<span class="number">0.2</span>,s=<span class="string">&#x27;OD280/OD315 of diluted wines&#x27;</span>,ha=<span class="string">&#x27;center&#x27;</span>,va=<span class="string">&#x27;center&#x27;</span>,fontsize=<span class="number">12</span>,transform=axarr[<span class="number">1</span>].transAxes)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e7ee7c34eacb4218b8e52011424f4055.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>从上面的决策边界图可以看到：</p><ul><li>Adaboost模型的决策边界比单层决策树的决策边界要复杂的多。也就是说，Adaboost试图用增加模型复杂度而降低偏差的方式去减少总误差，但是过程中引入了方差，可能出现过拟合</li><li>与单个分类器相比，Adaboost等Boosting模型增加了计算的复杂度，在实践中需要仔细思考是否愿意为预测性能的相对改善而增加计算成本</li><li>Boosting方式无法做到现在流行的并行计算的方式进行训练，因为每一步迭代都要基于上一部的基本分类器。</li></ul><h2 id="三、-前向分步算法"><a href="#三、-前向分步算法" class="headerlink" title="三、 前向分步算法"></a>三、 前向分步算法</h2><p>Adaboost的算法内容：通过计算M个基本分类器，每个分类器的错误率、样本权重以及模型权重。我们可以认为：Adaboost每次学习单一分类器以及单一分类器的参数(权重)。<br>抽象出Adaboost算法的整体框架逻辑，构建集成学习的一个非常重要的框架——前向分步算法，有了这个框架，我们不仅可以解决分类问题，也可以解决回归问题。</p><h3 id="3-1加法模型"><a href="#3-1加法模型" class="headerlink" title="3.1加法模型"></a>3.1加法模型</h3><p>在Adaboost模型中，我们把每个基本分类器合成一个复杂分类器的方法是每个基本分类器的加权和，即：$f(x)=\sum<em>{m=1}^{M} \beta</em>{m} b\left(x ; \gamma<em>{m}\right)$，其中，$b\left(x ; \gamma</em>{m}\right)$为即基本分类器，$\gamma<em>{m}$为基本分类器的参数，$\beta_m$为基本分类器的权重，显然这与第二章所学的加法模型。为什么这么说呢？大家把$b(x ; \gamma</em>{m})$看成是即函数即可。<br>在给定训练数据以及损失函数$L(y, f(x))$的条件下，学习加法模型$f(x)$就是：                        </p><script type="math/tex; mode=display">\min _{\beta_{m}, \gamma_{m}} \sum_{i=1}^{N} L\left(y_{i}, \sum_{m=1}^{M} \beta_{m} b\left(x_{i} ; \gamma_{m}\right)\right)</script><p>通常这是一个复杂的优化问题，很难通过简单的凸优化的相关知识进行解决。前向分步算法可以用来求解这种方式的问题，它的基本思路是：因为学习的是加法模型，如果从前向后，每一步只优化一个基函数及其系数，逐步逼近目标函数，那么就可以降低优化的复杂度。具体而言，每一步只需要优化：                    </p><script type="math/tex; mode=display">\min _{\beta, \gamma} \sum_{i=1}^{N} L\left(y_{i}, \beta b\left(x_{i} ; \gamma\right)\right)</script><h3 id="3-2-前向分步算法"><a href="#3-2-前向分步算法" class="headerlink" title="3.2 前向分步算法"></a>3.2 前向分步算法</h3><p>给定数据集$T=\left{\left(x<em>{1}, y</em>{1}\right),\left(x<em>{2}, y</em>{2}\right), \cdots,\left(x<em>{N}, y</em>{N}\right)\right}$，$x<em>{i} \in \mathcal{X} \subseteq \mathbf{R}^{n}$，$y</em>{i} \in \mathcal{Y}={+1,-1}$。损失函数$L(y, f(x))$，基函数集合${b(x ; \gamma)}$，我们需要输出加法模型$f(x)$。                         </p><ul><li>初始化：$f_{0}(x)=0$                           </li><li>对m = 1,2,…,M:                     <ul><li>(a) 极小化损失函数：<script type="math/tex; mode=display">\left(\beta_{m}, \gamma_{m}\right)=\arg \min _{\beta, \gamma} \sum_{i=1}^{N} L\left(y_{i}, f_{m-1}\left(x_{i}\right)+\beta b\left(x_{i} ; \gamma\right)\right)</script>得到参数$\beta<em>{m}$与$\gamma</em>{m}$                                           </li><li>(b) 更新：                          <script type="math/tex; mode=display">f_{m}(x)=f_{m-1}(x)+\beta_{m} b\left(x ; \gamma_{m}\right)</script></li></ul></li><li>得到加法模型：                           <script type="math/tex; mode=display">f(x)=f_{M}(x)=\sum_{m=1}^{M} \beta_{m} b\left(x ; \gamma_{m}\right)</script></li></ul><p>这样，前向分步算法将同时求解从m=1到M的所有参数$\beta<em>{m}$，$\gamma</em>{m}$的优化问题简化为逐次求解各个$\beta<em>{m}$，$\gamma</em>{m}$的问题。                           </p><h3 id="3-3-前向分步算法与Adaboost的关系"><a href="#3-3-前向分步算法与Adaboost的关系" class="headerlink" title="3.3 前向分步算法与Adaboost的关系"></a>3.3 前向分步算法与Adaboost的关系</h3><p>由于这里不是我们的重点，我们主要阐述这里的结论，不做相关证明，具体的证明见李航老师的《统计学习方法》第八章的3.2节。Adaboost算法是前向分步算法的特例，Adaboost算法是由基本分类器组成的加法模型，损失函数为指数损失函数。</p><h2 id="四、梯度提升决策树-GBDT"><a href="#四、梯度提升决策树-GBDT" class="headerlink" title="四、梯度提升决策树(GBDT)"></a>四、梯度提升决策树(GBDT)</h2><ul><li>GBDT 的全称是 Gradient Boosting Decision Tree，梯度提升树。GBDT使用的决策树是CART回归树。为什么不用CART分类树呢？因为GBDT每次迭代要拟合的是梯度值，是连续值所以要用回归树</li><li>CART假设决策树都是二叉树，内部节点特征取值为“是”和“否”，等价于递归二分每个特征。对回归树用平方误差最小化准则（回归树中的样本标签是连续数值，所以再使用熵之类的指标不再合适），对分类树用基尼系数最小化准则，进行特征选择生成二叉树</li><li><p>回归问题没有分类错误率可言，，用每个样本的残差表示每次使用基函数预测时没有解决的那部分问题</p><h3 id="4-1-Decision-Tree：CART回归树"><a href="#4-1-Decision-Tree：CART回归树" class="headerlink" title="4.1 Decision Tree：CART回归树"></a>4.1 Decision Tree：CART回归树</h3><p>最小二乘回归树生成算法见《统计学习方法》P82，算法5.5：<br><img src="https://img-blog.csdnimg.cn/15618f981d2f4b29a6d81ffceca8cfdb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="4-2-回归提升树算法"><a href="#4-2-回归提升树算法" class="headerlink" title="4.2 回归提升树算法"></a>4.2 回归提升树算法</h3><p>提升法：加法模型+前向分步算法。<br>提升树：以决策树为基函数（基本分类器）的提升方法，可表示为决策树的加法模型。<br>决策树：分类问题是二叉分类树，回归问题是二叉回归树</p></li><li><p>Adaboost：加法模型+前向分步算法的分类树模型</p></li><li>GBDT：     加法模型+前向分步算法的回归树模型</li></ul><p>分类误差率</p><ul><li>Adaboost算法：使用了分类错误率修正样本权重以及计算每个基本分类器的权重</li><li>GBDT：回归问题没有分类错误率可言，，用每个样本的残差表示每次使用基函数预测时没有解决的那部分问题</li></ul><p>根据以上两点得到回归问题提升树算法：</p><p>输入：数据集$T=\left{\left(x<em>{1}, y</em>{1}\right),\left(x<em>{2}, y</em>{2}\right), \cdots,\left(x<em>{N}, y</em>{N}\right)\right}, x<em>{i} \in \mathcal{X} \subseteq \mathbf{R}^{n}, y</em>{i} \in \mathcal{Y} \subseteq \mathbf{R}$<br>输出：最终的提升树$f_{M}(x)$                             </p><ul><li>初始化$f_0(x) = 0$                        </li><li>对m = 1,2,…,M：                  <ul><li>计算每个样本的残差:$r<em>{m i}=y</em>{i}-f<em>{m-1}\left(x</em>{i}\right), \quad i=1,2, \cdots, N$                                    </li><li>拟合残差$r<em>{mi}$学习一棵回归树，得到$T\left(x ; \Theta</em>{m}\right)$                        </li><li>更新$f<em>{m}(x)=f</em>{m-1}(x)+T\left(x ; \Theta_{m}\right)$</li></ul></li><li>得到最终的回归问题的提升树：$f<em>{M}(x)=\sum</em>{m=1}^{M} T\left(x ; \Theta_{m}\right)$                         </li></ul><p>下面我们用一个实际的案例来使用这个算法：(案例来源：李航老师《统计学习方法》P168，此处省略)                                                             </p><h3 id="4-3-梯度提升决策树算法-GBDT"><a href="#4-3-梯度提升决策树算法-GBDT" class="headerlink" title="4.3 梯度提升决策树算法(GBDT)"></a>4.3 梯度提升决策树算法(GBDT)</h3><p> GBDT：利用损失函数的负梯度作为回归问题提升树算法中的残差的近似值，拟合回归树。</p><ul><li>提升树利用加法模型和前向分步算法实现学习的过程，当损失函数为平方损失和指数损失时，每一步优化是相当简单的，也就是我们前面探讨的提升树算法和Adaboost算法。对于一般的损失函数而言，往往每一步的优化不是那么容易</li><li>针对这一问题，Freidman提出了梯度提升算法(gradient boosting)，利用损失函数的负梯度在当前模型的值$-\left[\frac{\partial L\left(y, f\left(x<em>{i}\right)\right)}{\partial f\left(x</em>{i}\right)}\right]<em>{f(x)=f</em>{m-1}(x)}$作为回归问题提升树算法中的残差的近似值，拟合回归树。<strong>与其说负梯度作为残差的近似值，不如说残差是负梯度的一种特例。</strong></li></ul><p>以下开始具体介绍梯度提升算法：<br>输入训练数据集$T=\left{\left(x<em>{1}, y</em>{1}\right),\left(x<em>{2}, y</em>{2}\right), \cdots,\left(x<em>{N}, y</em>{N}\right)\right}, x<em>{i} \in \mathcal{X} \subseteq \mathbf{R}^{n}, y</em>{i} \in \mathcal{Y} \subseteq \mathbf{R}$和损失函数$L(y, f(x))$，输出回归树$\hat{f}(x)$                              </p><ul><li>初始化$f<em>{0}(x)=\arg \min </em>{c} \sum<em>{i=1}^{N} L\left(y</em>{i}, c\right)$                     </li><li>对于m=1,2,…,M：                   <ul><li>对i = 1,2,…,N计算：$r<em>{m i}=-\left[\frac{\partial L\left(y</em>{i}, f\left(x<em>{i}\right)\right)}{\partial f\left(x</em>{i}\right)}\right]<em>{f(x)=f</em>{m-1}(x)}$                </li><li>对$r<em>{mi}$拟合一个回归树，得到第m棵树的叶结点区域$R</em>{m j}, j=1,2, \cdots, J$                           </li><li>对j=1,2,…J，计算：$c<em>{m j}=\arg \min </em>{c} \sum<em>{x</em>{i} \in R<em>{m j}} L\left(y</em>{i}, f<em>{m-1}\left(x</em>{i}\right)+c\right)$                      </li><li>更新$f<em>{m}(x)=f</em>{m-1}(x)+\sum<em>{j=1}^{J} c</em>{m j} I\left(x \in R_{m j}\right)$                    </li></ul></li><li>得到回归树：$\hat{f}(x)=f<em>{M}(x)=\sum</em>{m=1}^{M} \sum<em>{j=1}^{J} c</em>{m j} I\left(x \in R_{m j}\right)$</li></ul><p>下面，我们来使用一个具体的案例来说明GBDT是如何运作的(<a href="https://blog.csdn.net/zpalyq110/article/details/79527653">案例来源</a> )：<br>下面的表格是数据：<br><img src="https://img-blog.csdnimg.cn/14f12b8bf27d43ad90e52d67258a25b0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hBCnWMyY-1638484890166)(./6.png)\]"></p><p>学习率：learning_rate=0.1，迭代次数：n_trees=5，树的深度：max_depth=3<br>平方损失的负梯度为：</p><script type="math/tex; mode=display">-\left[\frac{\left.\partial L\left(y, f\left(x_{i}\right)\right)\right)}{\partial f\left(x_{i}\right)}\right]_{f(x)=f_{t-1}(x)}=y-f\left(x_{i}\right)</script><p>$c=(1.1+1.3+1.7+1.8)/4=1.475，f_{0}(x)=c=1.475$<br><img src="https://img-blog.csdnimg.cn/3319d5746aed4188b03e57d37cb53cca.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>学习决策树，分裂结点：<br><img src="https://img-blog.csdnimg.cn/3c1ff3f51eb7480e99248dd3fb4dba73.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/b9bcefd41c2342d99935c6070e6fbaa7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/69b7a5687482439a8025ba693cb33558.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>对于右节点，只有2，3两个样本，那么根据下表我们选择年龄30进行划分：<br><img src="https://img-blog.csdnimg.cn/7d63133f988e46648ccaa30269007385.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/cce3670868d54729933a6769d75f6a29.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DgdpHG6v-1638484890170)(./13.png)\]"></p><p>因此根据$\Upsilon<em>{j 1}=\underbrace{\arg \min }</em>{\Upsilon} \sum<em>{x</em>{i} \in R<em>{j 1}} L\left(y</em>{i}, f<em>{0}\left(x</em>{i}\right)+\Upsilon\right)$：                                </p><script type="math/tex; mode=display">\begin{array}{l}\left(x_{0} \in R_{11}\right), \quad \Upsilon_{11}=-0.375 \\\left(x_{1} \in R_{21}\right), \quad \Upsilon_{21}=-0.175 \\\left(x_{2} \in R_{31}\right), \quad \Upsilon_{31}=0.225 \\\left(x_{3} \in R_{41}\right), \quad \Upsilon_{41}=0.325\end{array}</script><p>这里其实和上面初始化学习器是一个道理，平方损失，求导，令导数等于零，化简之后得到每个叶子节点的参数$\Upsilon$,其实就是标签值的均值。<br>最后得到五轮迭代：<br><img src="https://img-blog.csdnimg.cn/ba161ee53e4b487fa7509dca014222c8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5rSb5Y2O,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>最后的强学习器为：$f(x)=f<em>{5}(x)=f</em>{0}(x)+\sum<em>{m=1}^{5} \sum</em>{j=1}^{4} \Upsilon<em>{j m} I\left(x \in R</em>{j m}\right)$。<br>其中：</p><script type="math/tex; mode=display">\begin{array}{ll}f_{0}(x)=1.475 & f_{2}(x)=0.0205 \\f_{3}(x)=0.1823 & f_{4}(x)=0.1640 \\f_{5}(x)=0.1476\end{array}</script><p>预测结果为：                       </p><script type="math/tex; mode=display">f(x)=1.475+0.1 *(0.2250+0.2025+0.1823+0.164+0.1476)=1.56714</script><p>为什么要用学习率呢？这是Shrinkage的思想，如果每次都全部加上（学习率为1）很容易一步学到位导致过拟合。    </p><h3 id="4-3-GBDT代码示例"><a href="#4-3-GBDT代码示例" class="headerlink" title="4.3 GBDT代码示例"></a>4.3 GBDT代码示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">下面我们来使用sklearn来使用GBDT</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_friedman1</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingRegressor</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">GradientBoostingRegressor参数解释：</span></span><br><span class="line"><span class="string">loss：&#123;‘ls’, ‘lad’, ‘huber’, ‘quantile’&#125;, default=’ls’：‘ls’ 指最小二乘回归. ‘lad’ (最小绝对偏差) 是仅基于输入变量的顺序信息的高度鲁棒的损失函数。. ‘huber’ 是两者的结合. ‘quantile’允许分位数回归（用于alpha指定分位数）</span></span><br><span class="line"><span class="string">learning_rate：学习率缩小了每棵树的贡献learning_rate。在learning_rate和n_estimators之间需要权衡。</span></span><br><span class="line"><span class="string">n_estimators：要执行的提升次数。</span></span><br><span class="line"><span class="string">subsample：用于拟合各个基础学习者的样本比例。如果小于1.0，则将导致随机梯度增强。subsample与参数n_estimators。选择会导致方差减少和偏差增加。subsample &lt; 1.0</span></span><br><span class="line"><span class="string">criterion：&#123;&#x27;friedman_mse&#x27;，&#x27;mse&#x27;，&#x27;mae&#x27;&#125;，默认=&#x27;friedman_mse&#x27;：“ mse”是均方误差，“ mae”是平均绝对误差。默认值“ friedman_mse”通常是最好的，因为在某些情况下它可以提供更好的近似值。</span></span><br><span class="line"><span class="string">min_samples_split：拆分内部节点所需的最少样本数</span></span><br><span class="line"><span class="string">min_samples_leaf：在叶节点处需要的最小样本数。</span></span><br><span class="line"><span class="string">min_weight_fraction_leaf：在所有叶节点处（所有输入样本）的权重总和中的最小加权分数。如果未提供sample_weight，则样本的权重相等。</span></span><br><span class="line"><span class="string">max_depth：各个回归模型的最大深度。最大深度限制了树中节点的数量。调整此参数以获得最佳性能；最佳值取决于输入变量的相互作用。</span></span><br><span class="line"><span class="string">min_impurity_decrease：如果节点分裂会导致杂质的减少大于或等于该值，则该节点将被分裂。</span></span><br><span class="line"><span class="string">min_impurity_split：提前停止树木生长的阈值。如果节点的杂质高于阈值，则该节点将分裂</span></span><br><span class="line"><span class="string">max_features&#123;‘auto’, ‘sqrt’, ‘log2’&#125;，int或float：寻找最佳分割时要考虑的功能数量：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果为int，则max_features在每个分割处考虑特征。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果为float，max_features则为小数，并 在每次拆分时考虑要素。int(max_features * n_features)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果“auto”，则max_features=n_features。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果是“ sqrt”，则max_features=sqrt(n_features)。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果为“ log2”，则为max_features=log2(n_features)。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果没有，则max_features=n_features。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">X, y = make_friedman1(n_samples=<span class="number">1200</span>, random_state=<span class="number">0</span>, noise=<span class="number">1.0</span>)</span><br><span class="line">X_train, X_test = X[:<span class="number">200</span>], X[<span class="number">200</span>:]</span><br><span class="line">y_train, y_test = y[:<span class="number">200</span>], y[<span class="number">200</span>:]</span><br><span class="line">est = GradientBoostingRegressor(n_estimators=<span class="number">100</span>, learning_rate=<span class="number">0.1</span>,</span><br><span class="line">    max_depth=<span class="number">1</span>, random_state=<span class="number">0</span>, loss=<span class="string">&#x27;ls&#x27;</span>).fit(X_train, y_train)</span><br><span class="line">mean_squared_error(y_test, est.predict(X_test))</span><br><span class="line"></span><br><span class="line"><span class="number">5.009154859960321</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_regression</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X, y = make_regression(random_state=<span class="number">0</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">    X, y, random_state=<span class="number">0</span>)</span><br><span class="line">reg = GradientBoostingRegressor(random_state=<span class="number">0</span>)</span><br><span class="line">reg.fit(X_train, y_train)</span><br><span class="line">reg.score(X_test, y_test)</span><br><span class="line"></span><br><span class="line"><span class="number">0.43848663277068134</span></span><br></pre></td></tr></table></figure><p>GradientBoostingRegressor与GradientBoostingClassifier函数的各个参数的意思！参考文档：<br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor</a><br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingClassifier.html?highlight=gra#sklearn.ensemble.GradientBoostingClassifier">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingClassifier.html?highlight=gra#sklearn.ensemble.GradientBoostingClassifier</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、-Boosting算法原理&quot;&gt;&lt;a href=&quot;#一、-Boosting算法原理&quot; class=&quot;headerlink&quot; title=&quot;一、 Boosting算法原理&quot;&gt;&lt;/a&gt;一、 Boosting算法原理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Bagging：通过Bootstrap 的方式对全样本数据集进行抽样得到抽样子集，对不同的子集使用同一种基本模型进行拟合，然后投票得出最终的预测。&lt;/li&gt;
&lt;li&gt;Bagging主要通过降低方差的方式减少预测误差&amp;lt;/font&amp;gt;&lt;/li&gt;
&lt;li&gt;Boosting：使用同一组数据集进行反复学习，得到一系列简单模型，然后组合这些模型构成一个预测性能十分强大的机器学习模型。&lt;/li&gt;
&lt;li&gt;Boosting通过不断减少偏差的形式提高最终的预测效果，与Bagging有着本质的不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在概率近似正确（PAC）学习的框架下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;弱学习：识别准确率略高于1/2（即准确率仅比随机猜测略高的学习算法）&lt;/li&gt;
&lt;li&gt;强学习：识别准确率很高并能在多项式时间内完成的学习算法&lt;/li&gt;
&lt;li&gt;强可学习和弱可学习是等价的，弱可学习算法，能提升至强可学习算法</summary>
    
    
    
    <category term="集成学习" scheme="https://zhxnlp.github.io/categories/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="集成学习" scheme="https://zhxnlp.github.io/tags/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Boosting" scheme="https://zhxnlp.github.io/tags/Boosting/"/>
    
    <category term="Adaboost" scheme="https://zhxnlp.github.io/tags/Adaboost/"/>
    
    <category term="GBDT" scheme="https://zhxnlp.github.io/tags/GBDT/"/>
    
  </entry>
  
</feed>
